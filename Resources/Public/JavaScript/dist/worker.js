/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@tannin/compile/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@tannin/compile/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ compile)
/* harmony export */ });
/* harmony import */ var _tannin_postfix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tannin/postfix */ "./node_modules/@tannin/postfix/index.js");
/* harmony import */ var _tannin_evaluate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tannin/evaluate */ "./node_modules/@tannin/evaluate/index.js");



/**
 * Given a C expression, returns a function which can be called to evaluate its
 * result.
 *
 * @example
 *
 * ```js
 * import compile from '@tannin/compile';
 *
 * const evaluate = compile( 'n > 1' );
 *
 * evaluate( { n: 2 } );
 * // ⇒ true
 * ```
 *
 * @param {string} expression C expression.
 *
 * @return {(variables?:{[variable:string]:*})=>*} Compiled evaluator.
 */
function compile(expression) {
  var terms = (0,_tannin_postfix__WEBPACK_IMPORTED_MODULE_0__["default"])(expression);
  return function (variables) {
    return (0,_tannin_evaluate__WEBPACK_IMPORTED_MODULE_1__["default"])(terms, variables);
  };
}

/***/ }),

/***/ "./node_modules/@tannin/evaluate/index.js":
/*!************************************************!*\
  !*** ./node_modules/@tannin/evaluate/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ evaluate)
/* harmony export */ });
/**
 * Operator callback functions.
 *
 * @type {Object}
 */
var OPERATORS = {
  '!': function (a) {
    return !a;
  },
  '*': function (a, b) {
    return a * b;
  },
  '/': function (a, b) {
    return a / b;
  },
  '%': function (a, b) {
    return a % b;
  },
  '+': function (a, b) {
    return a + b;
  },
  '-': function (a, b) {
    return a - b;
  },
  '<': function (a, b) {
    return a < b;
  },
  '<=': function (a, b) {
    return a <= b;
  },
  '>': function (a, b) {
    return a > b;
  },
  '>=': function (a, b) {
    return a >= b;
  },
  '==': function (a, b) {
    return a === b;
  },
  '!=': function (a, b) {
    return a !== b;
  },
  '&&': function (a, b) {
    return a && b;
  },
  '||': function (a, b) {
    return a || b;
  },
  '?:': function (a, b, c) {
    if (a) {
      throw b;
    }
    return c;
  }
};

/**
 * Given an array of postfix terms and operand variables, returns the result of
 * the postfix evaluation.
 *
 * @example
 *
 * ```js
 * import evaluate from '@tannin/evaluate';
 *
 * // 3 + 4 * 5 / 6 ⇒ '3 4 5 * 6 / +'
 * const terms = [ '3', '4', '5', '*', '6', '/', '+' ];
 *
 * evaluate( terms, {} );
 * // ⇒ 6.333333333333334
 * ```
 *
 * @param {string[]} postfix   Postfix terms.
 * @param {Object}   variables Operand variables.
 *
 * @return {*} Result of evaluation.
 */
function evaluate(postfix, variables) {
  var stack = [],
    i,
    j,
    args,
    getOperatorResult,
    term,
    value;
  for (i = 0; i < postfix.length; i++) {
    term = postfix[i];
    getOperatorResult = OPERATORS[term];
    if (getOperatorResult) {
      // Pop from stack by number of function arguments.
      j = getOperatorResult.length;
      args = Array(j);
      while (j--) {
        args[j] = stack.pop();
      }
      try {
        value = getOperatorResult.apply(null, args);
      } catch (earlyReturn) {
        return earlyReturn;
      }
    } else if (variables.hasOwnProperty(term)) {
      value = variables[term];
    } else {
      value = +term;
    }
    stack.push(value);
  }
  return stack[0];
}

/***/ }),

/***/ "./node_modules/@tannin/plural-forms/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@tannin/plural-forms/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pluralForms)
/* harmony export */ });
/* harmony import */ var _tannin_compile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tannin/compile */ "./node_modules/@tannin/compile/index.js");


/**
 * Given a C expression, returns a function which, when called with a value,
 * evaluates the result with the value assumed to be the "n" variable of the
 * expression. The result will be coerced to its numeric equivalent.
 *
 * @param {string} expression C expression.
 *
 * @return {Function} Evaluator function.
 */
function pluralForms(expression) {
  var evaluate = (0,_tannin_compile__WEBPACK_IMPORTED_MODULE_0__["default"])(expression);
  return function (n) {
    return +evaluate({
      n: n
    });
  };
}

/***/ }),

/***/ "./node_modules/@tannin/postfix/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@tannin/postfix/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ postfix)
/* harmony export */ });
var PRECEDENCE, OPENERS, TERMINATORS, PATTERN;

/**
 * Operator precedence mapping.
 *
 * @type {Object}
 */
PRECEDENCE = {
  '(': 9,
  '!': 8,
  '*': 7,
  '/': 7,
  '%': 7,
  '+': 6,
  '-': 6,
  '<': 5,
  '<=': 5,
  '>': 5,
  '>=': 5,
  '==': 4,
  '!=': 4,
  '&&': 3,
  '||': 2,
  '?': 1,
  '?:': 1
};

/**
 * Characters which signal pair opening, to be terminated by terminators.
 *
 * @type {string[]}
 */
OPENERS = ['(', '?'];

/**
 * Characters which signal pair termination, the value an array with the
 * opener as its first member. The second member is an optional operator
 * replacement to push to the stack.
 *
 * @type {string[]}
 */
TERMINATORS = {
  ')': ['('],
  ':': ['?', '?:']
};

/**
 * Pattern matching operators and openers.
 *
 * @type {RegExp}
 */
PATTERN = /<=|>=|==|!=|&&|\|\||\?:|\(|!|\*|\/|%|\+|-|<|>|\?|\)|:/;

/**
 * Given a C expression, returns the equivalent postfix (Reverse Polish)
 * notation terms as an array.
 *
 * If a postfix string is desired, simply `.join( ' ' )` the result.
 *
 * @example
 *
 * ```js
 * import postfix from '@tannin/postfix';
 *
 * postfix( 'n > 1' );
 * // ⇒ [ 'n', '1', '>' ]
 * ```
 *
 * @param {string} expression C expression.
 *
 * @return {string[]} Postfix terms.
 */
function postfix(expression) {
  var terms = [],
    stack = [],
    match,
    operator,
    term,
    element;
  while (match = expression.match(PATTERN)) {
    operator = match[0];

    // Term is the string preceding the operator match. It may contain
    // whitespace, and may be empty (if operator is at beginning).
    term = expression.substr(0, match.index).trim();
    if (term) {
      terms.push(term);
    }
    while (element = stack.pop()) {
      if (TERMINATORS[operator]) {
        if (TERMINATORS[operator][0] === element) {
          // Substitution works here under assumption that because
          // the assigned operator will no longer be a terminator, it
          // will be pushed to the stack during the condition below.
          operator = TERMINATORS[operator][1] || operator;
          break;
        }
      } else if (OPENERS.indexOf(element) >= 0 || PRECEDENCE[element] < PRECEDENCE[operator]) {
        // Push to stack if either an opener or when pop reveals an
        // element of lower precedence.
        stack.push(element);
        break;
      }

      // For each popped from stack, push to terms.
      terms.push(element);
    }
    if (!TERMINATORS[operator]) {
      stack.push(operator);
    }

    // Slice matched fragment from expression to continue match.
    expression = expression.substr(match.index + operator.length);
  }

  // Push remainder of operand, if exists, to terms.
  expression = expression.trim();
  if (expression) {
    terms.push(expression);
  }

  // Pop remaining items from stack into terms.
  return terms.concat(stack.reverse());
}

/***/ }),

/***/ "./node_modules/@yoast/feature-flag/build/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@yoast/feature-flag/build/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isFeatureEnabled = exports.enabledFeatures = exports.enableFeatures = void 0;
/**
 * Checks whether the given feature is enabled.
 *
 * @param {string} featureName      The name of the feature to check.
 *
 * @returns {boolean} `true` when the feature is enabled, `false` if not.
 */
const isFeatureEnabled = function (featureName) {
  if (self.wpseoFeatureFlags) {
    return self.wpseoFeatureFlags.includes(featureName);
  }
  return false;
};

/**
 * Enables the features with the given names.
 *
 * @param {string[]} featureNames   A list of names of the features to enable.
 *
 * @returns {void}
 */
exports.isFeatureEnabled = isFeatureEnabled;
const enableFeatures = function (featureNames) {
  // If no features have been enabled yet, initialize the global array.
  if (!self.wpseoFeatureFlags) {
    self.wpseoFeatureFlags = [];
  }

  // Check whether the features are already enabled, if not: add them.
  featureNames.forEach(name => {
    if (!self.wpseoFeatureFlags.includes(name)) {
      self.wpseoFeatureFlags.push(name);
    }
  });
};

/**
 * Returns the list of enabled features.
 *
 * @returns {string[]} The list of enabled features.
 */
exports.enableFeatures = enableFeatures;
const enabledFeatures = function () {
  return self.wpseoFeatureFlags || [];
};
exports.enabledFeatures = enabledFeatures;

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }
  return parts.join('');
}

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");
var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
: null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}
function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    var proto = {
      foo: function () {
        return 42;
      }
    };
    Object.setPrototypeOf(proto, Uint8Array.prototype);
    Object.setPrototypeOf(arr, proto);
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}
Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.buffer;
  }
});
Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.byteOffset;
  }
});
function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }
  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value);
  }
  if (value == null) {
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
  }
  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }
  var valueOf = value.valueOf && value.valueOf();
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length);
  }
  var b = fromObject(value);
  if (b) return b;
  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
  }
  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
};

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
}
function alloc(size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }
  return createBuffer(size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};
function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }
  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding);
  }
  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);
  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}
function fromArrayView(arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    var copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
  }
  return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }
  var buf;
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}
function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);
    if (buf.length === 0) {
      return buf;
    }
    obj.copy(buf, 0, 0, len);
    return buf;
  }
  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }
    return fromArrayLike(obj);
  }
  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
}
function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }
  return length | 0;
}
function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
};
Buffer.compare = function compare(a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a === b) return 0;
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};
Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer.alloc(0);
  }
  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        Buffer.from(buf).copy(buffer, pos);
      } else {
        Uint8Array.prototype.set.call(buffer, buf, pos);
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    } else {
      buf.copy(buffer, pos);
    }
    pos += buf.length;
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
  }
  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
        }
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }
  if (end === undefined || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return '';
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return '';
  }
  if (!encoding) encoding = 'utf8';
  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);
      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);
      case 'ascii':
        return asciiSlice(this, start, end);
      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);
      case 'base64':
        return base64Slice(this, start, end);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>';
};
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength);
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);
  }
  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }
  return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;
    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }
  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }
  if (!encoding) encoding = 'utf8';
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);
      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);
      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length);
      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]];
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (var i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start) end = start;
  var newBuf = this.subarray(start, end);
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype);
  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }
  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }
  return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }
  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } else if (typeof val === 'boolean') {
    val = Number(val);
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
    var len = bytes.length;
    if (len === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0];
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;
        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }
    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
  // For IE11 support
  return obj !== obj; // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function () {
  var alphabet = '0123456789abcdef';
  var table = new Array(256);
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16;
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j];
    }
  }
  return table;
}();

/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");
var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
module.exports = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic(name, !!allowMissing);
  if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};

/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var setFunctionLength = __webpack_require__(/*! set-function-length */ "./node_modules/set-function-length/index.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");
var $max = GetIntrinsic('%Math.max%');
module.exports = function callBind(originalFunction) {
  if (typeof originalFunction !== 'function') {
    throw new $TypeError('a function is required');
  }
  var func = $reflectApply(bind, $call, arguments);
  return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
};
var applyBind = function applyBind() {
  return $reflectApply(bind, $apply, arguments);
};
if ($defineProperty) {
  $defineProperty(module.exports, 'apply', {
    value: applyBind
  });
} else {
  module.exports.apply = applyBind;
}

/***/ }),

/***/ "./node_modules/define-data-property/index.js":
/*!****************************************************!*\
  !*** ./node_modules/define-data-property/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");
var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var gopd = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

/** @type {import('.')} */
module.exports = function defineDataProperty(obj, property, value) {
  if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
    throw new $TypeError('`obj` must be an object or a function`');
  }
  if (typeof property !== 'string' && typeof property !== 'symbol') {
    throw new $TypeError('`property` must be a string or a symbol`');
  }
  if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
    throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
  }
  if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
    throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
  }
  if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
    throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
  }
  if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
    throw new $TypeError('`loose`, if provided, must be a boolean');
  }
  var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
  var nonWritable = arguments.length > 4 ? arguments[4] : null;
  var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
  var loose = arguments.length > 6 ? arguments[6] : false;

  /* @type {false | TypedPropertyDescriptor<unknown>} */
  var desc = !!gopd && gopd(obj, property);
  if ($defineProperty) {
    $defineProperty(obj, property, {
      configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
      enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
      value: value,
      writable: nonWritable === null && desc ? desc.writable : !nonWritable
    });
  } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
    // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
    obj[property] = value; // eslint-disable-line no-param-reassign
  } else {
    throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
  }
};

/***/ }),

/***/ "./node_modules/dom-serializer/index.js":
/*!**********************************************!*\
  !*** ./node_modules/dom-serializer/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
  Module dependencies
*/
var ElementType = __webpack_require__(/*! domelementtype */ "./node_modules/domelementtype/lib/index.js");
var entities = __webpack_require__(/*! entities */ "./node_modules/dom-serializer/node_modules/entities/lib/index.js");

/* mixed-case SVG and MathML tags & attributes
   recognized by the HTML parser, see
   https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
*/
var foreignNames = __webpack_require__(/*! ./foreignNames.json */ "./node_modules/dom-serializer/foreignNames.json");
foreignNames.elementNames.__proto__ = null; /* use as a simple dictionary */
foreignNames.attributeNames.__proto__ = null;
var unencodedElements = {
  __proto__: null,
  style: true,
  script: true,
  xmp: true,
  iframe: true,
  noembed: true,
  noframes: true,
  plaintext: true,
  noscript: true
};

/*
  Format attributes
*/
function formatAttrs(attributes, opts) {
  if (!attributes) return;
  var output = '';
  var value;

  // Loop through the attributes
  for (var key in attributes) {
    value = attributes[key];
    if (output) {
      output += ' ';
    }
    if (opts.xmlMode === 'foreign') {
      /* fix up mixed-case attribute names */
      key = foreignNames.attributeNames[key] || key;
    }
    output += key;
    if (value !== null && value !== '' || opts.xmlMode) {
      output += '="' + (opts.decodeEntities ? entities.encodeXML(value) : value.replace(/\"/g, '&quot;')) + '"';
    }
  }
  return output;
}

/*
  Self-enclosing tags (stolen from node-htmlparser)
*/
var singleTag = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};
var render = module.exports = function (dom, opts) {
  if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];
  opts = opts || {};
  var output = '';
  for (var i = 0; i < dom.length; i++) {
    var elem = dom[i];
    if (elem.type === 'root') output += render(elem.children, opts);else if (ElementType.isTag(elem)) output += renderTag(elem, opts);else if (elem.type === ElementType.Directive) output += renderDirective(elem);else if (elem.type === ElementType.Comment) output += renderComment(elem);else if (elem.type === ElementType.CDATA) output += renderCdata(elem);else output += renderText(elem, opts);
  }
  return output;
};
var foreignModeIntegrationPoints = ['mi', 'mo', 'mn', 'ms', 'mtext', 'annotation-xml', 'foreignObject', 'desc', 'title'];
function renderTag(elem, opts) {
  // Handle SVG / MathML in HTML
  if (opts.xmlMode === 'foreign') {
    /* fix up mixed-case element names */
    elem.name = foreignNames.elementNames[elem.name] || elem.name;
    /* exit foreign mode at integration points */
    if (elem.parent && foreignModeIntegrationPoints.indexOf(elem.parent.name) >= 0) opts = Object.assign({}, opts, {
      xmlMode: false
    });
  }
  if (!opts.xmlMode && ['svg', 'math'].indexOf(elem.name) >= 0) {
    opts = Object.assign({}, opts, {
      xmlMode: 'foreign'
    });
  }
  var tag = '<' + elem.name;
  var attribs = formatAttrs(elem.attribs, opts);
  if (attribs) {
    tag += ' ' + attribs;
  }
  if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
    tag += '/>';
  } else {
    tag += '>';
    if (elem.children) {
      tag += render(elem.children, opts);
    }
    if (!singleTag[elem.name] || opts.xmlMode) {
      tag += '</' + elem.name + '>';
    }
  }
  return tag;
}
function renderDirective(elem) {
  return '<' + elem.data + '>';
}
function renderText(elem, opts) {
  var data = elem.data || '';

  // if entities weren't decoded, no need to encode them back
  if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {
    data = entities.encodeXML(data);
  }
  return data;
}
function renderCdata(elem) {
  return '<![CDATA[' + elem.children[0].data + ']]>';
}
function renderComment(elem) {
  return '<!--' + elem.data + '-->';
}

/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/decode.js":
/*!*************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/decode.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
var entities_json_1 = __importDefault(__webpack_require__(/*! ./maps/entities.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json"));
var legacy_json_1 = __importDefault(__webpack_require__(/*! ./maps/legacy.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json"));
var xml_json_1 = __importDefault(__webpack_require__(/*! ./maps/xml.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json"));
var decode_codepoint_1 = __importDefault(__webpack_require__(/*! ./decode_codepoint */ "./node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js"));
var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
exports.decodeXML = getStrictDecoder(xml_json_1.default);
exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
function getStrictDecoder(map) {
  var replace = getReplacer(map);
  return function (str) {
    return String(str).replace(strictEntityRe, replace);
  };
}
var sorter = function (a, b) {
  return a < b ? 1 : -1;
};
exports.decodeHTML = function () {
  var legacy = Object.keys(legacy_json_1.default).sort(sorter);
  var keys = Object.keys(entities_json_1.default).sort(sorter);
  for (var i = 0, j = 0; i < keys.length; i++) {
    if (legacy[j] === keys[i]) {
      keys[i] += ";?";
      j++;
    } else {
      keys[i] += ";";
    }
  }
  var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
  var replace = getReplacer(entities_json_1.default);
  function replacer(str) {
    if (str.substr(-1) !== ";") str += ";";
    return replace(str);
  }
  // TODO consider creating a merged map
  return function (str) {
    return String(str).replace(re, replacer);
  };
}();
function getReplacer(map) {
  return function replace(str) {
    if (str.charAt(1) === "#") {
      var secondChar = str.charAt(2);
      if (secondChar === "X" || secondChar === "x") {
        return decode_codepoint_1.default(parseInt(str.substr(3), 16));
      }
      return decode_codepoint_1.default(parseInt(str.substr(2), 10));
    }
    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
    return map[str.slice(1, -1)] || str;
  };
}

/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var decode_json_1 = __importDefault(__webpack_require__(/*! ./maps/decode.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json"));
// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
var fromCodePoint =
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.fromCodePoint || function (codePoint) {
  var output = "";
  if (codePoint > 0xffff) {
    codePoint -= 0x10000;
    output += String.fromCharCode(codePoint >>> 10 & 0x3ff | 0xd800);
    codePoint = 0xdc00 | codePoint & 0x3ff;
  }
  output += String.fromCharCode(codePoint);
  return output;
};
function decodeCodePoint(codePoint) {
  if (codePoint >= 0xd800 && codePoint <= 0xdfff || codePoint > 0x10ffff) {
    return "\uFFFD";
  }
  if (codePoint in decode_json_1.default) {
    codePoint = decode_json_1.default[codePoint];
  }
  return fromCodePoint(codePoint);
}
exports["default"] = decodeCodePoint;

/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/encode.js":
/*!*************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/encode.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
var xml_json_1 = __importDefault(__webpack_require__(/*! ./maps/xml.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json"));
var inverseXML = getInverseObj(xml_json_1.default);
var xmlReplacer = getInverseReplacer(inverseXML);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
exports.encodeXML = getASCIIEncoder(inverseXML);
var entities_json_1 = __importDefault(__webpack_require__(/*! ./maps/entities.json */ "./node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json"));
var inverseHTML = getInverseObj(entities_json_1.default);
var htmlReplacer = getInverseReplacer(inverseHTML);
/**
 * Encodes all entities and non-ASCII characters in the input.
 *
 * This includes characters that are valid ASCII characters in HTML documents.
 * For example `#` will be encoded as `&num;`. To get a more compact output,
 * consider using the `encodeNonAsciiHTML` function.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in HTML
 * documents using HTML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
function getInverseObj(obj) {
  return Object.keys(obj).sort().reduce(function (inverse, name) {
    inverse[obj[name]] = "&" + name + ";";
    return inverse;
  }, {});
}
function getInverseReplacer(inverse) {
  var single = [];
  var multiple = [];
  for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
    var k = _a[_i];
    if (k.length === 1) {
      // Add value to single array
      single.push("\\" + k);
    } else {
      // Add value to multiple array
      multiple.push(k);
    }
  }
  // Add ranges to single characters.
  single.sort();
  for (var start = 0; start < single.length - 1; start++) {
    // Find the end of a run of characters
    var end = start;
    while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
      end += 1;
    }
    var count = 1 + end - start;
    // We want to replace at least three characters
    if (count < 3) continue;
    single.splice(start, count, single[start] + "-" + single[end]);
  }
  multiple.unshift("[" + single.join("") + "]");
  return new RegExp(multiple.join("|"), "g");
}
// /[^\0-\x7F]/gu
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
var getCodePoint =
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.prototype.codePointAt != null ?
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
function (str) {
  return str.codePointAt(0);
} :
// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
function (c) {
  return (c.charCodeAt(0) - 0xd800) * 0x400 + c.charCodeAt(1) - 0xdc00 + 0x10000;
};
function singleCharReplacer(c) {
  return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
}
function getInverse(inverse, re) {
  return function (data) {
    return data.replace(re, function (name) {
      return inverse[name];
    }).replace(reNonASCII, singleCharReplacer);
  };
}
var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */
function escape(data) {
  return data.replace(reEscapeChars, singleCharReplacer);
}
exports.escape = escape;
/**
 * Encodes all characters not valid in XML documents using numeric hexadecimal
 * reference (eg. `&#xfc;`).
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */
function escapeUTF8(data) {
  return data.replace(xmlReplacer, singleCharReplacer);
}
exports.escapeUTF8 = escapeUTF8;
function getASCIIEncoder(obj) {
  return function (data) {
    return data.replace(reEscapeChars, function (c) {
      return obj[c] || singleCharReplacer(c);
    });
  };
}

/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
var decode_1 = __webpack_require__(/*! ./decode */ "./node_modules/dom-serializer/node_modules/entities/lib/decode.js");
var encode_1 = __webpack_require__(/*! ./encode */ "./node_modules/dom-serializer/node_modules/entities/lib/encode.js");
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `decodeXML` or `decodeHTML` directly.
 */
function decode(data, level) {
  return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
}
exports.decode = decode;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
 */
function decodeStrict(data, level) {
  return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
}
exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
 */
function encode(data, level) {
  return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
}
exports.encode = encode;
var encode_2 = __webpack_require__(/*! ./encode */ "./node_modules/dom-serializer/node_modules/entities/lib/encode.js");
Object.defineProperty(exports, "encodeXML", ({
  enumerable: true,
  get: function () {
    return encode_2.encodeXML;
  }
}));
Object.defineProperty(exports, "encodeHTML", ({
  enumerable: true,
  get: function () {
    return encode_2.encodeHTML;
  }
}));
Object.defineProperty(exports, "encodeNonAsciiHTML", ({
  enumerable: true,
  get: function () {
    return encode_2.encodeNonAsciiHTML;
  }
}));
Object.defineProperty(exports, "escape", ({
  enumerable: true,
  get: function () {
    return encode_2.escape;
  }
}));
Object.defineProperty(exports, "escapeUTF8", ({
  enumerable: true,
  get: function () {
    return encode_2.escapeUTF8;
  }
}));
// Legacy aliases (deprecated)
Object.defineProperty(exports, "encodeHTML4", ({
  enumerable: true,
  get: function () {
    return encode_2.encodeHTML;
  }
}));
Object.defineProperty(exports, "encodeHTML5", ({
  enumerable: true,
  get: function () {
    return encode_2.encodeHTML;
  }
}));
var decode_2 = __webpack_require__(/*! ./decode */ "./node_modules/dom-serializer/node_modules/entities/lib/decode.js");
Object.defineProperty(exports, "decodeXML", ({
  enumerable: true,
  get: function () {
    return decode_2.decodeXML;
  }
}));
Object.defineProperty(exports, "decodeHTML", ({
  enumerable: true,
  get: function () {
    return decode_2.decodeHTML;
  }
}));
Object.defineProperty(exports, "decodeHTMLStrict", ({
  enumerable: true,
  get: function () {
    return decode_2.decodeHTMLStrict;
  }
}));
// Legacy aliases (deprecated)
Object.defineProperty(exports, "decodeHTML4", ({
  enumerable: true,
  get: function () {
    return decode_2.decodeHTML;
  }
}));
Object.defineProperty(exports, "decodeHTML5", ({
  enumerable: true,
  get: function () {
    return decode_2.decodeHTML;
  }
}));
Object.defineProperty(exports, "decodeHTML4Strict", ({
  enumerable: true,
  get: function () {
    return decode_2.decodeHTMLStrict;
  }
}));
Object.defineProperty(exports, "decodeHTML5Strict", ({
  enumerable: true,
  get: function () {
    return decode_2.decodeHTMLStrict;
  }
}));
Object.defineProperty(exports, "decodeXMLStrict", ({
  enumerable: true,
  get: function () {
    return decode_2.decodeXML;
  }
}));

/***/ }),

/***/ "./node_modules/domelementtype/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/domelementtype/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
/** Types of elements found in htmlparser2's DOM */
var ElementType;
(function (ElementType) {
  /** Type for the root element of a document */
  ElementType["Root"] = "root";
  /** Type for Text */
  ElementType["Text"] = "text";
  /** Type for <? ... ?> */
  ElementType["Directive"] = "directive";
  /** Type for <!-- ... --> */
  ElementType["Comment"] = "comment";
  /** Type for <script> tags */
  ElementType["Script"] = "script";
  /** Type for <style> tags */
  ElementType["Style"] = "style";
  /** Type for Any tag */
  ElementType["Tag"] = "tag";
  /** Type for <![CDATA[ ... ]]> */
  ElementType["CDATA"] = "cdata";
  /** Type for <!doctype ...> */
  ElementType["Doctype"] = "doctype";
})(ElementType = exports.ElementType || (exports.ElementType = {}));
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
exports.isTag = isTag;
// Exports for backwards compatibility
/** Type for the root element of a document */
exports.Root = ElementType.Root;
/** Type for Text */
exports.Text = ElementType.Text;
/** Type for <? ... ?> */
exports.Directive = ElementType.Directive;
/** Type for <!-- ... --> */
exports.Comment = ElementType.Comment;
/** Type for <script> tags */
exports.Script = ElementType.Script;
/** Type for <style> tags */
exports.Style = ElementType.Style;
/** Type for Any tag */
exports.Tag = ElementType.Tag;
/** Type for <![CDATA[ ... ]]> */
exports.CDATA = ElementType.CDATA;
/** Type for <!doctype ...> */
exports.Doctype = ElementType.Doctype;

/***/ }),

/***/ "./node_modules/domutils/index.js":
/*!****************************************!*\
  !*** ./node_modules/domutils/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DomUtils = module.exports;
[__webpack_require__(/*! ./lib/stringify */ "./node_modules/domutils/lib/stringify.js"), __webpack_require__(/*! ./lib/traversal */ "./node_modules/domutils/lib/traversal.js"), __webpack_require__(/*! ./lib/manipulation */ "./node_modules/domutils/lib/manipulation.js"), __webpack_require__(/*! ./lib/querying */ "./node_modules/domutils/lib/querying.js"), __webpack_require__(/*! ./lib/legacy */ "./node_modules/domutils/lib/legacy.js"), __webpack_require__(/*! ./lib/helpers */ "./node_modules/domutils/lib/helpers.js")].forEach(function (ext) {
  Object.keys(ext).forEach(function (key) {
    DomUtils[key] = ext[key].bind(DomUtils);
  });
});

/***/ }),

/***/ "./node_modules/domutils/lib/helpers.js":
/*!**********************************************!*\
  !*** ./node_modules/domutils/lib/helpers.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

// removeSubsets
// Given an array of nodes, remove any member that is contained by another.
exports.removeSubsets = function (nodes) {
  var idx = nodes.length,
    node,
    ancestor,
    replace;

  // Check if each node (or one of its ancestors) is already contained in the
  // array.
  while (--idx > -1) {
    node = ancestor = nodes[idx];

    // Temporarily remove the node under consideration
    nodes[idx] = null;
    replace = true;
    while (ancestor) {
      if (nodes.indexOf(ancestor) > -1) {
        replace = false;
        nodes.splice(idx, 1);
        break;
      }
      ancestor = ancestor.parent;
    }

    // If the node has been found to be unique, re-insert it.
    if (replace) {
      nodes[idx] = node;
    }
  }
  return nodes;
};

// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition
var POSITION = {
  DISCONNECTED: 1,
  PRECEDING: 2,
  FOLLOWING: 4,
  CONTAINS: 8,
  CONTAINED_BY: 16
};

// Compare the position of one node against another node in any other document.
// The return value is a bitmask with the following values:
//
// document order:
// > There is an ordering, document order, defined on all the nodes in the
// > document corresponding to the order in which the first character of the
// > XML representation of each node occurs in the XML representation of the
// > document after expansion of general entities. Thus, the document element
// > node will be the first node. Element nodes occur before their children.
// > Thus, document order orders element nodes in order of the occurrence of
// > their start-tag in the XML (after expansion of entities). The attribute
// > nodes of an element occur after the element and before its children. The
// > relative order of attribute nodes is implementation-dependent./
// Source:
// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
//
// @argument {Node} nodaA The first node to use in the comparison
// @argument {Node} nodeB The second node to use in the comparison
//
// @return {Number} A bitmask describing the input nodes' relative position.
//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
//         a description of these values.
var comparePos = exports.compareDocumentPosition = function (nodeA, nodeB) {
  var aParents = [];
  var bParents = [];
  var current, sharedParent, siblings, aSibling, bSibling, idx;
  if (nodeA === nodeB) {
    return 0;
  }
  current = nodeA;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = nodeB;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  idx = 0;
  while (aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return POSITION.DISCONNECTED;
  }
  sharedParent = aParents[idx - 1];
  siblings = sharedParent.children;
  aSibling = aParents[idx];
  bSibling = bParents[idx];
  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
    }
    return POSITION.FOLLOWING;
  } else {
    if (sharedParent === nodeA) {
      return POSITION.PRECEDING | POSITION.CONTAINS;
    }
    return POSITION.PRECEDING;
  }
};

// Sort an array of nodes based on their relative position in the document and
// remove any duplicate nodes. If the array contains nodes that do not belong
// to the same document, sort order is unspecified.
//
// @argument {Array} nodes Array of DOM nodes
//
// @returns {Array} collection of unique nodes, sorted in document order
exports.uniqueSort = function (nodes) {
  var idx = nodes.length,
    node,
    position;
  nodes = nodes.slice();
  while (--idx > -1) {
    node = nodes[idx];
    position = nodes.indexOf(node);
    if (position > -1 && position < idx) {
      nodes.splice(idx, 1);
    }
  }
  nodes.sort(function (a, b) {
    var relative = comparePos(a, b);
    if (relative & POSITION.PRECEDING) {
      return -1;
    } else if (relative & POSITION.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
};

/***/ }),

/***/ "./node_modules/domutils/lib/legacy.js":
/*!*********************************************!*\
  !*** ./node_modules/domutils/lib/legacy.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var ElementType = __webpack_require__(/*! domelementtype */ "./node_modules/domutils/node_modules/domelementtype/index.js");
var isTag = exports.isTag = ElementType.isTag;
exports.testElement = function (options, element) {
  for (var key in options) {
    if (!options.hasOwnProperty(key)) ;else if (key === "tag_name") {
      if (!isTag(element) || !options.tag_name(element.name)) {
        return false;
      }
    } else if (key === "tag_type") {
      if (!options.tag_type(element.type)) return false;
    } else if (key === "tag_contains") {
      if (isTag(element) || !options.tag_contains(element.data)) {
        return false;
      }
    } else if (!element.attribs || !options[key](element.attribs[key])) {
      return false;
    }
  }
  return true;
};
var Checks = {
  tag_name: function (name) {
    if (typeof name === "function") {
      return function (elem) {
        return isTag(elem) && name(elem.name);
      };
    } else if (name === "*") {
      return isTag;
    } else {
      return function (elem) {
        return isTag(elem) && elem.name === name;
      };
    }
  },
  tag_type: function (type) {
    if (typeof type === "function") {
      return function (elem) {
        return type(elem.type);
      };
    } else {
      return function (elem) {
        return elem.type === type;
      };
    }
  },
  tag_contains: function (data) {
    if (typeof data === "function") {
      return function (elem) {
        return !isTag(elem) && data(elem.data);
      };
    } else {
      return function (elem) {
        return !isTag(elem) && elem.data === data;
      };
    }
  }
};
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return function (elem) {
      return elem.attribs && value(elem.attribs[attrib]);
    };
  } else {
    return function (elem) {
      return elem.attribs && elem.attribs[attrib] === value;
    };
  }
}
function combineFuncs(a, b) {
  return function (elem) {
    return a(elem) || b(elem);
  };
}
exports.getElements = function (options, element, recurse, limit) {
  var funcs = Object.keys(options).map(function (key) {
    var value = options[key];
    return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? [] : this.filter(funcs.reduce(combineFuncs), element, recurse, limit);
};
exports.getElementById = function (id, element, recurse) {
  if (!Array.isArray(element)) element = [element];
  return this.findOne(getAttribCheck("id", id), element, recurse !== false);
};
exports.getElementsByTagName = function (name, element, recurse, limit) {
  return this.filter(Checks.tag_name(name), element, recurse, limit);
};
exports.getElementsByTagType = function (type, element, recurse, limit) {
  return this.filter(Checks.tag_type(type), element, recurse, limit);
};

/***/ }),

/***/ "./node_modules/domutils/lib/manipulation.js":
/*!***************************************************!*\
  !*** ./node_modules/domutils/lib/manipulation.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

exports.removeElement = function (elem) {
  if (elem.prev) elem.prev.next = elem.next;
  if (elem.next) elem.next.prev = elem.prev;
  if (elem.parent) {
    var childs = elem.parent.children;
    childs.splice(childs.lastIndexOf(elem), 1);
  }
};
exports.replaceElement = function (elem, replacement) {
  var prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  var next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  var parent = replacement.parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
  }
};
exports.appendChild = function (elem, child) {
  child.parent = elem;
  if (elem.children.push(child) !== 1) {
    var sibling = elem.children[elem.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
    child.next = null;
  }
};
exports.append = function (elem, next) {
  var parent = elem.parent,
    currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      var childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
};
exports.prepend = function (elem, prev) {
  var parent = elem.parent;
  if (parent) {
    var childs = parent.children;
    childs.splice(childs.lastIndexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
};

/***/ }),

/***/ "./node_modules/domutils/lib/querying.js":
/*!***********************************************!*\
  !*** ./node_modules/domutils/lib/querying.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isTag = (__webpack_require__(/*! domelementtype */ "./node_modules/domutils/node_modules/domelementtype/index.js").isTag);
module.exports = {
  filter: filter,
  find: find,
  findOneChild: findOneChild,
  findOne: findOne,
  existsOne: existsOne,
  findAll: findAll
};
function filter(test, element, recurse, limit) {
  if (!Array.isArray(element)) element = [element];
  if (typeof limit !== "number" || !isFinite(limit)) {
    limit = Infinity;
  }
  return find(test, element, recurse !== false, limit);
}
function find(test, elems, recurse, limit) {
  var result = [],
    childs;
  for (var i = 0, j = elems.length; i < j; i++) {
    if (test(elems[i])) {
      result.push(elems[i]);
      if (--limit <= 0) break;
    }
    childs = elems[i].children;
    if (recurse && childs && childs.length > 0) {
      childs = find(test, childs, recurse, limit);
      result = result.concat(childs);
      limit -= childs.length;
      if (limit <= 0) break;
    }
  }
  return result;
}
function findOneChild(test, elems) {
  for (var i = 0, l = elems.length; i < l; i++) {
    if (test(elems[i])) return elems[i];
  }
  return null;
}
function findOne(test, elems) {
  var elem = null;
  for (var i = 0, l = elems.length; i < l && !elem; i++) {
    if (!isTag(elems[i])) {
      continue;
    } else if (test(elems[i])) {
      elem = elems[i];
    } else if (elems[i].children.length > 0) {
      elem = findOne(test, elems[i].children);
    }
  }
  return elem;
}
function existsOne(test, elems) {
  for (var i = 0, l = elems.length; i < l; i++) {
    if (isTag(elems[i]) && (test(elems[i]) || elems[i].children.length > 0 && existsOne(test, elems[i].children))) {
      return true;
    }
  }
  return false;
}
function findAll(test, rootElems) {
  var result = [];
  var stack = rootElems.slice();
  while (stack.length) {
    var elem = stack.shift();
    if (!isTag(elem)) continue;
    if (elem.children && elem.children.length > 0) {
      stack.unshift.apply(stack, elem.children);
    }
    if (test(elem)) result.push(elem);
  }
  return result;
}

/***/ }),

/***/ "./node_modules/domutils/lib/stringify.js":
/*!************************************************!*\
  !*** ./node_modules/domutils/lib/stringify.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ElementType = __webpack_require__(/*! domelementtype */ "./node_modules/domutils/node_modules/domelementtype/index.js"),
  getOuterHTML = __webpack_require__(/*! dom-serializer */ "./node_modules/dom-serializer/index.js"),
  isTag = ElementType.isTag;
module.exports = {
  getInnerHTML: getInnerHTML,
  getOuterHTML: getOuterHTML,
  getText: getText
};
function getInnerHTML(elem, opts) {
  return elem.children ? elem.children.map(function (elem) {
    return getOuterHTML(elem, opts);
  }).join("") : "";
}
function getText(elem) {
  if (Array.isArray(elem)) return elem.map(getText).join("");
  if (isTag(elem)) return elem.name === "br" ? "\n" : getText(elem.children);
  if (elem.type === ElementType.CDATA) return getText(elem.children);
  if (elem.type === ElementType.Text) return elem.data;
  return "";
}

/***/ }),

/***/ "./node_modules/domutils/lib/traversal.js":
/*!************************************************!*\
  !*** ./node_modules/domutils/lib/traversal.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

var getChildren = exports.getChildren = function (elem) {
  return elem.children;
};
var getParent = exports.getParent = function (elem) {
  return elem.parent;
};
exports.getSiblings = function (elem) {
  var parent = getParent(elem);
  return parent ? getChildren(parent) : [elem];
};
exports.getAttributeValue = function (elem, name) {
  return elem.attribs && elem.attribs[name];
};
exports.hasAttrib = function (elem, name) {
  return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
};
exports.getName = function (elem) {
  return elem.name;
};

/***/ }),

/***/ "./node_modules/domutils/node_modules/domelementtype/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/domutils/node_modules/domelementtype/index.js ***!
  \********************************************************************/
/***/ ((module) => {

//Types of elements found in the DOM
module.exports = {
  Text: "text",
  //Text
  Directive: "directive",
  //<? ... ?>
  Comment: "comment",
  //<!-- ... -->
  Script: "script",
  //<script> tags
  Style: "style",
  //<style> tags
  Tag: "tag",
  //Any tag
  CDATA: "cdata",
  //<![CDATA[ ... ]]>
  Doctype: "doctype",
  isTag: function (elem) {
    return elem.type === "tag" || elem.type === "script" || elem.type === "style";
  }
};

/***/ }),

/***/ "./node_modules/entities/lib/decode.js":
/*!*********************************************!*\
  !*** ./node_modules/entities/lib/decode.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function () {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
var decode_data_html_js_1 = __importDefault(__webpack_require__(/*! ./generated/decode-data-html.js */ "./node_modules/entities/lib/generated/decode-data-html.js"));
exports.htmlDecodeTree = decode_data_html_js_1.default;
var decode_data_xml_js_1 = __importDefault(__webpack_require__(/*! ./generated/decode-data-xml.js */ "./node_modules/entities/lib/generated/decode-data-xml.js"));
exports.xmlDecodeTree = decode_data_xml_js_1.default;
var decode_codepoint_js_1 = __importStar(__webpack_require__(/*! ./decode_codepoint.js */ "./node_modules/entities/lib/decode_codepoint.js"));
exports.decodeCodePoint = decode_codepoint_js_1.default;
var decode_codepoint_js_2 = __webpack_require__(/*! ./decode_codepoint.js */ "./node_modules/entities/lib/decode_codepoint.js");
Object.defineProperty(exports, "replaceCodePoint", ({
  enumerable: true,
  get: function () {
    return decode_codepoint_js_2.replaceCodePoint;
  }
}));
Object.defineProperty(exports, "fromCodePoint", ({
  enumerable: true,
  get: function () {
    return decode_codepoint_js_2.fromCodePoint;
  }
}));
var CharCodes;
(function (CharCodes) {
  CharCodes[CharCodes["NUM"] = 35] = "NUM";
  CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
  CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
  CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
  CharCodes[CharCodes["NINE"] = 57] = "NINE";
  CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
  CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
  CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
  CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
  CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
  CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
/** Bit that needs to be set to convert an upper case ASCII character to lower case */
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function (BinTrieFlags) {
  BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
/**
 * Checks if the given character is a valid end character for an entity in an attribute.
 *
 * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
 * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
 */
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function (EntityDecoderState) {
  EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function (DecodingMode) {
  /** Entities in text nodes that can end with any character. */
  DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
  /** Only allow entities terminated with a semicolon. */
  DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
  /** Entities in attributes have limitations on ending characters. */
  DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
})(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
/**
 * Token decoder with support of writing partial entities.
 */
var EntityDecoder = /** @class */function () {
  function EntityDecoder(/** The tree used to decode entities. */
  decodeTree,
  /**
   * The function that is called when a codepoint is decoded.
   *
   * For multi-byte named entities, this will be called multiple times,
   * with the second codepoint, and the same `consumed` value.
   *
   * @param codepoint The decoded codepoint.
   * @param consumed The number of bytes consumed by the decoder.
   */
  emitCodePoint, /** An object that is used to produce errors. */
  errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    /** The current state of the decoder. */
    this.state = EntityDecoderState.EntityStart;
    /** Characters that were consumed while parsing an entity. */
    this.consumed = 1;
    /**
     * The result of the entity.
     *
     * Either the result index of a numeric entity, or the codepoint of a
     * numeric entity.
     */
    this.result = 0;
    /** The current index in the decode tree. */
    this.treeIndex = 0;
    /** The number of characters that were consumed in excess. */
    this.excess = 1;
    /** The mode in which the decoder is operating. */
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  EntityDecoder.prototype.startEntity = function (decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  };
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  EntityDecoder.prototype.write = function (str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart:
        {
          if (str.charCodeAt(offset) === CharCodes.NUM) {
            this.state = EntityDecoderState.NumericStart;
            this.consumed += 1;
            return this.stateNumericStart(str, offset + 1);
          }
          this.state = EntityDecoderState.NamedEntity;
          return this.stateNamedEntity(str, offset);
        }
      case EntityDecoderState.NumericStart:
        {
          return this.stateNumericStart(str, offset);
        }
      case EntityDecoderState.NumericDecimal:
        {
          return this.stateNumericDecimal(str, offset);
        }
      case EntityDecoderState.NumericHex:
        {
          return this.stateNumericHex(str, offset);
        }
      case EntityDecoderState.NamedEntity:
        {
          return this.stateNamedEntity(str, offset);
        }
    }
  };
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  EntityDecoder.prototype.stateNumericStart = function (str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  };
  EntityDecoder.prototype.addToNumericResult = function (str, start, end, base) {
    if (start !== end) {
      var digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  };
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  EntityDecoder.prototype.stateNumericHex = function (str, offset) {
    var startIdx = offset;
    while (offset < str.length) {
      var char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  };
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  EntityDecoder.prototype.stateNumericDecimal = function (str, offset) {
    var startIdx = offset;
    while (offset < str.length) {
      var char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  };
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  EntityDecoder.prototype.emitNumericEntity = function (lastCp, expectedLength) {
    var _a;
    // Ensure we consumed at least one digit.
    if (this.consumed <= expectedLength) {
      (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    // Figure out if this is a legit end of the entity
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  };
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  EntityDecoder.prototype.stateNamedEntity = function (str, offset) {
    var decodeTree = this.decodeTree;
    var current = decodeTree[this.treeIndex];
    // The mask is the number of bytes of the value, including the current byte.
    var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      var char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 ||
        // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && (
        // We shouldn't have consumed any characters after the entity,
        valueLength === 0 ||
        // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      // If the branch is a value, store it and continue
      if (valueLength !== 0) {
        // If the entity is terminated by a semicolon, we are done.
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  };
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  EntityDecoder.prototype.emitNotTerminatedNamedEntity = function () {
    var _a;
    var _b = this,
      result = _b.result,
      decodeTree = _b.decodeTree;
    var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
    return this.consumed;
  };
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  EntityDecoder.prototype.emitNamedEntityData = function (result, valueLength, consumed) {
    var decodeTree = this.decodeTree;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      // For multi-byte values, we need to emit the second byte.
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  };
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  EntityDecoder.prototype.end = function () {
    var _a;
    switch (this.state) {
      case EntityDecoderState.NamedEntity:
        {
          // Emit a named entity if we have one.
          return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
        }
      // Otherwise, emit a numeric entity if we have one.
      case EntityDecoderState.NumericDecimal:
        {
          return this.emitNumericEntity(0, 2);
        }
      case EntityDecoderState.NumericHex:
        {
          return this.emitNumericEntity(0, 3);
        }
      case EntityDecoderState.NumericStart:
        {
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
          return 0;
        }
      case EntityDecoderState.EntityStart:
        {
          // Return 0 if we have no entity.
          return 0;
        }
    }
  };
  return EntityDecoder;
}();
exports.EntityDecoder = EntityDecoder;
/**
 * Creates a function that decodes entities in a string.
 *
 * @param decodeTree The decode tree.
 * @returns A function that decodes entities in a string.
 */
function getDecoder(decodeTree) {
  var ret = "";
  var decoder = new EntityDecoder(decodeTree, function (str) {
    return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
  });
  return function decodeWithTrie(str, decodeMode) {
    var lastIndex = 0;
    var offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      var len = decoder.write(str,
      // Skip the "&"
      offset + 1);
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      // If `len` is 0, skip the current `&` and continue.
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    var result = ret + str.slice(lastIndex);
    // Make sure we don't keep a reference to the final string.
    ret = "";
    return result;
  };
}
/**
 * Determines the branch of the current node that is taken given the current
 * character. This function is used to traverse the trie.
 *
 * @param decodeTree The trie.
 * @param current The current node.
 * @param nodeIdx The index right after the current node and its value.
 * @param char The current character.
 * @returns The index of the next node, or -1 if no branch is taken.
 */
function determineBranch(decodeTree, current, nodeIdx, char) {
  var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  // Case 1: Single branch encoded in jump offset
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  // Case 2: Multiple branches encoded in jump table
  if (jumpOffset) {
    var value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  // Case 3: Multiple branches encoded in dictionary
  // Binary search for the character.
  var lo = nodeIdx;
  var hi = lo + branchCount - 1;
  while (lo <= hi) {
    var mid = lo + hi >>> 1;
    var midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
exports.determineBranch = determineBranch;
var htmlDecoder = getDecoder(decode_data_html_js_1.default);
var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
/**
 * Decodes an HTML string.
 *
 * @param str The string to decode.
 * @param mode The decoding mode.
 * @returns The decoded string.
 */
function decodeHTML(str, mode) {
  if (mode === void 0) {
    mode = DecodingMode.Legacy;
  }
  return htmlDecoder(str, mode);
}
exports.decodeHTML = decodeHTML;
/**
 * Decodes an HTML string in an attribute.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeHTMLAttribute(str) {
  return htmlDecoder(str, DecodingMode.Attribute);
}
exports.decodeHTMLAttribute = decodeHTMLAttribute;
/**
 * Decodes an HTML string, requiring all entities to be terminated by a semicolon.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeHTMLStrict(str) {
  return htmlDecoder(str, DecodingMode.Strict);
}
exports.decodeHTMLStrict = decodeHTMLStrict;
/**
 * Decodes an XML string, requiring all entities to be terminated by a semicolon.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeXML(str) {
  return xmlDecoder(str, DecodingMode.Strict);
}
exports.decodeXML = decodeXML;

/***/ }),

/***/ "./node_modules/entities/lib/decode_codepoint.js":
/*!*******************************************************!*\
  !*** ./node_modules/entities/lib/decode_codepoint.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
var _a;
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.replaceCodePoint = exports.fromCodePoint = void 0;
var decodeMap = new Map([[0, 65533],
// C1 Unicode control character reference replacements
[128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]);
/**
 * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.
 */
exports.fromCodePoint =
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
(_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
  var output = "";
  if (codePoint > 0xffff) {
    codePoint -= 0x10000;
    output += String.fromCharCode(codePoint >>> 10 & 0x3ff | 0xd800);
    codePoint = 0xdc00 | codePoint & 0x3ff;
  }
  output += String.fromCharCode(codePoint);
  return output;
};
/**
 * Replace the given code point with a replacement character if it is a
 * surrogate or is outside the valid range. Otherwise return the code
 * point unchanged.
 */
function replaceCodePoint(codePoint) {
  var _a;
  if (codePoint >= 0xd800 && codePoint <= 0xdfff || codePoint > 0x10ffff) {
    return 0xfffd;
  }
  return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
}
exports.replaceCodePoint = replaceCodePoint;
/**
 * Replace the code point if relevant, then convert it to a string.
 *
 * @deprecated Use `fromCodePoint(replaceCodePoint(codePoint))` instead.
 * @param codePoint The code point to decode.
 * @returns The decoded code point.
 */
function decodeCodePoint(codePoint) {
  return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
}
exports["default"] = decodeCodePoint;

/***/ }),

/***/ "./node_modules/entities/lib/escape.js":
/*!*********************************************!*\
  !*** ./node_modules/entities/lib/escape.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = void 0;
exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = new Map([[34, "&quot;"], [38, "&amp;"], [39, "&apos;"], [60, "&lt;"], [62, "&gt;"]]);
// For compatibility with node < 4, we wrap `codePointAt`
exports.getCodePoint =
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.prototype.codePointAt != null ? function (str, index) {
  return str.codePointAt(index);
} :
// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
function (c, index) {
  return (c.charCodeAt(index) & 0xfc00) === 0xd800 ? (c.charCodeAt(index) - 0xd800) * 0x400 + c.charCodeAt(index + 1) - 0xdc00 + 0x10000 : c.charCodeAt(index);
};
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
function encodeXML(str) {
  var ret = "";
  var lastIdx = 0;
  var match;
  while ((match = exports.xmlReplacer.exec(str)) !== null) {
    var i = match.index;
    var char = str.charCodeAt(i);
    var next = xmlCodeMap.get(char);
    if (next !== undefined) {
      ret += str.substring(lastIdx, i) + next;
      lastIdx = i + 1;
    } else {
      ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports.getCodePoint)(str, i).toString(16), ";");
      // Increase by 1 if we have a surrogate pair
      lastIdx = exports.xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);
    }
  }
  return ret + str.substr(lastIdx);
}
exports.encodeXML = encodeXML;
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */
exports.escape = encodeXML;
/**
 * Creates a function that escapes all characters matched by the given regular
 * expression using the given map of characters to escape to their entities.
 *
 * @param regex Regular expression to match characters to escape.
 * @param map Map of characters to escape to their entities.
 *
 * @returns Function that escapes all characters matched by the given regular
 * expression using the given map of characters to escape to their entities.
 */
function getEscaper(regex, map) {
  return function escape(data) {
    var match;
    var lastIdx = 0;
    var result = "";
    while (match = regex.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      // We know that this character will be in the map.
      result += map.get(match[0].charCodeAt(0));
      // Every match will be of length 1
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
/**
 * Encodes all characters not valid in XML documents using XML entities.
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */
exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
/**
 * Encodes all characters that have to be escaped in HTML attributes,
 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
 *
 * @param data String to escape.
 */
exports.escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([[34, "&quot;"], [38, "&amp;"], [160, "&nbsp;"]]));
/**
 * Encodes all characters that have to be escaped in HTML text,
 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
 *
 * @param data String to escape.
 */
exports.escapeText = getEscaper(/[&<>\u00A0]/g, new Map([[38, "&amp;"], [60, "&lt;"], [62, "&gt;"], [160, "&nbsp;"]]));

/***/ }),

/***/ "./node_modules/entities/lib/generated/decode-data-html.js":
/*!*****************************************************************!*\
  !*** ./node_modules/entities/lib/generated/decode-data-html.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Generated using scripts/write-decode-map.ts
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = new Uint16Array(
// prettier-ignore
"\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c".split("").map(function (c) {
  return c.charCodeAt(0);
}));

/***/ }),

/***/ "./node_modules/entities/lib/generated/decode-data-xml.js":
/*!****************************************************************!*\
  !*** ./node_modules/entities/lib/generated/decode-data-xml.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Generated using scripts/write-decode-map.ts
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = new Uint16Array(
// prettier-ignore
"\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022".split("").map(function (c) {
  return c.charCodeAt(0);
}));

/***/ }),

/***/ "./node_modules/es-define-property/index.js":
/*!**************************************************!*\
  !*** ./node_modules/es-define-property/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

/** @type {import('.')} */
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
if ($defineProperty) {
  try {
    $defineProperty({}, 'a', {
      value: 1
    });
  } catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = false;
  }
}
module.exports = $defineProperty;

/***/ }),

/***/ "./node_modules/es-errors/eval.js":
/*!****************************************!*\
  !*** ./node_modules/es-errors/eval.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;

/***/ }),

/***/ "./node_modules/es-errors/index.js":
/*!*****************************************!*\
  !*** ./node_modules/es-errors/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;

/***/ }),

/***/ "./node_modules/es-errors/range.js":
/*!*****************************************!*\
  !*** ./node_modules/es-errors/range.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;

/***/ }),

/***/ "./node_modules/es-errors/ref.js":
/*!***************************************!*\
  !*** ./node_modules/es-errors/ref.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;

/***/ }),

/***/ "./node_modules/es-errors/syntax.js":
/*!******************************************!*\
  !*** ./node_modules/es-errors/syntax.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;

/***/ }),

/***/ "./node_modules/es-errors/type.js":
/*!****************************************!*\
  !*** ./node_modules/es-errors/type.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;

/***/ }),

/***/ "./node_modules/es-errors/uri.js":
/*!***************************************!*\
  !*** ./node_modules/es-errors/uri.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0) er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }
  var handler = events[type];
  if (handler === undefined) return false;
  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }
  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this;

  // not listening for removeListener, no need to emit
  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners = events[type];
  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;
  if (events !== undefined) {
    var evlistener = events[type];
    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i) copy[i] = arr[i];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    }
    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

/***/ }),

/***/ "./node_modules/for-each/index.js":
/*!****************************************!*\
  !*** ./node_modules/for-each/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isCallable = __webpack_require__(/*! is-callable */ "./node_modules/is-callable/index.js");
var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var forEachArray = function forEachArray(array, iterator, receiver) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (hasOwnProperty.call(array, i)) {
      if (receiver == null) {
        iterator(array[i], i, array);
      } else {
        iterator.call(receiver, array[i], i, array);
      }
    }
  }
};
var forEachString = function forEachString(string, iterator, receiver) {
  for (var i = 0, len = string.length; i < len; i++) {
    // no such thing as a sparse string.
    if (receiver == null) {
      iterator(string.charAt(i), i, string);
    } else {
      iterator.call(receiver, string.charAt(i), i, string);
    }
  }
};
var forEachObject = function forEachObject(object, iterator, receiver) {
  for (var k in object) {
    if (hasOwnProperty.call(object, k)) {
      if (receiver == null) {
        iterator(object[k], k, object);
      } else {
        iterator.call(receiver, object[k], k, object);
      }
    }
  }
};
var forEach = function forEach(list, iterator, thisArg) {
  if (!isCallable(iterator)) {
    throw new TypeError('iterator must be a function');
  }
  var receiver;
  if (arguments.length >= 3) {
    receiver = thisArg;
  }
  if (toStr.call(list) === '[object Array]') {
    forEachArray(list, iterator, receiver);
  } else if (typeof list === 'string') {
    forEachString(list, iterator, receiver);
  } else {
    forEachObject(list, iterator, receiver);
  }
};
module.exports = forEach;

/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */
var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';
var concatty = function concatty(a, b) {
  var arr = [];
  for (var i = 0; i < a.length; i += 1) {
    arr[i] = a[i];
  }
  for (var j = 0; j < b.length; j += 1) {
    arr[j + a.length] = b[j];
  }
  return arr;
};
var slicy = function slicy(arrLike, offset) {
  var arr = [];
  for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
    arr[j] = arrLike[i];
  }
  return arr;
};
var joiny = function (arr, joiner) {
  var str = '';
  for (var i = 0; i < arr.length; i += 1) {
    str += arr[i];
    if (i + 1 < arr.length) {
      str += joiner;
    }
  }
  return str;
};
module.exports = function bind(that) {
  var target = this;
  if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slicy(arguments, 1);
  var bound;
  var binder = function () {
    if (this instanceof bound) {
      var result = target.apply(this, concatty(args, arguments));
      if (Object(result) === result) {
        return result;
      }
      return this;
    }
    return target.apply(that, concatty(args, arguments));
  };
  var boundLength = max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs[i] = '$' + i;
  }
  bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
  if (target.prototype) {
    var Empty = function Empty() {};
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};

/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");
module.exports = Function.prototype.bind || implementation;

/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;
var $Error = __webpack_require__(/*! es-errors */ "./node_modules/es-errors/index.js");
var $EvalError = __webpack_require__(/*! es-errors/eval */ "./node_modules/es-errors/eval.js");
var $RangeError = __webpack_require__(/*! es-errors/range */ "./node_modules/es-errors/range.js");
var $ReferenceError = __webpack_require__(/*! es-errors/ref */ "./node_modules/es-errors/ref.js");
var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $URIError = __webpack_require__(/*! es-errors/uri */ "./node_modules/es-errors/uri.js");
var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
  } catch (e) {}
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, '');
  } catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
  }
}
var throwTypeError = function () {
  throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $gOPD(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();
var hasProto = __webpack_require__(/*! has-proto */ "./node_modules/has-proto/index.js")();
var getProto = Object.getPrototypeOf || (hasProto ? function (x) {
  return x.__proto__;
} // eslint-disable-line no-proto
: null);
var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
  '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
  '%AsyncFromSyncIteratorPrototype%': undefined,
  '%AsyncFunction%': needsEval,
  '%AsyncGenerator%': needsEval,
  '%AsyncGeneratorFunction%': needsEval,
  '%AsyncIteratorPrototype%': needsEval,
  '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
  '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
  '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
  '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
  '%Boolean%': Boolean,
  '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
  '%Date%': Date,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': $Error,
  '%eval%': eval,
  // eslint-disable-line no-eval
  '%EvalError%': $EvalError,
  '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
  '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
  '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
  '%Function%': $Function,
  '%GeneratorFunction%': needsEval,
  '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
  '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
  '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
  '%JSON%': typeof JSON === 'object' ? JSON : undefined,
  '%Map%': typeof Map === 'undefined' ? undefined : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
  '%Math%': Math,
  '%Number%': Number,
  '%Object%': Object,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
  '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
  '%RangeError%': $RangeError,
  '%ReferenceError%': $ReferenceError,
  '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
  '%RegExp%': RegExp,
  '%Set%': typeof Set === 'undefined' ? undefined : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
  '%String%': String,
  '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
  '%Symbol%': hasSymbols ? Symbol : undefined,
  '%SyntaxError%': $SyntaxError,
  '%ThrowTypeError%': ThrowTypeError,
  '%TypedArray%': TypedArray,
  '%TypeError%': $TypeError,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
  '%URIError%': $URIError,
  '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
  '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
  '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};
if (getProto) {
  try {
    null.error; // eslint-disable-line no-unused-expressions
  } catch (e) {
    // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
    var errorProto = getProto(getProto(e));
    INTRINSICS['%Error.prototype%'] = errorProto;
  }
}
var doEval = function doEval(name) {
  var value;
  if (name === '%AsyncFunction%') {
    value = getEvalledConstructor('async function () {}');
  } else if (name === '%GeneratorFunction%') {
    value = getEvalledConstructor('function* () {}');
  } else if (name === '%AsyncGeneratorFunction%') {
    value = getEvalledConstructor('async function* () {}');
  } else if (name === '%AsyncGenerator%') {
    var fn = doEval('%AsyncGeneratorFunction%');
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === '%AsyncIteratorPrototype%') {
    var gen = doEval('%AsyncGenerator%');
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  __proto__: null,
  '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
  '%ArrayPrototype%': ['Array', 'prototype'],
  '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
  '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
  '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
  '%ArrayProto_values%': ['Array', 'prototype', 'values'],
  '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
  '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
  '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
  '%BooleanPrototype%': ['Boolean', 'prototype'],
  '%DataViewPrototype%': ['DataView', 'prototype'],
  '%DatePrototype%': ['Date', 'prototype'],
  '%ErrorPrototype%': ['Error', 'prototype'],
  '%EvalErrorPrototype%': ['EvalError', 'prototype'],
  '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
  '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
  '%FunctionPrototype%': ['Function', 'prototype'],
  '%Generator%': ['GeneratorFunction', 'prototype'],
  '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
  '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
  '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
  '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
  '%JSONParse%': ['JSON', 'parse'],
  '%JSONStringify%': ['JSON', 'stringify'],
  '%MapPrototype%': ['Map', 'prototype'],
  '%NumberPrototype%': ['Number', 'prototype'],
  '%ObjectPrototype%': ['Object', 'prototype'],
  '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
  '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
  '%PromisePrototype%': ['Promise', 'prototype'],
  '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
  '%Promise_all%': ['Promise', 'all'],
  '%Promise_reject%': ['Promise', 'reject'],
  '%Promise_resolve%': ['Promise', 'resolve'],
  '%RangeErrorPrototype%': ['RangeError', 'prototype'],
  '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
  '%RegExpPrototype%': ['RegExp', 'prototype'],
  '%SetPrototype%': ['Set', 'prototype'],
  '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
  '%StringPrototype%': ['String', 'prototype'],
  '%SymbolPrototype%': ['Symbol', 'prototype'],
  '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
  '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
  '%TypeErrorPrototype%': ['TypeError', 'prototype'],
  '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
  '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
  '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
  '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
  '%URIErrorPrototype%': ['URIError', 'prototype'],
  '%WeakMapPrototype%': ['WeakMap', 'prototype'],
  '%WeakSetPrototype%': ['WeakSet', 'prototype']
};
var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/hasown/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === '%' && last !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
  } else if (last === '%' && first !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
  }
  var result = [];
  $replace(string, rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = '%' + alias[0] + '%';
  }
  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === 'undefined' && !allowMissing) {
      throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    }
    return {
      alias: alias,
      name: intrinsicName,
      value: value
    };
  }
  throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new $TypeError('intrinsic name must be a non-empty string');
  }
  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
  var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
      throw new $SyntaxError('property names with quotes must have matching quotes');
    }
    if (part === 'constructor' || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += '.' + part;
    intrinsicRealName = '%' + intrinsicBaseName + '%';
    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        }
        return void undefined;
      }
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;

        // By convention, when a data property is converted to an accessor
        // property to emulate a data property that does not suffer from
        // the override mistake, that accessor's getter is marked with
        // an `originalValue` property. Here, when we detect this, we
        // uphold the illusion by pretending to see that original data
        // property, i.e., returning the value rather than the getter
        // itself.
        if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};

/***/ }),

/***/ "./node_modules/gopd/index.js":
/*!************************************!*\
  !*** ./node_modules/gopd/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
if ($gOPD) {
  try {
    $gOPD([], 'length');
  } catch (e) {
    // IE 8 has a broken gOPD
    $gOPD = null;
  }
}
module.exports = $gOPD;

/***/ }),

/***/ "./node_modules/has-property-descriptors/index.js":
/*!********************************************************!*\
  !*** ./node_modules/has-property-descriptors/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");
var hasPropertyDescriptors = function hasPropertyDescriptors() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  // node v0.6 has a bug where array lengths can be Set but not Defined
  if (!$defineProperty) {
    return null;
  }
  try {
    return $defineProperty([], 'length', {
      value: 1
    }).length !== 1;
  } catch (e) {
    // In Firefox 4-22, defining length on an array throws an exception.
    return true;
  }
};
module.exports = hasPropertyDescriptors;

/***/ }),

/***/ "./node_modules/has-proto/index.js":
/*!*****************************************!*\
  !*** ./node_modules/has-proto/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


var test = {
  __proto__: null,
  foo: {}
};
var $Object = Object;

/** @type {import('.')} */
module.exports = function hasProto() {
  // @ts-expect-error: TS errors on an inherited property for some reason
  return {
    __proto__: test
  }.foo === test.foo && !(test instanceof $Object);
};

/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");
module.exports = function hasNativeSymbols() {
  if (typeof origSymbol !== 'function') {
    return false;
  }
  if (typeof Symbol !== 'function') {
    return false;
  }
  if (typeof origSymbol('foo') !== 'symbol') {
    return false;
  }
  if (typeof Symbol('bar') !== 'symbol') {
    return false;
  }
  return hasSymbolSham();
};

/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }
  if (typeof Symbol.iterator === 'symbol') {
    return true;
  }
  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);
  if (typeof sym === 'string') {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  }

  // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }

  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};

/***/ }),

/***/ "./node_modules/has-tostringtag/shams.js":
/*!***********************************************!*\
  !*** ./node_modules/has-tostringtag/shams.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/has-symbols/shams.js");

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
  return hasSymbols() && !!Symbol.toStringTag;
};

/***/ }),

/***/ "./node_modules/hasown/index.js":
/*!**************************************!*\
  !*** ./node_modules/hasown/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);

/***/ }),

/***/ "./node_modules/htmlparser2/lib/CollectingHandler.js":
/*!***********************************************************!*\
  !*** ./node_modules/htmlparser2/lib/CollectingHandler.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = CollectingHandler;
function CollectingHandler(cbs) {
  this._cbs = cbs || {};
  this.events = [];
}
var EVENTS = (__webpack_require__(/*! ./ */ "./node_modules/htmlparser2/lib/index.js").EVENTS);
Object.keys(EVENTS).forEach(function (name) {
  if (EVENTS[name] === 0) {
    name = "on" + name;
    CollectingHandler.prototype[name] = function () {
      this.events.push([name]);
      if (this._cbs[name]) this._cbs[name]();
    };
  } else if (EVENTS[name] === 1) {
    name = "on" + name;
    CollectingHandler.prototype[name] = function (a) {
      this.events.push([name, a]);
      if (this._cbs[name]) this._cbs[name](a);
    };
  } else if (EVENTS[name] === 2) {
    name = "on" + name;
    CollectingHandler.prototype[name] = function (a, b) {
      this.events.push([name, a, b]);
      if (this._cbs[name]) this._cbs[name](a, b);
    };
  } else {
    throw Error("wrong number of arguments");
  }
});
CollectingHandler.prototype.onreset = function () {
  this.events = [];
  if (this._cbs.onreset) this._cbs.onreset();
};
CollectingHandler.prototype.restart = function () {
  if (this._cbs.onreset) this._cbs.onreset();
  for (var i = 0, len = this.events.length; i < len; i++) {
    if (this._cbs[this.events[i][0]]) {
      var num = this.events[i].length;
      if (num === 1) {
        this._cbs[this.events[i][0]]();
      } else if (num === 2) {
        this._cbs[this.events[i][0]](this.events[i][1]);
      } else {
        this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);
      }
    }
  }
};

/***/ }),

/***/ "./node_modules/htmlparser2/lib/FeedHandler.js":
/*!*****************************************************!*\
  !*** ./node_modules/htmlparser2/lib/FeedHandler.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DomHandler = __webpack_require__(/*! domhandler */ "./node_modules/htmlparser2/node_modules/domhandler/index.js");
var DomUtils = __webpack_require__(/*! domutils */ "./node_modules/domutils/index.js");

//TODO: make this a streamable handler
function FeedHandler(callback, options) {
  this.init(callback, options);
}
__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(FeedHandler, DomHandler);
FeedHandler.prototype.init = DomHandler;
function getElements(what, where) {
  return DomUtils.getElementsByTagName(what, where, true);
}
function getOneElement(what, where) {
  return DomUtils.getElementsByTagName(what, where, true, 1)[0];
}
function fetch(what, where, recurse) {
  return DomUtils.getText(DomUtils.getElementsByTagName(what, where, recurse, 1)).trim();
}
function addConditionally(obj, prop, what, where, recurse) {
  var tmp = fetch(what, where, recurse);
  if (tmp) obj[prop] = tmp;
}
var isValidFeed = function (value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
};
FeedHandler.prototype.onend = function () {
  var feed = {},
    feedRoot = getOneElement(isValidFeed, this.dom),
    tmp,
    childs;
  if (feedRoot) {
    if (feedRoot.name === "feed") {
      childs = feedRoot.children;
      feed.type = "atom";
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      if ((tmp = getOneElement("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href)) feed.link = tmp;
      addConditionally(feed, "description", "subtitle", childs);
      if (tmp = fetch("updated", childs)) feed.updated = new Date(tmp);
      addConditionally(feed, "author", "email", childs, true);
      feed.items = getElements("entry", childs).map(function (item) {
        var entry = {},
          tmp;
        item = item.children;
        addConditionally(entry, "id", "id", item);
        addConditionally(entry, "title", "title", item);
        if ((tmp = getOneElement("link", item)) && (tmp = tmp.attribs) && (tmp = tmp.href)) entry.link = tmp;
        if (tmp = fetch("summary", item) || fetch("content", item)) entry.description = tmp;
        if (tmp = fetch("updated", item)) entry.pubDate = new Date(tmp);
        return entry;
      });
    } else {
      childs = getOneElement("channel", feedRoot.children).children;
      feed.type = feedRoot.name.substr(0, 3);
      feed.id = "";
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      if (tmp = fetch("lastBuildDate", childs)) feed.updated = new Date(tmp);
      addConditionally(feed, "author", "managingEditor", childs, true);
      feed.items = getElements("item", feedRoot.children).map(function (item) {
        var entry = {},
          tmp;
        item = item.children;
        addConditionally(entry, "id", "guid", item);
        addConditionally(entry, "title", "title", item);
        addConditionally(entry, "link", "link", item);
        addConditionally(entry, "description", "description", item);
        if (tmp = fetch("pubDate", item)) entry.pubDate = new Date(tmp);
        return entry;
      });
    }
  }
  this.dom = feed;
  DomHandler.prototype._handleCallback.call(this, feedRoot ? null : Error("couldn't find root of feed"));
};
module.exports = FeedHandler;

/***/ }),

/***/ "./node_modules/htmlparser2/lib/Parser.js":
/*!************************************************!*\
  !*** ./node_modules/htmlparser2/lib/Parser.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Tokenizer = __webpack_require__(/*! ./Tokenizer.js */ "./node_modules/htmlparser2/lib/Tokenizer.js");

/*
	Options:

	xmlMode: Disables the special behavior for script/style tags (false by default)
	lowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)
	lowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)
*/

/*
	Callbacks:

	oncdataend,
	oncdatastart,
	onclosetag,
	oncomment,
	oncommentend,
	onerror,
	onopentag,
	onprocessinginstruction,
	onreset,
	ontext
*/

var formTags = {
  input: true,
  option: true,
  optgroup: true,
  select: true,
  button: true,
  datalist: true,
  textarea: true
};
var openImpliesClose = {
  tr: {
    tr: true,
    th: true,
    td: true
  },
  th: {
    th: true
  },
  td: {
    thead: true,
    th: true,
    td: true
  },
  body: {
    head: true,
    link: true,
    script: true
  },
  li: {
    li: true
  },
  p: {
    p: true
  },
  h1: {
    p: true
  },
  h2: {
    p: true
  },
  h3: {
    p: true
  },
  h4: {
    p: true
  },
  h5: {
    p: true
  },
  h6: {
    p: true
  },
  select: formTags,
  input: formTags,
  output: formTags,
  button: formTags,
  datalist: formTags,
  textarea: formTags,
  option: {
    option: true
  },
  optgroup: {
    optgroup: true
  }
};
var voidElements = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};
var foreignContextElements = {
  __proto__: null,
  math: true,
  svg: true
};
var htmlIntegrationElements = {
  __proto__: null,
  mi: true,
  mo: true,
  mn: true,
  ms: true,
  mtext: true,
  "annotation-xml": true,
  foreignObject: true,
  desc: true,
  title: true
};
var re_nameEnd = /\s|\//;
function Parser(cbs, options) {
  this._options = options || {};
  this._cbs = cbs || {};
  this._tagname = "";
  this._attribname = "";
  this._attribvalue = "";
  this._attribs = null;
  this._stack = [];
  this._foreignContext = [];
  this.startIndex = 0;
  this.endIndex = null;
  this._lowerCaseTagNames = "lowerCaseTags" in this._options ? !!this._options.lowerCaseTags : !this._options.xmlMode;
  this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ? !!this._options.lowerCaseAttributeNames : !this._options.xmlMode;
  if (this._options.Tokenizer) {
    Tokenizer = this._options.Tokenizer;
  }
  this._tokenizer = new Tokenizer(this._options, this);
  if (this._cbs.onparserinit) this._cbs.onparserinit(this);
}
__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Parser, (__webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter));
Parser.prototype._updatePosition = function (initialOffset) {
  if (this.endIndex === null) {
    if (this._tokenizer._sectionStart <= initialOffset) {
      this.startIndex = 0;
    } else {
      this.startIndex = this._tokenizer._sectionStart - initialOffset;
    }
  } else this.startIndex = this.endIndex + 1;
  this.endIndex = this._tokenizer.getAbsoluteIndex();
};

//Tokenizer event handlers
Parser.prototype.ontext = function (data) {
  this._updatePosition(1);
  this.endIndex--;
  if (this._cbs.ontext) this._cbs.ontext(data);
};
Parser.prototype.onopentagname = function (name) {
  if (this._lowerCaseTagNames) {
    name = name.toLowerCase();
  }
  this._tagname = name;
  if (!this._options.xmlMode && name in openImpliesClose) {
    for (var el; (el = this._stack[this._stack.length - 1]) in openImpliesClose[name]; this.onclosetag(el));
  }
  if (this._options.xmlMode || !(name in voidElements)) {
    this._stack.push(name);
    if (name in foreignContextElements) this._foreignContext.push(true);else if (name in htmlIntegrationElements) this._foreignContext.push(false);
  }
  if (this._cbs.onopentagname) this._cbs.onopentagname(name);
  if (this._cbs.onopentag) this._attribs = {};
};
Parser.prototype.onopentagend = function () {
  this._updatePosition(1);
  if (this._attribs) {
    if (this._cbs.onopentag) this._cbs.onopentag(this._tagname, this._attribs);
    this._attribs = null;
  }
  if (!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements) {
    this._cbs.onclosetag(this._tagname);
  }
  this._tagname = "";
};
Parser.prototype.onclosetag = function (name) {
  this._updatePosition(1);
  if (this._lowerCaseTagNames) {
    name = name.toLowerCase();
  }
  if (name in foreignContextElements || name in htmlIntegrationElements) {
    this._foreignContext.pop();
  }
  if (this._stack.length && (!(name in voidElements) || this._options.xmlMode)) {
    var pos = this._stack.lastIndexOf(name);
    if (pos !== -1) {
      if (this._cbs.onclosetag) {
        pos = this._stack.length - pos;
        while (pos--) this._cbs.onclosetag(this._stack.pop());
      } else this._stack.length = pos;
    } else if (name === "p" && !this._options.xmlMode) {
      this.onopentagname(name);
      this._closeCurrentTag();
    }
  } else if (!this._options.xmlMode && (name === "br" || name === "p")) {
    this.onopentagname(name);
    this._closeCurrentTag();
  }
};
Parser.prototype.onselfclosingtag = function () {
  if (this._options.xmlMode || this._options.recognizeSelfClosing || this._foreignContext[this._foreignContext.length - 1]) {
    this._closeCurrentTag();
  } else {
    this.onopentagend();
  }
};
Parser.prototype._closeCurrentTag = function () {
  var name = this._tagname;
  this.onopentagend();

  //self-closing tags will be on the top of the stack
  //(cheaper check than in onclosetag)
  if (this._stack[this._stack.length - 1] === name) {
    if (this._cbs.onclosetag) {
      this._cbs.onclosetag(name);
    }
    this._stack.pop();
  }
};
Parser.prototype.onattribname = function (name) {
  if (this._lowerCaseAttributeNames) {
    name = name.toLowerCase();
  }
  this._attribname = name;
};
Parser.prototype.onattribdata = function (value) {
  this._attribvalue += value;
};
Parser.prototype.onattribend = function () {
  if (this._cbs.onattribute) this._cbs.onattribute(this._attribname, this._attribvalue);
  if (this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) {
    this._attribs[this._attribname] = this._attribvalue;
  }
  this._attribname = "";
  this._attribvalue = "";
};
Parser.prototype._getInstructionName = function (value) {
  var idx = value.search(re_nameEnd),
    name = idx < 0 ? value : value.substr(0, idx);
  if (this._lowerCaseTagNames) {
    name = name.toLowerCase();
  }
  return name;
};
Parser.prototype.ondeclaration = function (value) {
  if (this._cbs.onprocessinginstruction) {
    var name = this._getInstructionName(value);
    this._cbs.onprocessinginstruction("!" + name, "!" + value);
  }
};
Parser.prototype.onprocessinginstruction = function (value) {
  if (this._cbs.onprocessinginstruction) {
    var name = this._getInstructionName(value);
    this._cbs.onprocessinginstruction("?" + name, "?" + value);
  }
};
Parser.prototype.oncomment = function (value) {
  this._updatePosition(4);
  if (this._cbs.oncomment) this._cbs.oncomment(value);
  if (this._cbs.oncommentend) this._cbs.oncommentend();
};
Parser.prototype.oncdata = function (value) {
  this._updatePosition(1);
  if (this._options.xmlMode || this._options.recognizeCDATA) {
    if (this._cbs.oncdatastart) this._cbs.oncdatastart();
    if (this._cbs.ontext) this._cbs.ontext(value);
    if (this._cbs.oncdataend) this._cbs.oncdataend();
  } else {
    this.oncomment("[CDATA[" + value + "]]");
  }
};
Parser.prototype.onerror = function (err) {
  if (this._cbs.onerror) this._cbs.onerror(err);
};
Parser.prototype.onend = function () {
  if (this._cbs.onclosetag) {
    for (var i = this._stack.length; i > 0; this._cbs.onclosetag(this._stack[--i]));
  }
  if (this._cbs.onend) this._cbs.onend();
};

//Resets the parser to a blank state, ready to parse a new HTML document
Parser.prototype.reset = function () {
  if (this._cbs.onreset) this._cbs.onreset();
  this._tokenizer.reset();
  this._tagname = "";
  this._attribname = "";
  this._attribs = null;
  this._stack = [];
  if (this._cbs.onparserinit) this._cbs.onparserinit(this);
};

//Parses a complete HTML document and pushes it to the handler
Parser.prototype.parseComplete = function (data) {
  this.reset();
  this.end(data);
};
Parser.prototype.write = function (chunk) {
  this._tokenizer.write(chunk);
};
Parser.prototype.end = function (chunk) {
  this._tokenizer.end(chunk);
};
Parser.prototype.pause = function () {
  this._tokenizer.pause();
};
Parser.prototype.resume = function () {
  this._tokenizer.resume();
};

//alias for backwards compat
Parser.prototype.parseChunk = Parser.prototype.write;
Parser.prototype.done = Parser.prototype.end;
module.exports = Parser;

/***/ }),

/***/ "./node_modules/htmlparser2/lib/ProxyHandler.js":
/*!******************************************************!*\
  !*** ./node_modules/htmlparser2/lib/ProxyHandler.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = ProxyHandler;
function ProxyHandler(cbs) {
  this._cbs = cbs || {};
}
var EVENTS = (__webpack_require__(/*! ./ */ "./node_modules/htmlparser2/lib/index.js").EVENTS);
Object.keys(EVENTS).forEach(function (name) {
  if (EVENTS[name] === 0) {
    name = "on" + name;
    ProxyHandler.prototype[name] = function () {
      if (this._cbs[name]) this._cbs[name]();
    };
  } else if (EVENTS[name] === 1) {
    name = "on" + name;
    ProxyHandler.prototype[name] = function (a) {
      if (this._cbs[name]) this._cbs[name](a);
    };
  } else if (EVENTS[name] === 2) {
    name = "on" + name;
    ProxyHandler.prototype[name] = function (a, b) {
      if (this._cbs[name]) this._cbs[name](a, b);
    };
  } else {
    throw Error("wrong number of arguments");
  }
});

/***/ }),

/***/ "./node_modules/htmlparser2/lib/Stream.js":
/*!************************************************!*\
  !*** ./node_modules/htmlparser2/lib/Stream.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = Stream;
var Parser = __webpack_require__(/*! ./WritableStream.js */ "./node_modules/htmlparser2/lib/WritableStream.js");
function Stream(options) {
  Parser.call(this, new Cbs(this), options);
}
__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Stream, Parser);
Stream.prototype.readable = true;
function Cbs(scope) {
  this.scope = scope;
}
var EVENTS = (__webpack_require__(/*! ../ */ "./node_modules/htmlparser2/lib/index.js").EVENTS);
Object.keys(EVENTS).forEach(function (name) {
  if (EVENTS[name] === 0) {
    Cbs.prototype["on" + name] = function () {
      this.scope.emit(name);
    };
  } else if (EVENTS[name] === 1) {
    Cbs.prototype["on" + name] = function (a) {
      this.scope.emit(name, a);
    };
  } else if (EVENTS[name] === 2) {
    Cbs.prototype["on" + name] = function (a, b) {
      this.scope.emit(name, a, b);
    };
  } else {
    throw Error("wrong number of arguments!");
  }
});

/***/ }),

/***/ "./node_modules/htmlparser2/lib/Tokenizer.js":
/*!***************************************************!*\
  !*** ./node_modules/htmlparser2/lib/Tokenizer.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = Tokenizer;
var decodeCodePoint = __webpack_require__(/*! entities/lib/decode_codepoint.js */ "./node_modules/htmlparser2/node_modules/entities/lib/decode_codepoint.js");
var entityMap = __webpack_require__(/*! entities/maps/entities.json */ "./node_modules/htmlparser2/node_modules/entities/maps/entities.json");
var legacyMap = __webpack_require__(/*! entities/maps/legacy.json */ "./node_modules/htmlparser2/node_modules/entities/maps/legacy.json");
var xmlMap = __webpack_require__(/*! entities/maps/xml.json */ "./node_modules/htmlparser2/node_modules/entities/maps/xml.json");
var i = 0;
var TEXT = i++;
var BEFORE_TAG_NAME = i++; //after <
var IN_TAG_NAME = i++;
var IN_SELF_CLOSING_TAG = i++;
var BEFORE_CLOSING_TAG_NAME = i++;
var IN_CLOSING_TAG_NAME = i++;
var AFTER_CLOSING_TAG_NAME = i++;

//attributes
var BEFORE_ATTRIBUTE_NAME = i++;
var IN_ATTRIBUTE_NAME = i++;
var AFTER_ATTRIBUTE_NAME = i++;
var BEFORE_ATTRIBUTE_VALUE = i++;
var IN_ATTRIBUTE_VALUE_DQ = i++; // "
var IN_ATTRIBUTE_VALUE_SQ = i++; // '
var IN_ATTRIBUTE_VALUE_NQ = i++;

//declarations
var BEFORE_DECLARATION = i++; // !
var IN_DECLARATION = i++;

//processing instructions
var IN_PROCESSING_INSTRUCTION = i++; // ?

//comments
var BEFORE_COMMENT = i++;
var IN_COMMENT = i++;
var AFTER_COMMENT_1 = i++;
var AFTER_COMMENT_2 = i++;

//cdata
var BEFORE_CDATA_1 = i++; // [
var BEFORE_CDATA_2 = i++; // C
var BEFORE_CDATA_3 = i++; // D
var BEFORE_CDATA_4 = i++; // A
var BEFORE_CDATA_5 = i++; // T
var BEFORE_CDATA_6 = i++; // A
var IN_CDATA = i++; // [
var AFTER_CDATA_1 = i++; // ]
var AFTER_CDATA_2 = i++; // ]

//special tags
var BEFORE_SPECIAL = i++; //S
var BEFORE_SPECIAL_END = i++; //S

var BEFORE_SCRIPT_1 = i++; //C
var BEFORE_SCRIPT_2 = i++; //R
var BEFORE_SCRIPT_3 = i++; //I
var BEFORE_SCRIPT_4 = i++; //P
var BEFORE_SCRIPT_5 = i++; //T
var AFTER_SCRIPT_1 = i++; //C
var AFTER_SCRIPT_2 = i++; //R
var AFTER_SCRIPT_3 = i++; //I
var AFTER_SCRIPT_4 = i++; //P
var AFTER_SCRIPT_5 = i++; //T

var BEFORE_STYLE_1 = i++; //T
var BEFORE_STYLE_2 = i++; //Y
var BEFORE_STYLE_3 = i++; //L
var BEFORE_STYLE_4 = i++; //E
var AFTER_STYLE_1 = i++; //T
var AFTER_STYLE_2 = i++; //Y
var AFTER_STYLE_3 = i++; //L
var AFTER_STYLE_4 = i++; //E

var BEFORE_ENTITY = i++; //&
var BEFORE_NUMERIC_ENTITY = i++; //#
var IN_NAMED_ENTITY = i++;
var IN_NUMERIC_ENTITY = i++;
var IN_HEX_ENTITY = i++; //X

var j = 0;
var SPECIAL_NONE = j++;
var SPECIAL_SCRIPT = j++;
var SPECIAL_STYLE = j++;
function whitespace(c) {
  return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}
function ifElseState(upper, SUCCESS, FAILURE) {
  var lower = upper.toLowerCase();
  if (upper === lower) {
    return function (c) {
      if (c === lower) {
        this._state = SUCCESS;
      } else {
        this._state = FAILURE;
        this._index--;
      }
    };
  } else {
    return function (c) {
      if (c === lower || c === upper) {
        this._state = SUCCESS;
      } else {
        this._state = FAILURE;
        this._index--;
      }
    };
  }
}
function consumeSpecialNameChar(upper, NEXT_STATE) {
  var lower = upper.toLowerCase();
  return function (c) {
    if (c === lower || c === upper) {
      this._state = NEXT_STATE;
    } else {
      this._state = IN_TAG_NAME;
      this._index--; //consume the token again
    }
  };
}
function Tokenizer(options, cbs) {
  this._state = TEXT;
  this._buffer = "";
  this._sectionStart = 0;
  this._index = 0;
  this._bufferOffset = 0; //chars removed from _buffer
  this._baseState = TEXT;
  this._special = SPECIAL_NONE;
  this._cbs = cbs;
  this._running = true;
  this._ended = false;
  this._xmlMode = !!(options && options.xmlMode);
  this._decodeEntities = !!(options && options.decodeEntities);
}
Tokenizer.prototype._stateText = function (c) {
  if (c === "<") {
    if (this._index > this._sectionStart) {
      this._cbs.ontext(this._getSection());
    }
    this._state = BEFORE_TAG_NAME;
    this._sectionStart = this._index;
  } else if (this._decodeEntities && this._special === SPECIAL_NONE && c === "&") {
    if (this._index > this._sectionStart) {
      this._cbs.ontext(this._getSection());
    }
    this._baseState = TEXT;
    this._state = BEFORE_ENTITY;
    this._sectionStart = this._index;
  }
};
Tokenizer.prototype._stateBeforeTagName = function (c) {
  if (c === "/") {
    this._state = BEFORE_CLOSING_TAG_NAME;
  } else if (c === "<") {
    this._cbs.ontext(this._getSection());
    this._sectionStart = this._index;
  } else if (c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {
    this._state = TEXT;
  } else if (c === "!") {
    this._state = BEFORE_DECLARATION;
    this._sectionStart = this._index + 1;
  } else if (c === "?") {
    this._state = IN_PROCESSING_INSTRUCTION;
    this._sectionStart = this._index + 1;
  } else {
    this._state = !this._xmlMode && (c === "s" || c === "S") ? BEFORE_SPECIAL : IN_TAG_NAME;
    this._sectionStart = this._index;
  }
};
Tokenizer.prototype._stateInTagName = function (c) {
  if (c === "/" || c === ">" || whitespace(c)) {
    this._emitToken("onopentagname");
    this._state = BEFORE_ATTRIBUTE_NAME;
    this._index--;
  }
};
Tokenizer.prototype._stateBeforeCloseingTagName = function (c) {
  if (whitespace(c)) ;else if (c === ">") {
    this._state = TEXT;
  } else if (this._special !== SPECIAL_NONE) {
    if (c === "s" || c === "S") {
      this._state = BEFORE_SPECIAL_END;
    } else {
      this._state = TEXT;
      this._index--;
    }
  } else {
    this._state = IN_CLOSING_TAG_NAME;
    this._sectionStart = this._index;
  }
};
Tokenizer.prototype._stateInCloseingTagName = function (c) {
  if (c === ">" || whitespace(c)) {
    this._emitToken("onclosetag");
    this._state = AFTER_CLOSING_TAG_NAME;
    this._index--;
  }
};
Tokenizer.prototype._stateAfterCloseingTagName = function (c) {
  //skip everything until ">"
  if (c === ">") {
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  }
};
Tokenizer.prototype._stateBeforeAttributeName = function (c) {
  if (c === ">") {
    this._cbs.onopentagend();
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  } else if (c === "/") {
    this._state = IN_SELF_CLOSING_TAG;
  } else if (!whitespace(c)) {
    this._state = IN_ATTRIBUTE_NAME;
    this._sectionStart = this._index;
  }
};
Tokenizer.prototype._stateInSelfClosingTag = function (c) {
  if (c === ">") {
    this._cbs.onselfclosingtag();
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  } else if (!whitespace(c)) {
    this._state = BEFORE_ATTRIBUTE_NAME;
    this._index--;
  }
};
Tokenizer.prototype._stateInAttributeName = function (c) {
  if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
    this._cbs.onattribname(this._getSection());
    this._sectionStart = -1;
    this._state = AFTER_ATTRIBUTE_NAME;
    this._index--;
  }
};
Tokenizer.prototype._stateAfterAttributeName = function (c) {
  if (c === "=") {
    this._state = BEFORE_ATTRIBUTE_VALUE;
  } else if (c === "/" || c === ">") {
    this._cbs.onattribend();
    this._state = BEFORE_ATTRIBUTE_NAME;
    this._index--;
  } else if (!whitespace(c)) {
    this._cbs.onattribend();
    this._state = IN_ATTRIBUTE_NAME;
    this._sectionStart = this._index;
  }
};
Tokenizer.prototype._stateBeforeAttributeValue = function (c) {
  if (c === '"') {
    this._state = IN_ATTRIBUTE_VALUE_DQ;
    this._sectionStart = this._index + 1;
  } else if (c === "'") {
    this._state = IN_ATTRIBUTE_VALUE_SQ;
    this._sectionStart = this._index + 1;
  } else if (!whitespace(c)) {
    this._state = IN_ATTRIBUTE_VALUE_NQ;
    this._sectionStart = this._index;
    this._index--; //reconsume token
  }
};
Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function (c) {
  if (c === '"') {
    this._emitToken("onattribdata");
    this._cbs.onattribend();
    this._state = BEFORE_ATTRIBUTE_NAME;
  } else if (this._decodeEntities && c === "&") {
    this._emitToken("onattribdata");
    this._baseState = this._state;
    this._state = BEFORE_ENTITY;
    this._sectionStart = this._index;
  }
};
Tokenizer.prototype._stateInAttributeValueSingleQuotes = function (c) {
  if (c === "'") {
    this._emitToken("onattribdata");
    this._cbs.onattribend();
    this._state = BEFORE_ATTRIBUTE_NAME;
  } else if (this._decodeEntities && c === "&") {
    this._emitToken("onattribdata");
    this._baseState = this._state;
    this._state = BEFORE_ENTITY;
    this._sectionStart = this._index;
  }
};
Tokenizer.prototype._stateInAttributeValueNoQuotes = function (c) {
  if (whitespace(c) || c === ">") {
    this._emitToken("onattribdata");
    this._cbs.onattribend();
    this._state = BEFORE_ATTRIBUTE_NAME;
    this._index--;
  } else if (this._decodeEntities && c === "&") {
    this._emitToken("onattribdata");
    this._baseState = this._state;
    this._state = BEFORE_ENTITY;
    this._sectionStart = this._index;
  }
};
Tokenizer.prototype._stateBeforeDeclaration = function (c) {
  this._state = c === "[" ? BEFORE_CDATA_1 : c === "-" ? BEFORE_COMMENT : IN_DECLARATION;
};
Tokenizer.prototype._stateInDeclaration = function (c) {
  if (c === ">") {
    this._cbs.ondeclaration(this._getSection());
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  }
};
Tokenizer.prototype._stateInProcessingInstruction = function (c) {
  if (c === ">") {
    this._cbs.onprocessinginstruction(this._getSection());
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  }
};
Tokenizer.prototype._stateBeforeComment = function (c) {
  if (c === "-") {
    this._state = IN_COMMENT;
    this._sectionStart = this._index + 1;
  } else {
    this._state = IN_DECLARATION;
  }
};
Tokenizer.prototype._stateInComment = function (c) {
  if (c === "-") this._state = AFTER_COMMENT_1;
};
Tokenizer.prototype._stateAfterComment1 = function (c) {
  if (c === "-") {
    this._state = AFTER_COMMENT_2;
  } else {
    this._state = IN_COMMENT;
  }
};
Tokenizer.prototype._stateAfterComment2 = function (c) {
  if (c === ">") {
    //remove 2 trailing chars
    this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  } else if (c !== "-") {
    this._state = IN_COMMENT;
  }
  // else: stay in AFTER_COMMENT_2 (`--->`)
};
Tokenizer.prototype._stateBeforeCdata1 = ifElseState("C", BEFORE_CDATA_2, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata2 = ifElseState("D", BEFORE_CDATA_3, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata3 = ifElseState("A", BEFORE_CDATA_4, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata4 = ifElseState("T", BEFORE_CDATA_5, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata5 = ifElseState("A", BEFORE_CDATA_6, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata6 = function (c) {
  if (c === "[") {
    this._state = IN_CDATA;
    this._sectionStart = this._index + 1;
  } else {
    this._state = IN_DECLARATION;
    this._index--;
  }
};
Tokenizer.prototype._stateInCdata = function (c) {
  if (c === "]") this._state = AFTER_CDATA_1;
};
Tokenizer.prototype._stateAfterCdata1 = function (c) {
  if (c === "]") this._state = AFTER_CDATA_2;else this._state = IN_CDATA;
};
Tokenizer.prototype._stateAfterCdata2 = function (c) {
  if (c === ">") {
    //remove 2 trailing chars
    this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  } else if (c !== "]") {
    this._state = IN_CDATA;
  }
  //else: stay in AFTER_CDATA_2 (`]]]>`)
};
Tokenizer.prototype._stateBeforeSpecial = function (c) {
  if (c === "c" || c === "C") {
    this._state = BEFORE_SCRIPT_1;
  } else if (c === "t" || c === "T") {
    this._state = BEFORE_STYLE_1;
  } else {
    this._state = IN_TAG_NAME;
    this._index--; //consume the token again
  }
};
Tokenizer.prototype._stateBeforeSpecialEnd = function (c) {
  if (this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")) {
    this._state = AFTER_SCRIPT_1;
  } else if (this._special === SPECIAL_STYLE && (c === "t" || c === "T")) {
    this._state = AFTER_STYLE_1;
  } else this._state = TEXT;
};
Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar("R", BEFORE_SCRIPT_2);
Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar("I", BEFORE_SCRIPT_3);
Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar("P", BEFORE_SCRIPT_4);
Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar("T", BEFORE_SCRIPT_5);
Tokenizer.prototype._stateBeforeScript5 = function (c) {
  if (c === "/" || c === ">" || whitespace(c)) {
    this._special = SPECIAL_SCRIPT;
  }
  this._state = IN_TAG_NAME;
  this._index--; //consume the token again
};
Tokenizer.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
Tokenizer.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
Tokenizer.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
Tokenizer.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);
Tokenizer.prototype._stateAfterScript5 = function (c) {
  if (c === ">" || whitespace(c)) {
    this._special = SPECIAL_NONE;
    this._state = IN_CLOSING_TAG_NAME;
    this._sectionStart = this._index - 6;
    this._index--; //reconsume the token
  } else this._state = TEXT;
};
Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar("Y", BEFORE_STYLE_2);
Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar("L", BEFORE_STYLE_3);
Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar("E", BEFORE_STYLE_4);
Tokenizer.prototype._stateBeforeStyle4 = function (c) {
  if (c === "/" || c === ">" || whitespace(c)) {
    this._special = SPECIAL_STYLE;
  }
  this._state = IN_TAG_NAME;
  this._index--; //consume the token again
};
Tokenizer.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
Tokenizer.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
Tokenizer.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);
Tokenizer.prototype._stateAfterStyle4 = function (c) {
  if (c === ">" || whitespace(c)) {
    this._special = SPECIAL_NONE;
    this._state = IN_CLOSING_TAG_NAME;
    this._sectionStart = this._index - 5;
    this._index--; //reconsume the token
  } else this._state = TEXT;
};
Tokenizer.prototype._stateBeforeEntity = ifElseState("#", BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
Tokenizer.prototype._stateBeforeNumericEntity = ifElseState("X", IN_HEX_ENTITY, IN_NUMERIC_ENTITY);

//for entities terminated with a semicolon
Tokenizer.prototype._parseNamedEntityStrict = function () {
  //offset = 1
  if (this._sectionStart + 1 < this._index) {
    var entity = this._buffer.substring(this._sectionStart + 1, this._index),
      map = this._xmlMode ? xmlMap : entityMap;
    if (map.hasOwnProperty(entity)) {
      this._emitPartial(map[entity]);
      this._sectionStart = this._index + 1;
    }
  }
};

//parses legacy entities (without trailing semicolon)
Tokenizer.prototype._parseLegacyEntity = function () {
  var start = this._sectionStart + 1,
    limit = this._index - start;
  if (limit > 6) limit = 6; //the max length of legacy entities is 6

  while (limit >= 2) {
    //the min length of legacy entities is 2
    var entity = this._buffer.substr(start, limit);
    if (legacyMap.hasOwnProperty(entity)) {
      this._emitPartial(legacyMap[entity]);
      this._sectionStart += limit + 1;
      return;
    } else {
      limit--;
    }
  }
};
Tokenizer.prototype._stateInNamedEntity = function (c) {
  if (c === ";") {
    this._parseNamedEntityStrict();
    if (this._sectionStart + 1 < this._index && !this._xmlMode) {
      this._parseLegacyEntity();
    }
    this._state = this._baseState;
  } else if ((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")) {
    if (this._xmlMode) ;else if (this._sectionStart + 1 === this._index) ;else if (this._baseState !== TEXT) {
      if (c !== "=") {
        this._parseNamedEntityStrict();
      }
    } else {
      this._parseLegacyEntity();
    }
    this._state = this._baseState;
    this._index--;
  }
};
Tokenizer.prototype._decodeNumericEntity = function (offset, base) {
  var sectionStart = this._sectionStart + offset;
  if (sectionStart !== this._index) {
    //parse entity
    var entity = this._buffer.substring(sectionStart, this._index);
    var parsed = parseInt(entity, base);
    this._emitPartial(decodeCodePoint(parsed));
    this._sectionStart = this._index;
  } else {
    this._sectionStart--;
  }
  this._state = this._baseState;
};
Tokenizer.prototype._stateInNumericEntity = function (c) {
  if (c === ";") {
    this._decodeNumericEntity(2, 10);
    this._sectionStart++;
  } else if (c < "0" || c > "9") {
    if (!this._xmlMode) {
      this._decodeNumericEntity(2, 10);
    } else {
      this._state = this._baseState;
    }
    this._index--;
  }
};
Tokenizer.prototype._stateInHexEntity = function (c) {
  if (c === ";") {
    this._decodeNumericEntity(3, 16);
    this._sectionStart++;
  } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
    if (!this._xmlMode) {
      this._decodeNumericEntity(3, 16);
    } else {
      this._state = this._baseState;
    }
    this._index--;
  }
};
Tokenizer.prototype._cleanup = function () {
  if (this._sectionStart < 0) {
    this._buffer = "";
    this._bufferOffset += this._index;
    this._index = 0;
  } else if (this._running) {
    if (this._state === TEXT) {
      if (this._sectionStart !== this._index) {
        this._cbs.ontext(this._buffer.substr(this._sectionStart));
      }
      this._buffer = "";
      this._bufferOffset += this._index;
      this._index = 0;
    } else if (this._sectionStart === this._index) {
      //the section just started
      this._buffer = "";
      this._bufferOffset += this._index;
      this._index = 0;
    } else {
      //remove everything unnecessary
      this._buffer = this._buffer.substr(this._sectionStart);
      this._index -= this._sectionStart;
      this._bufferOffset += this._sectionStart;
    }
    this._sectionStart = 0;
  }
};

//TODO make events conditional
Tokenizer.prototype.write = function (chunk) {
  if (this._ended) this._cbs.onerror(Error(".write() after done!"));
  this._buffer += chunk;
  this._parse();
};
Tokenizer.prototype._parse = function () {
  while (this._index < this._buffer.length && this._running) {
    var c = this._buffer.charAt(this._index);
    if (this._state === TEXT) {
      this._stateText(c);
    } else if (this._state === BEFORE_TAG_NAME) {
      this._stateBeforeTagName(c);
    } else if (this._state === IN_TAG_NAME) {
      this._stateInTagName(c);
    } else if (this._state === BEFORE_CLOSING_TAG_NAME) {
      this._stateBeforeCloseingTagName(c);
    } else if (this._state === IN_CLOSING_TAG_NAME) {
      this._stateInCloseingTagName(c);
    } else if (this._state === AFTER_CLOSING_TAG_NAME) {
      this._stateAfterCloseingTagName(c);
    } else if (this._state === IN_SELF_CLOSING_TAG) {
      this._stateInSelfClosingTag(c);
    } else if (this._state === BEFORE_ATTRIBUTE_NAME) {
      /*
      *	attributes
      */
      this._stateBeforeAttributeName(c);
    } else if (this._state === IN_ATTRIBUTE_NAME) {
      this._stateInAttributeName(c);
    } else if (this._state === AFTER_ATTRIBUTE_NAME) {
      this._stateAfterAttributeName(c);
    } else if (this._state === BEFORE_ATTRIBUTE_VALUE) {
      this._stateBeforeAttributeValue(c);
    } else if (this._state === IN_ATTRIBUTE_VALUE_DQ) {
      this._stateInAttributeValueDoubleQuotes(c);
    } else if (this._state === IN_ATTRIBUTE_VALUE_SQ) {
      this._stateInAttributeValueSingleQuotes(c);
    } else if (this._state === IN_ATTRIBUTE_VALUE_NQ) {
      this._stateInAttributeValueNoQuotes(c);
    } else if (this._state === BEFORE_DECLARATION) {
      /*
      *	declarations
      */
      this._stateBeforeDeclaration(c);
    } else if (this._state === IN_DECLARATION) {
      this._stateInDeclaration(c);
    } else if (this._state === IN_PROCESSING_INSTRUCTION) {
      /*
      *	processing instructions
      */
      this._stateInProcessingInstruction(c);
    } else if (this._state === BEFORE_COMMENT) {
      /*
      *	comments
      */
      this._stateBeforeComment(c);
    } else if (this._state === IN_COMMENT) {
      this._stateInComment(c);
    } else if (this._state === AFTER_COMMENT_1) {
      this._stateAfterComment1(c);
    } else if (this._state === AFTER_COMMENT_2) {
      this._stateAfterComment2(c);
    } else if (this._state === BEFORE_CDATA_1) {
      /*
      *	cdata
      */
      this._stateBeforeCdata1(c);
    } else if (this._state === BEFORE_CDATA_2) {
      this._stateBeforeCdata2(c);
    } else if (this._state === BEFORE_CDATA_3) {
      this._stateBeforeCdata3(c);
    } else if (this._state === BEFORE_CDATA_4) {
      this._stateBeforeCdata4(c);
    } else if (this._state === BEFORE_CDATA_5) {
      this._stateBeforeCdata5(c);
    } else if (this._state === BEFORE_CDATA_6) {
      this._stateBeforeCdata6(c);
    } else if (this._state === IN_CDATA) {
      this._stateInCdata(c);
    } else if (this._state === AFTER_CDATA_1) {
      this._stateAfterCdata1(c);
    } else if (this._state === AFTER_CDATA_2) {
      this._stateAfterCdata2(c);
    } else if (this._state === BEFORE_SPECIAL) {
      /*
      * special tags
      */
      this._stateBeforeSpecial(c);
    } else if (this._state === BEFORE_SPECIAL_END) {
      this._stateBeforeSpecialEnd(c);
    } else if (this._state === BEFORE_SCRIPT_1) {
      /*
      * script
      */
      this._stateBeforeScript1(c);
    } else if (this._state === BEFORE_SCRIPT_2) {
      this._stateBeforeScript2(c);
    } else if (this._state === BEFORE_SCRIPT_3) {
      this._stateBeforeScript3(c);
    } else if (this._state === BEFORE_SCRIPT_4) {
      this._stateBeforeScript4(c);
    } else if (this._state === BEFORE_SCRIPT_5) {
      this._stateBeforeScript5(c);
    } else if (this._state === AFTER_SCRIPT_1) {
      this._stateAfterScript1(c);
    } else if (this._state === AFTER_SCRIPT_2) {
      this._stateAfterScript2(c);
    } else if (this._state === AFTER_SCRIPT_3) {
      this._stateAfterScript3(c);
    } else if (this._state === AFTER_SCRIPT_4) {
      this._stateAfterScript4(c);
    } else if (this._state === AFTER_SCRIPT_5) {
      this._stateAfterScript5(c);
    } else if (this._state === BEFORE_STYLE_1) {
      /*
      * style
      */
      this._stateBeforeStyle1(c);
    } else if (this._state === BEFORE_STYLE_2) {
      this._stateBeforeStyle2(c);
    } else if (this._state === BEFORE_STYLE_3) {
      this._stateBeforeStyle3(c);
    } else if (this._state === BEFORE_STYLE_4) {
      this._stateBeforeStyle4(c);
    } else if (this._state === AFTER_STYLE_1) {
      this._stateAfterStyle1(c);
    } else if (this._state === AFTER_STYLE_2) {
      this._stateAfterStyle2(c);
    } else if (this._state === AFTER_STYLE_3) {
      this._stateAfterStyle3(c);
    } else if (this._state === AFTER_STYLE_4) {
      this._stateAfterStyle4(c);
    } else if (this._state === BEFORE_ENTITY) {
      /*
      * entities
      */
      this._stateBeforeEntity(c);
    } else if (this._state === BEFORE_NUMERIC_ENTITY) {
      this._stateBeforeNumericEntity(c);
    } else if (this._state === IN_NAMED_ENTITY) {
      this._stateInNamedEntity(c);
    } else if (this._state === IN_NUMERIC_ENTITY) {
      this._stateInNumericEntity(c);
    } else if (this._state === IN_HEX_ENTITY) {
      this._stateInHexEntity(c);
    } else {
      this._cbs.onerror(Error("unknown _state"), this._state);
    }
    this._index++;
  }
  this._cleanup();
};
Tokenizer.prototype.pause = function () {
  this._running = false;
};
Tokenizer.prototype.resume = function () {
  this._running = true;
  if (this._index < this._buffer.length) {
    this._parse();
  }
  if (this._ended) {
    this._finish();
  }
};
Tokenizer.prototype.end = function (chunk) {
  if (this._ended) this._cbs.onerror(Error(".end() after done!"));
  if (chunk) this.write(chunk);
  this._ended = true;
  if (this._running) this._finish();
};
Tokenizer.prototype._finish = function () {
  //if there is remaining data, emit it in a reasonable way
  if (this._sectionStart < this._index) {
    this._handleTrailingData();
  }
  this._cbs.onend();
};
Tokenizer.prototype._handleTrailingData = function () {
  var data = this._buffer.substr(this._sectionStart);
  if (this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2) {
    this._cbs.oncdata(data);
  } else if (this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2) {
    this._cbs.oncomment(data);
  } else if (this._state === IN_NAMED_ENTITY && !this._xmlMode) {
    this._parseLegacyEntity();
    if (this._sectionStart < this._index) {
      this._state = this._baseState;
      this._handleTrailingData();
    }
  } else if (this._state === IN_NUMERIC_ENTITY && !this._xmlMode) {
    this._decodeNumericEntity(2, 10);
    if (this._sectionStart < this._index) {
      this._state = this._baseState;
      this._handleTrailingData();
    }
  } else if (this._state === IN_HEX_ENTITY && !this._xmlMode) {
    this._decodeNumericEntity(3, 16);
    if (this._sectionStart < this._index) {
      this._state = this._baseState;
      this._handleTrailingData();
    }
  } else if (this._state !== IN_TAG_NAME && this._state !== BEFORE_ATTRIBUTE_NAME && this._state !== BEFORE_ATTRIBUTE_VALUE && this._state !== AFTER_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_VALUE_SQ && this._state !== IN_ATTRIBUTE_VALUE_DQ && this._state !== IN_ATTRIBUTE_VALUE_NQ && this._state !== IN_CLOSING_TAG_NAME) {
    this._cbs.ontext(data);
  }
  //else, ignore remaining data
  //TODO add a way to remove current tag
};
Tokenizer.prototype.reset = function () {
  Tokenizer.call(this, {
    xmlMode: this._xmlMode,
    decodeEntities: this._decodeEntities
  }, this._cbs);
};
Tokenizer.prototype.getAbsoluteIndex = function () {
  return this._bufferOffset + this._index;
};
Tokenizer.prototype._getSection = function () {
  return this._buffer.substring(this._sectionStart, this._index);
};
Tokenizer.prototype._emitToken = function (name) {
  this._cbs[name](this._getSection());
  this._sectionStart = -1;
};
Tokenizer.prototype._emitPartial = function (value) {
  if (this._baseState !== TEXT) {
    this._cbs.onattribdata(value); //TODO implement the new event
  } else {
    this._cbs.ontext(value);
  }
};

/***/ }),

/***/ "./node_modules/htmlparser2/lib/WritableStream.js":
/*!********************************************************!*\
  !*** ./node_modules/htmlparser2/lib/WritableStream.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = Stream;
var Parser = __webpack_require__(/*! ./Parser.js */ "./node_modules/htmlparser2/lib/Parser.js");
var WritableStream = (__webpack_require__(/*! readable-stream */ "?13bc").Writable);
var StringDecoder = (__webpack_require__(/*! string_decoder */ "./node_modules/htmlparser2/node_modules/string_decoder/lib/string_decoder.js").StringDecoder);
var Buffer = (__webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer);
function Stream(cbs, options) {
  var parser = this._parser = new Parser(cbs, options);
  var decoder = this._decoder = new StringDecoder();
  WritableStream.call(this, {
    decodeStrings: false
  });
  this.once("finish", function () {
    parser.end(decoder.end());
  });
}
__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Stream, WritableStream);
Stream.prototype._write = function (chunk, encoding, cb) {
  if (chunk instanceof Buffer) chunk = this._decoder.write(chunk);
  this._parser.write(chunk);
  cb();
};

/***/ }),

/***/ "./node_modules/htmlparser2/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/htmlparser2/lib/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Parser = __webpack_require__(/*! ./Parser.js */ "./node_modules/htmlparser2/lib/Parser.js");
var DomHandler = __webpack_require__(/*! domhandler */ "./node_modules/htmlparser2/node_modules/domhandler/index.js");
function defineProp(name, value) {
  delete module.exports[name];
  module.exports[name] = value;
  return value;
}
module.exports = {
  Parser: Parser,
  Tokenizer: __webpack_require__(/*! ./Tokenizer.js */ "./node_modules/htmlparser2/lib/Tokenizer.js"),
  ElementType: __webpack_require__(/*! domelementtype */ "./node_modules/htmlparser2/node_modules/domelementtype/index.js"),
  DomHandler: DomHandler,
  get FeedHandler() {
    return defineProp("FeedHandler", __webpack_require__(/*! ./FeedHandler.js */ "./node_modules/htmlparser2/lib/FeedHandler.js"));
  },
  get Stream() {
    return defineProp("Stream", __webpack_require__(/*! ./Stream.js */ "./node_modules/htmlparser2/lib/Stream.js"));
  },
  get WritableStream() {
    return defineProp("WritableStream", __webpack_require__(/*! ./WritableStream.js */ "./node_modules/htmlparser2/lib/WritableStream.js"));
  },
  get ProxyHandler() {
    return defineProp("ProxyHandler", __webpack_require__(/*! ./ProxyHandler.js */ "./node_modules/htmlparser2/lib/ProxyHandler.js"));
  },
  get DomUtils() {
    return defineProp("DomUtils", __webpack_require__(/*! domutils */ "./node_modules/domutils/index.js"));
  },
  get CollectingHandler() {
    return defineProp("CollectingHandler", __webpack_require__(/*! ./CollectingHandler.js */ "./node_modules/htmlparser2/lib/CollectingHandler.js"));
  },
  // For legacy support
  DefaultHandler: DomHandler,
  get RssHandler() {
    return defineProp("RssHandler", this.FeedHandler);
  },
  //helper methods
  parseDOM: function (data, options) {
    var handler = new DomHandler(options);
    new Parser(handler, options).end(data);
    return handler.dom;
  },
  parseFeed: function (feed, options) {
    var handler = new module.exports.FeedHandler(options);
    new Parser(handler, options).end(feed);
    return handler.dom;
  },
  createDomStream: function (cb, options, elementCb) {
    var handler = new DomHandler(cb, options, elementCb);
    return new Parser(handler, options);
  },
  // List of all events that the parser emits
  EVENTS: {
    /* Format: eventname: number of arguments */
    attribute: 2,
    cdatastart: 0,
    cdataend: 0,
    text: 1,
    processinginstruction: 2,
    comment: 1,
    commentend: 0,
    closetag: 1,
    opentag: 2,
    opentagname: 1,
    error: 1,
    end: 0
  }
};

/***/ }),

/***/ "./node_modules/htmlparser2/node_modules/domelementtype/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/htmlparser2/node_modules/domelementtype/index.js ***!
  \***********************************************************************/
/***/ ((module) => {

//Types of elements found in the DOM
module.exports = {
  Text: "text",
  //Text
  Directive: "directive",
  //<? ... ?>
  Comment: "comment",
  //<!-- ... -->
  Script: "script",
  //<script> tags
  Style: "style",
  //<style> tags
  Tag: "tag",
  //Any tag
  CDATA: "cdata",
  //<![CDATA[ ... ]]>
  Doctype: "doctype",
  isTag: function (elem) {
    return elem.type === "tag" || elem.type === "script" || elem.type === "style";
  }
};

/***/ }),

/***/ "./node_modules/htmlparser2/node_modules/domhandler/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/htmlparser2/node_modules/domhandler/index.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ElementType = __webpack_require__(/*! domelementtype */ "./node_modules/htmlparser2/node_modules/domelementtype/index.js");
var re_whitespace = /\s+/g;
var NodePrototype = __webpack_require__(/*! ./lib/node */ "./node_modules/htmlparser2/node_modules/domhandler/lib/node.js");
var ElementPrototype = __webpack_require__(/*! ./lib/element */ "./node_modules/htmlparser2/node_modules/domhandler/lib/element.js");
function DomHandler(callback, options, elementCB) {
  if (typeof callback === "object") {
    elementCB = options;
    options = callback;
    callback = null;
  } else if (typeof options === "function") {
    elementCB = options;
    options = defaultOpts;
  }
  this._callback = callback;
  this._options = options || defaultOpts;
  this._elementCB = elementCB;
  this.dom = [];
  this._done = false;
  this._tagStack = [];
  this._parser = this._parser || null;
}

//default options
var defaultOpts = {
  normalizeWhitespace: false,
  //Replace all whitespace with single spaces
  withStartIndices: false,
  //Add startIndex properties to nodes
  withEndIndices: false //Add endIndex properties to nodes
};
DomHandler.prototype.onparserinit = function (parser) {
  this._parser = parser;
};

//Resets the handler back to starting state
DomHandler.prototype.onreset = function () {
  DomHandler.call(this, this._callback, this._options, this._elementCB);
};

//Signals the handler that parsing is done
DomHandler.prototype.onend = function () {
  if (this._done) return;
  this._done = true;
  this._parser = null;
  this._handleCallback(null);
};
DomHandler.prototype._handleCallback = DomHandler.prototype.onerror = function (error) {
  if (typeof this._callback === "function") {
    this._callback(error, this.dom);
  } else {
    if (error) throw error;
  }
};
DomHandler.prototype.onclosetag = function () {
  //if(this._tagStack.pop().name !== name) this._handleCallback(Error("Tagname didn't match!"));

  var elem = this._tagStack.pop();
  if (this._options.withEndIndices && elem) {
    elem.endIndex = this._parser.endIndex;
  }
  if (this._elementCB) this._elementCB(elem);
};
DomHandler.prototype._createDomElement = function (properties) {
  if (!this._options.withDomLvl1) return properties;
  var element;
  if (properties.type === "tag") {
    element = Object.create(ElementPrototype);
  } else {
    element = Object.create(NodePrototype);
  }
  for (var key in properties) {
    if (properties.hasOwnProperty(key)) {
      element[key] = properties[key];
    }
  }
  return element;
};
DomHandler.prototype._addDomElement = function (element) {
  var parent = this._tagStack[this._tagStack.length - 1];
  var siblings = parent ? parent.children : this.dom;
  var previousSibling = siblings[siblings.length - 1];
  element.next = null;
  if (this._options.withStartIndices) {
    element.startIndex = this._parser.startIndex;
  }
  if (this._options.withEndIndices) {
    element.endIndex = this._parser.endIndex;
  }
  if (previousSibling) {
    element.prev = previousSibling;
    previousSibling.next = element;
  } else {
    element.prev = null;
  }
  siblings.push(element);
  element.parent = parent || null;
};
DomHandler.prototype.onopentag = function (name, attribs) {
  var properties = {
    type: name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag,
    name: name,
    attribs: attribs,
    children: []
  };
  var element = this._createDomElement(properties);
  this._addDomElement(element);
  this._tagStack.push(element);
};
DomHandler.prototype.ontext = function (data) {
  //the ignoreWhitespace is officially dropped, but for now,
  //it's an alias for normalizeWhitespace
  var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;
  var lastTag;
  if (!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length - 1]).type === ElementType.Text) {
    if (normalize) {
      lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
    } else {
      lastTag.data += data;
    }
  } else {
    if (this._tagStack.length && (lastTag = this._tagStack[this._tagStack.length - 1]) && (lastTag = lastTag.children[lastTag.children.length - 1]) && lastTag.type === ElementType.Text) {
      if (normalize) {
        lastTag.data = (lastTag.data + data).replace(re_whitespace, " ");
      } else {
        lastTag.data += data;
      }
    } else {
      if (normalize) {
        data = data.replace(re_whitespace, " ");
      }
      var element = this._createDomElement({
        data: data,
        type: ElementType.Text
      });
      this._addDomElement(element);
    }
  }
};
DomHandler.prototype.oncomment = function (data) {
  var lastTag = this._tagStack[this._tagStack.length - 1];
  if (lastTag && lastTag.type === ElementType.Comment) {
    lastTag.data += data;
    return;
  }
  var properties = {
    data: data,
    type: ElementType.Comment
  };
  var element = this._createDomElement(properties);
  this._addDomElement(element);
  this._tagStack.push(element);
};
DomHandler.prototype.oncdatastart = function () {
  var properties = {
    children: [{
      data: "",
      type: ElementType.Text
    }],
    type: ElementType.CDATA
  };
  var element = this._createDomElement(properties);
  this._addDomElement(element);
  this._tagStack.push(element);
};
DomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function () {
  this._tagStack.pop();
};
DomHandler.prototype.onprocessinginstruction = function (name, data) {
  var element = this._createDomElement({
    name: name,
    data: data,
    type: ElementType.Directive
  });
  this._addDomElement(element);
};
module.exports = DomHandler;

/***/ }),

/***/ "./node_modules/htmlparser2/node_modules/domhandler/lib/element.js":
/*!*************************************************************************!*\
  !*** ./node_modules/htmlparser2/node_modules/domhandler/lib/element.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// DOM-Level-1-compliant structure
var NodePrototype = __webpack_require__(/*! ./node */ "./node_modules/htmlparser2/node_modules/domhandler/lib/node.js");
var ElementPrototype = module.exports = Object.create(NodePrototype);
var domLvl1 = {
  tagName: "name"
};
Object.keys(domLvl1).forEach(function (key) {
  var shorthand = domLvl1[key];
  Object.defineProperty(ElementPrototype, key, {
    get: function () {
      return this[shorthand] || null;
    },
    set: function (val) {
      this[shorthand] = val;
      return val;
    }
  });
});

/***/ }),

/***/ "./node_modules/htmlparser2/node_modules/domhandler/lib/node.js":
/*!**********************************************************************!*\
  !*** ./node_modules/htmlparser2/node_modules/domhandler/lib/node.js ***!
  \**********************************************************************/
/***/ ((module) => {

// This object will be used as the prototype for Nodes when creating a
// DOM-Level-1-compliant structure.
var NodePrototype = module.exports = {
  get firstChild() {
    var children = this.children;
    return children && children[0] || null;
  },
  get lastChild() {
    var children = this.children;
    return children && children[children.length - 1] || null;
  },
  get nodeType() {
    return nodeTypes[this.type] || nodeTypes.element;
  }
};
var domLvl1 = {
  tagName: "name",
  childNodes: "children",
  parentNode: "parent",
  previousSibling: "prev",
  nextSibling: "next",
  nodeValue: "data"
};
var nodeTypes = {
  element: 1,
  text: 3,
  cdata: 4,
  comment: 8
};
Object.keys(domLvl1).forEach(function (key) {
  var shorthand = domLvl1[key];
  Object.defineProperty(NodePrototype, key, {
    get: function () {
      return this[shorthand] || null;
    },
    set: function (val) {
      this[shorthand] = val;
      return val;
    }
  });
});

/***/ }),

/***/ "./node_modules/htmlparser2/node_modules/entities/lib/decode_codepoint.js":
/*!********************************************************************************!*\
  !*** ./node_modules/htmlparser2/node_modules/entities/lib/decode_codepoint.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var decodeMap = __webpack_require__(/*! ../maps/decode.json */ "./node_modules/htmlparser2/node_modules/entities/maps/decode.json");
module.exports = decodeCodePoint;

// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint) {
  if (codePoint >= 0xd800 && codePoint <= 0xdfff || codePoint > 0x10ffff) {
    return "\uFFFD";
  }
  if (codePoint in decodeMap) {
    codePoint = decodeMap[codePoint];
  }
  var output = "";
  if (codePoint > 0xffff) {
    codePoint -= 0x10000;
    output += String.fromCharCode(codePoint >>> 10 & 0x3ff | 0xd800);
    codePoint = 0xdc00 | codePoint & 0x3ff;
  }
  output += String.fromCharCode(codePoint);
  return output;
}

/***/ }),

/***/ "./node_modules/htmlparser2/node_modules/string_decoder/lib/string_decoder.js":
/*!************************************************************************************!*\
  !*** ./node_modules/htmlparser2/node_modules/string_decoder/lib/string_decoder.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/
var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;
    default:
      return false;
  }
};
function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}
;

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};
StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}
function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}
function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}
function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

/***/ }),

/***/ "./node_modules/is-arguments/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-arguments/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var $toString = callBound('Object.prototype.toString');
var isStandardArguments = function isArguments(value) {
  if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
    return false;
  }
  return $toString(value) === '[object Arguments]';
};
var isLegacyArguments = function isArguments(value) {
  if (isStandardArguments(value)) {
    return true;
  }
  return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && $toString(value.callee) === '[object Function]';
};
var supportsStandardArguments = function () {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

/***/ }),

/***/ "./node_modules/is-callable/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-callable/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
  try {
    badArrayLike = Object.defineProperty({}, 'length', {
      get: function () {
        throw isCallableMarker;
      }
    });
    isCallableMarker = {};
    // eslint-disable-next-line no-throw-literal
    reflectApply(function () {
      throw 42;
    }, null, badArrayLike);
  } catch (_) {
    if (_ !== isCallableMarker) {
      reflectApply = null;
    }
  }
} else {
  reflectApply = null;
}
var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
  try {
    var fnStr = fnToStr.call(value);
    return constructorRegex.test(fnStr);
  } catch (e) {
    return false; // not a function
  }
};
var tryFunctionObject = function tryFunctionToStr(value) {
  try {
    if (isES6ClassFn(value)) {
      return false;
    }
    fnToStr.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() {
  return false;
};
if (typeof document === 'object') {
  // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
  var all = document.all;
  if (toStr.call(all) === toStr.call(document.all)) {
    isDDA = function isDocumentDotAll(value) {
      /* globals document: false */
      // in IE 6-8, typeof document.all is "object" and it's truthy
      if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
        try {
          var str = toStr.call(value);
          return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
          || str === objectClass // IE 6-8
          ) && value('') == null; // eslint-disable-line eqeqeq
        } catch (e) {/**/}
      }
      return false;
    };
  }
}
module.exports = reflectApply ? function isCallable(value) {
  if (isDDA(value)) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== 'function' && typeof value !== 'object') {
    return false;
  }
  try {
    reflectApply(value, null, badArrayLike);
  } catch (e) {
    if (e !== isCallableMarker) {
      return false;
    }
  }
  return !isES6ClassFn(value) && tryFunctionObject(value);
} : function isCallable(value) {
  if (isDDA(value)) {
    return true;
  }
  if (!value) {
    return false;
  }
  if (typeof value !== 'function' && typeof value !== 'object') {
    return false;
  }
  if (hasToStringTag) {
    return tryFunctionObject(value);
  }
  if (isES6ClassFn(value)) {
    return false;
  }
  var strClass = toStr.call(value);
  if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
    return false;
  }
  return tryFunctionObject(value);
};

/***/ }),

/***/ "./node_modules/is-generator-function/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/is-generator-function/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function () {
  // eslint-disable-line consistent-return
  if (!hasToStringTag) {
    return false;
  }
  try {
    return Function('return function*() {}')();
  } catch (e) {}
};
var GeneratorFunction;
module.exports = function isGeneratorFunction(fn) {
  if (typeof fn !== 'function') {
    return false;
  }
  if (isFnRegex.test(fnToStr.call(fn))) {
    return true;
  }
  if (!hasToStringTag) {
    var str = toStr.call(fn);
    return str === '[object GeneratorFunction]';
  }
  if (!getProto) {
    return false;
  }
  if (typeof GeneratorFunction === 'undefined') {
    var generatorFunc = getGeneratorFunc();
    GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
  }
  return getProto(fn) === GeneratorFunction;
};

/***/ }),

/***/ "./node_modules/is-typed-array/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-typed-array/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/which-typed-array/index.js");

/** @type {import('.')} */
module.exports = function isTypedArray(value) {
  return !!whichTypedArray(value);
};

/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.17.21';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function',INVALID_TEMPL_VAR_ERROR_TEXT='Invalid `variable` option passed into `_.template`';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading whitespace. */var reTrimStart=/^\s+/;/** Used to match a single whitespace character. */var reWhitespace=/\s/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */var reForbiddenIdentifierChars=/[()=,{}\[\]\/\s]/;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\ud800-\\udfff',rsComboMarksRange='\\u0300-\\u036f',reComboHalfMarksRange='\\ufe20-\\ufe2f',rsComboSymbolsRange='\\u20d0-\\u20ff',rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange='\\u2700-\\u27bf',rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange='\\u2000-\\u206f',rsSpaceRange=' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange='\\ufe0e\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\ud83c[\\udffb-\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\ud83c[\\udde6-\\uddff]){2}',rsSurrPair='[\\ud800-\\udbff][\\udc00-\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\u200d';/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
'\u0100':'A','\u0102':'A','\u0104':'A','\u0101':'a','\u0103':'a','\u0105':'a','\u0106':'C','\u0108':'C','\u010a':'C','\u010c':'C','\u0107':'c','\u0109':'c','\u010b':'c','\u010d':'c','\u010e':'D','\u0110':'D','\u010f':'d','\u0111':'d','\u0112':'E','\u0114':'E','\u0116':'E','\u0118':'E','\u011a':'E','\u0113':'e','\u0115':'e','\u0117':'e','\u0119':'e','\u011b':'e','\u011c':'G','\u011e':'G','\u0120':'G','\u0122':'G','\u011d':'g','\u011f':'g','\u0121':'g','\u0123':'g','\u0124':'H','\u0126':'H','\u0125':'h','\u0127':'h','\u0128':'I','\u012a':'I','\u012c':'I','\u012e':'I','\u0130':'I','\u0129':'i','\u012b':'i','\u012d':'i','\u012f':'i','\u0131':'i','\u0134':'J','\u0135':'j','\u0136':'K','\u0137':'k','\u0138':'k','\u0139':'L','\u013b':'L','\u013d':'L','\u013f':'L','\u0141':'L','\u013a':'l','\u013c':'l','\u013e':'l','\u0140':'l','\u0142':'l','\u0143':'N','\u0145':'N','\u0147':'N','\u014a':'N','\u0144':'n','\u0146':'n','\u0148':'n','\u014b':'n','\u014c':'O','\u014e':'O','\u0150':'O','\u014d':'o','\u014f':'o','\u0151':'o','\u0154':'R','\u0156':'R','\u0158':'R','\u0155':'r','\u0157':'r','\u0159':'r','\u015a':'S','\u015c':'S','\u015e':'S','\u0160':'S','\u015b':'s','\u015d':'s','\u015f':'s','\u0161':'s','\u0162':'T','\u0164':'T','\u0166':'T','\u0163':'t','\u0165':'t','\u0167':'t','\u0168':'U','\u016a':'U','\u016c':'U','\u016e':'U','\u0170':'U','\u0172':'U','\u0169':'u','\u016b':'u','\u016d':'u','\u016f':'u','\u0171':'u','\u0173':'u','\u0174':'W','\u0175':'w','\u0176':'Y','\u0177':'y','\u0178':'Y','\u0179':'Z','\u017b':'Z','\u017d':'Z','\u017a':'z','\u017c':'z','\u017e':'z','\u0132':'IJ','\u0133':'ij','\u0152':'Oe','\u0153':'oe','\u0149':"'n",'\u017f':'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r','\u2028':'u2028','\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=typeof __webpack_require__.g=='object'&&__webpack_require__.g&&__webpack_require__.g.Object===Object&&__webpack_require__.g;/** Detect free variable `self`. */var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports= true&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&"object"=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*//**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}/**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */var asciiSize=baseProperty('length');/**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function asciiToArray(string){return string.split('');}/**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */function baseIsNaN(value){return value!==value;}/**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */function basePropertyOf(object){return function(key){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */function baseTrim(string){return string?string.slice(0,trimmedEndIndex(string)+1).replace(reTrimStart,''):string;}/**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */function baseUnary(func){return function(value){return func(value);};}/**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */function cacheHas(cache,key){return cache.has(key);}/**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */var deburrLetter=basePropertyOf(deburredLetters);/**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */function escapeStringChar(chr){return'\\'+stringEscapes[chr];}/**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */function getValue(object,key){return object==null?undefined:object[key];}/**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */function hasUnicode(string){return reHasUnicode.test(string);}/**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */function trimmedEndIndex(string){var index=string.length;while(index--&&reWhitespace.test(string.charAt(index))){}return index;}/**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*//**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined,symIterator=Symbol?Symbol.iterator:undefined,symToStringTag=Symbol?Symbol.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=Symbol?Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*//**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */function baseLodash(){// No operation performed.
}/**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */lodash.templateSettings={/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'escape':reEscape,/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'evaluate':reEvaluate,/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'interpolate':reInterpolate,/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */'variable':'',/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */'imports':{/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*//**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*//**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*//**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */function listCacheClear(){this.__data__=[];this.size=0;}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*//**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*//**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*//**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function stackGet(key){return this.__data__.get(key);}/**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function stackHas(key){return this.__data__.has(key);}/**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*//**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined;}/**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined:get(object,paths[index]);}return result;}/**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return!length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined&&!(key in object)||!predicate(value)){return false;}}return true;}/**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEach=createBaseEach(baseForOwn);/**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseFor=createBaseFor();/**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseForRight=createBaseFor(true);/**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */function baseGt(value,other){return value>other;}/**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined:apply(func,object,args);}/**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if(typeof value=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */function baseLt(value,other){return value<other;}/**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */function baseOrderBy(collection,iteratees,orders){if(iteratees.length){iteratees=arrayMap(iteratees,function(iteratee){if(isArray(iteratee)){return function(value){return baseGet(value,iteratee.length===1?iteratee[0]:iteratee);};}return iteratee;});}else{iteratees=[identity];}var index=-1;iteratees=arrayMap(iteratees,baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}/**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */function baseSample(collection){return arraySample(values(collection));}/**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(key==='__proto__'||key==='constructor'||key==='prototype'){return object;}if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndexBy(array,value,iteratee,retHighest){var low=0,high=array==null?0:array.length;if(high===0){return 0;}value=iteratee(value);var valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */function castFunction(value){return typeof value=='function'?value:identity;}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */var castRest=baseRest;/**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
// that causes it, under certain circumstances, to provide the same value for
// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
// for more details.
//
// This also ensures a stable sort in V8 and other engines.
// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
return object.index-other.index;}/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
// for more details.
var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
// See https://es5.github.io/#x13.2.2 for more details.
return isObject(result)?result:thisBinding;};}/**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}/**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined&&other===undefined){return defaultValue;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.
start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}step=step===undefined?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
// See [MDN](https://mdn.io/round#Examples) for more details.
var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */function customOmitClone(value){return isPlainObject(value)?undefined:value;}/**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Check that cyclic values are equal.
var arrStacked=stack.get(array);var othStacked=stack.get(other);if(arrStacked&&othStacked){return arrStacked==other&&othStacked==array;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Check that cyclic values are equal.
var objStacked=stack.get(object);var othStacked=stack.get(other);if(objStacked&&othStacked){return objStacked==other&&othStacked==object;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}/**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */function isIndex(value,length){var type=typeof value;length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index;if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function isKeyable(value){var type=typeof value;return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */var isMaskable=coreJsData?isFunction:stubFalse;/**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
data[0]=source[0];data[1]=newBitmask;return data;}/**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */function objectToString(value){return nativeObjectToString.call(value);}/**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var setData=shortOut(baseSetData);/**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var setToString=shortOut(baseSetToString);/**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*//**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */function concat(){var length=arguments.length;if(!length){return[];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */function head(array){return array&&array.length?array[0]:undefined;}/**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}/**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */var pull=baseRest(pullAll);/**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined;return array&&array.length?baseUniq(array,undefined,comparator):[];}/**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */var zip=baseRest(unzip);/**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*//**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */function tap(value,interceptor){interceptor(value);return value;}/**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */function thru(value,interceptor){return interceptor(value);}/**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */function wrapperChain(){return chain(this);}/**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */function wrapperToIterator(){return this;}/**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*//**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else{baseAssignValue(result,key,1);}});/**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */var find=createFind(findIndex);/**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */var findLast=createFind(findLastIndex);/**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});/**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*//**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*//**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;/**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */function once(func){return before(2,func);}/**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined,partials,holders);});/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});/**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?start:toInteger(start);return baseRest(func,start);}/**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */function unary(func){return ary(func,1);}/**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*//**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */var gt=createRelationalOperation(baseGt);/**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */var isArray=Array.isArray;/**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */var isBuffer=nativeIsBuffer||stubFalse;/**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */function isEqual(value,other){return baseIsEqual(value,other);}/**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,undefined,customizer):!!result;}/**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function isObject(value){var type=typeof value;return value!=null&&(type=='object'||type=='function');}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function isObjectLike(value){return value!=null&&typeof value=='object';}/**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
// Perform the `toStringTag` check first to avoid errors with some
// ActiveX objects in IE.
return isNumber(value)&&value!=+value;}/**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */function isNull(value){return value===null;}/**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */function isNil(value){return value==null;}/**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function isSymbol(value){return typeof value=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */function isUndefined(value){return value===undefined;}/**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */var lt=createRelationalOperation(baseLt);/**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=baseTrim(value);var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*//**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */var at=flatRest(baseAt);/**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */var defaultsDeep=baseRest(function(args){args.push(undefined,customDefaultsMerge);return apply(mergeWith,undefined,args);});/**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */var invoke=baseRest(baseInvoke);/**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
if(!length){length=1;object=undefined;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */var toPairs=createToPairs(keys);/**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */var toPairsIn=createToPairs(keysIn);/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*//**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */function inRange(number,start,end){start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*//**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */var lowerFirst=createCaseFirst('toLowerCase');/**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
// (http://ejohn.org/blog/javascript-micro-templating/)
// and Laura Doktorova's doT.js (https://github.com/olado/doT).
var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
// The sourceURL gets injected into the source that's eval-ed, so be careful
// to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
// and escape the comment, thus injecting code that gets evaled.
var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/\s/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
// order to produce the correct `offset` value.
return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
// code to add the data object to the top of the scope chain.
var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Throw an error if a forbidden character was found in `variable`, to prevent
// potential command injection attacks.
else if(reForbiddenIdentifierChars.test(variable)){throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);}// Cleanup code by stripping empty strings.
source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or
// the `source` property as a convenience for inlining compiled templates.
result.source=source;if(isError(result)){throw result;}return result;}/**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */function toLower(value){return toString(value).toLowerCase();}/**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */function toUpper(value){return toString(value).toUpperCase();}/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return baseTrim(string);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.slice(0,trimmedEndIndex(string)+1);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */var upperFirst=createCaseFirst('toUpperCase');/**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*//**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */var attempt=baseRest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */function constant(value){return function(){return value;};}/**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */var flow=createFlow();/**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */var flowRight=createFlow(true);/**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */function identity(value){return value;}/**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */function noop(){// No operation performed.
}/**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */var over=createOver(arrayMap);/**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */var overEvery=createOver(arrayEvery);/**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */var overSome=createOver(arraySome);/**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */var range=createRange();/**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */var rangeRight=createRange(true);/**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */function stubArray(){return[];}/**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */function stubFalse(){return false;}/**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */function stubObject(){return{};}/**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */function stubString(){return'';}/**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */function stubTrue(){return true;}/**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*//**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */var ceil=createRound('ceil');/**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */var floor=createRound('floor');/**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined;}/**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */function mean(array){return baseMean(array,identity);}/**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined;}/**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */var round=createRound('round');/**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/// Add methods that return wrapped values in chain sequences.
lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
mixin(lodash,lodash);/*------------------------------------------------------------------------*/// Add methods that return unwrapped values in chain sequences.
lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*//**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */lodash.VERSION=VERSION;// Assign default placeholders.
arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/// Export lodash.
var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
if(true){// Expose Lodash on the global object to prevent errors when Lodash is
// loaded by a script tag in the presence of an AMD loader.
// See http://requirejs.org/docs/errors.html#mismatch for more details.
// Use `_.noConflict` to remove Lodash from the global object.
root._=_;// Define as an anonymous module so, through path mapping, it can be
// referenced as the "underscore" module.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return _;}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}// Check for `exports` after `define` in case a build optimizer adds it.
else {}}).call(this);

/***/ }),

/***/ "./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
  "use strict";

  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function () {
  "use strict";

  // Slightly dubious tricks to cut down minimized file size
  var noop = function () {};
  var undefinedType = "undefined";
  var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
  var logMethods = ["trace", "debug", "info", "warn", "error"];
  var _loggersByName = {};
  var defaultLogger = null;

  // Cross-browser bind equivalent that works at least back to IE6
  function bindMethod(obj, methodName) {
    var method = obj[methodName];
    if (typeof method.bind === 'function') {
      return method.bind(obj);
    } else {
      try {
        return Function.prototype.bind.call(method, obj);
      } catch (e) {
        // Missing bind shim or IE8 + Modernizr, fallback to wrapping
        return function () {
          return Function.prototype.apply.apply(method, [obj, arguments]);
        };
      }
    }
  }

  // Trace() doesn't print the message in IE, so for that case we need to wrap it
  function traceForIE() {
    if (console.log) {
      if (console.log.apply) {
        console.log.apply(console, arguments);
      } else {
        // In old IE, native console methods themselves don't have apply().
        Function.prototype.apply.apply(console.log, [console, arguments]);
      }
    }
    if (console.trace) console.trace();
  }

  // Build the best logging method possible for this env
  // Wherever possible we want to bind, not wrap, to preserve stack traces
  function realMethod(methodName) {
    if (methodName === 'debug') {
      methodName = 'log';
    }
    if (typeof console === undefinedType) {
      return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
    } else if (methodName === 'trace' && isIE) {
      return traceForIE;
    } else if (console[methodName] !== undefined) {
      return bindMethod(console, methodName);
    } else if (console.log !== undefined) {
      return bindMethod(console, 'log');
    } else {
      return noop;
    }
  }

  // These private functions always need `this` to be set properly

  function replaceLoggingMethods() {
    /*jshint validthis:true */
    var level = this.getLevel();

    // Replace the actual methods.
    for (var i = 0; i < logMethods.length; i++) {
      var methodName = logMethods[i];
      this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);
    }

    // Define log.log as an alias for log.debug
    this.log = this.debug;

    // Return any important warnings.
    if (typeof console === undefinedType && level < this.levels.SILENT) {
      return "No console available for logging";
    }
  }

  // In old IE versions, the console isn't present until you first open it.
  // We build realMethod() replacements here that regenerate logging methods
  function enableLoggingWhenConsoleArrives(methodName) {
    return function () {
      if (typeof console !== undefinedType) {
        replaceLoggingMethods.call(this);
        this[methodName].apply(this, arguments);
      }
    };
  }

  // By default, we use closely bound real methods wherever possible, and
  // otherwise we wait for a console to appear, and then try again.
  function defaultMethodFactory(methodName, _level, _loggerName) {
    /*jshint validthis:true */
    return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
  }
  function Logger(name, factory) {
    // Private instance variables.
    var self = this;
    /**
     * The level inherited from a parent logger (or a global default). We
     * cache this here rather than delegating to the parent so that it stays
     * in sync with the actual logging methods that we have installed (the
     * parent could change levels but we might not have rebuilt the loggers
     * in this child yet).
     * @type {number}
     */
    var inheritedLevel;
    /**
     * The default level for this logger, if any. If set, this overrides
     * `inheritedLevel`.
     * @type {number|null}
     */
    var defaultLevel;
    /**
     * A user-specific level for this logger. If set, this overrides
     * `defaultLevel`.
     * @type {number|null}
     */
    var userLevel;
    var storageKey = "loglevel";
    if (typeof name === "string") {
      storageKey += ":" + name;
    } else if (typeof name === "symbol") {
      storageKey = undefined;
    }
    function persistLevelIfPossible(levelNum) {
      var levelName = (logMethods[levelNum] || 'silent').toUpperCase();
      if (typeof window === undefinedType || !storageKey) return;

      // Use localStorage if available
      try {
        window.localStorage[storageKey] = levelName;
        return;
      } catch (ignore) {}

      // Use session cookie as fallback
      try {
        window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
      } catch (ignore) {}
    }
    function getPersistedLevel() {
      var storedLevel;
      if (typeof window === undefinedType || !storageKey) return;
      try {
        storedLevel = window.localStorage[storageKey];
      } catch (ignore) {}

      // Fallback to cookies if local storage gives us nothing
      if (typeof storedLevel === undefinedType) {
        try {
          var cookie = window.document.cookie;
          var cookieName = encodeURIComponent(storageKey);
          var location = cookie.indexOf(cookieName + "=");
          if (location !== -1) {
            storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];
          }
        } catch (ignore) {}
      }

      // If the stored level is not valid, treat it as if nothing was stored.
      if (self.levels[storedLevel] === undefined) {
        storedLevel = undefined;
      }
      return storedLevel;
    }
    function clearPersistedLevel() {
      if (typeof window === undefinedType || !storageKey) return;

      // Use localStorage if available
      try {
        window.localStorage.removeItem(storageKey);
      } catch (ignore) {}

      // Use session cookie as fallback
      try {
        window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
      } catch (ignore) {}
    }
    function normalizeLevel(input) {
      var level = input;
      if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
        level = self.levels[level.toUpperCase()];
      }
      if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
        return level;
      } else {
        throw new TypeError("log.setLevel() called with invalid level: " + input);
      }
    }

    /*
     *
     * Public logger API - see https://github.com/pimterry/loglevel for details
     *
     */

    self.name = name;
    self.levels = {
      "TRACE": 0,
      "DEBUG": 1,
      "INFO": 2,
      "WARN": 3,
      "ERROR": 4,
      "SILENT": 5
    };
    self.methodFactory = factory || defaultMethodFactory;
    self.getLevel = function () {
      if (userLevel != null) {
        return userLevel;
      } else if (defaultLevel != null) {
        return defaultLevel;
      } else {
        return inheritedLevel;
      }
    };
    self.setLevel = function (level, persist) {
      userLevel = normalizeLevel(level);
      if (persist !== false) {
        // defaults to true
        persistLevelIfPossible(userLevel);
      }

      // NOTE: in v2, this should call rebuild(), which updates children.
      return replaceLoggingMethods.call(self);
    };
    self.setDefaultLevel = function (level) {
      defaultLevel = normalizeLevel(level);
      if (!getPersistedLevel()) {
        self.setLevel(level, false);
      }
    };
    self.resetLevel = function () {
      userLevel = null;
      clearPersistedLevel();
      replaceLoggingMethods.call(self);
    };
    self.enableAll = function (persist) {
      self.setLevel(self.levels.TRACE, persist);
    };
    self.disableAll = function (persist) {
      self.setLevel(self.levels.SILENT, persist);
    };
    self.rebuild = function () {
      if (defaultLogger !== self) {
        inheritedLevel = normalizeLevel(defaultLogger.getLevel());
      }
      replaceLoggingMethods.call(self);
      if (defaultLogger === self) {
        for (var childName in _loggersByName) {
          _loggersByName[childName].rebuild();
        }
      }
    };

    // Initialize all the internal levels.
    inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : "WARN");
    var initialLevel = getPersistedLevel();
    if (initialLevel != null) {
      userLevel = normalizeLevel(initialLevel);
    }
    replaceLoggingMethods.call(self);
  }

  /*
   *
   * Top-level API
   *
   */

  defaultLogger = new Logger();
  defaultLogger.getLogger = function getLogger(name) {
    if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
      throw new TypeError("You must supply a name when creating a logger.");
    }
    var logger = _loggersByName[name];
    if (!logger) {
      logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);
    }
    return logger;
  };

  // Grab the current global log variable in case of overwrite
  var _log = typeof window !== undefinedType ? window.log : undefined;
  defaultLogger.noConflict = function () {
    if (typeof window !== undefinedType && window.log === defaultLogger) {
      window.log = _log;
    }
    return defaultLogger;
  };
  defaultLogger.getLoggers = function getLoggers() {
    return _loggersByName;
  };

  // ES6 default export, for compatibility
  defaultLogger['default'] = defaultLogger;
  return defaultLogger;
});

/***/ }),

/***/ "./node_modules/object-inspect/index.js":
/*!**********************************************!*\
  !*** ./node_modules/object-inspect/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol') ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype // eslint-disable-line no-proto
? function (O) {
  return O.__proto__; // eslint-disable-line no-proto
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === 'number') {
    var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
    }
  }
  return $replace.call(str, sepRegex, '$&_');
}
var utilInspect = __webpack_require__(/*! ./util.inspect */ "?4f7e");
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
module.exports = function inspect_(obj, options, depth, seen) {
  var opts = options || {};
  if (has(opts, 'quoteStyle') && opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double') {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number' ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
  if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
    throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
  }
  if (has(opts, 'indent') && opts.indent !== null && opts.indent !== '\t' && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts.numericSeparator;
  if (typeof obj === 'undefined') {
    return 'undefined';
  }
  if (obj === null) {
    return 'null';
  }
  if (typeof obj === 'boolean') {
    return obj ? 'true' : 'false';
  }
  if (typeof obj === 'string') {
    return inspectString(obj, opts);
  }
  if (typeof obj === 'number') {
    if (obj === 0) {
      return Infinity / obj > 0 ? '0' : '-0';
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === 'bigint') {
    var bigIntStr = String(obj) + 'n';
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
  if (typeof depth === 'undefined') {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
    return isArray(obj) ? '[Array]' : '[Object]';
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === 'undefined') {
    seen = [];
  } else if (indexOf(seen, obj) >= 0) {
    return '[Circular]';
  }
  function inspect(value, from, noIndent) {
    if (from) {
      seen = $arrSlice.call(seen);
      seen.push(from);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has(opts, 'quoteStyle')) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj === 'function' && !isRegExp(obj)) {
    // in older engines, regexes are callable
    var name = nameOf(obj);
    var keys = arrObjKeys(obj, inspect);
    return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
  }
  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
    return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s = '<' + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];
    for (var i = 0; i < attrs.length; i++) {
      s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
    }
    s += '>';
    if (obj.childNodes && obj.childNodes.length) {
      s += '...';
    }
    s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
    return s;
  }
  if (isArray(obj)) {
    if (obj.length === 0) {
      return '[]';
    }
    var xs = arrObjKeys(obj, inspect);
    if (indent && !singleLineValues(xs)) {
      return '[' + indentedJoin(xs, indent) + ']';
    }
    return '[ ' + $join.call(xs, ', ') + ' ]';
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect);
    if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
      return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
    }
    if (parts.length === 0) {
      return '[' + String(obj) + ']';
    }
    return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
  }
  if (typeof obj === 'object' && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
      return utilInspect(obj, {
        depth: maxDepth - depth
      });
    } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
      return obj.inspect();
    }
  }
  if (isMap(obj)) {
    var mapParts = [];
    if (mapForEach) {
      mapForEach.call(obj, function (value, key) {
        mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
      });
    }
    return collectionOf('Map', mapSize.call(obj), mapParts, indent);
  }
  if (isSet(obj)) {
    var setParts = [];
    if (setForEach) {
      setForEach.call(obj, function (value) {
        setParts.push(inspect(value, obj));
      });
    }
    return collectionOf('Set', setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf('WeakMap');
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf('WeakSet');
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf('WeakRef');
  }
  if (isNumber(obj)) {
    return markBoxed(inspect(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect(bigIntValueOf.call(obj)));
  }
  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString(obj)) {
    return markBoxed(inspect(String(obj)));
  }
  // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
  /* eslint-env browser */
  if (typeof window !== 'undefined' && obj === window) {
    return '{ [object Window] }';
  }
  if (typeof globalThis !== 'undefined' && obj === globalThis || typeof __webpack_require__.g !== 'undefined' && obj === __webpack_require__.g) {
    return '{ [object globalThis] }';
  }
  if (!isDate(obj) && !isRegExp(obj)) {
    var ys = arrObjKeys(obj, inspect);
    var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? '' : 'null prototype';
    var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
    var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
    var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
    if (ys.length === 0) {
      return tag + '{}';
    }
    if (indent) {
      return tag + '{' + indentedJoin(ys, indent) + '}';
    }
    return tag + '{ ' + $join.call(ys, ', ') + ' }';
  }
  return String(obj);
};
function wrapQuotes(s, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
  return quoteChar + s + quoteChar;
}
function quote(s) {
  return $replace.call(String(s), /"/g, '&quot;');
}
function isArray(obj) {
  return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
}
function isDate(obj) {
  return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
}
function isRegExp(obj) {
  return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
}
function isError(obj) {
  return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
}
function isString(obj) {
  return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
}
function isNumber(obj) {
  return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
}
function isBoolean(obj) {
  return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
}

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === 'object' && obj instanceof Symbol;
  }
  if (typeof obj === 'symbol') {
    return true;
  }
  if (!obj || typeof obj !== 'object' || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e) {}
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e) {}
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty || function (key) {
  return key in this;
};
function has(obj, key) {
  return hasOwn.call(obj, key);
}
function toStr(obj) {
  return objectToString.call(obj);
}
function nameOf(f) {
  if (f.name) {
    return f.name;
  }
  var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
  if (m) {
    return m[1];
  }
  return null;
}
function indexOf(xs, x) {
  if (xs.indexOf) {
    return xs.indexOf(x);
  }
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) {
      return i;
    }
  }
  return -1;
}
function isMap(x) {
  if (!mapSize || !x || typeof x !== 'object') {
    return false;
  }
  try {
    mapSize.call(x);
    try {
      setSize.call(x);
    } catch (s) {
      return true;
    }
    return x instanceof Map; // core-js workaround, pre-v2.5.0
  } catch (e) {}
  return false;
}
function isWeakMap(x) {
  if (!weakMapHas || !x || typeof x !== 'object') {
    return false;
  }
  try {
    weakMapHas.call(x, weakMapHas);
    try {
      weakSetHas.call(x, weakSetHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
  } catch (e) {}
  return false;
}
function isWeakRef(x) {
  if (!weakRefDeref || !x || typeof x !== 'object') {
    return false;
  }
  try {
    weakRefDeref.call(x);
    return true;
  } catch (e) {}
  return false;
}
function isSet(x) {
  if (!setSize || !x || typeof x !== 'object') {
    return false;
  }
  try {
    setSize.call(x);
    try {
      mapSize.call(x);
    } catch (m) {
      return true;
    }
    return x instanceof Set; // core-js workaround, pre-v2.5.0
  } catch (e) {}
  return false;
}
function isWeakSet(x) {
  if (!weakSetHas || !x || typeof x !== 'object') {
    return false;
  }
  try {
    weakSetHas.call(x, weakSetHas);
    try {
      weakMapHas.call(x, weakMapHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
  } catch (e) {}
  return false;
}
function isElement(x) {
  if (!x || typeof x !== 'object') {
    return false;
  }
  if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
    return true;
  }
  return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  }
  // eslint-disable-next-line no-control-regex
  var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s, 'single', opts);
}
function lowbyte(c) {
  var n = c.charCodeAt(0);
  var x = {
    8: 'b',
    9: 't',
    10: 'n',
    12: 'f',
    13: 'r'
  }[n];
  if (x) {
    return '\\' + x;
  }
  return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}
function markBoxed(str) {
  return 'Object(' + str + ')';
}
function weakCollectionOf(type) {
  return type + ' { ? }';
}
function collectionOf(type, size, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
  return type + ' (' + size + ') {' + joinedEntries + '}';
}
function singleLineValues(xs) {
  for (var i = 0; i < xs.length; i++) {
    if (indexOf(xs[i], '\n') >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === '\t') {
    baseIndent = '\t';
  } else if (typeof opts.indent === 'number' && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), ' ');
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return '';
  }
  var lineJoiner = '\n' + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}
function arrObjKeys(obj, inspect) {
  var isArr = isArray(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i = 0; i < obj.length; i++) {
      xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
    }
  }
  var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k = 0; k < syms.length; k++) {
      symMap['$' + syms[k]] = syms[k];
    }
  }
  for (var key in obj) {
    // eslint-disable-line no-restricted-syntax
    if (!has(obj, key)) {
      continue;
    } // eslint-disable-line no-restricted-syntax, no-continue
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    } // eslint-disable-line no-restricted-syntax, no-continue
    if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
      // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
      continue; // eslint-disable-line no-restricted-syntax, no-continue
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
    } else {
      xs.push(key + ': ' + inspect(obj[key], obj));
    }
  }
  if (typeof gOPS === 'function') {
    for (var j = 0; j < syms.length; j++) {
      if (isEnumerable.call(obj, syms[j])) {
        xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
      }
    }
  }
  return xs;
}

/***/ }),

/***/ "./node_modules/possible-typed-array-names/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/possible-typed-array-names/index.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'BigInt64Array', 'BigUint64Array'];

/***/ }),

/***/ "./node_modules/qs/lib/formats.js":
/*!****************************************!*\
  !*** ./node_modules/qs/lib/formats.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: 'RFC1738',
  RFC3986: 'RFC3986'
};
module.exports = {
  'default': Format.RFC3986,
  formatters: {
    RFC1738: function (value) {
      return replace.call(value, percentTwenties, '+');
    },
    RFC3986: function (value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};

/***/ }),

/***/ "./node_modules/qs/lib/index.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "./node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "./node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");
module.exports = {
  formats: formats,
  parse: parse,
  stringify: stringify
};

/***/ }),

/***/ "./node_modules/qs/lib/parse.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/parse.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var defaults = {
  allowDots: false,
  allowEmptyArrays: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: 'utf-8',
  charsetSentinel: false,
  comma: false,
  decodeDotInKeys: false,
  decoder: utils.decode,
  delimiter: '&',
  depth: 5,
  duplicates: 'combine',
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1000,
  parseArrays: true,
  plainObjects: false,
  strictDepth: false,
  strictNullHandling: false
};
var interpretNumericEntities = function (str) {
  return str.replace(/&#(\d+);/g, function ($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function (val, options) {
  if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
    return val.split(',');
  }
  return val;
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
  var obj = {
    __proto__: null
  };
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
  cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
  var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);
  var skipIndex = -1; // Keep track of where the utf8 sentinel was found
  var i;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i = 0; i < parts.length; ++i) {
      if (parts[i].indexOf('utf8=') === 0) {
        if (parts[i] === charsetSentinel) {
          charset = 'utf-8';
        } else if (parts[i] === isoSentinel) {
          charset = 'iso-8859-1';
        }
        skipIndex = i;
        i = parts.length; // The eslint settings do not allow break;
      }
    }
  }
  for (i = 0; i < parts.length; ++i) {
    if (i === skipIndex) {
      continue;
    }
    var part = parts[i];
    var bracketEqualsPos = part.indexOf(']=');
    var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;
    var key, val;
    if (pos === -1) {
      key = options.decoder(part, defaults.decoder, charset, 'key');
      val = options.strictNullHandling ? null : '';
    } else {
      key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
      val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function (encodedVal) {
        return options.decoder(encodedVal, defaults.decoder, charset, 'value');
      });
    }
    if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf('[]=') > -1) {
      val = isArray(val) ? [val] : val;
    }
    var existing = has.call(obj, key);
    if (existing && options.duplicates === 'combine') {
      obj[key] = utils.combine(obj[key], val);
    } else if (!existing || options.duplicates === 'last') {
      obj[key] = val;
    }
  }
  return obj;
};
var parseObject = function (chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);
  for (var i = chain.length - 1; i >= 0; --i) {
    var obj;
    var root = chain[i];
    if (root === '[]' && options.parseArrays) {
      obj = options.allowEmptyArrays && (leaf === '' || options.strictNullHandling && leaf === null) ? [] : [].concat(leaf);
    } else {
      obj = options.plainObjects ? Object.create(null) : {};
      var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
      var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
      var index = parseInt(decodedRoot, 10);
      if (!options.parseArrays && decodedRoot === '') {
        obj = {
          0: leaf
        };
      } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
        obj = [];
        obj[index] = leaf;
      } else if (decodedRoot !== '__proto__') {
        obj[decodedRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }

  // Transform dot notation to bracket notation
  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

  // The regex chunks

  var brackets = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;

  // Get the parent

  var segment = options.depth > 0 && brackets.exec(key);
  var parent = segment ? key.slice(0, segment.index) : key;

  // Stash the parent if it exists

  var keys = [];
  if (parent) {
    // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
    if (!options.plainObjects && has.call(Object.prototype, parent)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(parent);
  }

  // Loop through children appending to the array until we hit depth

  var i = 0;
  while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
    i += 1;
    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys.push(segment[1]);
  }

  // If there's a remainder, check strictDepth option for throw, else just add whatever is left

  if (segment) {
    if (options.strictDepth === true) {
      throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
    }
    keys.push('[' + key.slice(segment.index) + ']');
  }
  return parseObject(keys, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions(opts) {
  if (!opts) {
    return defaults;
  }
  if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
    throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
  }
  if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
    throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
  }
  if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
    throw new TypeError('Decoder has to be a function.');
  }
  if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
    throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
  }
  var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;
  var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;
  if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
    throw new TypeError('The duplicates option must be either combine, first, or last');
  }
  var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    allowDots: allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
    allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
    arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
    charset: charset,
    charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
    comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
    decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
    decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
    delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof opts.depth === 'number' || opts.depth === false ? +opts.depth : defaults.depth,
    duplicates: duplicates,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
    strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
    strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
  };
};
module.exports = function (str, opts) {
  var options = normalizeParseOptions(opts);
  if (str === '' || str === null || typeof str === 'undefined') {
    return options.plainObjects ? Object.create(null) : {};
  }
  var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
  var obj = options.plainObjects ? Object.create(null) : {};

  // Iterate over the keys and setup the new object

  var keys = Object.keys(tempObj);
  for (var i = 0; i < keys.length; ++i) {
    var key = keys[i];
    var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
    obj = utils.merge(obj, newObj, options);
  }
  if (options.allowSparse === true) {
    return obj;
  }
  return utils.compact(obj);
};

/***/ }),

/***/ "./node_modules/qs/lib/stringify.js":
/*!******************************************!*\
  !*** ./node_modules/qs/lib/stringify.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getSideChannel = __webpack_require__(/*! side-channel */ "./node_modules/side-channel/index.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");
var has = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + '[]';
  },
  comma: 'comma',
  indices: function indices(prefix, key) {
    return prefix + '[' + key + ']';
  },
  repeat: function repeat(prefix) {
    return prefix;
  }
};
var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
  push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats['default'];
var defaults = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: 'indices',
  charset: 'utf-8',
  charsetSentinel: false,
  delimiter: '&',
  encode: true,
  encodeDotInKeys: false,
  encoder: utils.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats.formatters[defaultFormat],
  // deprecated
  indices: false,
  serializeDate: function serializeDate(date) {
    return toISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
  return typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || typeof v === 'symbol' || typeof v === 'bigint';
};
var sentinel = {};
var stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
  var obj = object;
  var tmpSc = sideChannel;
  var step = 0;
  var findFlag = false;
  while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
    // Where object last appeared in the ref tree
    var pos = tmpSc.get(object);
    step += 1;
    if (typeof pos !== 'undefined') {
      if (pos === step) {
        throw new RangeError('Cyclic object value');
      } else {
        findFlag = true; // Break while
      }
    }
    if (typeof tmpSc.get(sentinel) === 'undefined') {
      step = 0;
    }
  }
  if (typeof filter === 'function') {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate(obj);
  } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
    obj = utils.maybeMap(obj, function (value) {
      if (value instanceof Date) {
        return serializeDate(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
    }
    obj = '';
  }
  if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
      return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
    }
    return [formatter(prefix) + '=' + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === 'undefined') {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === 'comma' && isArray(obj)) {
    // we need to join elements in
    if (encodeValuesOnly && encoder) {
      obj = utils.maybeMap(obj, encoder);
    }
    objKeys = [{
      value: obj.length > 0 ? obj.join(',') || null : void undefined
    }];
  } else if (isArray(filter)) {
    objKeys = filter;
  } else {
    var keys = Object.keys(obj);
    objKeys = sort ? keys.sort(sort) : keys;
  }
  var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, '%2E') : prefix;
  var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;
  if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
    return adjustedPrefix + '[]';
  }
  for (var j = 0; j < objKeys.length; ++j) {
    var key = objKeys[j];
    var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];
    if (skipNulls && value === null) {
      continue;
    }
    var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, '%2E') : key;
    var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');
    sideChannel.set(object, step);
    var valueSideChannel = getSideChannel();
    valueSideChannel.set(sentinel, sideChannel);
    pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
  if (!opts) {
    return defaults;
  }
  if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
    throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
  }
  if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
    throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
  }
  if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
    throw new TypeError('Encoder has to be a function.');
  }
  var charset = opts.charset || defaults.charset;
  if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
    throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
  }
  var format = formats['default'];
  if (typeof opts.format !== 'undefined') {
    if (!has.call(formats.formatters, opts.format)) {
      throw new TypeError('Unknown format option provided.');
    }
    format = opts.format;
  }
  var formatter = formats.formatters[format];
  var filter = defaults.filter;
  if (typeof opts.filter === 'function' || isArray(opts.filter)) {
    filter = opts.filter;
  }
  var arrayFormat;
  if (opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if ('indices' in opts) {
    arrayFormat = opts.indices ? 'indices' : 'repeat';
  } else {
    arrayFormat = defaults.arrayFormat;
  }
  if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
    throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
  }
  var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
    allowDots: allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat: arrayFormat,
    charset: charset,
    charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter: filter,
    format: format,
    formatter: formatter,
    serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
    sort: typeof opts.sort === 'function' ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
  };
};
module.exports = function (object, opts) {
  var obj = object;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter;
  if (typeof options.filter === 'function') {
    filter = options.filter;
    obj = filter('', obj);
  } else if (isArray(options.filter)) {
    filter = options.filter;
    objKeys = filter;
  }
  var keys = [];
  if (typeof obj !== 'object' || obj === null) {
    return '';
  }
  var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
  var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  var sideChannel = getSideChannel();
  for (var i = 0; i < objKeys.length; ++i) {
    var key = objKeys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
  }
  var joined = keys.join(options.delimiter);
  var prefix = options.addQueryPrefix === true ? '?' : '';
  if (options.charsetSentinel) {
    if (options.charset === 'iso-8859-1') {
      // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
      prefix += 'utf8=%26%2310003%3B&';
    } else {
      // encodeURIComponent('✓')
      prefix += 'utf8=%E2%9C%93&';
    }
  }
  return joined.length > 0 ? prefix + joined : '';
};

/***/ }),

/***/ "./node_modules/qs/lib/utils.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/utils.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");
var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var hexTable = function () {
  var array = [];
  for (var i = 0; i < 256; ++i) {
    array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
  }
  return array;
}();
var compactQueue = function compactQueue(queue) {
  while (queue.length > 1) {
    var item = queue.pop();
    var obj = item.obj[item.prop];
    if (isArray(obj)) {
      var compacted = [];
      for (var j = 0; j < obj.length; ++j) {
        if (typeof obj[j] !== 'undefined') {
          compacted.push(obj[j]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject(source, options) {
  var obj = options && options.plainObjects ? Object.create(null) : {};
  for (var i = 0; i < source.length; ++i) {
    if (typeof source[i] !== 'undefined') {
      obj[i] = source[i];
    }
  }
  return obj;
};
var merge = function merge(target, source, options) {
  /* eslint no-param-reassign: 0 */
  if (!source) {
    return target;
  }
  if (typeof source !== 'object') {
    if (isArray(target)) {
      target.push(source);
    } else if (target && typeof target === 'object') {
      if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }
    return target;
  }
  if (!target || typeof target !== 'object') {
    return [target].concat(source);
  }
  var mergeTarget = target;
  if (isArray(target) && !isArray(source)) {
    mergeTarget = arrayToObject(target, options);
  }
  if (isArray(target) && isArray(source)) {
    source.forEach(function (item, i) {
      if (has.call(target, i)) {
        var targetItem = target[i];
        if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
          target[i] = merge(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i] = item;
      }
    });
    return target;
  }
  return Object.keys(source).reduce(function (acc, key) {
    var value = source[key];
    if (has.call(acc, key)) {
      acc[key] = merge(acc[key], value, options);
    } else {
      acc[key] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function (acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};
var decode = function (str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, ' ');
  if (charset === 'iso-8859-1') {
    // unescape never throws, no try...catch needed:
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  // utf-8
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e) {
    return strWithoutPlus;
  }
};
var limit = 1024;

/* eslint operator-linebreak: [2, "before"] */

var encode = function encode(str, defaultEncoder, charset, kind, format) {
  // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
  // It has been adapted here for stricter adherence to RFC 3986
  if (str.length === 0) {
    return str;
  }
  var string = str;
  if (typeof str === 'symbol') {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== 'string') {
    string = String(str);
  }
  if (charset === 'iso-8859-1') {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
      return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
    });
  }
  var out = '';
  for (var j = 0; j < string.length; j += limit) {
    var segment = string.length >= limit ? string.slice(j, j + limit) : string;
    var arr = [];
    for (var i = 0; i < segment.length; ++i) {
      var c = segment.charCodeAt(i);
      if (c === 0x2D // -
      || c === 0x2E // .
      || c === 0x5F // _
      || c === 0x7E // ~
      || c >= 0x30 && c <= 0x39 // 0-9
      || c >= 0x41 && c <= 0x5A // a-z
      || c >= 0x61 && c <= 0x7A // A-Z
      || format === formats.RFC1738 && (c === 0x28 || c === 0x29) // ( )
      ) {
        arr[arr.length] = segment.charAt(i);
        continue;
      }
      if (c < 0x80) {
        arr[arr.length] = hexTable[c];
        continue;
      }
      if (c < 0x800) {
        arr[arr.length] = hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F];
        continue;
      }
      if (c < 0xD800 || c >= 0xE000) {
        arr[arr.length] = hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
        continue;
      }
      i += 1;
      c = 0x10000 + ((c & 0x3FF) << 10 | segment.charCodeAt(i) & 0x3FF);
      arr[arr.length] = hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
    }
    out += arr.join('');
  }
  return out;
};
var compact = function compact(value) {
  var queue = [{
    obj: {
      o: value
    },
    prop: 'o'
  }];
  var refs = [];
  for (var i = 0; i < queue.length; ++i) {
    var item = queue[i];
    var obj = item.obj[item.prop];
    var keys = Object.keys(obj);
    for (var j = 0; j < keys.length; ++j) {
      var key = keys[j];
      var val = obj[key];
      if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
        queue.push({
          obj: obj,
          prop: key
        });
        refs.push(val);
      }
    }
  }
  compactQueue(queue);
  return value;
};
var isRegExp = function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === '[object RegExp]';
};
var isBuffer = function isBuffer(obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine(a, b) {
  return [].concat(a, b);
};
var maybeMap = function maybeMap(val, fn) {
  if (isArray(val)) {
    var mapped = [];
    for (var i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
};
module.exports = {
  arrayToObject: arrayToObject,
  assign: assign,
  combine: combine,
  compact: compact,
  decode: decode,
  encode: encode,
  isBuffer: isBuffer,
  isRegExp: isRegExp,
  maybeMap: maybeMap,
  merge: merge
};

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");
var Buffer = buffer.Buffer;

// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }
  return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  var buf = Buffer(size);
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }
  return buf;
};
SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return buffer.SlowBuffer(size);
};

/***/ }),

/***/ "./node_modules/set-function-length/index.js":
/*!***************************************************!*\
  !*** ./node_modules/set-function-length/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var define = __webpack_require__(/*! define-data-property */ "./node_modules/define-data-property/index.js");
var hasDescriptors = __webpack_require__(/*! has-property-descriptors */ "./node_modules/has-property-descriptors/index.js")();
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
  if (typeof fn !== 'function') {
    throw new $TypeError('`fn` is not a function');
  }
  if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
    throw new $TypeError('`length` must be a positive 32-bit integer');
  }
  var loose = arguments.length > 2 && !!arguments[2];
  var functionLengthIsConfigurable = true;
  var functionLengthIsWritable = true;
  if ('length' in fn && gOPD) {
    var desc = gOPD(fn, 'length');
    if (desc && !desc.configurable) {
      functionLengthIsConfigurable = false;
    }
    if (desc && !desc.writable) {
      functionLengthIsWritable = false;
    }
  }
  if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
    if (hasDescriptors) {
      define(/** @type {Parameters<define>[0]} */fn, 'length', length, true, true);
    } else {
      define(/** @type {Parameters<define>[0]} */fn, 'length', length);
    }
  }
  return fn;
};

/***/ }),

/***/ "./node_modules/side-channel/index.js":
/*!********************************************!*\
  !*** ./node_modules/side-channel/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var inspect = __webpack_require__(/*! object-inspect */ "./node_modules/object-inspect/index.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);
var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list. By doing so, all the recently used nodes can be accessed relatively quickly.
*/
/** @type {import('.').listGetNode} */
var listGetNode = function (list, key) {
  // eslint-disable-line consistent-return
  /** @type {typeof list | NonNullable<(typeof list)['next']>} */
  var prev = list;
  /** @type {(typeof list)['next']} */
  var curr;
  for (; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key) {
      prev.next = curr.next;
      // eslint-disable-next-line no-extra-parens
      curr.next = /** @type {NonNullable<typeof list.next>} */list.next;
      list.next = curr; // eslint-disable-line no-param-reassign
      return curr;
    }
  }
};

/** @type {import('.').listGet} */
var listGet = function (objects, key) {
  var node = listGetNode(objects, key);
  return node && node.value;
};
/** @type {import('.').listSet} */
var listSet = function (objects, key, value) {
  var node = listGetNode(objects, key);
  if (node) {
    node.value = value;
  } else {
    // Prepend the new node to the beginning of the list
    objects.next = /** @type {import('.').ListNode<typeof value>} */{
      // eslint-disable-line no-param-reassign, no-extra-parens
      key: key,
      next: objects.next,
      value: value
    };
  }
};
/** @type {import('.').listHas} */
var listHas = function (objects, key) {
  return !!listGetNode(objects, key);
};

/** @type {import('.')} */
module.exports = function getSideChannel() {
  /** @type {WeakMap<object, unknown>} */var $wm;
  /** @type {Map<object, unknown>} */
  var $m;
  /** @type {import('.').RootNode<unknown>} */
  var $o;

  /** @type {import('.').Channel} */
  var channel = {
    assert: function (key) {
      if (!channel.has(key)) {
        throw new $TypeError('Side channel does not contain ' + inspect(key));
      }
    },
    get: function (key) {
      // eslint-disable-line consistent-return
      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key);
        }
      } else {
        if ($o) {
          // eslint-disable-line no-lonely-if
          return listGet($o, key);
        }
      }
    },
    has: function (key) {
      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key);
        }
      } else {
        if ($o) {
          // eslint-disable-line no-lonely-if
          return listHas($o, key);
        }
      }
      return false;
    },
    set: function (key, value) {
      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value);
      } else {
        if (!$o) {
          // Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
          $o = {
            key: {},
            next: null
          };
        }
        listSet($o, key, value);
      }
    }
  };
  return channel;
};

/***/ }),

/***/ "./node_modules/sprintf-js/src/sprintf.js":
/*!************************************************!*\
  !*** ./node_modules/sprintf-js/src/sprintf.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/* global window, exports, define */

!function () {
  'use strict';

  var re = {
    not_string: /[^s]/,
    not_bool: /[^t]/,
    not_type: /[^T]/,
    not_primitive: /[^v]/,
    number: /[diefg]/,
    numeric_arg: /[bcdiefguxX]/,
    json: /[j]/,
    not_json: /[^j]/,
    text: /^[^\x25]+/,
    modulo: /^\x25{2}/,
    placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
    key: /^([a-z_][a-z_\d]*)/i,
    key_access: /^\.([a-z_][a-z_\d]*)/i,
    index_access: /^\[(\d+)\]/,
    sign: /^[+-]/
  };
  function sprintf(key) {
    // `arguments` is not an array, but should be fine for this call
    return sprintf_format(sprintf_parse(key), arguments);
  }
  function vsprintf(fmt, argv) {
    return sprintf.apply(null, [fmt].concat(argv || []));
  }
  function sprintf_format(parse_tree, argv) {
    var cursor = 1,
      tree_length = parse_tree.length,
      arg,
      output = '',
      i,
      k,
      ph,
      pad,
      pad_character,
      pad_length,
      is_positive,
      sign;
    for (i = 0; i < tree_length; i++) {
      if (typeof parse_tree[i] === 'string') {
        output += parse_tree[i];
      } else if (typeof parse_tree[i] === 'object') {
        ph = parse_tree[i]; // convenience purposes only
        if (ph.keys) {
          // keyword argument
          arg = argv[cursor];
          for (k = 0; k < ph.keys.length; k++) {
            if (arg == undefined) {
              throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
            }
            arg = arg[ph.keys[k]];
          }
        } else if (ph.param_no) {
          // positional argument (explicit)
          arg = argv[ph.param_no];
        } else {
          // positional argument (implicit)
          arg = argv[cursor++];
        }
        if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
          arg = arg();
        }
        if (re.numeric_arg.test(ph.type) && typeof arg !== 'number' && isNaN(arg)) {
          throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg));
        }
        if (re.number.test(ph.type)) {
          is_positive = arg >= 0;
        }
        switch (ph.type) {
          case 'b':
            arg = parseInt(arg, 10).toString(2);
            break;
          case 'c':
            arg = String.fromCharCode(parseInt(arg, 10));
            break;
          case 'd':
          case 'i':
            arg = parseInt(arg, 10);
            break;
          case 'j':
            arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
            break;
          case 'e':
            arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
            break;
          case 'f':
            arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
            break;
          case 'g':
            arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
            break;
          case 'o':
            arg = (parseInt(arg, 10) >>> 0).toString(8);
            break;
          case 's':
            arg = String(arg);
            arg = ph.precision ? arg.substring(0, ph.precision) : arg;
            break;
          case 't':
            arg = String(!!arg);
            arg = ph.precision ? arg.substring(0, ph.precision) : arg;
            break;
          case 'T':
            arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
            arg = ph.precision ? arg.substring(0, ph.precision) : arg;
            break;
          case 'u':
            arg = parseInt(arg, 10) >>> 0;
            break;
          case 'v':
            arg = arg.valueOf();
            arg = ph.precision ? arg.substring(0, ph.precision) : arg;
            break;
          case 'x':
            arg = (parseInt(arg, 10) >>> 0).toString(16);
            break;
          case 'X':
            arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
            break;
        }
        if (re.json.test(ph.type)) {
          output += arg;
        } else {
          if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
            sign = is_positive ? '+' : '-';
            arg = arg.toString().replace(re.sign, '');
          } else {
            sign = '';
          }
          pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' ';
          pad_length = ph.width - (sign + arg).length;
          pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : '' : '';
          output += ph.align ? sign + arg + pad : pad_character === '0' ? sign + pad + arg : pad + sign + arg;
        }
      }
    }
    return output;
  }
  var sprintf_cache = Object.create(null);
  function sprintf_parse(fmt) {
    if (sprintf_cache[fmt]) {
      return sprintf_cache[fmt];
    }
    var _fmt = fmt,
      match,
      parse_tree = [],
      arg_names = 0;
    while (_fmt) {
      if ((match = re.text.exec(_fmt)) !== null) {
        parse_tree.push(match[0]);
      } else if ((match = re.modulo.exec(_fmt)) !== null) {
        parse_tree.push('%');
      } else if ((match = re.placeholder.exec(_fmt)) !== null) {
        if (match[2]) {
          arg_names |= 1;
          var field_list = [],
            replacement_field = match[2],
            field_match = [];
          if ((field_match = re.key.exec(replacement_field)) !== null) {
            field_list.push(field_match[1]);
            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
              if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
              } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
              } else {
                throw new SyntaxError('[sprintf] failed to parse named argument key');
              }
            }
          } else {
            throw new SyntaxError('[sprintf] failed to parse named argument key');
          }
          match[2] = field_list;
        } else {
          arg_names |= 2;
        }
        if (arg_names === 3) {
          throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');
        }
        parse_tree.push({
          placeholder: match[0],
          param_no: match[1],
          keys: match[2],
          sign: match[3],
          pad_char: match[4],
          align: match[5],
          width: match[6],
          precision: match[7],
          type: match[8]
        });
      } else {
        throw new SyntaxError('[sprintf] unexpected placeholder');
      }
      _fmt = _fmt.substring(match[0].length);
    }
    return sprintf_cache[fmt] = parse_tree;
  }

  /**
   * export to either browser or node.js
   */
  /* eslint-disable quote-props */
  if (true) {
    exports.sprintf = sprintf;
    exports.vsprintf = vsprintf;
  }
  if (typeof window !== 'undefined') {
    window['sprintf'] = sprintf;
    window['vsprintf'] = vsprintf;
    if (true) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return {
          'sprintf': sprintf,
          'vsprintf': vsprintf
        };
      }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
  /* eslint-enable quote-props */
}(); // eslint-disable-line

/***/ }),

/***/ "./node_modules/tannin/index.js":
/*!**************************************!*\
  !*** ./node_modules/tannin/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Tannin)
/* harmony export */ });
/* harmony import */ var _tannin_plural_forms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tannin/plural-forms */ "./node_modules/@tannin/plural-forms/index.js");


/**
 * Tannin constructor options.
 *
 * @typedef {Object} TanninOptions
 *
 * @property {string}   [contextDelimiter] Joiner in string lookup with context.
 * @property {Function} [onMissingKey]     Callback to invoke when key missing.
 */

/**
 * Domain metadata.
 *
 * @typedef {Object} TanninDomainMetadata
 *
 * @property {string}            [domain]       Domain name.
 * @property {string}            [lang]         Language code.
 * @property {(string|Function)} [plural_forms] Plural forms expression or
 *                                              function evaluator.
 */

/**
 * Domain translation pair respectively representing the singular and plural
 * translation.
 *
 * @typedef {[string,string]} TanninTranslation
 */

/**
 * Locale data domain. The key is used as reference for lookup, the value an
 * array of two string entries respectively representing the singular and plural
 * translation.
 *
 * @typedef {{[key:string]:TanninDomainMetadata|TanninTranslation,'':TanninDomainMetadata|TanninTranslation}} TanninLocaleDomain
 */

/**
 * Jed-formatted locale data.
 *
 * @see http://messageformat.github.io/Jed/
 *
 * @typedef {{[domain:string]:TanninLocaleDomain}} TanninLocaleData
 */

/**
 * Default Tannin constructor options.
 *
 * @type {TanninOptions}
 */
var DEFAULT_OPTIONS = {
  contextDelimiter: '\u0004',
  onMissingKey: null
};

/**
 * Given a specific locale data's config `plural_forms` value, returns the
 * expression.
 *
 * @example
 *
 * ```
 * getPluralExpression( 'nplurals=2; plural=(n != 1);' ) === '(n != 1)'
 * ```
 *
 * @param {string} pf Locale data plural forms.
 *
 * @return {string} Plural forms expression.
 */
function getPluralExpression(pf) {
  var parts, i, part;
  parts = pf.split(';');
  for (i = 0; i < parts.length; i++) {
    part = parts[i].trim();
    if (part.indexOf('plural=') === 0) {
      return part.substr(7);
    }
  }
}

/**
 * Tannin constructor.
 *
 * @class
 *
 * @param {TanninLocaleData} data      Jed-formatted locale data.
 * @param {TanninOptions}    [options] Tannin options.
 */
function Tannin(data, options) {
  var key;

  /**
   * Jed-formatted locale data.
   *
   * @name Tannin#data
   * @type {TanninLocaleData}
   */
  this.data = data;

  /**
   * Plural forms function cache, keyed by plural forms string.
   *
   * @name Tannin#pluralForms
   * @type {Object<string,Function>}
   */
  this.pluralForms = {};

  /**
   * Effective options for instance, including defaults.
   *
   * @name Tannin#options
   * @type {TanninOptions}
   */
  this.options = {};
  for (key in DEFAULT_OPTIONS) {
    this.options[key] = options !== undefined && key in options ? options[key] : DEFAULT_OPTIONS[key];
  }
}

/**
 * Returns the plural form index for the given domain and value.
 *
 * @param {string} domain Domain on which to calculate plural form.
 * @param {number} n      Value for which plural form is to be calculated.
 *
 * @return {number} Plural form index.
 */
Tannin.prototype.getPluralForm = function (domain, n) {
  var getPluralForm = this.pluralForms[domain],
    config,
    plural,
    pf;
  if (!getPluralForm) {
    config = this.data[domain][''];
    pf = config['Plural-Forms'] || config['plural-forms'] ||
    // Ignore reason: As known, there's no way to document the empty
    // string property on a key to guarantee this as metadata.
    // @ts-ignore
    config.plural_forms;
    if (typeof pf !== 'function') {
      plural = getPluralExpression(config['Plural-Forms'] || config['plural-forms'] ||
      // Ignore reason: As known, there's no way to document the empty
      // string property on a key to guarantee this as metadata.
      // @ts-ignore
      config.plural_forms);
      pf = (0,_tannin_plural_forms__WEBPACK_IMPORTED_MODULE_0__["default"])(plural);
    }
    getPluralForm = this.pluralForms[domain] = pf;
  }
  return getPluralForm(n);
};

/**
 * Translate a string.
 *
 * @param {string}      domain   Translation domain.
 * @param {string|void} context  Context distinguishing terms of the same name.
 * @param {string}      singular Primary key for translation lookup.
 * @param {string=}     plural   Fallback value used for non-zero plural
 *                               form index.
 * @param {number=}     n        Value to use in calculating plural form.
 *
 * @return {string} Translated string.
 */
Tannin.prototype.dcnpgettext = function (domain, context, singular, plural, n) {
  var index, key, entry;
  if (n === undefined) {
    // Default to singular.
    index = 0;
  } else {
    // Find index by evaluating plural form for value.
    index = this.getPluralForm(domain, n);
  }
  key = singular;

  // If provided, context is prepended to key with delimiter.
  if (context) {
    key = context + this.options.contextDelimiter + singular;
  }
  entry = this.data[domain][key];

  // Verify not only that entry exists, but that the intended index is within
  // range and non-empty.
  if (entry && entry[index]) {
    return entry[index];
  }
  if (this.options.onMissingKey) {
    this.options.onMissingKey(singular, domain);
  }

  // If entry not found, fall back to singular vs. plural with zero index
  // representing the singular value.
  return index === 0 ? singular : plural;
};

/***/ }),

/***/ "./node_modules/tokenizer2/core.js":
/*!*****************************************!*\
  !*** ./node_modules/tokenizer2/core.js ***!
  \*****************************************/
/***/ ((module) => {

var findMatchingRule = function (rules, text) {
  var i;
  for (i = 0; i < rules.length; i++) if (rules[i].regex.test(text)) return rules[i];
  return undefined;
};
var findMaxIndexAndRule = function (rules, text) {
  var i, rule, last_matching_rule;
  for (i = 0; i < text.length; i++) {
    rule = findMatchingRule(rules, text.substring(0, i + 1));
    if (rule) last_matching_rule = rule;else if (last_matching_rule) return {
      max_index: i,
      rule: last_matching_rule
    };
  }
  return last_matching_rule ? {
    max_index: text.length,
    rule: last_matching_rule
  } : undefined;
};
module.exports = function (onToken_orig) {
  var buffer = "";
  var rules = [];
  var line = 1;
  var col = 1;
  var onToken = function (src, type) {
    onToken_orig({
      type: type,
      src: src,
      line: line,
      col: col
    });
    var lines = src.split("\n");
    line += lines.length - 1;
    col = (lines.length > 1 ? 1 : col) + lines[lines.length - 1].length;
  };
  return {
    addRule: function (regex, type) {
      rules.push({
        regex: regex,
        type: type
      });
    },
    onText: function (text) {
      var str = buffer + text;
      var m = findMaxIndexAndRule(rules, str);
      while (m && m.max_index !== str.length) {
        onToken(str.substring(0, m.max_index), m.rule.type);

        //now find the next token
        str = str.substring(m.max_index);
        m = findMaxIndexAndRule(rules, str);
      }
      buffer = str;
    },
    end: function () {
      if (buffer.length === 0) return;
      var rule = findMatchingRule(rules, buffer);
      if (!rule) {
        var err = new Error("unable to tokenize");
        err.tokenizer2 = {
          buffer: buffer,
          line: line,
          col: col
        };
        throw err;
      }
      onToken(buffer, rule.type);
    }
  };
};

/***/ }),

/***/ "./node_modules/url/node_modules/punycode/punycode.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;
(function (root) {
  /** Detect free variables */
  var freeExports =  true && exports && !exports.nodeType && exports;
  var freeModule =  true && module && !module.nodeType && module;
  var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
    root = freeGlobal;
  }

  /**
   * The `punycode` object.
   * @name punycode
   * @type Object
   */
  var punycode,
    /** Highest positive signed 32-bit float value */
    maxInt = 2147483647,
    // aka. 0x7FFFFFFF or 2^31-1

    /** Bootstring parameters */
    base = 36,
    tMin = 1,
    tMax = 26,
    skew = 38,
    damp = 700,
    initialBias = 72,
    initialN = 128,
    // 0x80
    delimiter = '-',
    // '\x2D'

    /** Regular expressions */
    regexPunycode = /^xn--/,
    regexNonASCII = /[^\x20-\x7E]/,
    // unprintable ASCII chars + non-ASCII chars
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
    // RFC 3490 separators

    /** Error messages */
    errors = {
      'overflow': 'Overflow: input needs wider integers to process',
      'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
      'invalid-input': 'Invalid input'
    },
    /** Convenience shortcuts */
    baseMinusTMin = base - tMin,
    floor = Math.floor,
    stringFromCharCode = String.fromCharCode,
    /** Temporary variable */
    key;

  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */
  function error(type) {
    throw new RangeError(errors[type]);
  }

  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */
  function map(array, fn) {
    var length = array.length;
    var result = [];
    while (length--) {
      result[length] = fn(array[length]);
    }
    return result;
  }

  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */
  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';
    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    }
    // Avoid `split(regex)` for IE8 compatibility. See #17.
    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }

  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */
  function ucs2decode(string) {
    var output = [],
      counter = 0,
      length = string.length,
      value,
      extra;
    while (counter < length) {
      value = string.charCodeAt(counter++);
      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // high surrogate, and there is a next character
        extra = string.charCodeAt(counter++);
        if ((extra & 0xFC00) == 0xDC00) {
          // low surrogate
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }

  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */
  function ucs2encode(array) {
    return map(array, function (value) {
      var output = '';
      if (value > 0xFFFF) {
        value -= 0x10000;
        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
        value = 0xDC00 | value & 0x3FF;
      }
      output += stringFromCharCode(value);
      return output;
    }).join('');
  }

  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */
  function basicToDigit(codePoint) {
    if (codePoint - 48 < 10) {
      return codePoint - 22;
    }
    if (codePoint - 65 < 26) {
      return codePoint - 65;
    }
    if (codePoint - 97 < 26) {
      return codePoint - 97;
    }
    return base;
  }

  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */
  function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  }

  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * https://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */
  function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for /* no initialization */
    (; delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  }

  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */
  function decode(input) {
    // Don't use UCS-2
    var output = [],
      inputLength = input.length,
      out,
      i = 0,
      n = initialN,
      bias = initialBias,
      basic,
      j,
      index,
      oldi,
      w,
      k,
      digit,
      t,
      /** Cached calculation results */
      baseMinusT;

    // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
      basic = 0;
    }
    for (j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error('not-basic');
      }
      output.push(input.charCodeAt(j));
    }

    // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.

    for /* no final expression */
    (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      for /* no condition */
      (oldi = i, w = 1, k = base;; k += base) {
        if (index >= inputLength) {
          error('invalid-input');
        }
        digit = basicToDigit(input.charCodeAt(index++));
        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error('overflow');
        }
        i += digit * w;
        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
        if (digit < t) {
          break;
        }
        baseMinusT = base - t;
        if (w > floor(maxInt / baseMinusT)) {
          error('overflow');
        }
        w *= baseMinusT;
      }
      out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0);

      // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:
      if (floor(i / out) > maxInt - n) {
        error('overflow');
      }
      n += floor(i / out);
      i %= out;

      // Insert `n` at position `i` of the output
      output.splice(i++, 0, n);
    }
    return ucs2encode(output);
  }

  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */
  function encode(input) {
    var n,
      delta,
      handledCPCount,
      basicLength,
      bias,
      j,
      m,
      q,
      k,
      t,
      currentValue,
      output = [],
      /** `inputLength` will hold the number of code points in `input`. */
      inputLength,
      /** Cached calculation results */
      handledCPCountPlusOne,
      baseMinusT,
      qMinusT;

    // Convert the input in UCS-2 to Unicode
    input = ucs2decode(input);

    // Cache the length
    inputLength = input.length;

    // Initialize the state
    n = initialN;
    delta = 0;
    bias = initialBias;

    // Handle the basic code points
    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];
      if (currentValue < 0x80) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    handledCPCount = basicLength = output.length;

    // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.

    // Finish the basic string - if it is not empty - with a delimiter
    if (basicLength) {
      output.push(delimiter);
    }

    // Main encoding loop:
    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      }

      // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
      // but guard against overflow
      handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error('overflow');
      }
      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue < n && ++delta > maxInt) {
          error('overflow');
        }
        if (currentValue == n) {
          // Represent delta as a generalized variable-length integer
          for /* no condition */
          (q = delta, k = base;; k += base) {
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q < t) {
              break;
            }
            qMinusT = q - t;
            baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n;
    }
    return output.join('');
  }

  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */
  function toUnicode(input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  }

  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */
  function toASCII(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  }

  /*--------------------------------------------------------------------------*/

  /** Define the public API */
  punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    'version': '1.4.1',
    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  };

  /** Expose `punycode` */
  // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:
  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return punycode;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this);

/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */



var punycode = __webpack_require__(/*! punycode/ */ "./node_modules/url/node_modules/punycode/punycode.js");
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

/*
 * define these here so at least they only have to be
 * compiled once on the first module load.
 */
var protocolPattern = /^([a-z0-9.+-]+:)/i,
  portPattern = /:[0-9]*$/,
  // Special case for a simple path URL
  simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,
  /*
   * RFC 2396: characters reserved for delimiting URLs.
   * We actually just auto-escape these.
   */
  delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
  // RFC 2396: characters not allowed for various reasons.
  unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
  autoEscape = ['\''].concat(unwise),
  /*
   * Characters that are never ever allowed in a hostname.
   * Note that any invalid chars are also handled, but these
   * are the ones that are *expected* to be seen, so we fast-path
   * them.
   */
  nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
  hostEndingChars = ['/', '?', '#'],
  hostnameMaxLen = 255,
  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
  // protocols that can allow "unsafe" and "unwise" chars.
  unsafeProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that never have a hostname.
  hostlessProtocol = {
    javascript: true,
    'javascript:': true
  },
  // protocols that always contain a // bit.
  slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
  },
  querystring = __webpack_require__(/*! qs */ "./node_modules/qs/lib/index.js");
function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof url === 'object' && url instanceof Url) {
    return url;
  }
  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  /*
   * Copy chrome, IE, opera backslash-handling behavior.
   * Back slashes before the query string get converted to forward slashes
   * See: https://code.google.com/p/chromium/issues/detail?id=25916
   */
  var queryIndex = url.indexOf('?'),
    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
    uSplit = url.split(splitter),
    slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);
  var rest = url;

  /*
   * trim before proceeding.
   * This is to support parse stuff like "  http://foo.com  \n"
   */
  rest = rest.trim();
  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  /*
   * figure out if it's got a host
   * user@server is *always* interpreted as a hostname, and url
   * resolution will treat //foo/bar as host=foo,path=bar because that's
   * how the browser resolves relative URLs.
   */
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    /*
     * there's a hostname.
     * the first instance of /, ?, ;, or # ends the host.
     *
     * If there is an @ in the hostname, then non-host chars *are* allowed
     * to the left of the last @ sign, unless some host-ending character
     * comes *before* the @-sign.
     * URLs are obnoxious.
     *
     * ex:
     * http://a@b@c/ => user:a@b host:c
     * http://a@b?@c => user:a host:c path:/?@c
     */

    /*
     * v0.12 TODO(isaacs): This is not quite how Chrome does things.
     * Review our test case against browsers more comprehensively.
     */

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    /*
     * at this point, either we have an explicit point where the
     * auth portion cannot go past, or the last @ char is the decider.
     */
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      /*
       * atSign must be in auth portion.
       * http://a@b/c@d => host:b auth:a path:/c@d
       */
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    /*
     * Now we have a portion which is definitely the auth.
     * Pull that off.
     */
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    /*
     * we've indicated that there is a hostname,
     * so even if it's empty, it has to be present.
     */
    this.hostname = this.hostname || '';

    /*
     * if hostname begins with [ and ends with ]
     * assume that it's an IPv6 address.
     */
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              /*
               * we replace non-ASCII char with a temporary placeholder
               * we need this to make sure size of hostname is not
               * broken by replacing non-ASCII by nothing
               */
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      /*
       * IDNA Support: Returns a punycoded representation of "domain".
       * It only converts parts of the domain name that
       * have non-ASCII characters, i.e. it doesn't matter if
       * you call it with a domain that already is ASCII-only.
       */
      this.hostname = punycode.toASCII(this.hostname);
    }
    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    /*
     * strip [ and ] from the hostname
     * the host field still retains them, though
     */
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  /*
   * now rest is set to the post-host stuff.
   * chop off any delim chars.
   */
  if (!unsafeProtocol[lowerProto]) {
    /*
     * First, make 100% sure that any "autoEscape" chars get
     * escaped, even if encodeURIComponent doesn't think they
     * need to be.
     */
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) {
        continue;
      }
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  // to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  /*
   * ensure it's an object, and not a string url.
   * If it's an obj, this is a no-op.
   * this way, you can call url_format() on strings
   * to clean up potentially wonky urls.
   */
  if (typeof obj === 'string') {
    obj = urlParse(obj);
  }
  if (!(obj instanceof Url)) {
    return Url.prototype.format.call(obj);
  }
  return obj.format();
}
Url.prototype.format = function () {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }
  var protocol = this.protocol || '',
    pathname = this.pathname || '',
    hash = this.hash || '',
    host = false,
    query = '';
  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }
  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {
    query = querystring.stringify(this.query, {
      arrayFormat: 'repeat',
      addQueryPrefix: false
    });
  }
  var search = this.search || query && '?' + query || '';
  if (protocol && protocol.substr(-1) !== ':') {
    protocol += ':';
  }

  /*
   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
   * unless they had them to begin with.
   */
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') {
      pathname = '/' + pathname;
    }
  } else if (!host) {
    host = '';
  }
  if (hash && hash.charAt(0) !== '#') {
    hash = '#' + hash;
  }
  if (search && search.charAt(0) !== '?') {
    search = '?' + search;
  }
  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');
  return protocol + host + pathname + search + hash;
};
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};
function urlResolveObject(source, relative) {
  if (!source) {
    return relative;
  }
  return urlParse(source, false, true).resolveObject(relative);
}
Url.prototype.resolveObject = function (relative) {
  if (typeof relative === 'string') {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }
  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  /*
   * hash is always overridden, no matter what.
   * even href="" will remove it.
   */
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') {
        result[rkey] = relative[rkey];
      }
    }

    // urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.pathname = '/';
      result.path = result.pathname;
    }
    result.href = result.format();
    return result;
  }
  if (relative.protocol && relative.protocol !== result.protocol) {
    /*
     * if it's a known url protocol, then changing
     * the protocol does weird things
     * first, if it's not file:, then we MUST have a host,
     * and if there was a path
     * to begin with, then we MUST have a path.
     * if it is file:, then the host is dropped,
     * because that's known to be hostless.
     * anything else is assumed to be absolute.
     */
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }
    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift())) {}
      if (!relative.host) {
        relative.host = '';
      }
      if (!relative.hostname) {
        relative.hostname = '';
      }
      if (relPath[0] !== '') {
        relPath.unshift('');
      }
      if (relPath.length < 2) {
        relPath.unshift('');
      }
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }
  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
    mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
    removeAllDots = mustEndAbs,
    srcPath = result.pathname && result.pathname.split('/') || [],
    relPath = relative.pathname && relative.pathname.split('/') || [],
    psychotic = result.protocol && !slashedProtocol[result.protocol];

  /*
   * if the url is a non-slashed url, then relative
   * links like ../.. should be able
   * to crawl up to the hostname, as well.  This is strange.
   * result.protocol has already been set by now.
   * Later on, put the first path part into the host field.
   */
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') {
        srcPath[0] = result.host;
      } else {
        srcPath.unshift(result.host);
      }
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') {
          relPath[0] = relative.host;
        } else {
          relPath.unshift(relative.host);
        }
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }
  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    /*
     * it's relative
     * throw away the existing file, and take the new path instead.
     */
    if (!srcPath) {
      srcPath = [];
    }
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search != null) {
    /*
     * just pull out the search.
     * like href='?foo'.
     * Put this after the other two cases because it simplifies the booleans
     */
    if (psychotic) {
      result.host = srcPath.shift();
      result.hostname = result.host;
      /*
       * occationaly the auth can get stuck only in host
       * this especially happens in cases like
       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
       */
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    // to support http.request
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }
  if (!srcPath.length) {
    /*
     * no path at all.  easy.
     * we've already handled the other stuff above.
     */
    result.pathname = null;
    // to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  /*
   * if a url ENDs in . or .., then it must get a trailing slash.
   * however, if it ends in anything else non-slashy,
   * then it must NOT get a trailing slash.
   */
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

  /*
   * strip single dots, resolve double dots to parent dir
   * if the path tries to go above the root, `up` ends up > 0
   */
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }
  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }
  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
    srcPath.push('');
  }
  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';

  // put the host back
  if (psychotic) {
    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
    result.host = result.hostname;
    /*
     * occationaly the auth can get stuck only in host
     * this especially happens in cases like
     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
     */
    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.hostname = authInHost.shift();
      result.host = result.hostname;
    }
  }
  mustEndAbs = mustEndAbs || result.host && srcPath.length;
  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }
  if (srcPath.length > 0) {
    result.pathname = srcPath.join('/');
  } else {
    result.pathname = null;
    result.path = null;
  }

  // to support request.http
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};
Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

/***/ }),

/***/ "./node_modules/util/support/types.js":
/*!********************************************!*\
  !*** ./node_modules/util/support/types.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9



var isArgumentsObject = __webpack_require__(/*! is-arguments */ "./node_modules/is-arguments/index.js");
var isGeneratorFunction = __webpack_require__(/*! is-generator-function */ "./node_modules/is-generator-function/index.js");
var whichTypedArray = __webpack_require__(/*! which-typed-array */ "./node_modules/which-typed-array/index.js");
var isTypedArray = __webpack_require__(/*! is-typed-array */ "./node_modules/is-typed-array/index.js");
function uncurryThis(f) {
  return f.call.bind(f);
}
var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';
var ObjectToString = uncurryThis(Object.prototype.toString);
var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);
if (BigIntSupported) {
  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}
if (SymbolSupported) {
  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}
function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch (e) {
    return false;
  }
}
exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;

// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
  return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
}
exports.isPromise = isPromise;
function isArrayBufferView(value) {
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    return ArrayBuffer.isView(value);
  }
  return isTypedArray(value) || isDataView(value);
}
exports.isArrayBufferView = isArrayBufferView;
function isUint8Array(value) {
  return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;
function isUint8ClampedArray(value) {
  return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;
function isUint16Array(value) {
  return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;
function isUint32Array(value) {
  return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;
function isInt8Array(value) {
  return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;
function isInt16Array(value) {
  return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;
function isInt32Array(value) {
  return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;
function isFloat32Array(value) {
  return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;
function isFloat64Array(value) {
  return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;
function isBigInt64Array(value) {
  return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;
function isBigUint64Array(value) {
  return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;
function isMapToString(value) {
  return ObjectToString(value) === '[object Map]';
}
isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());
function isMap(value) {
  if (typeof Map === 'undefined') {
    return false;
  }
  return isMapToString.working ? isMapToString(value) : value instanceof Map;
}
exports.isMap = isMap;
function isSetToString(value) {
  return ObjectToString(value) === '[object Set]';
}
isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());
function isSet(value) {
  if (typeof Set === 'undefined') {
    return false;
  }
  return isSetToString.working ? isSetToString(value) : value instanceof Set;
}
exports.isSet = isSet;
function isWeakMapToString(value) {
  return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());
function isWeakMap(value) {
  if (typeof WeakMap === 'undefined') {
    return false;
  }
  return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;
function isWeakSetToString(value) {
  return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());
function isWeakSet(value) {
  return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;
function isArrayBufferToString(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());
function isArrayBuffer(value) {
  if (typeof ArrayBuffer === 'undefined') {
    return false;
  }
  return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;
function isDataViewToString(value) {
  return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
function isDataView(value) {
  if (typeof DataView === 'undefined') {
    return false;
  }
  return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
}
exports.isDataView = isDataView;

// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
  if (typeof SharedArrayBufferCopy === 'undefined') {
    return false;
  }
  if (typeof isSharedArrayBufferToString.working === 'undefined') {
    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
  }
  return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;
function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;
function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;
function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;
function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;
function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;
function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;
function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;
function isBigIntObject(value) {
  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;
function isSymbolObject(value) {
  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;
function isBoxedPrimitive(value) {
  return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
}
exports.isBoxedPrimitive = isBoxedPrimitive;
function isAnyArrayBuffer(value) {
  return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;
['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function (method) {
  Object.defineProperty(exports, method, {
    enumerable: false,
    value: function () {
      throw new Error(method + ' is not supported in userland');
    }
  });
});

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};
  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }
  return descriptors;
};
var formatRegExp = /%[sdj%]/g;
exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s':
        return String(args[i++]);
      case '%d':
        return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function (fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
};
var debugs = {};
var debugEnvRegex = /^$/;
if (false) { var debugEnv; }
exports.debuglog = function (set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      var pid = process.pid;
      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }
  return debugs[set];
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) &&
  // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect &&
  // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);
  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = '',
    array = false,
    braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }
  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value)) return ctx.stylize('null', 'null');
}
function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').slice(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.slice(1, -1);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }
  return name + ': ' + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }
  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __webpack_require__(/*! ./support/types */ "./node_modules/util/support/types.js");
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;
function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;
function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;
function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;
function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;
function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;
function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;
function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;
function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;
function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;
function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;
function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' ||
  // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;
exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");
exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;
exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }
  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });
    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }
    return promise;
  }
  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};
exports.promisify.custom = kCustomPromisifiedSymbol;
function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}
function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function () {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args).then(function (ret) {
      process.nextTick(cb.bind(null, null, ret));
    }, function (rej) {
      process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
    });
  }
  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

/***/ }),

/***/ "./node_modules/which-typed-array/index.js":
/*!*************************************************!*\
  !*** ./node_modules/which-typed-array/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var forEach = __webpack_require__(/*! for-each */ "./node_modules/for-each/index.js");
var availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ "./node_modules/available-typed-arrays/index.js");
var callBind = __webpack_require__(/*! call-bind */ "./node_modules/call-bind/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

/** @type {(O: object) => string} */
var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();
var $slice = callBound('String.prototype.slice');
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */
var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
  for (var i = 0; i < array.length; i += 1) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
};

/** @typedef {(receiver: import('.').TypedArray) => string | typeof Uint8Array.prototype.slice.call | typeof Uint8Array.prototype.set.call} Getter */
/** @type {{ [k in `\$${import('.').TypedArrayName}`]?: Getter } & { __proto__: null }} */
var cache = {
  __proto__: null
};
if (hasToStringTag && gOPD && getPrototypeOf) {
  forEach(typedArrays, function (typedArray) {
    var arr = new g[typedArray]();
    if (Symbol.toStringTag in arr) {
      var proto = getPrototypeOf(arr);
      // @ts-expect-error TS won't narrow inside a closure
      var descriptor = gOPD(proto, Symbol.toStringTag);
      if (!descriptor) {
        var superProto = getPrototypeOf(proto);
        // @ts-expect-error TS won't narrow inside a closure
        descriptor = gOPD(superProto, Symbol.toStringTag);
      }
      // @ts-expect-error TODO: fix
      cache['$' + typedArray] = callBind(descriptor.get);
    }
  });
} else {
  forEach(typedArrays, function (typedArray) {
    var arr = new g[typedArray]();
    var fn = arr.slice || arr.set;
    if (fn) {
      // @ts-expect-error TODO: fix
      cache['$' + typedArray] = callBind(fn);
    }
  });
}

/** @type {(value: object) => false | import('.').TypedArrayName} */
var tryTypedArrays = function tryAllTypedArrays(value) {
  /** @type {ReturnType<typeof tryAllTypedArrays>} */var found = false;
  forEach(
  // eslint-disable-next-line no-extra-parens
  /** @type {Record<`\$${TypedArrayName}`, Getter>} */ /** @type {any} */
  cache, /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
  function (getter, typedArray) {
    if (!found) {
      try {
        // @ts-expect-error TODO: fix
        if ('$' + getter(value) === typedArray) {
          found = $slice(typedArray, 1);
        }
      } catch (e) {/**/}
    }
  });
  return found;
};

/** @type {(value: object) => false | import('.').TypedArrayName} */
var trySlices = function tryAllSlices(value) {
  /** @type {ReturnType<typeof tryAllSlices>} */var found = false;
  forEach(
  // eslint-disable-next-line no-extra-parens
  /** @type {Record<`\$${TypedArrayName}`, Getter>} */ /** @type {any} */
  cache, /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */function (getter, name) {
    if (!found) {
      try {
        // @ts-expect-error TODO: fix
        getter(value);
        found = $slice(name, 1);
      } catch (e) {/**/}
    }
  });
  return found;
};

/** @type {import('.')} */
module.exports = function whichTypedArray(value) {
  if (!value || typeof value !== 'object') {
    return false;
  }
  if (!hasToStringTag) {
    /** @type {string} */
    var tag = $slice($toString(value), 8, -1);
    if ($indexOf(typedArrays, tag) > -1) {
      return tag;
    }
    if (tag !== 'Object') {
      return false;
    }
    // node < 0.6 hits here on real Typed Arrays
    return trySlices(value);
  }
  if (!gOPD) {
    return null;
  } // unknown engine
  return tryTypedArrays(value);
};

/***/ }),

/***/ "./node_modules/yoastseo/build/app.js":
/*!********************************************!*\
  !*** ./node_modules/yoastseo/build/app.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _missingArgument = _interopRequireDefault(__webpack_require__(/*! ./errors/missingArgument */ "./node_modules/yoastseo/build/errors/missingArgument.js"));
var _helpers = __webpack_require__(/*! ./helpers */ "./node_modules/yoastseo/build/helpers/index.js");
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ./languageProcessing/helpers/html/htmlParser.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
var _pluggable = _interopRequireDefault(__webpack_require__(/*! ./pluggable.js */ "./node_modules/yoastseo/build/pluggable.js"));
var _contentAssessor = _interopRequireDefault(__webpack_require__(/*! ./scoring/contentAssessor.js */ "./node_modules/yoastseo/build/scoring/contentAssessor.js"));
var _contentAssessor2 = _interopRequireDefault(__webpack_require__(/*! ./scoring/cornerstone/contentAssessor.js */ "./node_modules/yoastseo/build/scoring/cornerstone/contentAssessor.js"));
var _seoAssessor = _interopRequireDefault(__webpack_require__(/*! ./scoring/cornerstone/seoAssessor.js */ "./node_modules/yoastseo/build/scoring/cornerstone/seoAssessor.js"));
var _AssessorPresenter = _interopRequireDefault(__webpack_require__(/*! ./scoring/renderers/AssessorPresenter.js */ "./node_modules/yoastseo/build/scoring/renderers/AssessorPresenter.js"));
var _seoAssessor2 = _interopRequireDefault(__webpack_require__(/*! ./scoring/seoAssessor.js */ "./node_modules/yoastseo/build/scoring/seoAssessor.js"));
var _Paper = _interopRequireDefault(__webpack_require__(/*! ./values/Paper.js */ "./node_modules/yoastseo/build/values/Paper.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var inputDebounceDelay = 800;

/**
 * Default config for YoastSEO.js
 *
 * @type {Object}
 */
var defaults = {
  callbacks: {
    bindElementEvents: _lodash.noop,
    updateSnippetValues: _lodash.noop,
    saveScores: _lodash.noop,
    saveContentScore: _lodash.noop,
    updatedContentResults: _lodash.noop,
    updatedKeywordsResults: _lodash.noop
  },
  sampleText: {
    baseUrl: "example.org/",
    snippetCite: "example-post/",
    title: "",
    keyword: "Choose a focus keyword",
    meta: "",
    text: "Start writing your text!"
  },
  queue: ["wordCount", "keywordDensity", "subHeadings", "stopwords", "fleschReading", "linkCount", "imageCount", "slugKeyword", "urlLength", "metaDescription", "pageTitleKeyword", "pageTitleWidth", "firstParagraph", "'keywordDoubles"],
  typeDelay: 3000,
  typeDelayStep: 1500,
  maxTypeDelay: 5000,
  dynamicDelay: true,
  locale: "en_US",
  translations: {
    domain: "wordpress-seo",
    // eslint-disable-next-line camelcase
    locale_data: {
      "wordpress-seo": {
        "": {}
      }
    }
  },
  replaceTarget: [],
  resetTarget: [],
  elementTarget: [],
  marker: _lodash.noop,
  keywordAnalysisActive: true,
  contentAnalysisActive: true,
  debounceRefresh: true
};

/**
 * Check arguments passed to the App to check if all necessary arguments are set.
 *
 * @private
 * @param {Object}      args            The arguments object passed to the App.
 * @returns {void}
 */
function verifyArguments(args) {
  if (!(0, _lodash.isObject)(args.callbacks.getData)) {
    throw new _missingArgument.default("The app requires an object with a getdata callback.");
  }
  if (!(0, _lodash.isObject)(args.targets)) {
    throw new _missingArgument.default("`targets` is a required App argument, `targets` is not an object.");
  }
}

/**
 * This should return an object with the given properties
 *
 * @callback YoastSEO.App~getData
 * @returns {Object} data
 * @returns {String} data.keyword The keyword that should be used
 * @returns {String} data.meta
 * @returns {String} data.text The text to analyze
 * @returns {String} data.metaTitle The text in the HTML title tag
 * @returns {String} data.title The title to analyze
 * @returns {String} data.url The URL for the given page
 * @returns {String} data.excerpt Excerpt for the pages
 */

/**
 * @callback YoastSEO.App~getAnalyzerInput
 *
 * @returns {Array} An array containing the analyzer queue
 */

/**
 * @callback YoastSEO.App~bindElementEvents
 *
 * @param {YoastSEO.App} app A reference to the YoastSEO.App from where this is called.
 */

/**
 * @callback YoastSEO.App~updateSnippetValues
 *
 * @param {Object} ev The event emitted from the DOM
 */

/**
 * @callback YoastSEO.App~saveScores
 *
 * @param {int} score The overall keyword score as determined by the assessor.
 * @param {AssessorPresenter} assessorPresenter The assessor presenter that will be used to render the keyword score.
 */

/**
 * @callback YoastSEO.App~saveContentScore
 *
 * @param {int} score The overall content score as determined by the assessor.
 * @param {AssessorPresenter} assessorPresenter The assessor presenter that will be used to render the content score.
 */

/**
 * @callback YoastSEO.App~updatedContentResults
 *
 * @param {Object[]} result The updated content analysis results.
 * @param {number} result[].score The SEO score.
 * @param {string} result[].rating String representation of the SEO score.
 * @param {string} result[].text Textual explanation of the score.
 * @param {number} overallContentScore The overall content SEO score.
 */

/**
 * @callback YoastSEO.App~updatedKeywordsResults
 *
 * @param {Object[]} result The updated keywords analysis results.
 * @param {number} result[].score The SEO score.
 * @param {string} result[].rating String representation of the SEO score.
 * @param {string} result[].text Textual explanation of the score.
 * @param {number} overallContentScore The overall keywords SEO score.
 */

/**
 * Loader for the analyzer, loads the eventbinder and the elementdefiner
 *
 * @param {Object} args The arguments passed to the loader.
 * @param {Object} args.translations Jed compatible translations.
 * @param {Object} args.targets Targets to retrieve or set on.
 * @param {String} args.targets.snippet ID for the snippet preview element.
 * @param {String} args.targets.output ID for the element to put the output of the analyzer in.
 * @param {int} args.typeDelay Number of milliseconds to wait between typing to refresh the analyzer output.
 * @param {boolean} args.dynamicDelay   Whether to enable dynamic delay, will ignore type delay if the analyzer takes a long time.
 *                                      Applicable on slow devices.
 * @param {int} args.maxTypeDelay The maximum amount of type delay even if dynamic delay is on.
 * @param {int} args.typeDelayStep The amount with which to increase the typeDelay on each step when dynamic delay is enabled.
 * @param {Object} args.callbacks The callbacks that the app requires.
 * @param {Object} args.assessor The Assessor to use instead of the default assessor.
 * @param {YoastSEO.App~getData} args.callbacks.getData Called to retrieve input data
 * @param {YoastSEO.App~getAnalyzerInput} args.callbacks.getAnalyzerInput Called to retrieve input for the analyzer.
 * @param {YoastSEO.App~bindElementEvents} args.callbacks.bindElementEvents Called to bind events to the DOM elements.
 * @param {YoastSEO.App~updateSnippetValues} args.callbacks.updateSnippetValues Called when the snippet values need to be updated.
 * @param {YoastSEO.App~saveScores} args.callbacks.saveScores Called when the score has been determined by the analyzer.
 * @param {YoastSEO.App~saveContentScore} args.callback.saveContentScore Called when the content score has been
 *                                                                       determined by the assessor.
 * @param {YoastSEO.App~updatedContentResults} args.callbacks.updatedContentResults Called when the score has been determined
 *                                                                                  by the analyzer.
 * @param {YoastSEO.App~updatedKeywordsResults} args.callback.updatedKeywordsResults Called when the content score has been
 *                                                                                   determined by the assessor.
 * @param {Function} args.callbacks.saveSnippetData Function called when the snippet data is changed.
 * @param {Function} args.marker The marker to use to apply the list of marks retrieved from an assessment.
 *
 * @param {boolean} [args.debouncedRefresh] Whether or not to debounce the
 *                                          refresh function. Defaults to true.
 * @param {Researcher} args.researcher The Researcher object to be used.
 *
 * @constructor
 */
var App = function (args) {
  if (!(0, _lodash.isObject)(args)) {
    args = {};
  }
  (0, _lodash.defaultsDeep)(args, defaults);
  verifyArguments(args);
  this.config = args;
  if (args.debouncedRefresh === true) {
    this.refresh = (0, _lodash.debounce)(this.refresh.bind(this), inputDebounceDelay);
  }
  this._pureRefresh = (0, _lodash.throttle)(this._pureRefresh.bind(this), this.config.typeDelay);
  this.callbacks = this.config.callbacks;
  (0, _i18n.setLocaleData)(this.config.translations.locale_data["wordpress-seo"], "wordpress-seo");
  this.initializeAssessors(args);
  this.pluggable = new _pluggable.default(this);
  this.getData();
  this.defaultOutputElement = this.getDefaultOutputElement(args);
  if (this.defaultOutputElement !== "") {
    this.showLoadingDialog();
  }
  this._assessorOptions = {
    useCornerStone: false
  };
  this.initAssessorPresenters();
};

/**
 * Returns the default output element based on which analyses are active.
 *
 * @param {Object} args The arguments passed to the App.
 * @returns {string} The ID of the target that is active.
 */
App.prototype.getDefaultOutputElement = function (args) {
  if (args.keywordAnalysisActive) {
    return args.targets.output;
  }
  if (args.contentAnalysisActive) {
    return args.targets.contentOutput;
  }
  return "";
};

/**
 * Sets the assessors based on the assessor options and refreshes them.
 *
 * @param {Object} assessorOptions The specific options.
 * @returns {void}
 */
App.prototype.changeAssessorOptions = function (assessorOptions) {
  this._assessorOptions = (0, _lodash.merge)(this._assessorOptions, assessorOptions);

  // Set the assessors based on the new assessor options.
  this.seoAssessor = this.getSeoAssessor();
  this.contentAssessor = this.getContentAssessor();

  // Refresh everything so the user sees the changes.
  this.initAssessorPresenters();
  this.refresh();
};

/**
 * Returns an instance of the seo assessor to use.
 *
 * @returns {Assessor} The assessor instance.
 */
App.prototype.getSeoAssessor = function () {
  const {
    useCornerStone
  } = this._assessorOptions;
  return useCornerStone ? this.cornerStoneSeoAssessor : this.defaultSeoAssessor;
};

/**
 * Returns an instance of the content assessor to use.
 *
 * @returns {Assessor} The assessor instance.
 */
App.prototype.getContentAssessor = function () {
  const {
    useCornerStone
  } = this._assessorOptions;
  return useCornerStone ? this.cornerStoneContentAssessor : this.defaultContentAssessor;
};

/**
 * Initializes assessors based on if the respective analysis is active.
 *
 * @param {Object} args The arguments passed to the App.
 * @returns {void}
 */
App.prototype.initializeAssessors = function (args) {
  this.initializeSEOAssessor(args);
  this.initializeContentAssessor(args);
};

/**
 * Initializes the SEO assessor.
 *
 * @param {Object} args The arguments passed to the App.
 * @returns {void}
 */
App.prototype.initializeSEOAssessor = function (args) {
  if (!args.keywordAnalysisActive) {
    return;
  }
  this.defaultSeoAssessor = new _seoAssessor2.default({
    marker: this.config.marker
  });
  this.cornerStoneSeoAssessor = new _seoAssessor.default({
    marker: this.config.marker
  });

  // Set the assessor
  if ((0, _lodash.isUndefined)(args.seoAssessor)) {
    this.seoAssessor = this.defaultSeoAssessor;
  } else {
    this.seoAssessor = args.seoAssessor;
  }
};

/**
 * Initializes the content assessor.
 *
 * @param {Object} args The arguments passed to the App.
 * @returns {void}
 */
App.prototype.initializeContentAssessor = function (args) {
  if (!args.contentAnalysisActive) {
    return;
  }
  this.defaultContentAssessor = new _contentAssessor.default({
    marker: this.config.marker,
    locale: this.config.locale
  });
  this.cornerStoneContentAssessor = new _contentAssessor2.default({
    marker: this.config.marker,
    locale: this.config.locale
  });

  // Set the content assessor
  if ((0, _lodash.isUndefined)(args._contentAssessor)) {
    this.contentAssessor = this.defaultContentAssessor;
  } else {
    this.contentAssessor = args._contentAssessor;
  }
};

/**
 * Extend the config with defaults.
 *
 * @param   {Object}    args    The arguments to be extended.
 * @returns {Object}    args    The extended arguments.
 */
App.prototype.extendConfig = function (args) {
  args.sampleText = this.extendSampleText(args.sampleText);
  args.locale = args.locale || "en_US";
  return args;
};

/**
 * Extend sample text config with defaults.
 *
 * @param   {Object}    sampleText  The sample text to be extended.
 * @returns {Object}    sampleText  The extended sample text.
 */
App.prototype.extendSampleText = function (sampleText) {
  var defaultSampleText = defaults.sampleText;
  if ((0, _lodash.isUndefined)(sampleText)) {
    return defaultSampleText;
  }
  for (var key in sampleText) {
    if ((0, _lodash.isUndefined)(sampleText[key])) {
      sampleText[key] = defaultSampleText[key];
    }
  }
  return sampleText;
};

/**
 * Registers a custom data callback.
 *
 * @param {Function} callback The callback to register.
 *
 * @returns {void}
 */
App.prototype.registerCustomDataCallback = function (callback) {
  if (!this.callbacks.custom) {
    this.callbacks.custom = [];
  }
  if ((0, _lodash.isFunction)(callback)) {
    this.callbacks.custom.push(callback);
  }
};

/**
 * Retrieves data from the callbacks.getData and applies modification to store these in this.rawData.
 *
 * @returns {void}
 */
App.prototype.getData = function () {
  this.rawData = this.callbacks.getData();

  // Add the custom data to the raw data.
  if ((0, _lodash.isArray)(this.callbacks.custom)) {
    this.callbacks.custom.forEach(customCallback => {
      const customData = customCallback();
      this.rawData = (0, _lodash.merge)(this.rawData, customData);
    });
  }
  if (this.pluggable.loaded) {
    this.rawData.metaTitle = this.pluggable._applyModifications("data_page_title", this.rawData.metaTitle);
    this.rawData.meta = this.pluggable._applyModifications("data_meta_desc", this.rawData.meta);
  }
  this.rawData.titleWidth = (0, _helpers.measureTextWidth)(this.rawData.metaTitle);
  this.rawData.locale = this.config.locale;
};

/**
 * Refreshes the analyzer and output of the analyzer, is debounced for a better experience.
 *
 * @returns {void}
 */
App.prototype.refresh = function () {
  // Until all plugins are loaded, do not trigger a refresh.
  if (!this.pluggable.loaded) {
    return;
  }
  this._pureRefresh();
};

/**
 * Refreshes the analyzer and output of the analyzer, is throttled to prevent performance issues.
 *
 * @returns {void}
 *
 * @private
 */
App.prototype._pureRefresh = function () {
  this.getData();
  this.runAnalyzer();
};

/**
 * Initializes the assessor presenters for content and SEO.
 *
 * @returns {void}
 */
App.prototype.initAssessorPresenters = function () {
  // Pass the assessor result through to the formatter
  if (!(0, _lodash.isUndefined)(this.config.targets.output)) {
    this.seoAssessorPresenter = new _AssessorPresenter.default({
      targets: {
        output: this.config.targets.output
      },
      assessor: this.seoAssessor
    });
  }
  if (!(0, _lodash.isUndefined)(this.config.targets.contentOutput)) {
    // Pass the assessor result through to the formatter
    this.contentAssessorPresenter = new _AssessorPresenter.default({
      targets: {
        output: this.config.targets.contentOutput
      },
      assessor: this.contentAssessor
    });
  }
};

/**
 * Sets the startTime timestamp.
 *
 * @returns {void}
 */
App.prototype.startTime = function () {
  this.startTimestamp = new Date().getTime();
};

/**
 * Sets the endTime timestamp and compares with startTime to determine typeDelayincrease.
 *
 * @returns {void}
 */
App.prototype.endTime = function () {
  this.endTimestamp = new Date().getTime();
  if (this.endTimestamp - this.startTimestamp > this.config.typeDelay) {
    if (this.config.typeDelay < this.config.maxTypeDelay - this.config.typeDelayStep) {
      this.config.typeDelay += this.config.typeDelayStep;
    }
  }
};

/**
 * Inits a new pageAnalyzer with the inputs from the getInput function and calls the scoreFormatter
 * to format outputs.
 *
 * @returns {void}
 */
App.prototype.runAnalyzer = function () {
  if (this.pluggable.loaded === false) {
    return;
  }
  if (this.config.dynamicDelay) {
    this.startTime();
  }
  this.analyzerData = this.modifyData(this.rawData);
  let text = this.analyzerData.text;

  // Insert HTML stripping code
  text = (0, _htmlParser.default)(text);
  const titleWidth = this.analyzerData.titleWidth;

  // Create a paper object for the Researcher
  this.paper = new _Paper.default(text, {
    keyword: this.analyzerData.keyword,
    synonyms: this.analyzerData.synonyms,
    description: this.analyzerData.meta,
    slug: this.analyzerData.slug,
    title: this.analyzerData.metaTitle,
    titleWidth: titleWidth,
    locale: this.config.locale,
    permalink: this.analyzerData.permalink
  });
  this.config.researcher.setPaper(this.paper);
  this.runKeywordAnalysis();
  this.runContentAnalysis();
  this._renderAnalysisResults();
  if (this.config.dynamicDelay) {
    this.endTime();
  }
};

/**
 * Runs the keyword analysis and calls the appropriate callbacks.
 *
 * @returns {void}
 */
App.prototype.runKeywordAnalysis = function () {
  if (this.config.keywordAnalysisActive) {
    this.seoAssessor.assess(this.paper);
    const overallSeoScore = this.seoAssessor.calculateOverallScore();
    if (!(0, _lodash.isUndefined)(this.callbacks.updatedKeywordsResults)) {
      this.callbacks.updatedKeywordsResults(this.seoAssessor.results, overallSeoScore);
    }
    if (!(0, _lodash.isUndefined)(this.callbacks.saveScores)) {
      this.callbacks.saveScores(overallSeoScore, this.seoAssessorPresenter);
    }
  }
};

/**
 * Runs the content analysis and calls the appropriate callbacks.
 *
 * @returns {void}
 */
App.prototype.runContentAnalysis = function () {
  if (this.config.contentAnalysisActive) {
    this.contentAssessor.assess(this.paper);
    const overallContentScore = this.contentAssessor.calculateOverallScore();
    if (!(0, _lodash.isUndefined)(this.callbacks.updatedContentResults)) {
      this.callbacks.updatedContentResults(this.contentAssessor.results, overallContentScore);
    }
    if (!(0, _lodash.isUndefined)(this.callbacks.saveContentScore)) {
      this.callbacks.saveContentScore(overallContentScore, this.contentAssessorPresenter);
    }
  }
};

/**
 * Modifies the data with plugins before it is sent to the analyzer.
 *
 * @param   {Object}  data      The data to be modified.
 * @returns {Object}            The data with the applied modifications.
 */
App.prototype.modifyData = function (data) {
  // Copy rawdata to lose object reference.
  data = JSON.parse(JSON.stringify(data));
  data.text = this.pluggable._applyModifications("content", data.text);
  data.metaTitle = this.pluggable._applyModifications("title", data.metaTitle);
  return data;
};

/**
 * Function to fire the analyzer when all plugins are loaded, removes the loading dialog.
 *
 * @returns {void}
 */
App.prototype.pluginsLoaded = function () {
  this.removeLoadingDialog();
  this.refresh();
};

/**
 * Shows the loading dialog which shows the loading of the plugins.
 *
 * @returns {void}
 */
App.prototype.showLoadingDialog = function () {
  var outputElement = document.getElementById(this.defaultOutputElement);
  if (this.defaultOutputElement !== "" && !(0, _lodash.isEmpty)(outputElement)) {
    var dialogDiv = document.createElement("div");
    dialogDiv.className = "YoastSEO_msg";
    dialogDiv.id = "YoastSEO-plugin-loading";
    document.getElementById(this.defaultOutputElement).appendChild(dialogDiv);
  }
};

/**
 * Updates the loading plugins. Uses the plugins as arguments to show which plugins are loading.
 *
 * @param   {Object}  plugins   The plugins to be parsed into the dialog.
 * @returns {void}
 */
App.prototype.updateLoadingDialog = function (plugins) {
  var outputElement = document.getElementById(this.defaultOutputElement);
  if (this.defaultOutputElement === "" || (0, _lodash.isEmpty)(outputElement)) {
    return;
  }
  var dialog = document.getElementById("YoastSEO-plugin-loading");
  dialog.textContent = "";
  (0, _lodash.forEach)(plugins, function (plugin, pluginName) {
    dialog.innerHTML += "<span class=left>" + pluginName + "</span><span class=right " + plugin.status + ">" + plugin.status + "</span><br />";
  });
  dialog.innerHTML += "<span class=bufferbar></span>";
};

/**
 * Removes the pluging load dialog.
 *
 * @returns {void}
 */
App.prototype.removeLoadingDialog = function () {
  var outputElement = document.getElementById(this.defaultOutputElement);
  var loadingDialog = document.getElementById("YoastSEO-plugin-loading");
  if (this.defaultOutputElement !== "" && !(0, _lodash.isEmpty)(outputElement) && !(0, _lodash.isEmpty)(loadingDialog)) {
    document.getElementById(this.defaultOutputElement).removeChild(document.getElementById("YoastSEO-plugin-loading"));
  }
};

// ***** PLUGGABLE PUBLIC DSL ***** //

/**
 * Delegates to `YoastSEO.app.pluggable.registerPlugin`
 *
 * @param {string}  pluginName      The name of the plugin to be registered.
 * @param {object}  options         The options object.
 * @param {string}  options.status  The status of the plugin being registered. Can either be "loading" or "ready".
 * @returns {boolean}               Whether or not it was successfully registered.
 */
App.prototype.registerPlugin = function (pluginName, options) {
  return this.pluggable._registerPlugin(pluginName, options);
};

/**
 * Delegates to `YoastSEO.app.pluggable.ready`
 *
 * @param {string}  pluginName  The name of the plugin to check.
 * @returns {boolean}           Whether or not the plugin is ready.
 */
App.prototype.pluginReady = function (pluginName) {
  return this.pluggable._ready(pluginName);
};

/**
 * Delegates to `YoastSEO.app.pluggable.reloaded`
 *
 * @param {string} pluginName   The name of the plugin to reload
 * @returns {boolean}           Whether or not the plugin was reloaded.
 */
App.prototype.pluginReloaded = function (pluginName) {
  return this.pluggable._reloaded(pluginName);
};

/**
 * Delegates to `YoastSEO.app.pluggable.registerModification`.
 *
 * @param {string}   modification   The name of the filter
 * @param {function} callable       The callable function
 * @param {string}   pluginName     The plugin that is registering the modification.
 * @param {number}   [priority]     Used to specify the order in which the callables associated with a particular filter are called.
 *                                  Lower numbers correspond with earlier execution.
 *
 * @returns {boolean} Whether or not the modification was successfully registered.
 */
App.prototype.registerModification = function (modification, callable, pluginName, priority) {
  return this.pluggable._registerModification(modification, callable, pluginName, priority);
};

/**
 * Registers a custom assessment for use in the analyzer, this will result in a new line in the analyzer results.
 * The function needs to use the assessmentresult to return an result  based on the contents of the page/posts.
 *
 * Score 0 results in a grey circle if it is not explicitly set by using setscore
 * Scores 0, 1, 2, 3 and 4 result in a red circle
 * Scores 6 and 7 result in a yellow circle
 * Scores 8, 9 and 10 result in a green circle
 *
 * @param {string} name Name of the test.
 * @param {function} assessment The assessment to run
 * @param {string}   pluginName The plugin that is registering the test.
 * @returns {boolean} Whether or not the test was successfully registered.
 */
App.prototype.registerAssessment = function (name, assessment, pluginName) {
  if (!(0, _lodash.isUndefined)(this.seoAssessor)) {
    return this.pluggable._registerAssessment(this.defaultSeoAssessor, name, assessment, pluginName) && this.pluggable._registerAssessment(this.cornerStoneSeoAssessor, name, assessment, pluginName);
  }
};

/**
 * Disables markers visually in the UI.
 *
 * @returns {void}
 */
App.prototype.disableMarkers = function () {
  if (!(0, _lodash.isUndefined)(this.seoAssessorPresenter)) {
    this.seoAssessorPresenter.disableMarker();
  }
  if (!(0, _lodash.isUndefined)(this.contentAssessorPresenter)) {
    this.contentAssessorPresenter.disableMarker();
  }
};

/**
 * Renders the content and keyword analysis results.
 *
 * @returns {void}
 */
App.prototype._renderAnalysisResults = function () {
  if (this.config.contentAnalysisActive && !(0, _lodash.isUndefined)(this.contentAssessorPresenter)) {
    this.contentAssessorPresenter.renderIndividualRatings();
  }
  if (this.config.keywordAnalysisActive && !(0, _lodash.isUndefined)(this.seoAssessorPresenter)) {
    this.seoAssessorPresenter.setKeyword(this.paper.getKeyword());
    this.seoAssessorPresenter.render();
  }
};

// Deprecated functions
/**
 * The analyzeTimer calls the checkInputs function with a delay, so the function won't be executed
 * at every keystroke checks the reference object, so this function can be called from anywhere,
 * without problems with different scopes.
 *
 * @deprecated: 1.3 - Use this.refresh() instead.
 *
 * @returns {void}
 */
App.prototype.analyzeTimer = function () {
  this.refresh();
};

/**
 * Registers a custom test for use in the analyzer, this will result in a new line in the analyzer results. The function
 * has to return a result based on the contents of the page/posts.
 *
 * The scoring object is a special object with definitions about how to translate a result from your analysis function
 * to a SEO score.
 *
 * Negative scores result in a red circle
 * Scores 1, 2, 3, 4 and 5 result in a orange circle
 * Scores 6 and 7 result in a yellow circle
 * Scores 8, 9 and 10 result in a red circle
 *
 * @returns {void}
 *
 * @deprecated since version 1.2
 */
App.prototype.registerTest = function () {
  console.error("This function is deprecated, please use registerAssessment");
};

/**
 * Switches between the cornerstone and default assessors.
 *
 * @deprecated 1.35.0 - Use changeAssessorOption instead.
 *
 * @param {boolean} useCornerStone True when cornerstone should be used.
 *
 * @returns {void}
 */
App.prototype.switchAssessors = function (useCornerStone) {
  // eslint-disable-next-line no-console
  console.warn("Switch assessor is deprecated since YoastSEO.js version 1.35.0");
  this.changeAssessorOptions({
    useCornerStone
  });
};
var _default = exports["default"] = App;

/***/ }),

/***/ "./node_modules/yoastseo/build/bundledPlugins/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/yoastseo/build/bundledPlugins/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "usedKeywords", ({
  enumerable: true,
  get: function () {
    return _previouslyUsedKeywords.default;
  }
}));
var _previouslyUsedKeywords = _interopRequireDefault(__webpack_require__(/*! ./previouslyUsedKeywords */ "./node_modules/yoastseo/build/bundledPlugins/previouslyUsedKeywords.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/bundledPlugins/previouslyUsedKeywords.js":
/*!******************************************************************************!*\
  !*** ./node_modules/yoastseo/build/bundledPlugins/previouslyUsedKeywords.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _missingArgument = _interopRequireDefault(__webpack_require__(/*! ../errors/missingArgument */ "./node_modules/yoastseo/build/errors/missingArgument.js"));
var _shortlinker = __webpack_require__(/*! ../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../values/AssessmentResult.js */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * @param {object} app The app
 * @param {object} args An arguments object with usedKeywords, searchUrl, postUrl,
 * @param {object} args.usedKeywords An object with keywords and ids where they are used.
 * @param {object} args.usedKeywordsPostTypes An object with the post types of the post ids from usedKeywords.
 * @param {string} args.searchUrl The url used to link to a search page when multiple usages of the keyword are found.
 * @param {string} args.postUrl The url used to link to a post when 1 usage of the keyword is found.
 * @constructor
 */
var PreviouslyUsedKeyword = function (app, args) {
  if ((0, _lodash.isUndefined)(app)) {
    throw new _missingArgument.default("The previously keyword plugin requires the YoastSEO app");
  }
  if ((0, _lodash.isUndefined)(args)) {
    args = {
      usedKeywords: {},
      usedKeywordsPostTypes: {},
      searchUrl: "",
      postUrl: ""
    };
  }
  this.app = app;
  this.usedKeywords = args.usedKeywords;
  this.usedKeywordsPostTypes = args.usedKeywordsPostTypes;
  this.searchUrl = args.searchUrl;
  this.postUrl = args.postUrl;
  this.urlTitle = (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/33x");
  this.urlCallToAction = (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/33y");
};

/**
 * Registers the assessment with the assessor.
 *
 * @returns {void}
 */
PreviouslyUsedKeyword.prototype.registerPlugin = function () {
  this.app.registerAssessment("usedKeywords", {
    getResult: this.assess.bind(this),
    /**
     * Checks if the paper has a keyphrase, which is a prerequisite for the assessment to run.
     *
     * @param {Paper} paper The paper.
     *
     * @returns {boolean} Whether the paper has a keyphrase.
     */
    isApplicable: function (paper) {
      return paper.hasKeyword();
    }
  }, "previouslyUsedKeywords");
};

/**
 * Updates the usedKeywords.
 *
 * @param {object} usedKeywords An object with keywords and ids where they are used.
 * @param {object} usedKeywordsPostTypes An object with keywords and in which post types they are used.
 * The post types correspond with the ids in the usedKeywords parameter.
 * @returns {void}
 */
PreviouslyUsedKeyword.prototype.updateKeywordUsage = function (usedKeywords, usedKeywordsPostTypes) {
  this.usedKeywords = usedKeywords;
  this.usedKeywordsPostTypes = usedKeywordsPostTypes;
};

/**
 * Scores the previously used keyword assessment based on the count.
 *
 * @param {object} previouslyUsedKeywords The result of the previously used keywords research
 * @param {Paper} paper The paper object to research.
 * @returns {object} the scoreobject with text and score.
 */
PreviouslyUsedKeyword.prototype.scoreAssessment = function (previouslyUsedKeywords, paper) {
  const count = previouslyUsedKeywords.count;
  const id = previouslyUsedKeywords.id;
  const postTypeToDisplay = previouslyUsedKeywords.postTypeToDisplay;
  let url;
  if (count === 0) {
    return {
      text: (0, _i18n.sprintf)(
      /* translators:
      %1$s expands to a link to an article on yoast.com,
      %2$s expands to an anchor end tag. */
      (0, _i18n.__)("%1$sPreviously used keyphrase%2$s: You've not used this keyphrase before, very good.", "wordpress-seo"), this.urlTitle, "</a>"),
      score: 9
    };
  }
  if (count === 1) {
    url = `<a href='${this.postUrl.replace("{id}", id)}' target='_blank'>`;
    return {
      /* translators: %1$s expands to an admin link where the keyphrase is already used,
       %2$s expands to the anchor end tag, %3$s and %4$s expand to links on yoast.com. */
      text: (0, _i18n.sprintf)((0, _i18n.__)("%3$sPreviously used keyphrase%2$s: You've used this keyphrase %1$sonce before%2$s. %4$sDo not use your keyphrase more than once%2$s.", "wordpress-seo"), url, "</a>", this.urlTitle, this.urlCallToAction),
      score: 6
    };
  }
  if (count > 1) {
    if (postTypeToDisplay) {
      url = `<a href='${this.searchUrl.replace("{keyword}", encodeURIComponent(paper.getKeyword()))}&post_type=${postTypeToDisplay}' target='_blank'>`;
    } else {
      url = `<a href='${this.searchUrl.replace("{keyword}", encodeURIComponent(paper.getKeyword()))}' target='_blank'>`;
    }
    return {
      /* translators: %1$s expands to a link to the admin search page for the keyphrase,
       %2$s expands to the anchor end tag, %3$s and %4$s expand to links to yoast.com */
      text: (0, _i18n.sprintf)((0, _i18n.__)("%3$sPreviously used keyphrase%2$s: You've used this keyphrase %1$smultiple times before%2$s. %4$sDo not use your keyphrase more than once%2$s.", "wordpress-seo"), url, "</a>", this.urlTitle, this.urlCallToAction),
      score: 1
    };
  }
};

/**
 * Researches the previously used keywords, based on the used keywords and the keyword in the paper.
 *
 * @param {Paper} paper The paper object to research.
 * @returns {{id: number, count: number}} The object with the count and the id of the previously used keyword
 */
PreviouslyUsedKeyword.prototype.researchPreviouslyUsedKeywords = function (paper) {
  const keyword = paper.getKeyword();
  let count = 0;
  let postTypeToDisplay = "";
  let id = 0;
  if (!(0, _lodash.isUndefined)(this.usedKeywords[keyword]) && this.usedKeywords[keyword].length > 0) {
    count = this.usedKeywords[keyword].length;
    if (this.usedKeywordsPostTypes) {
      postTypeToDisplay = this.usedKeywordsPostTypes[keyword][0];
    }
    id = this.usedKeywords[keyword][0];
  }
  return {
    id: id,
    count: count,
    postTypeToDisplay: postTypeToDisplay
  };
};

/**
 * The assessment for the previously used keywords.
 *
 * @param {Paper} paper The Paper object to assess.
 * @returns {AssessmentResult} The assessment result of the assessment
 */
PreviouslyUsedKeyword.prototype.assess = function (paper) {
  var previouslyUsedKeywords = this.researchPreviouslyUsedKeywords(paper);
  var previouslyUsedKeywordsResult = this.scoreAssessment(previouslyUsedKeywords, paper);
  var assessmentResult = new _AssessmentResult.default();
  assessmentResult.setScore(previouslyUsedKeywordsResult.score);
  assessmentResult.setText(previouslyUsedKeywordsResult.text);
  return assessmentResult;
};
var _default = exports["default"] = PreviouslyUsedKeyword;

/***/ }),

/***/ "./node_modules/yoastseo/build/config/diacritics.js":
/*!**********************************************************!*\
  !*** ./node_modules/yoastseo/build/config/diacritics.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/** @module config/diacritics */

/**
 * Returns the diacritics map
 *
 * @returns {array} diacritics map
 */
function _default() {
  return [{
    base: "a",
    letters: /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g
  }, {
    base: "aa",
    letters: /[\uA733]/g
  }, {
    base: "ae",
    letters: /[\u00E6\u01FD\u01E3]/g
  }, {
    base: "ao",
    letters: /[\uA735]/g
  }, {
    base: "au",
    letters: /[\uA737]/g
  }, {
    base: "av",
    letters: /[\uA739\uA73B]/g
  }, {
    base: "ay",
    letters: /[\uA73D]/g
  }, {
    base: "b",
    letters: /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g
  }, {
    base: "c",
    letters: /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g
  }, {
    base: "d",
    letters: /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g
  }, {
    base: "dz",
    letters: /[\u01F3\u01C6]/g
  }, {
    base: "e",
    letters: /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g
  }, {
    base: "f",
    letters: /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g
  }, {
    base: "g",
    letters: /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g
  }, {
    base: "h",
    letters: /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g
  }, {
    base: "hv",
    letters: /[\u0195]/g
  }, {
    base: "i",
    letters: /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g
  }, {
    base: "j",
    letters: /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g
  }, {
    base: "k",
    letters: /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g
  }, {
    base: "l",
    letters: /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g
  }, {
    base: "lj",
    letters: /[\u01C9]/g
  }, {
    base: "m",
    letters: /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g
  }, {
    base: "n",
    letters: /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g
  }, {
    base: "nj",
    letters: /[\u01CC]/g
  }, {
    base: "o",
    letters: /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g
  }, {
    base: "oi",
    letters: /[\u01A3]/g
  }, {
    base: "ou",
    letters: /[\u0223]/g
  }, {
    base: "oo",
    letters: /[\uA74F]/g
  }, {
    base: "p",
    letters: /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g
  }, {
    base: "q",
    letters: /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g
  }, {
    base: "r",
    letters: /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g
  }, {
    base: "s",
    letters: /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g
  }, {
    base: "t",
    letters: /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g
  }, {
    base: "tz",
    letters: /[\uA729]/g
  }, {
    base: "u",
    letters: /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g
  }, {
    base: "v",
    letters: /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g
  }, {
    base: "vy",
    letters: /[\uA761]/g
  }, {
    base: "w",
    letters: /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g
  }, {
    base: "x",
    letters: /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g
  }, {
    base: "y",
    letters: /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g
  }, {
    base: "z",
    letters: /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g
  }];
}

/***/ }),

/***/ "./node_modules/yoastseo/build/config/getTransliterations.js":
/*!*******************************************************************!*\
  !*** ./node_modules/yoastseo/build/config/getTransliterations.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
exports.transliterations = void 0;
var _getLanguage = _interopRequireDefault(__webpack_require__(/*! ../languageProcessing/helpers/language/getLanguage.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/language/getLanguage.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const transliterations = exports.transliterations = {
  // Language: Spanish.
  // Source: https://en.wikipedia.org/wiki/Spanish_orthography
  es: [{
    letter: /[\u00F1]/g,
    alternative: "n"
  }, {
    letter: /[\u00D1]/g,
    alternative: "N"
  }, {
    letter: /[\u00E1]/g,
    alternative: "a"
  }, {
    letter: /[\u00C1]/g,
    alternative: "A"
  }, {
    letter: /[\u00E9]/g,
    alternative: "e"
  }, {
    letter: /[\u00C9]/g,
    alternative: "E"
  }, {
    letter: /[\u00ED]/g,
    alternative: "i"
  }, {
    letter: /[\u00CD]/g,
    alternative: "I"
  }, {
    letter: /[\u00F3]/g,
    alternative: "o"
  }, {
    letter: /[\u00D3]/g,
    alternative: "O"
  }, {
    letter: /[\u00FA\u00FC]/g,
    alternative: "u"
  }, {
    letter: /[\u00DA\u00DC]/g,
    alternative: "U"
  }],
  // Language: Polish.
  // Source: https://en.wikipedia.org/wiki/Polish_orthography
  pl: [{
    letter: /[\u0105]/g,
    alternative: "a"
  }, {
    letter: /[\u0104]/g,
    alternative: "A"
  }, {
    letter: /[\u0107]/g,
    alternative: "c"
  }, {
    letter: /[\u0106]/g,
    alternative: "C"
  }, {
    letter: /[\u0119]/g,
    alternative: "e"
  }, {
    letter: /[\u0118]/g,
    alternative: "E"
  }, {
    letter: /[\u0142]/g,
    alternative: "l"
  }, {
    letter: /[\u0141]/g,
    alternative: "L"
  }, {
    letter: /[\u0144]/g,
    alternative: "n"
  }, {
    letter: /[\u0143]/g,
    alternative: "N"
  }, {
    letter: /[\u00F3]/g,
    alternative: "o"
  }, {
    letter: /[\u00D3]/g,
    alternative: "O"
  }, {
    letter: /[\u015B]/g,
    alternative: "s"
  }, {
    letter: /[\u015A]/g,
    alternative: "S"
  }, {
    letter: /[\u017A\u017C]/g,
    alternative: "z"
  }, {
    letter: /[\u0179\u017B]/g,
    alternative: "Z"
  }],
  // Language: German.
  // Source: https://en.wikipedia.org/wiki/German_orthography#Special_characters
  de: [{
    letter: /[\u00E4]/g,
    alternative: "ae"
  }, {
    letter: /[\u00C4]/g,
    alternative: "Ae"
  }, {
    letter: /[\u00FC]/g,
    alternative: "ue"
  }, {
    letter: /[\u00DC]/g,
    alternative: "Ue"
  }, {
    letter: /[\u00F6]/g,
    alternative: "oe"
  }, {
    letter: /[\u00D6]/g,
    alternative: "Oe"
  }, {
    letter: /[\u00DF]/g,
    alternative: "ss"
  }, {
    letter: /[\u1E9E]/g,
    alternative: "SS"
  }],
  // Language Bokmål
  // Source: http://www.dagbladet.no/2011/12/30/tema/reise/reiseeksperter/forbrukerrettigheter/19494227/
  // Language Nynorks
  // Source: http://www.dagbladet.no/2011/12/30/tema/reise/reiseeksperter/forbrukerrettigheter/19494227/
  // Bokmål and Nynorks use the same transliterations
  nbnn: [{
    letter: /[\u00E6\u04D5]/g,
    alternative: "ae"
  }, {
    letter: /[\u00C6\u04D4]/g,
    alternative: "Ae"
  }, {
    letter: /[\u00E5]/g,
    alternative: "aa"
  }, {
    letter: /[\u00C5]/g,
    alternative: "Aa"
  }, {
    letter: /[\u00F8]/g,
    alternative: "oe"
  }, {
    letter: /[\u00D8]/g,
    alternative: "Oe"
  }, {
    letter: /[\u00E9\u00E8\u00EA]/g,
    alternative: "e"
  }, {
    letter: /[\u00C9\u00C8\u00CA]/g,
    alternative: "E"
  }, {
    letter: /[\u00F3\u00F2\u00F4]/g,
    alternative: "o"
  }, {
    letter: /[\u00D3\u00D2\u00D4]/g,
    alternative: "O"
  }],
  // Language: Swedish.
  // Sources: https://sv.wikipedia.org/wiki/%C3%85#Historia
  // http://forum.wordreference.com/threads/swedish-%C3%A4-ae-%C3%B6-oe-acceptable.1451839/
  sv: [{
    letter: /[\u00E5]/g,
    alternative: "aa"
  }, {
    letter: /[\u00C5]/g,
    alternative: "Aa"
  }, {
    letter: /[\u00E4]/g,
    alternative: "ae"
  }, {
    letter: /[\u00C4]/g,
    alternative: "Ae"
  }, {
    letter: /[\u00F6]/g,
    alternative: "oe"
  }, {
    letter: /[\u00D6]/g,
    alternative: "Oe"
  }, {
    letter: /[\u00E9]/g,
    alternative: "e"
  }, {
    letter: /[\u00C9]/g,
    alternative: "E"
  }, {
    letter: /[\u00E0]/g,
    alternative: "a"
  }, {
    letter: /[\u00C0]/g,
    alternative: "A"
  }],
  // Language: Finnish.
  // Sources: https://www.cs.tut.fi/~jkorpela/lang/finnish-letters.html
  // https://en.wikipedia.org/wiki/Finnish_orthography
  fi: [{
    letter: /[\u00E5]/g,
    alternative: "aa"
  }, {
    letter: /[\u00C5]/g,
    alternative: "Aa"
  }, {
    letter: /[\u00E4]/g,
    alternative: "a"
  }, {
    letter: /[\u00C4]/g,
    alternative: "A"
  }, {
    letter: /[\u00F6]/g,
    alternative: "o"
  }, {
    letter: /[\u00D6]/g,
    alternative: "O"
  }, {
    letter: /[\u017E]/g,
    alternative: "zh"
  }, {
    letter: /[\u017D]/g,
    alternative: "Zh"
  }, {
    letter: /[\u0161]/g,
    alternative: "sh"
  }, {
    letter: /[\u0160]/g,
    alternative: "Sh"
  }],
  // Language: Danish.
  // Sources: https://sv.wikipedia.org/wiki/%C3%85#Historia
  // https://en.wikipedia.org/wiki/Danish_orthography
  da: [{
    letter: /[\u00E5]/g,
    alternative: "aa"
  }, {
    letter: /[\u00C5]/g,
    alternative: "Aa"
  }, {
    letter: /[\u00E6\u04D5]/g,
    alternative: "ae"
  }, {
    letter: /[\u00C6\u04D4]/g,
    alternative: "Ae"
  }, {
    letter: /[\u00C4]/g,
    alternative: "Ae"
  }, {
    letter: /[\u00F8]/g,
    alternative: "oe"
  }, {
    letter: /[\u00D8]/g,
    alternative: "Oe"
  }, {
    letter: /[\u00E9]/g,
    alternative: "e"
  }, {
    letter: /[\u00C9]/g,
    alternative: "E"
  }],
  // Language: Turkish.
  // Source: https://en.wikipedia.org/wiki/Turkish_alphabet
  // ‘İ’ is the capital dotted ‘i’. Its lowercase counterpart is the ‘regular’ ‘i’.
  tr: [{
    letter: /[\u00E7]/g,
    alternative: "c"
  }, {
    letter: /[\u00C7]/g,
    alternative: "C"
  }, {
    letter: /[\u011F]/g,
    alternative: "g"
  }, {
    letter: /[\u011E]/g,
    alternative: "G"
  }, {
    letter: /[\u00F6]/g,
    alternative: "o"
  }, {
    letter: /[\u00D6]/g,
    alternative: "O"
  }, {
    letter: /[\u015F]/g,
    alternative: "s"
  }, {
    letter: /[\u015E]/g,
    alternative: "S"
  }, {
    letter: /[\u00E2]/g,
    alternative: "a"
  }, {
    letter: /[\u00C2]/g,
    alternative: "A"
  }, {
    letter: /[\u0131\u00EE]/g,
    alternative: "i"
  }, {
    letter: /[\u0130\u00CE]/g,
    alternative: "I"
  }, {
    letter: /[\u00FC\u00FB]/g,
    alternative: "u"
  }, {
    letter: /[\u00DC\u00DB]/g,
    alternative: "U"
  }],
  // Language: Latvian.
  // Source: https://en.wikipedia.org/wiki/Latvian_orthography
  lv: [{
    letter: /[\u0101]/g,
    alternative: "a"
  }, {
    letter: /[\u0100]/g,
    alternative: "A"
  }, {
    letter: /[\u010D]/g,
    alternative: "c"
  }, {
    letter: /[\u010C]/g,
    alternative: "C"
  }, {
    letter: /[\u0113]/g,
    alternative: "e"
  }, {
    letter: /[\u0112]/g,
    alternative: "E"
  }, {
    letter: /[\u0123]/g,
    alternative: "g"
  }, {
    letter: /[\u0122]/g,
    alternative: "G"
  }, {
    letter: /[\u012B]/g,
    alternative: "i"
  }, {
    letter: /[\u012A]/g,
    alternative: "I"
  }, {
    letter: /[\u0137]/g,
    alternative: "k"
  }, {
    letter: /[\u0136]/g,
    alternative: "K"
  }, {
    letter: /[\u013C]/g,
    alternative: "l"
  }, {
    letter: /[\u013B]/g,
    alternative: "L"
  }, {
    letter: /[\u0146]/g,
    alternative: "n"
  }, {
    letter: /[\u0145]/g,
    alternative: "N"
  }, {
    letter: /[\u0161]/g,
    alternative: "s"
  }, {
    letter: /[\u0160]/g,
    alternative: "S"
  }, {
    letter: /[\u016B]/g,
    alternative: "u"
  }, {
    letter: /[\u016A]/g,
    alternative: "U"
  }, {
    letter: /[\u017E]/g,
    alternative: "z"
  }, {
    letter: /[\u017D]/g,
    alternative: "Z"
  }],
  // Language: Icelandic.
  // Sources: https://en.wikipedia.org/wiki/Thorn_(letter),
  // https://en.wikipedia.org/wiki/Eth,  https://en.wikipedia.org/wiki/Icelandic_orthography
  is: [{
    letter: /[\u00E1]/g,
    alternative: "a"
  }, {
    letter: /[\u00C1]/g,
    alternative: "A"
  }, {
    letter: /[\u00F0]/g,
    alternative: "d"
  }, {
    letter: /[\u00D0]/g,
    alternative: "D"
  }, {
    letter: /[\u00E9]/g,
    alternative: "e"
  }, {
    letter: /[\u00C9]/g,
    alternative: "E"
  }, {
    letter: /[\u00ED]/g,
    alternative: "i"
  }, {
    letter: /[\u00CD]/g,
    alternative: "I"
  }, {
    letter: /[\u00F3\u00F6]/g,
    alternative: "o"
  }, {
    letter: /[\u00D3\u00D6]/g,
    alternative: "O"
  }, {
    letter: /[\u00FA]/g,
    alternative: "u"
  }, {
    letter: /[\u00DA]/g,
    alternative: "U"
  }, {
    letter: /[\u00FD]/g,
    alternative: "y"
  }, {
    letter: /[\u00DD]/g,
    alternative: "Y"
  }, {
    letter: /[\u00FE]/g,
    alternative: "th"
  }, {
    letter: /[\u00DE]/g,
    alternative: "Th"
  }, {
    letter: /[\u00E6\u04D5]/g,
    alternative: "ae"
  }, {
    letter: /[\u00C6\u04D4]/g,
    alternative: "Ae"
  }],
  // Language: Faroese.
  // Source: https://www.facebook.com/groups/1557965757758234/permalink/1749847165236758/
  // (conversation in private Facebook Group ‘Faroese Language Learning Enthusiasts’)
  // Depending on the word, ð can be d, g, j, v, ng or nothing. However, ‘d’ is most frequent.
  // When writing text messages or using a foreign keyboard, í is sometimes written as ij, ý as yj, ú as uv, ó as ov, ø as oe, and á as aa or oa.
  // However, in website URLs the alternatives mentioned below are by far the most common.
  fa: [{
    letter: /[\u00E1]/g,
    alternative: "a"
  }, {
    letter: /[\u00C1]/g,
    alternative: "A"
  }, {
    letter: /[\u00F0]/g,
    alternative: "d"
  }, {
    letter: /[\u00D0]/g,
    alternative: "D"
  }, {
    letter: /[\u00ED]/g,
    alternative: "i"
  }, {
    letter: /[\u00CD]/g,
    alternative: "I"
  }, {
    letter: /[\u00FD]/g,
    alternative: "y"
  }, {
    letter: /[\u00DD]/g,
    alternative: "Y"
  }, {
    letter: /[\u00FA]/g,
    alternative: "u"
  }, {
    letter: /[\u00DA]/g,
    alternative: "U"
  }, {
    letter: /[\u00F3\u00F8]/g,
    alternative: "o"
  }, {
    letter: /[\u00D3\u00D8]/g,
    alternative: "O"
  }, {
    letter: /[\u00E6\u04D5]/g,
    alternative: "ae"
  }, {
    letter: /[\u00C6\u04D4]/g,
    alternative: "Ae"
  }],
  // Language: Czech.
  // Source: https://en.wikipedia.org/wiki/Czech_orthography
  cs: [{
    letter: /[\u00E1]/g,
    alternative: "a"
  }, {
    letter: /[\u00C1]/g,
    alternative: "A"
  }, {
    letter: /[\u010D]/g,
    alternative: "c"
  }, {
    letter: /[\u010C]/g,
    alternative: "C"
  }, {
    letter: /[\u010F]/g,
    alternative: "d"
  }, {
    letter: /[\u010E]/g,
    alternative: "D"
  }, {
    letter: /[\u00ED]/g,
    alternative: "i"
  }, {
    letter: /[\u00CD]/g,
    alternative: "I"
  }, {
    letter: /[\u0148]/g,
    alternative: "n"
  }, {
    letter: /[\u0147]/g,
    alternative: "N"
  }, {
    letter: /[\u00F3]/g,
    alternative: "o"
  }, {
    letter: /[\u00D3]/g,
    alternative: "O"
  }, {
    letter: /[\u0159]/g,
    alternative: "r"
  }, {
    letter: /[\u0158]/g,
    alternative: "R"
  }, {
    letter: /[\u0161]/g,
    alternative: "s"
  }, {
    letter: /[\u0160]/g,
    alternative: "S"
  }, {
    letter: /[\u0165]/g,
    alternative: "t"
  }, {
    letter: /[\u0164]/g,
    alternative: "T"
  }, {
    letter: /[\u00FD]/g,
    alternative: "y"
  }, {
    letter: /[\u00DD]/g,
    alternative: "Y"
  }, {
    letter: /[\u017E]/g,
    alternative: "z"
  }, {
    letter: /[\u017D]/g,
    alternative: "Z"
  }, {
    letter: /[\u00E9\u011B]/g,
    alternative: "e"
  }, {
    letter: /[\u00C9\u011A]/g,
    alternative: "E"
  }, {
    letter: /[\u00FA\u016F]/g,
    alternative: "u"
  }, {
    letter: /[\u00DA\u016E]/g,
    alternative: "U"
  }],
  // Language: Russian.
  // Source:  Machine Readable Travel Documents, Doc 9303, Part 1, Volume 1 (PDF) (Sixth ed.).
  // ICAO. 2006. p. IV-50—IV-52. http://www.icao.int/publications/Documents/9303_p3_cons_en.pdf
  // ‘ь’ is the so-called soft sign, indicating a sound change (palatalization) of the preceding consonant.
  // In a text, it is transliterated to a character similar to an apostrophe: ′.
  // I recommend omittance in slugs. (https://en.wikipedia.org/wiki/Romanization_of_Russian)
  ru: [{
    letter: /[\u0430]/g,
    alternative: "a"
  }, {
    letter: /[\u0410]/g,
    alternative: "A"
  }, {
    letter: /[\u0431]/g,
    alternative: "b"
  }, {
    letter: /[\u0411]/g,
    alternative: "B"
  }, {
    letter: /[\u0432]/g,
    alternative: "v"
  }, {
    letter: /[\u0412]/g,
    alternative: "V"
  }, {
    letter: /[\u0433]/g,
    alternative: "g"
  }, {
    letter: /[\u0413]/g,
    alternative: "G"
  }, {
    letter: /[\u0434]/g,
    alternative: "d"
  }, {
    letter: /[\u0414]/g,
    alternative: "D"
  }, {
    letter: /[\u0435]/g,
    alternative: "e"
  }, {
    letter: /[\u0415]/g,
    alternative: "E"
  }, {
    letter: /[\u0436]/g,
    alternative: "zh"
  }, {
    letter: /[\u0416]/g,
    alternative: "Zh"
  }, {
    letter: /[\u0437]/g,
    alternative: "z"
  }, {
    letter: /[\u0417]/g,
    alternative: "Z"
  }, {
    letter: /[\u0456\u0438\u0439]/g,
    alternative: "i"
  }, {
    letter: /[\u0406\u0418\u0419]/g,
    alternative: "I"
  }, {
    letter: /[\u043A]/g,
    alternative: "k"
  }, {
    letter: /[\u041A]/g,
    alternative: "K"
  }, {
    letter: /[\u043B]/g,
    alternative: "l"
  }, {
    letter: /[\u041B]/g,
    alternative: "L"
  }, {
    letter: /[\u043C]/g,
    alternative: "m"
  }, {
    letter: /[\u041C]/g,
    alternative: "M"
  }, {
    letter: /[\u043D]/g,
    alternative: "n"
  }, {
    letter: /[\u041D]/g,
    alternative: "N"
  }, {
    letter: /[\u0440]/g,
    alternative: "r"
  }, {
    letter: /[\u0420]/g,
    alternative: "R"
  }, {
    letter: /[\u043E]/g,
    alternative: "o"
  }, {
    letter: /[\u041E]/g,
    alternative: "O"
  }, {
    letter: /[\u043F]/g,
    alternative: "p"
  }, {
    letter: /[\u041F]/g,
    alternative: "P"
  }, {
    letter: /[\u0441]/g,
    alternative: "s"
  }, {
    letter: /[\u0421]/g,
    alternative: "S"
  }, {
    letter: /[\u0442]/g,
    alternative: "t"
  }, {
    letter: /[\u0422]/g,
    alternative: "T"
  }, {
    letter: /[\u0443]/g,
    alternative: "u"
  }, {
    letter: /[\u0423]/g,
    alternative: "U"
  }, {
    letter: /[\u0444]/g,
    alternative: "f"
  }, {
    letter: /[\u0424]/g,
    alternative: "F"
  }, {
    letter: /[\u0445]/g,
    alternative: "kh"
  }, {
    letter: /[\u0425]/g,
    alternative: "Kh"
  }, {
    letter: /[\u0446]/g,
    alternative: "ts"
  }, {
    letter: /[\u0426]/g,
    alternative: "Ts"
  }, {
    letter: /[\u0447]/g,
    alternative: "ch"
  }, {
    letter: /[\u0427]/g,
    alternative: "Ch"
  }, {
    letter: /[\u0448]/g,
    alternative: "sh"
  }, {
    letter: /[\u0428]/g,
    alternative: "Sh"
  }, {
    letter: /[\u0449]/g,
    alternative: "shch"
  }, {
    letter: /[\u0429]/g,
    alternative: "Shch"
  }, {
    letter: /[\u044A]/g,
    alternative: "ie"
  }, {
    letter: /[\u042A]/g,
    alternative: "Ie"
  }, {
    letter: /[\u044B]/g,
    alternative: "y"
  }, {
    letter: /[\u042B]/g,
    alternative: "Y"
  }, {
    letter: /[\u044C]/g,
    alternative: ""
  }, {
    letter: /[\u042C]/g,
    alternative: ""
  }, {
    letter: /[\u0451\u044D]/g,
    alternative: "e"
  }, {
    letter: /[\u0401\u042D]/g,
    alternative: "E"
  }, {
    letter: /[\u044E]/g,
    alternative: "iu"
  }, {
    letter: /[\u042E]/g,
    alternative: "Iu"
  }, {
    letter: /[\u044F]/g,
    alternative: "ia"
  }, {
    letter: /[\u042F]/g,
    alternative: "Ia"
  }],
  // Language: Esperanto.
  // Source: https://en.wikipedia.org/wiki/Esperanto#Writing_diacritics
  eo: [{
    letter: /[\u0109]/g,
    alternative: "ch"
  }, {
    letter: /[\u0108]/g,
    alternative: "Ch"
  }, {
    letter: /[\u011d]/g,
    alternative: "gh"
  }, {
    letter: /[\u011c]/g,
    alternative: "Gh"
  }, {
    letter: /[\u0125]/g,
    alternative: "hx"
  }, {
    letter: /[\u0124]/g,
    alternative: "Hx"
  }, {
    letter: /[\u0135]/g,
    alternative: "jx"
  }, {
    letter: /[\u0134]/g,
    alternative: "Jx"
  }, {
    letter: /[\u015d]/g,
    alternative: "sx"
  }, {
    letter: /[\u015c]/g,
    alternative: "Sx"
  }, {
    letter: /[\u016d]/g,
    alternative: "ux"
  }, {
    letter: /[\u016c]/g,
    alternative: "Ux"
  }],
  // Language: Afrikaans.
  // Source: https://en.wikipedia.org/wiki/Afrikaans#Orthography
  af: [{
    letter: /[\u00E8\u00EA\u00EB]/g,
    alternative: "e"
  }, {
    letter: /[\u00CB\u00C8\u00CA]/g,
    alternative: "E"
  }, {
    letter: /[\u00EE\u00EF]/g,
    alternative: "i"
  }, {
    letter: /[\u00CE\u00CF]/g,
    alternative: "I"
  }, {
    letter: /[\u00F4\u00F6]/g,
    alternative: "o"
  }, {
    letter: /[\u00D4\u00D6]/g,
    alternative: "O"
  }, {
    letter: /[\u00FB\u00FC]/g,
    alternative: "u"
  }, {
    letter: /[\u00DB\u00DC]/g,
    alternative: "U"
  }],
  // Language: Catalan.
  // Source: https://en.wikipedia.org/wiki/Catalan_orthography
  ca: [{
    letter: /[\u00E0]/g,
    alternative: "a"
  }, {
    letter: /[\u00C0]/g,
    alternative: "A"
  }, {
    letter: /[\u00E9|\u00E8]/g,
    alternative: "e"
  }, {
    letter: /[\u00C9|\u00C8]/g,
    alternative: "E"
  }, {
    letter: /[\u00ED|\u00EF]/g,
    alternative: "i"
  }, {
    letter: /[\u00CD|\u00CF]/g,
    alternative: "I"
  }, {
    letter: /[\u00F3|\u00F2]/g,
    alternative: "o"
  }, {
    letter: /[\u00D3|\u00D2]/g,
    alternative: "O"
  }, {
    letter: /[\u00FA|\u00FC]/g,
    alternative: "u"
  }, {
    letter: /[\u00DA|\u00DC]/g,
    alternative: "U"
  }, {
    letter: /[\u00E7]/g,
    alternative: "c"
  }, {
    letter: /[\u00C7]/g,
    alternative: "C"
  }],
  // Language: Asturian.
  // Source: http://www.orbilat.com/Languages/Asturian/Grammar/Asturian-Alphabet.html
  ast: [{
    letter: /[\u00F1]/g,
    alternative: "n"
  }, {
    letter: /[\u00D1]/g,
    alternative: "N"
  }],
  // Language: Aragonese.
  // Source: https://en.wikipedia.org/wiki/Aragonese_language#Orthography
  an: [{
    letter: /[\u00FC]/g,
    alternative: "u"
  }, {
    letter: /[\u00F1]/g,
    alternative: "ny"
  }, {
    letter: /[\u00E7]/g,
    alternative: "c"
  }, {
    letter: /[\u00ED]/g,
    alternative: "i"
  }, {
    letter: /[\u00F3]/g,
    alternative: "o"
  }, {
    letter: /[\u00E1]/g,
    alternative: "a"
  }, {
    letter: /[\u00DC]/g,
    alternative: "U"
  }, {
    letter: /[\u00D1]/g,
    alternative: "Ny"
  }, {
    letter: /[\u00C7]/g,
    alternative: "C"
  }, {
    letter: /[\u00CD]/g,
    alternative: "I"
  }, {
    letter: /[\u00D3]/g,
    alternative: "O"
  }, {
    letter: /[\u00C1]/g,
    alternative: "A"
  }],
  // Language: Aymara.
  // Source: http://www.omniglot.com/writing/aymara.htm
  ay: [{
    letter: /(([\u00EF])|([\u00ED]))/g,
    alternative: "i"
  }, {
    letter: /(([\u00CF])|([\u00CD]))/g,
    alternative: "I"
  }, {
    letter: /[\u00E4]/g,
    alternative: "a"
  }, {
    letter: /[\u00C4]/g,
    alternative: "A"
  }, {
    letter: /[\u00FC]/g,
    alternative: "u"
  }, {
    letter: /[\u00DC]/g,
    alternative: "U"
  }, {
    letter: /[\u0027]/g,
    alternative: ""
  }, {
    letter: /[\u00F1]/g,
    alternative: "n"
  }, {
    letter: /[\u00D1]/g,
    alternative: "N"
  }],
  // Language: English.
  // Sources: https://en.wikipedia.org/wiki/English_terms_with_diacritical_marks https://en.wikipedia.org/wiki/English_orthography
  en: [{
    letter: /[\u00E6\u04D5]/g,
    alternative: "ae"
  }, {
    letter: /[\u00C6\u04D4]/g,
    alternative: "Ae"
  }, {
    letter: /[\u0153]/g,
    alternative: "oe"
  }, {
    letter: /[\u0152]/g,
    alternative: "Oe"
  }, {
    letter: /[\u00EB\u00E9]/g,
    alternative: "e"
  }, {
    letter: /[\u00C9\u00CB]/g,
    alternative: "E"
  }, {
    letter: /[\u00F4\u00F6]/g,
    alternative: "o"
  }, {
    letter: /[\u00D4\u00D6]/g,
    alternative: "O"
  }, {
    letter: /[\u00EF]/g,
    alternative: "i"
  }, {
    letter: /[\u00CF]/g,
    alternative: "I"
  }, {
    letter: /[\u00E7]/g,
    alternative: "c"
  }, {
    letter: /[\u00C7]/g,
    alternative: "C"
  }, {
    letter: /[\u00F1]/g,
    alternative: "n"
  }, {
    letter: /[\u00D1]/g,
    alternative: "N"
  }, {
    letter: /[\u00FC]/g,
    alternative: "u"
  }, {
    letter: /[\u00DC]/g,
    alternative: "U"
  }, {
    letter: /[\u00E4]/g,
    alternative: "a"
  }, {
    letter: /[\u00C4]/g,
    alternative: "A"
  }],
  // Language: French.
  // Sources: https://en.wikipedia.org/wiki/French_orthography#Ligatures https://en.wikipedia.org/wiki/French_orthography#Diacritics
  fr: [{
    letter: /[\u00E6\u04D5]/g,
    alternative: "ae"
  }, {
    letter: /[\u00C6\u04D4]/g,
    alternative: "Ae"
  }, {
    letter: /[\u0153]/g,
    alternative: "oe"
  }, {
    letter: /[\u0152]/g,
    alternative: "Oe"
  }, {
    letter: /[\u00E9\u00E8\u00EB\u00EA]/g,
    alternative: "e"
  }, {
    letter: /[\u00C9\u00C8\u00CB\u00CA]/g,
    alternative: "E"
  }, {
    letter: /[\u00E0\u00E2]/g,
    alternative: "a"
  }, {
    letter: /[\u00C0\u00C2]/g,
    alternative: "A"
  }, {
    letter: /[\u00EF\u00EE]/g,
    alternative: "i"
  }, {
    letter: /[\u00CF\u00CE]/g,
    alternative: "I"
  }, {
    letter: /[\u00F9\u00FB\u00FC]/g,
    alternative: "u"
  }, {
    letter: /[\u00D9\u00DB\u00DC]/g,
    alternative: "U"
  }, {
    letter: /[\u00F4]/g,
    alternative: "o"
  }, {
    letter: /[\u00D4]/g,
    alternative: "O"
  }, {
    letter: /[\u00FF]/g,
    alternative: "y"
  }, {
    letter: /[\u0178]/g,
    alternative: "Y"
  }, {
    letter: /[\u00E7]/g,
    alternative: "c"
  }, {
    letter: /[\u00C7]/g,
    alternative: "C"
  }, {
    letter: /[\u00F1]/g,
    alternative: "n"
  }, {
    letter: /[\u00D1]/g,
    alternative: "N"
  }],
  // Language: Italian.
  // Source: https://en.wikipedia.org/wiki/Italian_orthography
  it: [{
    letter: /[\u00E0]/g,
    alternative: "a"
  }, {
    letter: /[\u00C0]/g,
    alternative: "A"
  }, {
    letter: /[\u00E9\u00E8]/g,
    alternative: "e"
  }, {
    letter: /[\u00C9\u00C8]/g,
    alternative: "E"
  }, {
    letter: /[\u00EC\u00ED\u00EE]/g,
    alternative: "i"
  }, {
    letter: /[\u00CC\u00CD\u00CE]/g,
    alternative: "I"
  }, {
    letter: /[\u00F3\u00F2]/g,
    alternative: "o"
  }, {
    letter: /[\u00D3\u00D2]/g,
    alternative: "O"
  }, {
    letter: /[\u00F9\u00FA]/g,
    alternative: "u"
  }, {
    letter: /[\u00D9\u00DA]/g,
    alternative: "U"
  }],
  // Language: Dutch.
  // Sources: https://en.wikipedia.org/wiki/Dutch_orthography https://nl.wikipedia.org/wiki/Trema_in_de_Nederlandse_spelling
  nl: [{
    letter: /[\u00E7]/g,
    alternative: "c"
  }, {
    letter: /[\u00C7]/g,
    alternative: "C"
  }, {
    letter: /[\u00F1]/g,
    alternative: "n"
  }, {
    letter: /[\u00D1]/g,
    alternative: "N"
  }, {
    letter: /[\u00E9\u00E8\u00EA\u00EB]/g,
    alternative: "e"
  }, {
    letter: /[\u00C9\u00C8\u00CA\u00CB]/g,
    alternative: "E"
  }, {
    letter: /[\u00F4\u00F6]/g,
    alternative: "o"
  }, {
    letter: /[\u00D4\u00D6]/g,
    alternative: "O"
  }, {
    letter: /[\u00EF]/g,
    alternative: "i"
  }, {
    letter: /[\u00CF]/g,
    alternative: "I"
  }, {
    letter: /[\u00FC]/g,
    alternative: "u"
  }, {
    letter: /[\u00DC]/g,
    alternative: "U"
  }, {
    letter: /[\u00E4]/g,
    alternative: "a"
  }, {
    letter: /[\u00C4]/g,
    alternative: "A"
  }],
  // Language: Bambara.
  // Sources: http://www.omniglot.com/writing/bambara.htm https://en.wikipedia.org/wiki/Bambara_language
  bm: [{
    letter: /[\u025B]/g,
    alternative: "e"
  }, {
    letter: /[\u0190]/g,
    alternative: "E"
  }, {
    letter: /[\u0272]/g,
    alternative: "ny"
  }, {
    letter: /[\u019D]/g,
    alternative: "Ny"
  }, {
    letter: /[\u014B]/g,
    alternative: "ng"
  }, {
    letter: /[\u014A]/g,
    alternative: "Ng"
  }, {
    letter: /[\u0254]/g,
    alternative: "o"
  }, {
    letter: /[\u0186]/g,
    alternative: "O"
  }],
  // Language: Ukrainian.
  // Source: Resolution no. 55 of the Cabinet of Ministers of Ukraine, January 27, 2010 http://zakon2.rada.gov.ua/laws/show/55-2010-%D0%BF
  // ‘ь’ is the so-called soft sign, indicating a sound change (palatalization) of the preceding consonant. In a text, it is sometimes transliterated
  // To a character similar to an apostrophe: ′. Omittance is recommended in slugs (https://en.wikipedia.org/wiki/Romanization_of_Ukrainian).
  uk: [{
    letter: /[\u0431]/g,
    alternative: "b"
  }, {
    letter: /[\u0411]/g,
    alternative: "B"
  }, {
    letter: /[\u0432]/g,
    alternative: "v"
  }, {
    letter: /[\u0412]/g,
    alternative: "V"
  }, {
    letter: /[\u0433]/g,
    alternative: "h"
  }, {
    letter: /[\u0413]/g,
    alternative: "H"
  }, {
    letter: /[\u0491]/g,
    alternative: "g"
  }, {
    letter: /[\u0490]/g,
    alternative: "G"
  }, {
    letter: /[\u0434]/g,
    alternative: "d"
  }, {
    letter: /[\u0414]/g,
    alternative: "D"
  }, {
    letter: /[\u043A]/g,
    alternative: "k"
  }, {
    letter: /[\u041A]/g,
    alternative: "K"
  }, {
    letter: /[\u043B]/g,
    alternative: "l"
  }, {
    letter: /[\u041B]/g,
    alternative: "L"
  }, {
    letter: /[\u043C]/g,
    alternative: "m"
  }, {
    letter: /[\u041C]/g,
    alternative: "M"
  }, {
    letter: /[\u0070]/g,
    alternative: "r"
  }, {
    letter: /[\u0050]/g,
    alternative: "R"
  }, {
    letter: /[\u043F]/g,
    alternative: "p"
  }, {
    letter: /[\u041F]/g,
    alternative: "P"
  }, {
    letter: /[\u0441]/g,
    alternative: "s"
  }, {
    letter: /[\u0421]/g,
    alternative: "S"
  }, {
    letter: /[\u0442]/g,
    alternative: "t"
  }, {
    letter: /[\u0422]/g,
    alternative: "T"
  }, {
    letter: /[\u0443]/g,
    alternative: "u"
  }, {
    letter: /[\u0423]/g,
    alternative: "U"
  }, {
    letter: /[\u0444]/g,
    alternative: "f"
  }, {
    letter: /[\u0424]/g,
    alternative: "F"
  }, {
    letter: /[\u0445]/g,
    alternative: "kh"
  }, {
    letter: /[\u0425]/g,
    alternative: "Kh"
  }, {
    letter: /[\u0446]/g,
    alternative: "ts"
  }, {
    letter: /[\u0426]/g,
    alternative: "Ts"
  }, {
    letter: /[\u0447]/g,
    alternative: "ch"
  }, {
    letter: /[\u0427]/g,
    alternative: "Ch"
  }, {
    letter: /[\u0448]/g,
    alternative: "sh"
  }, {
    letter: /[\u0428]/g,
    alternative: "Sh"
  }, {
    letter: /[\u0449]/g,
    alternative: "shch"
  }, {
    letter: /[\u0429]/g,
    alternative: "Shch"
  }, {
    letter: /[\u044C\u042C]/g,
    alternative: ""
  }, {
    letter: /[\u0436]/g,
    alternative: "zh"
  }, {
    letter: /[\u0416]/g,
    alternative: "Zh"
  }, {
    letter: /[\u0437]/g,
    alternative: "z"
  }, {
    letter: /[\u0417]/g,
    alternative: "Z"
  }, {
    letter: /[\u0438]/g,
    alternative: "y"
  }, {
    letter: /[\u0418]/g,
    alternative: "Y"
  }, {
    letter: /^[\u0454]/g,
    alternative: "ye"
  }, {
    letter: /[\s][\u0454]/g,
    alternative: " ye"
  }, {
    letter: /[\u0454]/g,
    alternative: "ie"
  }, {
    letter: /^[\u0404]/g,
    alternative: "Ye"
  }, {
    letter: /[\s][\u0404]/g,
    alternative: " Ye"
  }, {
    letter: /[\u0404]/g,
    alternative: "IE"
  }, {
    letter: /^[\u0457]/g,
    alternative: "yi"
  }, {
    letter: /[\s][\u0457]/g,
    alternative: " yi"
  }, {
    letter: /[\u0457]/g,
    alternative: "i"
  }, {
    letter: /^[\u0407]/g,
    alternative: "Yi"
  }, {
    letter: /[\s][\u0407]/g,
    alternative: " Yi"
  }, {
    letter: /[\u0407]/g,
    alternative: "I"
  }, {
    letter: /^[\u0439]/g,
    alternative: "y"
  }, {
    letter: /[\s][\u0439]/g,
    alternative: " y"
  }, {
    letter: /[\u0439]/g,
    alternative: "i"
  }, {
    letter: /^[\u0419]/g,
    alternative: "Y"
  }, {
    letter: /[\s][\u0419]/g,
    alternative: " Y"
  }, {
    letter: /[\u0419]/g,
    alternative: "I"
  }, {
    letter: /^[\u044E]/g,
    alternative: "yu"
  }, {
    letter: /[\s][\u044E]/g,
    alternative: " yu"
  }, {
    letter: /[\u044E]/g,
    alternative: "iu"
  }, {
    letter: /^[\u042E]/g,
    alternative: "Yu"
  }, {
    letter: /[\s][\u042E]/g,
    alternative: " Yu"
  }, {
    letter: /[\u042E]/g,
    alternative: "IU"
  }, {
    letter: /^[\u044F]/g,
    alternative: "ya"
  }, {
    letter: /[\s][\u044F]/g,
    alternative: " ya"
  }, {
    letter: /[\u044F]/g,
    alternative: "ia"
  }, {
    letter: /^[\u042F]/g,
    alternative: "Ya"
  }, {
    letter: /[\s][\u042F]/g,
    alternative: " Ya"
  }, {
    letter: /[\u042F]/g,
    alternative: "IA"
  }],
  // Language: Breton
  // Source: http://www.omniglot.com/writing/breton.htm
  br: [{
    letter: /\u0063\u0027\u0068/g,
    alternative: "ch"
  }, {
    letter: /\u0043\u0027\u0048/g,
    alternative: "CH"
  }, {
    letter: /[\u00e2]/g,
    alternative: "a"
  }, {
    letter: /[\u00c2]/g,
    alternative: "A"
  }, {
    letter: /[\u00ea]/g,
    alternative: "e"
  }, {
    letter: /[\u00ca]/g,
    alternative: "E"
  }, {
    letter: /[\u00ee]/g,
    alternative: "i"
  }, {
    letter: /[\u00ce]/g,
    alternative: "I"
  }, {
    letter: /[\u00f4]/g,
    alternative: "o"
  }, {
    letter: /[\u00d4]/g,
    alternative: "O"
  }, {
    letter: /[\u00fb\u00f9\u00fc]/g,
    alternative: "u"
  }, {
    letter: /[\u00db\u00d9\u00dc]/g,
    alternative: "U"
  }, {
    letter: /[\u00f1]/g,
    alternative: "n"
  }, {
    letter: /[\u00d1]/g,
    alternative: "N"
  }],
  // Language: Chamorro
  // Source: http://www.omniglot.com/writing/chamorro.htm
  ch: [{
    letter: /[\u0027]/g,
    alternative: ""
  }, {
    letter: /[\u00e5]/g,
    alternative: "a"
  }, {
    letter: /[\u00c5]/g,
    alternative: "A"
  }, {
    letter: /[\u00f1]/g,
    alternative: "n"
  }, {
    letter: /[\u00d1]/g,
    alternative: "N"
  }],
  // Language: Corsican
  // Sources: http://www.omniglot.com/writing/corsican.htm https://en.wikipedia.org/wiki/Corsican_alphabet
  co: [{
    letter: /[\u00e2\u00e0]/g,
    alternative: "a"
  }, {
    letter: /[\u00c2\u00c0]/g,
    alternative: "A"
  }, {
    letter: /[\u00e6\u04d5]/g,
    alternative: "ae"
  }, {
    letter: /[\u00c6\u04d4]/g,
    alternative: "Ae"
  }, {
    letter: /[\u00e7]/g,
    alternative: "c"
  }, {
    letter: /[\u00c7]/g,
    alternative: "C"
  }, {
    letter: /[\u00e9\u00ea\u00e8\u00eb]/g,
    alternative: "e"
  }, {
    letter: /[\u00c9\u00ca\u00c8\u00cb]/g,
    alternative: "E"
  }, {
    letter: /[\u00ec\u00ee\u00ef]/g,
    alternative: "i"
  }, {
    letter: /[\u00cc\u00ce\u00cf]/g,
    alternative: "I"
  }, {
    letter: /[\u00f1]/g,
    alternative: "n"
  }, {
    letter: /[\u00d1]/g,
    alternative: "N"
  }, {
    letter: /[\u00f4\u00f2]/g,
    alternative: "o"
  }, {
    letter: /[\u00d4\u00d2]/g,
    alternative: "O"
  }, {
    letter: /[\u0153]/g,
    alternative: "oe"
  }, {
    letter: /[\u0152]]/g,
    alternative: "Oe"
  }, {
    letter: /[\u00f9\u00fc]/g,
    alternative: "u"
  }, {
    letter: /[\u00d9\u00dc]/g,
    alternative: "U"
  }, {
    letter: /[\u00ff]/g,
    alternative: "y"
  }, {
    letter: /[\u0178]/g,
    alternative: "Y"
  }],
  // Language: Kashubian
  // Sources: http://www.omniglot.com/writing/kashubian.htm https://en.wikipedia.org/wiki/Kashubian_language
  csb: [{
    letter: /[\u0105\u00e3]/g,
    alternative: "a"
  }, {
    letter: /[\u0104\u00c3]/g,
    alternative: "A"
  }, {
    letter: /[\u00e9\u00eb]/g,
    alternative: "e"
  }, {
    letter: /[\u00c9\u00cb]/g,
    alternative: "E"
  }, {
    letter: /[\u0142]/g,
    alternative: "l"
  }, {
    letter: /[\u0141]/g,
    alternative: "L"
  }, {
    letter: /[\u0144]/g,
    alternative: "n"
  }, {
    letter: /[\u0143]/g,
    alternative: "N"
  }, {
    letter: /[\u00f2\u00f3\u00f4]/g,
    alternative: "o"
  }, {
    letter: /[\u00d2\u00d3\u00d4]/g,
    alternative: "O"
  }, {
    letter: /[\u00f9]/g,
    alternative: "u"
  }, {
    letter: /[\u00d9]/g,
    alternative: "U"
  }, {
    letter: /[\u017c]/g,
    alternative: "z"
  }, {
    letter: /[\u017b]/g,
    alternative: "Z"
  }],
  // Language: Welsh
  // Sources: http://www.omniglot.com/writing/welsh.htm https://en.wikipedia.org/wiki/Welsh_orthography#Diacritics
  cy: [{
    letter: /[\u00e2]/g,
    alternative: "a"
  }, {
    letter: /[\u00c2]/g,
    alternative: "A"
  }, {
    letter: /[\u00ea]/g,
    alternative: "e"
  }, {
    letter: /[\u00ca]/g,
    alternative: "E"
  }, {
    letter: /[\u00ee]/g,
    alternative: "i"
  }, {
    letter: /[\u00ce]/g,
    alternative: "I"
  }, {
    letter: /[\u00f4]/g,
    alternative: "o"
  }, {
    letter: /[\u00d4]/g,
    alternative: "O"
  }, {
    letter: /[\u00fb]/g,
    alternative: "u"
  }, {
    letter: /[\u00db]/g,
    alternative: "U"
  }, {
    letter: /[\u0175]/g,
    alternative: "w"
  }, {
    letter: /[\u0174]/g,
    alternative: "W"
  }, {
    letter: /[\u0177]/g,
    alternative: "y"
  }, {
    letter: /[\u0176]/g,
    alternative: "Y"
  }],
  // Language: Ewe
  // Sources: http://www.omniglot.com/writing/ewe.htm https://en.wikipedia.org/wiki/Ewe_language#Writing_system
  ee: [{
    letter: /[\u0256]/g,
    alternative: "d"
  }, {
    letter: /[\u0189]/g,
    alternative: "D"
  }, {
    letter: /[\u025b]/g,
    alternative: "e"
  }, {
    letter: /[\u0190]/g,
    alternative: "E"
  }, {
    letter: /[\u0192]/g,
    alternative: "f"
  }, {
    letter: /[\u0191]/g,
    alternative: "F"
  }, {
    letter: /[\u0263]/g,
    alternative: "g"
  }, {
    letter: /[\u0194]/g,
    alternative: "G"
  }, {
    letter: /[\u014b]/g,
    alternative: "ng"
  }, {
    letter: /[\u014a]/g,
    alternative: "Ng"
  }, {
    letter: /[\u0254]/g,
    alternative: "o"
  }, {
    letter: /[\u0186]/g,
    alternative: "O"
  }, {
    letter: /[\u028b]/g,
    alternative: "w"
  }, {
    letter: /[\u01b2]/g,
    alternative: "W"
  }, {
    letter: /\u0061\u0303/g,
    alternative: "a"
  }, {
    letter: /[\u00e1\u00e0\u01ce\u00e2\u00e3]/g,
    alternative: "a"
  }, {
    letter: /\u0041\u0303/g,
    alternative: "A"
  }, {
    letter: /[\u00c1\u00c0\u01cd\u00c2\u00c3]/g,
    alternative: "A"
  }, {
    letter: /[\u00e9\u00e8\u011b\u00ea]/g,
    alternative: "e"
  }, {
    letter: /[\u00c9\u00c8\u011a\u00ca]/g,
    alternative: "E"
  }, {
    letter: /[\u00f3\u00f2\u01d2\u00f4]/g,
    alternative: "o"
  }, {
    letter: /[\u00d3\u00d2\u01d1\u00d4]/g,
    alternative: "O"
  }, {
    letter: /[\u00fa\u00f9\u01d4\u00fb]/g,
    alternative: "u"
  }, {
    letter: /[\u00da\u00d9\u01d3\u00db]/g,
    alternative: "U"
  }, {
    letter: /[\u00ed\u00ec\u01d0\u00ee]/g,
    alternative: "i"
  }, {
    letter: /[\u00cd\u00cc\u01cf\u00ce]/g,
    alternative: "I"
  }],
  // Language: Estonian
  // Sources: http://www.omniglot.com/writing/estonian.htm https://en.wikipedia.org/wiki/Estonian_orthography
  // https://en.wikipedia.org/wiki/%C5%BD https://en.wikipedia.org/wiki/%C5%A0
  et: [{
    letter: /[\u0161]/g,
    alternative: "sh"
  }, {
    letter: /[\u0160]/g,
    alternative: "Sh"
  }, {
    letter: /[\u017e]/g,
    alternative: "zh"
  }, {
    letter: /[\u017d]/g,
    alternative: "Zh"
  }, {
    letter: /[\u00f5\u00f6]/g,
    alternative: "o"
  }, {
    letter: /[\u00d6\u00d5]/g,
    alternative: "O"
  }, {
    letter: /[\u00e4]/g,
    alternative: "a"
  }, {
    letter: /[\u00c4]/g,
    alternative: "A"
  }, {
    letter: /[\u00fc]/g,
    alternative: "u"
  }, {
    letter: /[\u00dc]/g,
    alternative: "U"
  }],
  // Language: Basque
  // Sources: http://www.omniglot.com/writing/basque.htm https://en.wikipedia.org/wiki/Basque_language#Writing_system
  // https://en.wikipedia.org/wiki/Basque_alphabet
  eu: [{
    letter: /[\u00f1]/g,
    alternative: "n"
  }, {
    letter: /[\u00d1]/g,
    alternative: "N"
  }, {
    letter: /[\u00e7]/g,
    alternative: "c"
  }, {
    letter: /[\u00c7]/g,
    alternative: "C"
  }, {
    letter: /[\u00fc]/g,
    alternative: "u"
  }, {
    letter: /[\u00dc]/g,
    alternative: "U"
  }],
  // Language: Fulah
  // Sources: http://www.omniglot.com/writing/fula.htm https://en.wikipedia.org/wiki/Fula_language#Writing_systems
  fuc: [{
    letter: /[\u0253]/g,
    alternative: "b"
  }, {
    letter: /[\u0181]/g,
    alternative: "B"
  }, {
    letter: /[\u0257]/g,
    alternative: "d"
  }, {
    letter: /[\u018a]/g,
    alternative: "D"
  }, {
    letter: /[\u014b]/g,
    alternative: "ng"
  }, {
    letter: /[\u014a]/g,
    alternative: "Ng"
  }, {
    letter: /[\u0272\u00f1]/g,
    alternative: "ny"
  }, {
    letter: /[\u019d\u00d1]/g,
    alternative: "Ny"
  }, {
    letter: /[\u01b4]/g,
    alternative: "y"
  }, {
    letter: /[\u01b3]/g,
    alternative: "Y"
  }, {
    letter: /[\u0260]/g,
    alternative: "g"
  }, {
    letter: /[\u0193]/g,
    alternative: "G"
  }],
  // Language: Fijian
  // Source: http://www.omniglot.com/writing/fijian.htm
  fj: [{
    letter: /[\u0101]/g,
    alternative: "a"
  }, {
    letter: /[\u0100]/g,
    alternative: "A"
  }, {
    letter: /[\u0113]/g,
    alternative: "e"
  }, {
    letter: /[\u0112]/g,
    alternative: "E"
  }, {
    letter: /[\u012b]/g,
    alternative: "i"
  }, {
    letter: /[\u012a]/g,
    alternative: "I"
  }, {
    letter: /[\u016b]/g,
    alternative: "u"
  }, {
    letter: /[\u016a]/g,
    alternative: "U"
  }, {
    letter: /[\u014d]/g,
    alternative: "o"
  }, {
    letter: /[\u014c]/g,
    alternative: "O"
  }],
  // Language: Arpitan (Franco-Provençal language)
  // Source: http://www.omniglot.com/writing/francoprovencal.htm
  frp: [{
    letter: /[\u00e2]/g,
    alternative: "a"
  }, {
    letter: /[\u00c2]/g,
    alternative: "A"
  }, {
    letter: /[\u00ea\u00e8\u00e9]/g,
    alternative: "e"
  }, {
    letter: /[\u00ca\u00c8\u00c9]/g,
    alternative: "E"
  }, {
    letter: /[\u00ee]/g,
    alternative: "i"
  }, {
    letter: /[\u00ce]/g,
    alternative: "I"
  }, {
    letter: /[\u00fb\u00fc]/g,
    alternative: "u"
  }, {
    letter: /[\u00db\u00dc]/g,
    alternative: "U"
  }, {
    letter: /[\u00f4]/g,
    alternative: "o"
  }, {
    letter: /[\u00d4]/g,
    alternative: "O"
  }],
  // Language: Friulian
  // Sources: https://en.wikipedia.org/wiki/Friulian_language https://en.wikipedia.org/wiki/Faggin-Nazzi_alphabet
  // http://www.omniglot.com/writing/friulian.htm
  fur: [{
    letter: /[\u00E7]/g,
    alternative: "c"
  }, {
    letter: /[\u00C7]/g,
    alternative: "C"
  }, {
    letter: /[\u00e0\u00e2]/g,
    alternative: "a"
  }, {
    letter: /[\u00c0\u00c2]/g,
    alternative: "A"
  }, {
    letter: /[\u00e8\u00ea]/g,
    alternative: "e"
  }, {
    letter: /[\u00c8\u00ca]/g,
    alternative: "E"
  }, {
    letter: /[\u00ec\u00ee]/g,
    alternative: "i"
  }, {
    letter: /[\u00cc\u00ce]/g,
    alternative: "I"
  }, {
    letter: /[\u00f2\u00f4]/g,
    alternative: "o"
  }, {
    letter: /[\u00d2\u00d4]/g,
    alternative: "O"
  }, {
    letter: /[\u00f9\u00fb]/g,
    alternative: "u"
  }, {
    letter: /[\u00d9\u00db]/g,
    alternative: "U"
  }, {
    letter: /[\u010d]/g,
    alternative: "c"
  }, {
    letter: /[\u010c]/g,
    alternative: "C"
  }, {
    letter: /[\u011f]/g,
    alternative: "g"
  }, {
    letter: /[\u011e]/g,
    alternative: "G"
  }, {
    letter: /[\u0161]/g,
    alternative: "s"
  }, {
    letter: /[\u0160]/g,
    alternative: "S"
  }],
  // Language: Frisian
  // Sources: https://en.wikipedia.org/wiki/West_Frisian_alphabet http://www.omniglot.com/writing/frisian.htm
  fy: [{
    letter: /[\u00e2\u0101\u00e4\u00e5]/g,
    alternative: "a"
  }, {
    letter: /[\u00c2\u0100\u00c4\u00c5]/g,
    alternative: "A"
  }, {
    letter: /[\u00ea\u00e9\u0113]/g,
    alternative: "e"
  }, {
    letter: /[\u00ca\u00c9\u0112]/g,
    alternative: "E"
  }, {
    letter: /[\u00f4\u00f6]/g,
    alternative: "o"
  }, {
    letter: /[\u00d4\u00d6]/g,
    alternative: "O"
  }, {
    letter: /[\u00fa\u00fb\u00fc]/g,
    alternative: "u"
  }, {
    letter: /[\u00da\u00db\u00dc]/g,
    alternative: "U"
  }, {
    letter: /[\u00ed]/g,
    alternative: "i"
  }, {
    letter: /[\u00cd]/g,
    alternative: "I"
  }, {
    letter: /[\u0111\u00f0]/g,
    alternative: "d"
  }, {
    letter: /[\u0110\u00d0]/g,
    alternative: "D"
  }],
  // Language: Irish
  // Source: https://en.wikipedia.org/wiki/Irish_orthography
  ga: [{
    letter: /[\u00e1]/g,
    alternative: "a"
  }, {
    letter: /[\u00c1]/g,
    alternative: "A"
  }, {
    letter: /[\u00e9]/g,
    alternative: "e"
  }, {
    letter: /[\u00c9]/g,
    alternative: "E"
  }, {
    letter: /[\u00f3]/g,
    alternative: "o"
  }, {
    letter: /[\u00d3]/g,
    alternative: "O"
  }, {
    letter: /[\u00fa]/g,
    alternative: "u"
  }, {
    letter: /[\u00da]/g,
    alternative: "U"
  }, {
    letter: /[\u00ed]/g,
    alternative: "i"
  }, {
    letter: /[\u00cd]/g,
    alternative: "I"
  }],
  // Language: Scottish Gaelic
  // Sources: https://en.wikipedia.org/wiki/Scottish_Gaelic_orthography http://www.omniglot.com/writing/gaelic.htm
  gd: [{
    letter: /[\u00e0]/g,
    alternative: "a"
  }, {
    letter: /[\u00c0]/g,
    alternative: "A"
  }, {
    letter: /[\u00e8]/g,
    alternative: "e"
  }, {
    letter: /[\u00c8]/g,
    alternative: "E"
  }, {
    letter: /[\u00f2]/g,
    alternative: "o"
  }, {
    letter: /[\u00d2]/g,
    alternative: "O"
  }, {
    letter: /[\u00f9]/g,
    alternative: "u"
  }, {
    letter: /[\u00d9]/g,
    alternative: "U"
  }, {
    letter: /[\u00ec]/g,
    alternative: "i"
  }, {
    letter: /[\u00cc]/g,
    alternative: "I"
  }],
  // Language: Galician
  // Sources: https://en.wikipedia.org/wiki/Diacritic https://en.wikipedia.org/wiki/Galician_Alphabet
  gl: [{
    letter: /[\u00e1\u00e0]/g,
    alternative: "a"
  }, {
    letter: /[\u00c1\u00c0]/g,
    alternative: "A"
  }, {
    letter: /[\u00e9\u00ea]/g,
    alternative: "e"
  }, {
    letter: /[\u00c9\u00ca]/g,
    alternative: "E"
  }, {
    letter: /[\u00ed\u00ef]/g,
    alternative: "i"
  }, {
    letter: /[\u00cd\u00cf]/g,
    alternative: "I"
  }, {
    letter: /[\u00f3]/g,
    alternative: "o"
  }, {
    letter: /[\u00d3]/g,
    alternative: "O"
  }, {
    letter: /[\u00fa\u00fc]/g,
    alternative: "u"
  }, {
    letter: /[\u00da\u00dc]/g,
    alternative: "U"
  }, {
    letter: /[\u00e7]/g,
    alternative: "c"
  }, {
    letter: /[\u00c7]/g,
    alternative: "C"
  }, {
    letter: /[\u00f1]/g,
    alternative: "n"
  }, {
    letter: /[\u00d1]/g,
    alternative: "N"
  }],
  // Language: Guarani
  // Sources: https://en.wikipedia.org/wiki/Guarani_alphabet http://www.omniglot.com/writing/guarani.htm
  gn: [{
    letter: /[\u2019]/g,
    alternative: ""
  }, {
    letter: /\u0067\u0303/g,
    alternative: "g"
  }, {
    letter: /\u0047\u0303/g,
    alternative: "G"
  }, {
    letter: /[\u00e3]/g,
    alternative: "a"
  }, {
    letter: /[\u00c3]/g,
    alternative: "A"
  }, {
    letter: /[\u1ebd]/g,
    alternative: "e"
  }, {
    letter: /[\u1ebc]/g,
    alternative: "E"
  }, {
    letter: /[\u0129]/g,
    alternative: "i"
  }, {
    letter: /[\u0128]/g,
    alternative: "I"
  }, {
    letter: /[\u00f5]/g,
    alternative: "o"
  }, {
    letter: /[\u00d5]/g,
    alternative: "O"
  }, {
    letter: /[\u00f1]/g,
    alternative: "n"
  }, {
    letter: /[\u00d1]/g,
    alternative: "N"
  }, {
    letter: /[\u0169]/g,
    alternative: "u"
  }, {
    letter: /[\u0168]/g,
    alternative: "U"
  }, {
    letter: /[\u1ef9]/g,
    alternative: "y"
  }, {
    letter: /[\u1ef8]/g,
    alternative: "Y"
  }],
  // Language: Swiss German
  // Source: http://www.omniglot.com/writing/swissgerman.htm
  gsw: [{
    letter: /[\u00e4]/g,
    alternative: "a"
  }, {
    letter: /[\u00c4]/g,
    alternative: "A"
  }, {
    letter: /[\u00f6]/g,
    alternative: "o"
  }, {
    letter: /[\u00d6]/g,
    alternative: "O"
  }, {
    letter: /[\u00fc]/g,
    alternative: "u"
  }, {
    letter: /[\u00dc]/g,
    alternative: "U"
  }],
  // Language: Haitian Creole
  // Sources: https://en.wikipedia.org/wiki/Haitian_Creole http://www.omniglot.com/writing/haitiancreole.htm
  hat: [{
    letter: /[\u00e8]/g,
    alternative: "e"
  }, {
    letter: /[\u00c8]/g,
    alternative: "E"
  }, {
    letter: /[\u00f2]/g,
    alternative: "o"
  }, {
    letter: /[\u00d2]/g,
    alternative: "O"
  }],
  // Language: Hawaiian
  // Sources: https://en.wikipedia.org/wiki/Hawaiian_language#Macron http://www.omniglot.com/writing/hawaiian.htm
  haw: [{
    letter: /[\u02bb\u0027\u2019]/g,
    alternative: ""
  }, {
    letter: /[\u0101]/g,
    alternative: "a"
  }, {
    letter: /[\u0113]/g,
    alternative: "e"
  }, {
    letter: /[\u012b]/g,
    alternative: "i"
  }, {
    letter: /[\u014d]/g,
    alternative: "o"
  }, {
    letter: /[\u016b]/g,
    alternative: "u"
  }, {
    letter: /[\u0100]/g,
    alternative: "A"
  }, {
    letter: /[\u0112]/g,
    alternative: "E"
  }, {
    letter: /[\u012a]/g,
    alternative: "I"
  }, {
    letter: /[\u014c]/g,
    alternative: "O"
  }, {
    letter: /[\u016a]/g,
    alternative: "U"
  }],
  // Language: Croatian
  // Sources: https://en.wikipedia.org/wiki/Gaj%27s_Latin_alphabet https://en.wikipedia.org/wiki/D_with_stroke
  // http://www.omniglot.com/writing/croatian.htm
  hr: [{
    letter: /[\u010d\u0107]/g,
    alternative: "c"
  }, {
    letter: /[\u010c\u0106]/g,
    alternative: "C"
  }, {
    letter: /[\u0111]/g,
    alternative: "dj"
  }, {
    letter: /[\u0110]/g,
    alternative: "Dj"
  }, {
    letter: /[\u0161]/g,
    alternative: "s"
  }, {
    letter: /[\u0160]/g,
    alternative: "S"
  }, {
    letter: /[\u017e]/g,
    alternative: "z"
  }, {
    letter: /[\u017d]/g,
    alternative: "Z"
  }, {
    letter: /[\u01c4]/g,
    alternative: "DZ"
  }, {
    letter: /[\u01c5]/g,
    alternative: "Dz"
  }, {
    letter: /[\u01c6]/g,
    alternative: "dz"
  }],
  // Language: Georgian
  // The Georgian language does not use capital letters.
  // Sources: https://en.wikipedia.org/wiki/Romanization_of_Georgian (national system)
  ka: [{
    letter: /[\u10d0]/g,
    alternative: "a"
  }, {
    letter: /[\u10d1]/g,
    alternative: "b"
  }, {
    letter: /[\u10d2]/g,
    alternative: "g"
  }, {
    letter: /[\u10d3]/g,
    alternative: "d"
  }, {
    letter: /[\u10d4]/g,
    alternative: "e"
  }, {
    letter: /[\u10d5]/g,
    alternative: "v"
  }, {
    letter: /[\u10d6]/g,
    alternative: "z"
  }, {
    letter: /[\u10d7]/g,
    alternative: "t"
  }, {
    letter: /[\u10d8]/g,
    alternative: "i"
  }, {
    letter: /[\u10d9]/g,
    alternative: "k"
  }, {
    letter: /[\u10da]/g,
    alternative: "l"
  }, {
    letter: /[\u10db]/g,
    alternative: "m"
  }, {
    letter: /[\u10dc]/g,
    alternative: "n"
  }, {
    letter: /[\u10dd]/g,
    alternative: "o"
  }, {
    letter: /[\u10de]/g,
    alternative: "p"
  }, {
    letter: /[\u10df]/g,
    alternative: "zh"
  }, {
    letter: /[\u10e0]/g,
    alternative: "r"
  }, {
    letter: /[\u10e1]/g,
    alternative: "s"
  }, {
    letter: /[\u10e2]/g,
    alternative: "t"
  }, {
    letter: /[\u10e3]/g,
    alternative: "u"
  }, {
    letter: /[\u10e4]/g,
    alternative: "p"
  }, {
    letter: /[\u10e5]/g,
    alternative: "k"
  }, {
    letter: /[\u10e6]/g,
    alternative: "gh"
  }, {
    letter: /[\u10e7]/g,
    alternative: "q"
  }, {
    letter: /[\u10e8]/g,
    alternative: "sh"
  }, {
    letter: /[\u10e9]/g,
    alternative: "ch"
  }, {
    letter: /[\u10ea]/g,
    alternative: "ts"
  }, {
    letter: /[\u10eb]/g,
    alternative: "dz"
  }, {
    letter: /[\u10ec]/g,
    alternative: "ts"
  }, {
    letter: /[\u10ed]/g,
    alternative: "ch"
  }, {
    letter: /[\u10ee]/g,
    alternative: "kh"
  }, {
    letter: /[\u10ef]/g,
    alternative: "j"
  }, {
    letter: /[\u10f0]/g,
    alternative: "h"
  }],
  // Language: Greenlandic.
  // Source: https://en.wikipedia.org/wiki/Greenlandic_language#Orthography
  kal: [{
    letter: /[\u00E5]/g,
    alternative: "aa"
  }, {
    letter: /[\u00C5]/g,
    alternative: "Aa"
  }, {
    letter: /[\u00E6\u04D5]/g,
    alternative: "ae"
  }, {
    letter: /[\u00C6\u04D4]/g,
    alternative: "Ae"
  }, {
    letter: /[\u00C4]/g,
    alternative: "Ae"
  }, {
    letter: /[\u00F8]/g,
    alternative: "oe"
  }, {
    letter: /[\u00D8]/g,
    alternative: "Oe"
  }],
  // Language: Kinyarwanda.
  // Source: https://en.wikipedia.org/wiki/Kinyarwanda
  kin: [{
    letter: /[\u2019\u0027]/g,
    alternative: ""
  }],
  // Language: Luxembourgish.
  // Source: http://www.omniglot.com/writing/luxembourgish.htm
  lb: [{
    letter: /[\u00e4]/g,
    alternative: "a"
  }, {
    letter: /[\u00c4]/g,
    alternative: "A"
  }, {
    letter: /[\u00eb\u00e9]/g,
    alternative: "e"
  }, {
    letter: /[\u00cb\u00c9]/g,
    alternative: "E"
  }],
  // Language: Limburgish.
  // Source: http://www.omniglot.com/writing/limburgish.htm
  li: [{
    letter: /[\u00e1\u00e2\u00e0\u00e4]/g,
    alternative: "a"
  }, {
    letter: /[\u00c1\u00c2\u00c0\u00c4]/g,
    alternative: "A"
  }, {
    letter: /[\u00eb\u00e8\u00ea]/g,
    alternative: "e"
  }, {
    letter: /[\u00cb\u00c8\u00ca]/g,
    alternative: "E"
  }, {
    letter: /[\u00f6\u00f3]/g,
    alternative: "o"
  }, {
    letter: /[\u00d6\u00d3]/g,
    alternative: "O"
  }],
  // Language: Lingala.
  // Sources: https://en.wikipedia.org/wiki/Lingala#Writing_system http://www.omniglot.com/writing/lingala.htm
  lin: [{
    letter: /[\u00e1\u00e2\u01ce]/g,
    alternative: "a"
  }, {
    letter: /[\u00c1\u00c2\u01cd]/g,
    alternative: "A"
  }, {
    letter: /\u025b\u0301/g,
    alternative: "e"
  }, {
    letter: /\u025b\u0302/g,
    alternative: "e"
  }, {
    letter: /\u025b\u030c/g,
    alternative: "e"
  }, {
    letter: /[\u00e9\u00ea\u011b\u025b]/g,
    alternative: "e"
  }, {
    letter: /\u0190\u0301/g,
    alternative: "E"
  }, {
    letter: /\u0190\u0302/g,
    alternative: "E"
  }, {
    letter: /\u0190\u030c/g,
    alternative: "E"
  }, {
    letter: /[\u00c9\u00ca\u011a\u0190]/g,
    alternative: "E"
  }, {
    letter: /[\u00ed\u00ee\u01d0]/g,
    alternative: "i"
  }, {
    letter: /[\u00cd\u00ce\u01cf]/g,
    alternative: "I"
  }, {
    letter: /\u0254\u0301/g,
    alternative: "o"
  }, {
    letter: /\u0254\u0302/g,
    alternative: "o"
  }, {
    letter: /\u0254\u030c/g,
    alternative: "o"
  }, {
    letter: /[\u00f3\u00f4\u01d2\u0254]/g,
    alternative: "o"
  }, {
    letter: /\u0186\u0301/g,
    alternative: "O"
  }, {
    letter: /\u0186\u0302/g,
    alternative: "O"
  }, {
    letter: /\u0186\u030c/g,
    alternative: "O"
  }, {
    letter: /[\u00d3\u00d4\u01d1\u0186]/g,
    alternative: "O"
  }, {
    letter: /[\u00fa]/g,
    alternative: "u"
  }, {
    letter: /[\u00da]/g,
    alternative: "U"
  }],
  // Language: Lithuanian.
  // Sources: https://en.wikipedia.org/wiki/Lithuanian_orthography http://www.omniglot.com/writing/lithuanian.htm
  lt: [{
    letter: /[\u0105]/g,
    alternative: "a"
  }, {
    letter: /[\u0104]/g,
    alternative: "A"
  }, {
    letter: /[\u010d]/g,
    alternative: "c"
  }, {
    letter: /[\u010c]/g,
    alternative: "C"
  }, {
    letter: /[\u0119\u0117]/g,
    alternative: "e"
  }, {
    letter: /[\u0118\u0116]/g,
    alternative: "E"
  }, {
    letter: /[\u012f]/g,
    alternative: "i"
  }, {
    letter: /[\u012e]/g,
    alternative: "I"
  }, {
    letter: /[\u0161]/g,
    alternative: "s"
  }, {
    letter: /[\u0160]/g,
    alternative: "S"
  }, {
    letter: /[\u0173\u016b]/g,
    alternative: "u"
  }, {
    letter: /[\u0172\u016a]/g,
    alternative: "U"
  }, {
    letter: /[\u017e]/g,
    alternative: "z"
  }, {
    letter: /[\u017d]/g,
    alternative: "Z"
  }],
  // Language: Malagasy.
  // Source: http://www.omniglot.com/writing/malagasy.htm
  mg: [{
    letter: /[\u00f4]/g,
    alternative: "ao"
  }, {
    letter: /[\u00d4]/g,
    alternative: "Ao"
  }],
  // Language: Macedonian.
  // Source: http://www.omniglot.com/writing/macedonian.htm
  mk: [{
    letter: /[\u0430]/g,
    alternative: "a"
  }, {
    letter: /[\u0410]/g,
    alternative: "A"
  }, {
    letter: /[\u0431]/g,
    alternative: "b"
  }, {
    letter: /[\u0411]/g,
    alternative: "B"
  }, {
    letter: /[\u0432]/g,
    alternative: "v"
  }, {
    letter: /[\u0412]/g,
    alternative: "V"
  }, {
    letter: /[\u0433]/g,
    alternative: "g"
  }, {
    letter: /[\u0413]/g,
    alternative: "G"
  }, {
    letter: /[\u0434]/g,
    alternative: "d"
  }, {
    letter: /[\u0414]/g,
    alternative: "D"
  }, {
    letter: /[\u0453]/g,
    alternative: "gj"
  }, {
    letter: /[\u0403]/g,
    alternative: "Gj"
  }, {
    letter: /[\u0435]/g,
    alternative: "e"
  }, {
    letter: /[\u0415]/g,
    alternative: "E"
  }, {
    letter: /[\u0436]/g,
    alternative: "zh"
  }, {
    letter: /[\u0416]/g,
    alternative: "Zh"
  }, {
    letter: /[\u0437]/g,
    alternative: "z"
  }, {
    letter: /[\u0417]/g,
    alternative: "Z"
  }, {
    letter: /[\u0455]/g,
    alternative: "dz"
  }, {
    letter: /[\u0405]/g,
    alternative: "Dz"
  }, {
    letter: /[\u0438]/g,
    alternative: "i"
  }, {
    letter: /[\u0418]/g,
    alternative: "I"
  }, {
    letter: /[\u0458]/g,
    alternative: "j"
  }, {
    letter: /[\u0408]/g,
    alternative: "J"
  }, {
    letter: /[\u043A]/g,
    alternative: "k"
  }, {
    letter: /[\u041A]/g,
    alternative: "K"
  }, {
    letter: /[\u043B]/g,
    alternative: "l"
  }, {
    letter: /[\u041B]/g,
    alternative: "L"
  }, {
    letter: /[\u0459]/g,
    alternative: "lj"
  }, {
    letter: /[\u0409]/g,
    alternative: "Lj"
  }, {
    letter: /[\u043C]/g,
    alternative: "m"
  }, {
    letter: /[\u041C]/g,
    alternative: "M"
  }, {
    letter: /[\u043D]/g,
    alternative: "n"
  }, {
    letter: /[\u041D]/g,
    alternative: "N"
  }, {
    letter: /[\u045A]/g,
    alternative: "nj"
  }, {
    letter: /[\u040A]/g,
    alternative: "Nj"
  }, {
    letter: /[\u043E]/g,
    alternative: "o"
  }, {
    letter: /[\u041E]/g,
    alternative: "O"
  }, {
    letter: /[\u0440]/g,
    alternative: "r"
  }, {
    letter: /[\u0420]/g,
    alternative: "R"
  }, {
    letter: /[\u043F]/g,
    alternative: "p"
  }, {
    letter: /[\u041F]/g,
    alternative: "P"
  }, {
    letter: /[\u0441]/g,
    alternative: "s"
  }, {
    letter: /[\u0421]/g,
    alternative: "S"
  }, {
    letter: /[\u0442]/g,
    alternative: "t"
  }, {
    letter: /[\u0422]/g,
    alternative: "T"
  }, {
    letter: /[\u045C]/g,
    alternative: "kj"
  }, {
    letter: /[\u040C]/g,
    alternative: "Kj"
  }, {
    letter: /[\u0443]/g,
    alternative: "u"
  }, {
    letter: /[\u0423]/g,
    alternative: "U"
  }, {
    letter: /[\u0444]/g,
    alternative: "f"
  }, {
    letter: /[\u0424]/g,
    alternative: "F"
  }, {
    letter: /[\u0445]/g,
    alternative: "h"
  }, {
    letter: /[\u0425]/g,
    alternative: "H"
  }, {
    letter: /[\u0446]/g,
    alternative: "c"
  }, {
    letter: /[\u0426]/g,
    alternative: "C"
  }, {
    letter: /[\u0447]/g,
    alternative: "ch"
  }, {
    letter: /[\u0427]/g,
    alternative: "Ch"
  }, {
    letter: /[\u045F]/g,
    alternative: "dj"
  }, {
    letter: /[\u040F]/g,
    alternative: "Dj"
  }, {
    letter: /[\u0448]/g,
    alternative: "sh"
  }, {
    letter: /[\u0428]/g,
    alternative: "Sh"
  }],
  // Language: Maori.
  // Source: http://www.omniglot.com/writing/maori.htm
  mri: [{
    letter: /[\u0101]/g,
    alternative: "aa"
  }, {
    letter: /[\u0100]/g,
    alternative: "Aa"
  }, {
    letter: /[\u0113]/g,
    alternative: "ee"
  }, {
    letter: /[\u0112]/g,
    alternative: "Ee"
  }, {
    letter: /[\u012b]/g,
    alternative: "ii"
  }, {
    letter: /[\u012a]/g,
    alternative: "Ii"
  }, {
    letter: /[\u014d]/g,
    alternative: "oo"
  }, {
    letter: /[\u014c]/g,
    alternative: "Oo"
  }, {
    letter: /[\u016b]/g,
    alternative: "uu"
  }, {
    letter: /[\u016a]/g,
    alternative: "Uu"
  }],
  // Language: Mirandese.
  // Source: http://www.omniglot.com/writing/mirandese.htm
  mwl: [{
    letter: /[\u00e7]/g,
    alternative: "c"
  }, {
    letter: /[\u00c7]/g,
    alternative: "C"
  }, {
    letter: /[\u00e1]/g,
    alternative: "a"
  }, {
    letter: /[\u00c1]/g,
    alternative: "A"
  }, {
    letter: /[\u00e9\u00ea]/g,
    alternative: "e"
  }, {
    letter: /[\u00c9\u00ca]/g,
    alternative: "E"
  }, {
    letter: /[\u00ed]/g,
    alternative: "i"
  }, {
    letter: /[\u00cd]/g,
    alternative: "I"
  }, {
    letter: /[\u00f3\u00f4]/g,
    alternative: "o"
  }, {
    letter: /[\u00d3\u00d4]/g,
    alternative: "O"
  }, {
    letter: /[\u00fa\u0169]/g,
    alternative: "u"
  }, {
    letter: /[\u00da\u0168]/g,
    alternative: "U"
  }],
  // Language: Occitan.
  // Sources: http://www.omniglot.com/writing/oromo.htm https://en.wikipedia.org/wiki/Occitan_alphabet
  oci: [{
    letter: /[\u00e7]/g,
    alternative: "c"
  }, {
    letter: /[\u00c7]/g,
    alternative: "C"
  }, {
    letter: /[\u00e0\u00e1]/g,
    alternative: "a"
  }, {
    letter: /[\u00c0\u00c1]/g,
    alternative: "A"
  }, {
    letter: /[\u00e8\u00e9]/g,
    alternative: "e"
  }, {
    letter: /[\u00c8\u00c9]/g,
    alternative: "E"
  }, {
    letter: /[\u00ed\u00ef]/g,
    alternative: "i"
  }, {
    letter: /[\u00cd\u00cf]/g,
    alternative: "I"
  }, {
    letter: /[\u00f2\u00f3]/g,
    alternative: "o"
  }, {
    letter: /[\u00d2\u00d3]/g,
    alternative: "O"
  }, {
    letter: /[\u00fa\u00fc]/g,
    alternative: "u"
  }, {
    letter: /[\u00da\u00dc]/g,
    alternative: "U"
  }, {
    letter: /[\u00b7]/g,
    alternative: ""
  }],
  // Language: Oromo.
  // Source: http://www.omniglot.com/writing/occitan.htm
  orm: [{
    letter: /[\u0027]/g,
    alternative: ""
  }],
  // Language: Portuguese.
  // Source: https://en.wikipedia.org/wiki/Portuguese_orthography http://www.omniglot.com/writing/portuguese.htm
  pt: [{
    letter: /[\u00e7]/g,
    alternative: "c"
  }, {
    letter: /[\u00c7]/g,
    alternative: "C"
  }, {
    letter: /[\u00e1\u00e2\u00e3\u00e0]/g,
    alternative: "a"
  }, {
    letter: /[\u00c1\u00c2\u00c3\u00c0]/g,
    alternative: "A"
  }, {
    letter: /[\u00e9\u00ea]/g,
    alternative: "e"
  }, {
    letter: /[\u00c9\u00ca]/g,
    alternative: "E"
  }, {
    letter: /[\u00ed]/g,
    alternative: "i"
  }, {
    letter: /[\u00cd]/g,
    alternative: "I"
  }, {
    letter: /[\u00f3\u00f4\u00f5]/g,
    alternative: "o"
  }, {
    letter: /[\u00d3\u00d4\u00d5]/g,
    alternative: "O"
  }, {
    letter: /[\u00fa]/g,
    alternative: "u"
  }, {
    letter: /[\u00da]/g,
    alternative: "U"
  }],
  // Language: Romansh Vallader.
  // Source: https://en.wikipedia.org/wiki/Romansh_language#Orthography http://www.omniglot.com/writing/romansh.htm
  roh: [{
    letter: /[\u00e9\u00e8\u00ea]/g,
    alternative: "e"
  }, {
    letter: /[\u00c9\u00c8\u00ca]/g,
    alternative: "E"
  }, {
    letter: /[\u00ef]/g,
    alternative: "i"
  }, {
    letter: /[\u00cf]/g,
    alternative: "I"
  }, {
    letter: /[\u00f6]/g,
    alternative: "oe"
  }, {
    letter: /[\u00d6]/g,
    alternative: "Oe"
  }, {
    letter: /[\u00fc]/g,
    alternative: "ue"
  }, {
    letter: /[\u00dc]/g,
    alternative: "Ue"
  }, {
    letter: /[\u00e4]/g,
    alternative: "ae"
  }, {
    letter: /[\u00c4]/g,
    alternative: "Ae"
  }],
  // Language: Aromanian.
  // Sources: https://en.wikipedia.org/wiki/Aromanian_alphabet http://www.omniglot.com/writing/aromanian.htm
  rup: [{
    letter: /[\u00e3]/g,
    alternative: "a"
  }, {
    letter: /[\u00c3]/g,
    alternative: "A"
  }],
  // Language: Romanian.
  // Sources: http://forum.wordreference.com/threads/romanian-transliteration.3193544/#post-16161251
  // https://en.wikipedia.org/wiki/Romanian_alphabet http://www.omniglot.com/writing/romanian.htm
  ro: [{
    letter: /[\u0103\u00e2]/g,
    alternative: "a"
  }, {
    letter: /[\u0102\u00c2]/g,
    alternative: "A"
  }, {
    letter: /[\u00ee]/g,
    alternative: "i"
  }, {
    letter: /[\u00ce]/g,
    alternative: "I"
  }, {
    letter: /[\u0219\u015f]/g,
    alternative: "s"
  }, {
    letter: /[\u0218\u015e]/g,
    alternative: "S"
  }, {
    letter: /[\u021b\u0163]/g,
    alternative: "t"
  }, {
    letter: /[\u021a\u0162]/g,
    alternative: "T"
  }],
  // Language: Klingon.
  // Sources: http://www.omniglot.com/conscripts/klingon.htm https://en.wikipedia.org/wiki/Klingon_language#Writing_systems
  // This translation module only works for Klingon written in Latin characters. KLI PlqaD script is not supported yet.
  tlh: [{
    letter: /[\u2019\u0027]/g,
    alternative: ""
  }],
  // Language: Slovak.
  // Sources: https://en.wikipedia.org/wiki/Dz_(digraph) https://en.wikipedia.org/wiki/Slovak_orthography
  // http://www.omniglot.com/writing/slovak.htm
  sk: [{
    letter: /[\u01c4]/g,
    alternative: "DZ"
  }, {
    letter: /[\u01c5]/g,
    alternative: "Dz"
  }, {
    letter: /[\u01c6]/g,
    alternative: "dz"
  }, {
    letter: /[\u00e1\u00e4]/g,
    alternative: "a"
  }, {
    letter: /[\u00c1\u00c4]/g,
    alternative: "A"
  }, {
    letter: /[\u010d]/g,
    alternative: "c"
  }, {
    letter: /[\u010c]/g,
    alternative: "C"
  }, {
    letter: /[\u010f]/g,
    alternative: "d"
  }, {
    letter: /[\u010e]/g,
    alternative: "D"
  }, {
    letter: /[\u00e9]/g,
    alternative: "e"
  }, {
    letter: /[\u00c9]/g,
    alternative: "E"
  }, {
    letter: /[\u00ed]/g,
    alternative: "i"
  }, {
    letter: /[\u00cd]/g,
    alternative: "I"
  }, {
    letter: /[\u013e\u013a]/g,
    alternative: "l"
  }, {
    letter: /[\u013d\u0139]/g,
    alternative: "L"
  }, {
    letter: /[\u0148]/g,
    alternative: "n"
  }, {
    letter: /[\u0147]/g,
    alternative: "N"
  }, {
    letter: /[\u00f3\u00f4]/g,
    alternative: "o"
  }, {
    letter: /[\u00d3\u00d4]/g,
    alternative: "O"
  }, {
    letter: /[\u0155]/g,
    alternative: "r"
  }, {
    letter: /[\u0154]/g,
    alternative: "R"
  }, {
    letter: /[\u0161]/g,
    alternative: "s"
  }, {
    letter: /[\u0160]/g,
    alternative: "S"
  }, {
    letter: /[\u0165]/g,
    alternative: "t"
  }, {
    letter: /[\u0164]/g,
    alternative: "T"
  }, {
    letter: /[\u00fa]/g,
    alternative: "u"
  }, {
    letter: /[\u00da]/g,
    alternative: "U"
  }, {
    letter: /[\u00fd]/g,
    alternative: "y"
  }, {
    letter: /[\u00dd]/g,
    alternative: "Y"
  }, {
    letter: /[\u017e]/g,
    alternative: "z"
  }, {
    letter: /[\u017d]/g,
    alternative: "Z"
  }],
  // Language: Slovenian.
  // Sources: https://en.wikipedia.org/wiki/Slovene_alphabet http://www.omniglot.com/writing/slovene.htm
  sl: [{
    letter: /[\u010d\u0107]/g,
    alternative: "c"
  }, {
    letter: /[\u010c\u0106]/g,
    alternative: "C"
  }, {
    letter: /[\u0111]/g,
    alternative: "d"
  }, {
    letter: /[\u0110]/g,
    alternative: "D"
  }, {
    letter: /[\u0161]/g,
    alternative: "s"
  }, {
    letter: /[\u0160]/g,
    alternative: "S"
  }, {
    letter: /[\u017e]/g,
    alternative: "z"
  }, {
    letter: /[\u017d]/g,
    alternative: "Z"
  }, {
    letter: /[\u00e0\u00e1\u0203\u0201]/g,
    alternative: "a"
  }, {
    letter: /[\u00c0\u00c1\u0202\u0200]/g,
    alternative: "A"
  }, {
    letter: /[\u00e8\u00e9\u0207\u0205]/g,
    alternative: "e"
  }, {
    letter: /\u01dd\u0300/g,
    alternative: "e"
  }, {
    letter: /\u01dd\u030f/g,
    alternative: "e"
  }, {
    letter: /\u1eb9\u0301/g,
    alternative: "e"
  }, {
    letter: /\u1eb9\u0311/g,
    alternative: "e"
  }, {
    letter: /[\u00c8\u00c9\u0206\u0204]/g,
    alternative: "E"
  }, {
    letter: /\u018e\u030f/g,
    alternative: "E"
  }, {
    letter: /\u018e\u0300/g,
    alternative: "E"
  }, {
    letter: /\u1eb8\u0311/g,
    alternative: "E"
  }, {
    letter: /\u1eb8\u0301/g,
    alternative: "E"
  }, {
    letter: /[\u00ec\u00ed\u020b\u0209]/g,
    alternative: "i"
  }, {
    letter: /[\u00cc\u00cd\u020a\u0208]/g,
    alternative: "I"
  }, {
    letter: /[\u00f2\u00f3\u020f\u020d]/g,
    alternative: "o"
  }, {
    letter: /\u1ecd\u0311/g,
    alternative: "o"
  }, {
    letter: /\u1ecd\u0301/g,
    alternative: "o"
  }, {
    letter: /\u1ecc\u0311/g,
    alternative: "O"
  }, {
    letter: /\u1ecc\u0301/g,
    alternative: "O"
  }, {
    letter: /[\u00d2\u00d3\u020e\u020c]/g,
    alternative: "O"
  }, {
    letter: /[\u00f9\u00fa\u0217\u0215]/g,
    alternative: "u"
  }, {
    letter: /[\u00d9\u00da\u0216\u0214]/g,
    alternative: "U"
  }, {
    letter: /[\u0155\u0213]/g,
    alternative: "r"
  }, {
    letter: /[\u0154\u0212]/g,
    alternative: "R"
  }],
  // Language: Albanian.
  // Sources: https://en.wikipedia.org/wiki/Albanian_alphabet http://www.omniglot.com/writing/albanian.htm
  sq: [{
    letter: /[\u00e7]/g,
    alternative: "c"
  }, {
    letter: /[\u00c7]/g,
    alternative: "C"
  }, {
    letter: /[\u00eb]/g,
    alternative: "e"
  }, {
    letter: /[\u00cb]/g,
    alternative: "E"
  }],
  // Language: Hungarian.
  // Sources: http://forum.wordreference.com/threads/hungarian-transliteration.3193022/#post-16166901
  // http://www.omniglot.com/writing/hungarian.htm
  hu: [{
    letter: /[\u00e1]/g,
    alternative: "a"
  }, {
    letter: /[\u00c1]/g,
    alternative: "A"
  }, {
    letter: /[\u00e9]/g,
    alternative: "e"
  }, {
    letter: /[\u00c9]/g,
    alternative: "E"
  }, {
    letter: /[\u00ed]/g,
    alternative: "i"
  }, {
    letter: /[\u00cd]/g,
    alternative: "I"
  }, {
    letter: /[\u00f3\u00f6\u0151]/g,
    alternative: "o"
  }, {
    letter: /[\u00d3\u00d6\u0150]/g,
    alternative: "O"
  }, {
    letter: /[\u00fa\u00fc\u0171]/g,
    alternative: "u"
  }, {
    letter: /[\u00da\u00dc\u0170]/g,
    alternative: "U"
  }],
  // Language: Sardinian.
  // Sources: http://www.omniglot.com/writing/sardinian.htm https://en.wikipedia.org/wiki/Sardinian_language
  srd: [{
    letter: /[\u00e7]/g,
    alternative: "c"
  }, {
    letter: /[\u00c7]/g,
    alternative: "C"
  }, {
    letter: /[\u00e0\u00e1]/g,
    alternative: "a"
  }, {
    letter: /[\u00c0\u00c1]/g,
    alternative: "A"
  }, {
    letter: /[\u00e8\u00e9]/g,
    alternative: "e"
  }, {
    letter: /[\u00c8\u00c9]/g,
    alternative: "E"
  }, {
    letter: /[\u00ed\u00ef]/g,
    alternative: "i"
  }, {
    letter: /[\u00cd\u00cf]/g,
    alternative: "I"
  }, {
    letter: /[\u00f2\u00f3]/g,
    alternative: "o"
  }, {
    letter: /[\u00d2\u00d3]/g,
    alternative: "O"
  }, {
    letter: /[\u00fa\u00f9]/g,
    alternative: "u"
  }, {
    letter: /[\u00da\u00d9]/g,
    alternative: "U"
  }],
  // Language: Silesian.
  // Source: https://en.wikipedia.org/wiki/Silesian_language#Writing_system
  szl: [{
    letter: /[\u0107]/g,
    alternative: "c"
  }, {
    letter: /[\u0106]/g,
    alternative: "C"
  }, {
    letter: /[\u00e3]/g,
    alternative: "a"
  }, {
    letter: /[\u00c3]/g,
    alternative: "A"
  }, {
    letter: /[\u0142]/g,
    alternative: "u"
  }, {
    letter: /[\u0141]/g,
    alternative: "U"
  }, {
    letter: /[\u006e]/g,
    alternative: "n"
  }, {
    letter: /[\u004e]/g,
    alternative: "N"
  }, {
    letter: /[\u014f\u014d\u00f4\u00f5]/g,
    alternative: "o"
  }, {
    letter: /[\u014e\u014c\u00d4\u00d5]/g,
    alternative: "O"
  }, {
    letter: /[\u015b]/g,
    alternative: "s"
  }, {
    letter: /[\u015a]/g,
    alternative: "S"
  }, {
    letter: /[\u017a\u017c\u017e]/g,
    alternative: "z"
  }, {
    letter: /[\u0179\u017b\u017d]/g,
    alternative: "Z"
  }, {
    letter: /[\u016f]/g,
    alternative: "u"
  }, {
    letter: /[\u016e]/g,
    alternative: "U"
  }, {
    letter: /[\u010d]/g,
    alternative: "cz"
  }, {
    letter: /[\u010c]/g,
    alternative: "Cz"
  }, {
    letter: /[\u0159]/g,
    alternative: "rz"
  }, {
    letter: /[\u0158]/g,
    alternative: "Rz"
  }, {
    letter: /[\u0161]/g,
    alternative: "sz"
  }, {
    letter: /[\u0160]/g,
    alternative: "Sz"
  }],
  // Language: Tahitian.
  // Sources: https://en.wikipedia.org/wiki/Tahitian_language#Phonology http://www.omniglot.com/writing/tahitian.htm
  tah: [{
    letter: /[\u0101\u00e2\u00e0]/g,
    alternative: "a"
  }, {
    letter: /[\u0100\u00c2\u00c0]/g,
    alternative: "A"
  }, {
    letter: /[\u00ef\u00ee\u00ec]/g,
    alternative: "i"
  }, {
    letter: /[\u00cf\u00ce\u00cc]/g,
    alternative: "I"
  }, {
    letter: /[\u0113\u00ea\u00e9]/g,
    alternative: "e"
  }, {
    letter: /[\u0112\u00ca\u00c9]/g,
    alternative: "E"
  }, {
    letter: /[\u016b\u00fb\u00fa]/g,
    alternative: "u"
  }, {
    letter: /[\u016a\u00db\u00da]/g,
    alternative: "U"
  }, {
    letter: /[\u00e7]/g,
    alternative: "c"
  }, {
    letter: /[\u00c7]/g,
    alternative: "C"
  }, {
    letter: /[\u00f2\u00f4\u014d]/g,
    alternative: "o"
  }, {
    letter: /[\u00d2\u00d4\u014c]/g,
    alternative: "O"
  }, {
    letter: /[\u2019\u0027\u2018]/g,
    alternative: ""
  }],
  // Language: Venetian.
  // Sources: http://www.omniglot.com/writing/venetian.htm https://en.wikipedia.org/wiki/Venetian_language#Spelling_systems
  // http://www.venipedia.org/wiki/index.php?title=Venetian_Language
  vec: [{
    letter: /\u0073\u002d\u0063/g,
    alternative: "sc"
  }, {
    letter: /\u0053\u002d\u0043/g,
    alternative: "SC"
  }, {
    letter: /\u0073\u0027\u0063/g,
    alternative: "sc"
  }, {
    letter: /\u0053\u0027\u0043/g,
    alternative: "SC"
  }, {
    letter: /\u0073\u2019\u0063/g,
    alternative: "sc"
  }, {
    letter: /\u0053\u2019\u0043/g,
    alternative: "SC"
  }, {
    letter: /\u0073\u2018\u0063/g,
    alternative: "sc"
  }, {
    letter: /\u0053\u2018\u0043/g,
    alternative: "SC"
  }, {
    letter: /\u0053\u002d\u0063/g,
    alternative: "Sc"
  }, {
    letter: /\u0053\u0027\u0063/g,
    alternative: "Sc"
  }, {
    letter: /\u0053\u2019\u0063/g,
    alternative: "Sc"
  }, {
    letter: /\u0053\u2018\u0063/g,
    alternative: "Sc"
  }, {
    letter: /\u0063\u2019/g,
    alternative: "c"
  }, {
    letter: /\u0043\u2019/g,
    alternative: "C"
  }, {
    letter: /\u0063\u2018/g,
    alternative: "c"
  }, {
    letter: /\u0043\u2018/g,
    alternative: "C"
  }, {
    letter: /\u0063\u0027/g,
    alternative: "c"
  }, {
    letter: /\u0043\u0027/g,
    alternative: "C"
  }, {
    letter: /[\u00e0\u00e1\u00e2]/g,
    alternative: "a"
  }, {
    letter: /[\u00c0\u00c1\u00c2]/g,
    alternative: "A"
  }, {
    letter: /[\u00e8\u00e9]/g,
    alternative: "e"
  }, {
    letter: /[\u00c8\u00c9]/g,
    alternative: "E"
  }, {
    letter: /[\u00f2\u00f3]/g,
    alternative: "o"
  }, {
    letter: /[\u00d2\u00d3]/g,
    alternative: "O"
  }, {
    letter: /[\u00f9\u00fa]/g,
    alternative: "u"
  }, {
    letter: /[\u00d9\u00da]/g,
    alternative: "U"
  }, {
    letter: /[\u00e7\u010d\u010b]/g,
    alternative: "c"
  }, {
    letter: /[\u00c7\u010c\u010a]/g,
    alternative: "C"
  }, {
    letter: /[\u0142]/g,
    alternative: "l"
  }, {
    letter: /[\u00a3\u0141]/g,
    alternative: "L"
  }, {
    letter: /\ud835\udeff/g,
    alternative: "dh"
  }, {
    letter: /[\u0111\u03b4]/g,
    alternative: "dh"
  }, {
    letter: /[\u0110\u0394]/g,
    alternative: "Dh"
  }],
  // Language: Walloon.
  // Sources: http://www.omniglot.com/writing/walloon.htm https://en.wikipedia.org/wiki/Walloon_alphabet
  wa: [{
    letter: /[\u00e2\u00e5]/g,
    alternative: "a"
  }, {
    letter: /[\u00c2\u00c5]/g,
    alternative: "A"
  }, {
    letter: /[\u00e7]/g,
    alternative: "c"
  }, {
    letter: /[\u00c7]/g,
    alternative: "C"
  }, {
    letter: /\u0065\u030a/g,
    alternative: "e"
  }, {
    letter: /\u0045\u030a/g,
    alternative: "E"
  }, {
    letter: /[\u00eb\u00ea\u00e8\u00e9]/g,
    alternative: "e"
  }, {
    letter: /[\u00c9\u00c8\u00ca\u00cb]/g,
    alternative: "E"
  }, {
    letter: /[\u00ee]/g,
    alternative: "i"
  }, {
    letter: /[\u00ce]/g,
    alternative: "I"
  }, {
    letter: /[\u00f4\u00f6]/g,
    alternative: "o"
  }, {
    letter: /[\u00d6\u00d4]/g,
    alternative: "O"
  }, {
    letter: /[\u00fb]/g,
    alternative: "u"
  }, {
    letter: /[\u00db]/g,
    alternative: "U"
  }],
  // Language: Yoruba.
  // Sources: http://www.omniglot.com/writing/yoruba.htm https://en.wikipedia.org/wiki/Yoruba_language
  yor: [{
    letter: /[\u00e1\u00e0]/g,
    alternative: "a"
  }, {
    letter: /[\u00c1\u00c0]/g,
    alternative: "A"
  }, {
    letter: /[\u00ec\u00ed]/g,
    alternative: "i"
  }, {
    letter: /[\u00cc\u00cd]/g,
    alternative: "I"
  }, {
    letter: /\u1ecd\u0301/g,
    alternative: "o"
  }, {
    letter: /\u1ecc\u0301/g,
    alternative: "O"
  }, {
    letter: /\u1ecd\u0300/g,
    alternative: "o"
  }, {
    letter: /\u1ecc\u0300/g,
    alternative: "O"
  }, {
    letter: /[\u00f3\u00f2\u1ecd]/g,
    alternative: "o"
  }, {
    letter: /[\u00d3\u00d2\u1ecc]/g,
    alternative: "O"
  }, {
    letter: /[\u00fa\u00f9]/g,
    alternative: "u"
  }, {
    letter: /[\u00da\u00d9]/g,
    alternative: "U"
  }, {
    letter: /\u1eb9\u0301/g,
    alternative: "e"
  }, {
    letter: /\u1eb8\u0301/g,
    alternative: "E"
  }, {
    letter: /\u1eb9\u0300/g,
    alternative: "e"
  }, {
    letter: /\u1eb8\u0300/g,
    alternative: "E"
  }, {
    letter: /[\u00e9\u00e8\u1eb9]/g,
    alternative: "e"
  }, {
    letter: /[\u00c9\u00c8\u1eb8]/g,
    alternative: "E"
  }, {
    letter: /[\u1e63]/g,
    alternative: "s"
  }, {
    letter: /[\u1e62]/g,
    alternative: "S"
  }]
};

/**
 * Returns an array containing transliteration objects, based on the given locale.
 *
 * @param {string} locale The locale.
 *
 * @returns {Object[]} An array containing transliteration objects.
 */
function _default(locale) {
  if ((0, _lodash.isUndefined)(locale)) {
    return [];
  }
  const language = (0, _getLanguage.default)(locale);
  if (language === "nb" || language === "nn") {
    return transliterations.nbnn;
  }
  if (language === "bal" || language === "ca") {
    return transliterations.ca;
  }
  return transliterations[language] || [];
}

/***/ }),

/***/ "./node_modules/yoastseo/build/config/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/yoastseo/build/config/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "presenter", ({
  enumerable: true,
  get: function () {
    return _presenter.default;
  }
}));
var _presenter = _interopRequireDefault(__webpack_require__(/*! ./presenter */ "./node_modules/yoastseo/build/config/presenter.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/config/presenter.js":
/*!*********************************************************!*\
  !*** ./node_modules/yoastseo/build/config/presenter.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
/**
 * Returns the configuration used for score ratings and the AssessorPresenter.
 * @returns {Object} The config object.
 */
function _default() {
  const contentOptimizationLabel = (0, _i18n.__)("Content optimization:", "wordpress-seo");
  return {
    feedback: {
      className: "na",
      screenReaderText: (0, _i18n.__)("Feedback", "wordpress-seo"),
      fullText: `${contentOptimizationLabel} ${(0, _i18n.__)("Has feedback", "wordpress-seo")}`,
      screenReaderReadabilityText: ""
    },
    bad: {
      className: "bad",
      screenReaderText: (0, _i18n.__)("Needs improvement", "wordpress-seo"),
      fullText: `${contentOptimizationLabel} ${(0, _i18n.__)("Needs improvement", "wordpress-seo")}`,
      screenReaderReadabilityText: (0, _i18n.__)("Needs improvement", "wordpress-seo")
    },
    ok: {
      className: "ok",
      screenReaderText: (0, _i18n.__)("OK SEO score", "wordpress-seo"),
      fullText: `${contentOptimizationLabel} ${(0, _i18n.__)("OK SEO score", "wordpress-seo")}`,
      screenReaderReadabilityText: (0, _i18n.__)("OK", "wordpress-seo")
    },
    good: {
      className: "good",
      screenReaderText: (0, _i18n.__)("Good SEO score", "wordpress-seo"),
      fullText: `${contentOptimizationLabel} ${(0, _i18n.__)("Good SEO score", "wordpress-seo")}`,
      screenReaderReadabilityText: (0, _i18n.__)("Good", "wordpress-seo")
    }
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/config/transliterationsWPstyle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/yoastseo/build/config/transliterationsWPstyle.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _getLanguage = _interopRequireDefault(__webpack_require__(/*! ../languageProcessing/helpers/language/getLanguage.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/language/getLanguage.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/*
 * The list of accent characters and their ASCII alternatives is taken from wordpress-develop-mirror/blob/master/src/wp-includes/formatting.php.
 */

const transliterationsGeneral = [
/*
 * These transliteration objects are not language-specific, and will be applied independently on the locale.
 *
 * Currency signs:
 *
 * |   Code   | Glyph | Replacement |     Description     |
 * | -------- | ----- | ----------- | ------------------- |
 * | U+00A3   | £     | (empty)     | British Pound sign  |
 * | U+20AC   | €     | E           | Euro sign           |
 *
 * Decompositions for Latin-1 Supplement:
 *
 * |  Code   | Glyph | Replacement |               Description              |
 * | ------- | ----- | ----------- | -------------------------------------- |
 * | U+00AA  | ª     | a           | Feminine ordinal indicator             |
 * | U+00BA  | º     | o           | Masculine ordinal indicator            |
 * | U+00C0  | À     | A           | Latin capital letter A with grave      |
 * | U+00C1  | Á     | A           | Latin capital letter A with acute      |
 * | U+00C2  | Â     | A           | Latin capital letter A with circumflex |
 * | U+00C3  | Ã     | A           | Latin capital letter A with tilde      |
 * | U+00C4  | Ä     | A           | Latin capital letter A with diaeresis  |
 * | U+00C5  | Å     | A           | Latin capital letter A with ring above |
 * | U+00C6  | Æ     | AE          | Latin capital letter AE                |
 * | U+00C7  | Ç     | C           | Latin capital letter C with cedilla    |
 * | U+00C8  | È     | E           | Latin capital letter E with grave      |
 * | U+00C9  | É     | E           | Latin capital letter E with acute      |
 * | U+00CA  | Ê     | E           | Latin capital letter E with circumflex |
 * | U+00CB  | Ë     | E           | Latin capital letter E with diaeresis  |
 * | U+00CC  | Ì     | I           | Latin capital letter I with grave      |
 * | U+00CD  | Í     | I           | Latin capital letter I with acute      |
 * | U+00CE  | Î     | I           | Latin capital letter I with circumflex |
 * | U+00CF  | Ï     | I           | Latin capital letter I with diaeresis  |
 * | U+00D0  | Ð     | D           | Latin capital letter Eth               |
 * | U+00D1  | Ñ     | N           | Latin capital letter N with tilde      |
 * | U+00D2  | Ò     | O           | Latin capital letter O with grave      |
 * | U+00D3  | Ó     | O           | Latin capital letter O with acute      |
 * | U+00D4  | Ô     | O           | Latin capital letter O with circumflex |
 * | U+00D5  | Õ     | O           | Latin capital letter O with tilde      |
 * | U+00D6  | Ö     | O           | Latin capital letter O with diaeresis  |
 * | U+00D8  | Ø     | O           | Latin capital letter O with stroke     |
 * | U+00D9  | Ù     | U           | Latin capital letter U with grave      |
 * | U+00DA  | Ú     | U           | Latin capital letter U with acute      |
 * | U+00DB  | Û     | U           | Latin capital letter U with circumflex |
 * | U+00DC  | Ü     | U           | Latin capital letter U with diaeresis  |
 * | U+00DD  | Ý     | Y           | Latin capital letter Y with acute      |
 * | U+00DE  | Þ     | TH          | Latin capital letter Thorn             |
 * | U+00DF  | ß     | s           | Latin small letter sharp s             |
 * | U+00E0  | à     | a           | Latin small letter a with grave        |
 * | U+00E1  | á     | a           | Latin small letter a with acute        |
 * | U+00E2  | â     | a           | Latin small letter a with circumflex   |
 * | U+00E3  | ã     | a           | Latin small letter a with tilde        |
 * | U+00E4  | ä     | a           | Latin small letter a with diaeresis    |
 * | U+00E5  | å     | a           | Latin small letter a with ring above   |
 * | U+00E6  | æ     | ae          | Latin small letter ae                  |
 * | U+00E7  | ç     | c           | Latin small letter c with cedilla      |
 * | U+00E8  | è     | e           | Latin small letter e with grave        |
 * | U+00E9  | é     | e           | Latin small letter e with acute        |
 * | U+00EA  | ê     | e           | Latin small letter e with circumflex   |
 * | U+00EB  | ë     | e           | Latin small letter e with diaeresis    |
 * | U+00EC  | ì     | i           | Latin small letter i with grave        |
 * | U+00ED  | í     | i           | Latin small letter i with acute        |
 * | U+00EE  | î     | i           | Latin small letter i with circumflex   |
 * | U+00EF  | ï     | i           | Latin small letter i with diaeresis    |
 * | U+00F0  | ð     | d           | Latin small letter Eth                 |
 * | U+00F1  | ñ     | n           | Latin small letter n with tilde        |
 * | U+00F2  | ò     | o           | Latin small letter o with grave        |
 * | U+00F3  | ó     | o           | Latin small letter o with acute        |
 * | U+00F4  | ô     | o           | Latin small letter o with circumflex   |
 * | U+00F5  | õ     | o           | Latin small letter o with tilde        |
 * | U+00F6  | ö     | o           | Latin small letter o with diaeresis    |
 * | U+00F8  | ø     | o           | Latin small letter o with stroke       |
 * | U+00F9  | ù     | u           | Latin small letter u with grave        |
 * | U+00FA  | ú     | u           | Latin small letter u with acute        |
 * | U+00FB  | û     | u           | Latin small letter u with circumflex   |
 * | U+00FC  | ü     | u           | Latin small letter u with diaeresis    |
 * | U+00FD  | ý     | y           | Latin small letter y with acute        |
 * | U+00FE  | þ     | th          | Latin small letter Thorn               |
 * | U+00FF  | ÿ     | y           | Latin small letter y with diaeresis    |
 *
 * Decompositions for Latin Extended-A:
 *
 * |  Code   | Glyph | Replacement |                    Description                    |
 * | ------- | ----- | ----------- | ------------------------------------------------- |
 * | U+0100  | Ā     | A           | Latin capital letter A with macron                |
 * | U+0101  | ā     | a           | Latin small letter a with macron                  |
 * | U+0102  | Ă     | A           | Latin capital letter A with breve                 |
 * | U+0103  | ă     | a           | Latin small letter a with breve                   |
 * | U+0104  | Ą     | A           | Latin capital letter A with ogonek                |
 * | U+0105  | ą     | a           | Latin small letter a with ogonek                  |
 * | U+0106  | Ć     | C           | Latin capital letter C with acute                 |
 * | U+0107  | ć     | c           | Latin small letter c with acute                   |
 * | U+0108  | Ĉ     | C           | Latin capital letter C with circumflex            |
 * | U+0109  | ĉ     | c           | Latin small letter c with circumflex              |
 * | U+010A  | Ċ     | C           | Latin capital letter C with dot above             |
 * | U+010B  | ċ     | c           | Latin small letter c with dot above               |
 * | U+010C  | Č     | C           | Latin capital letter C with caron                 |
 * | U+010D  | č     | c           | Latin small letter c with caron                   |
 * | U+010E  | Ď     | D           | Latin capital letter D with caron                 |
 * | U+010F  | ď     | d           | Latin small letter d with caron                   |
 * | U+0110  | Đ     | D           | Latin capital letter D with stroke                |
 * | U+0111  | đ     | d           | Latin small letter d with stroke                  |
 * | U+0112  | Ē     | E           | Latin capital letter E with macron                |
 * | U+0113  | ē     | e           | Latin small letter e with macron                  |
 * | U+0114  | Ĕ     | E           | Latin capital letter E with breve                 |
 * | U+0115  | ĕ     | e           | Latin small letter e with breve                   |
 * | U+0116  | Ė     | E           | Latin capital letter E with dot above             |
 * | U+0117  | ė     | e           | Latin small letter e with dot above               |
 * | U+0118  | Ę     | E           | Latin capital letter E with ogonek                |
 * | U+0119  | ę     | e           | Latin small letter e with ogonek                  |
 * | U+011A  | Ě     | E           | Latin capital letter E with caron                 |
 * | U+011B  | ě     | e           | Latin small letter e with caron                   |
 * | U+011C  | Ĝ     | G           | Latin capital letter G with circumflex            |
 * | U+011D  | ĝ     | g           | Latin small letter g with circumflex              |
 * | U+011E  | Ğ     | G           | Latin capital letter G with breve                 |
 * | U+011F  | ğ     | g           | Latin small letter g with breve                   |
 * | U+0120  | Ġ     | G           | Latin capital letter G with dot above             |
 * | U+0121  | ġ     | g           | Latin small letter g with dot above               |
 * | U+0122  | Ģ     | G           | Latin capital letter G with cedilla               |
 * | U+0123  | ģ     | g           | Latin small letter g with cedilla                 |
 * | U+0124  | Ĥ     | H           | Latin capital letter H with circumflex            |
 * | U+0125  | ĥ     | h           | Latin small letter h with circumflex              |
 * | U+0126  | Ħ     | H           | Latin capital letter H with stroke                |
 * | U+0127  | ħ     | h           | Latin small letter h with stroke                  |
 * | U+0128  | Ĩ     | I           | Latin capital letter I with tilde                 |
 * | U+0129  | ĩ     | i           | Latin small letter i with tilde                   |
 * | U+012A  | Ī     | I           | Latin capital letter I with macron                |
 * | U+012B  | ī     | i           | Latin small letter i with macron                  |
 * | U+012C  | Ĭ     | I           | Latin capital letter I with breve                 |
 * | U+012D  | ĭ     | i           | Latin small letter i with breve                   |
 * | U+012E  | Į     | I           | Latin capital letter I with ogonek                |
 * | U+012F  | į     | i           | Latin small letter i with ogonek                  |
 * | U+0130  | İ     | I           | Latin capital letter I with dot above             |
 * | U+0131  | ı     | i           | Latin small letter dotless i                      |
 * | U+0132  | Ĳ     | IJ          | Latin capital ligature IJ                         |
 * | U+0133  | ĳ     | ij          | Latin small ligature ij                           |
 * | U+0134  | Ĵ     | J           | Latin capital letter J with circumflex            |
 * | U+0135  | ĵ     | j           | Latin small letter j with circumflex              |
 * | U+0136  | Ķ     | K           | Latin capital letter K with cedilla               |
 * | U+0137  | ķ     | k           | Latin small letter k with cedilla                 |
 * | U+0138  | ĸ     | k           | Latin small letter Kra                            |
 * | U+0139  | Ĺ     | L           | Latin capital letter L with acute                 |
 * | U+013A  | ĺ     | l           | Latin small letter l with acute                   |
 * | U+013B  | Ļ     | L           | Latin capital letter L with cedilla               |
 * | U+013C  | ļ     | l           | Latin small letter l with cedilla                 |
 * | U+013D  | Ľ     | L           | Latin capital letter L with caron                 |
 * | U+013E  | ľ     | l           | Latin small letter l with caron                   |
 * | U+013F  | Ŀ     | L           | Latin capital letter L with middle dot            |
 * | U+0140  | ŀ     | l           | Latin small letter l with middle dot              |
 * | U+0141  | Ł     | L           | Latin capital letter L with stroke                |
 * | U+0142  | ł     | l           | Latin small letter l with stroke                  |
 * | U+0143  | Ń     | N           | Latin capital letter N with acute                 |
 * | U+0144  | ń     | n           | Latin small letter N with acute                   |
 * | U+0145  | Ņ     | N           | Latin capital letter N with cedilla               |
 * | U+0146  | ņ     | n           | Latin small letter n with cedilla                 |
 * | U+0147  | Ň     | N           | Latin capital letter N with caron                 |
 * | U+0148  | ň     | n           | Latin small letter n with caron                   |
 * | U+0149  | ŉ     | n           | Latin small letter n preceded by apostrophe       |
 * | U+014A  | Ŋ     | N           | Latin capital letter Eng                          |
 * | U+014B  | ŋ     | n           | Latin small letter Eng                            |
 * | U+014C  | Ō     | O           | Latin capital letter O with macron                |
 * | U+014D  | ō     | o           | Latin small letter o with macron                  |
 * | U+014E  | Ŏ     | O           | Latin capital letter O with breve                 |
 * | U+014F  | ŏ     | o           | Latin small letter o with breve                   |
 * | U+0150  | Ő     | O           | Latin capital letter O with double acute          |
 * | U+0151  | ő     | o           | Latin small letter o with double acute            |
 * | U+0152  | Œ     | OE          | Latin capital ligature OE                         |
 * | U+0153  | œ     | oe          | Latin small ligature oe                           |
 * | U+0154  | Ŕ     | R           | Latin capital letter R with acute                 |
 * | U+0155  | ŕ     | r           | Latin small letter r with acute                   |
 * | U+0156  | Ŗ     | R           | Latin capital letter R with cedilla               |
 * | U+0157  | ŗ     | r           | Latin small letter r with cedilla                 |
 * | U+0158  | Ř     | R           | Latin capital letter R with caron                 |
 * | U+0159  | ř     | r           | Latin small letter r with caron                   |
 * | U+015A  | Ś     | S           | Latin capital letter S with acute                 |
 * | U+015B  | ś     | s           | Latin small letter s with acute                   |
 * | U+015C  | Ŝ     | S           | Latin capital letter S with circumflex            |
 * | U+015D  | ŝ     | s           | Latin small letter s with circumflex              |
 * | U+015E  | Ş     | S           | Latin capital letter S with cedilla               |
 * | U+015F  | ş     | s           | Latin small letter s with cedilla                 |
 * | U+0160  | Š     | S           | Latin capital letter S with caron                 |
 * | U+0161  | š     | s           | Latin small letter s with caron                   |
 * | U+0162  | Ţ     | T           | Latin capital letter T with cedilla               |
 * | U+0163  | ţ     | t           | Latin small letter t with cedilla                 |
 * | U+0164  | Ť     | T           | Latin capital letter T with caron                 |
 * | U+0165  | ť     | t           | Latin small letter t with caron                   |
 * | U+0166  | Ŧ     | T           | Latin capital letter T with stroke                |
 * | U+0167  | ŧ     | t           | Latin small letter t with stroke                  |
 * | U+0168  | Ũ     | U           | Latin capital letter U with tilde                 |
 * | U+0169  | ũ     | u           | Latin small letter u with tilde                   |
 * | U+016A  | Ū     | U           | Latin capital letter U with macron                |
 * | U+016B  | ū     | u           | Latin small letter u with macron                  |
 * | U+016C  | Ŭ     | U           | Latin capital letter U with breve                 |
 * | U+016D  | ŭ     | u           | Latin small letter u with breve                   |
 * | U+016E  | Ů     | U           | Latin capital letter U with ring above            |
 * | U+016F  | ů     | u           | Latin small letter u with ring above              |
 * | U+0170  | Ű     | U           | Latin capital letter U with double acute          |
 * | U+0171  | ű     | u           | Latin small letter u with double acute            |
 * | U+0172  | Ų     | U           | Latin capital letter U with ogonek                |
 * | U+0173  | ų     | u           | Latin small letter u with ogonek                  |
 * | U+0174  | Ŵ     | W           | Latin capital letter W with circumflex            |
 * | U+0175  | ŵ     | w           | Latin small letter w with circumflex              |
 * | U+0176  | Ŷ     | Y           | Latin capital letter Y with circumflex            |
 * | U+0177  | ŷ     | y           | Latin small letter y with circumflex              |
 * | U+0178  | Ÿ     | Y           | Latin capital letter Y with diaeresis             |
 * | U+0179  | Ź     | Z           | Latin capital letter Z with acute                 |
 * | U+017A  | ź     | z           | Latin small letter z with acute                   |
 * | U+017B  | Ż     | Z           | Latin capital letter Z with dot above             |
 * | U+017C  | ż     | z           | Latin small letter z with dot above               |
 * | U+017D  | Ž     | Z           | Latin capital letter Z with caron                 |
 * | U+017E  | ž     | z           | Latin small letter z with caron                   |
 * | U+017F  | ſ     | s           | Latin small letter long s                         |
 * | U+01A0  | Ơ     | O           | Latin capital letter O with horn                  |
 * | U+01A1  | ơ     | o           | Latin small letter o with horn                    |
 * | U+01AF  | Ư     | U           | Latin capital letter U with horn                  |
 * | U+01B0  | ư     | u           | Latin small letter u with horn                    |
 * | U+01CD  | Ǎ     | A           | Latin capital letter A with caron                 |
 * | U+01CE  | ǎ     | a           | Latin small letter a with caron                   |
 * | U+01CF  | Ǐ     | I           | Latin capital letter I with caron                 |
 * | U+01D0  | ǐ     | i           | Latin small letter i with caron                   |
 * | U+01D1  | Ǒ     | O           | Latin capital letter O with caron                 |
 * | U+01D2  | ǒ     | o           | Latin small letter o with caron                   |
 * | U+01D3  | Ǔ     | U           | Latin capital letter U with caron                 |
 * | U+01D4  | ǔ     | u           | Latin small letter u with caron                   |
 * | U+01D5  | Ǖ     | U           | Latin capital letter U with diaeresis and macron  |
 * | U+01D6  | ǖ     | u           | Latin small letter u with diaeresis and macron    |
 * | U+01D7  | Ǘ     | U           | Latin capital letter U with diaeresis and acute   |
 * | U+01D8  | ǘ     | u           | Latin small letter u with diaeresis and acute     |
 * | U+01D9  | Ǚ     | U           | Latin capital letter U with diaeresis and caron   |
 * | U+01DA  | ǚ     | u           | Latin small letter u with diaeresis and caron     |
 * | U+01DB  | Ǜ     | U           | Latin capital letter U with diaeresis and grave   |
 * | U+01DC  | ǜ     | u           | Latin small letter u with diaeresis and grave     |
 *
 * Decompositions for Latin Extended-B:
 *
 * |   Code   | Glyph | Replacement |                Description                |
 * | -------- | ----- | ----------- | ----------------------------------------- |
 * | U+0218   | Ș     | S           | Latin capital letter S with comma below   |
 * | U+0219   | ș     | s           | Latin small letter s with comma below     |
 * | U+021A   | Ț     | T           | Latin capital letter T with comma below   |
 * | U+021B   | ț     | t           | Latin small letter t with comma below     |
 *
 * Vowels with diacritic (Chinese, Hanyu Pinyin):
 *
 * |   Code   | Glyph | Replacement |                      Description                      |
 * | -------- | ----- | ----------- | ----------------------------------------------------- |
 * | U+0251   | ɑ     | a           | Latin small letter alpha                              |
 * | U+1EA0   | Ạ     | A           | Latin capital letter A with dot below                 |
 * | U+1EA1   | ạ     | a           | Latin small letter a with dot below                   |
 * | U+1EA2   | Ả     | A           | Latin capital letter A with hook above                |
 * | U+1EA3   | ả     | a           | Latin small letter a with hook above                  |
 * | U+1EA4   | Ấ     | A           | Latin capital letter A with circumflex and acute      |
 * | U+1EA5   | ấ     | a           | Latin small letter a with circumflex and acute        |
 * | U+1EA6   | Ầ     | A           | Latin capital letter A with circumflex and grave      |
 * | U+1EA7   | ầ     | a           | Latin small letter a with circumflex and grave        |
 * | U+1EA8   | Ẩ     | A           | Latin capital letter A with circumflex and hook above |
 * | U+1EA9   | ẩ     | a           | Latin small letter a with circumflex and hook above   |
 * | U+1EAA   | Ẫ     | A           | Latin capital letter A with circumflex and tilde      |
 * | U+1EAB   | ẫ     | a           | Latin small letter a with circumflex and tilde        |
 * | U+1EA6   | Ậ     | A           | Latin capital letter A with circumflex and dot below  |
 * | U+1EAD   | ậ     | a           | Latin small letter a with circumflex and dot below    |
 * | U+1EAE   | Ắ     | A           | Latin capital letter A with breve and acute           |
 * | U+1EAF   | ắ     | a           | Latin small letter a with breve and acute             |
 * | U+1EB0   | Ằ     | A           | Latin capital letter A with breve and grave           |
 * | U+1EB1   | ằ     | a           | Latin small letter a with breve and grave             |
 * | U+1EB2   | Ẳ     | A           | Latin capital letter A with breve and hook above      |
 * | U+1EB3   | ẳ     | a           | Latin small letter a with breve and hook above        |
 * | U+1EB4   | Ẵ     | A           | Latin capital letter A with breve and tilde           |
 * | U+1EB5   | ẵ     | a           | Latin small letter a with breve and tilde             |
 * | U+1EB6   | Ặ     | A           | Latin capital letter A with breve and dot below       |
 * | U+1EB7   | ặ     | a           | Latin small letter a with breve and dot below         |
 * | U+1EB8   | Ẹ     | E           | Latin capital letter E with dot below                 |
 * | U+1EB9   | ẹ     | e           | Latin small letter e with dot below                   |
 * | U+1EBA   | Ẻ     | E           | Latin capital letter E with hook above                |
 * | U+1EBB   | ẻ     | e           | Latin small letter e with hook above                  |
 * | U+1EBC   | Ẽ     | E           | Latin capital letter E with tilde                     |
 * | U+1EBD   | ẽ     | e           | Latin small letter e with tilde                       |
 * | U+1EBE   | Ế     | E           | Latin capital letter E with circumflex and acute      |
 * | U+1EBF   | ế     | e           | Latin small letter e with circumflex and acute        |
 * | U+1EC0   | Ề     | E           | Latin capital letter E with circumflex and grave      |
 * | U+1EC1   | ề     | e           | Latin small letter e with circumflex and grave        |
 * | U+1EC2   | Ể     | E           | Latin capital letter E with circumflex and hook above |
 * | U+1EC3   | ể     | e           | Latin small letter e with circumflex and hook above   |
 * | U+1EC4   | Ễ     | E           | Latin capital letter E with circumflex and tilde      |
 * | U+1EC5   | ễ     | e           | Latin small letter e with circumflex and tilde        |
 * | U+1EC6   | Ệ     | E           | Latin capital letter E with circumflex and dot below  |
 * | U+1EC7   | ệ     | e           | Latin small letter e with circumflex and dot below    |
 * | U+1EC8   | Ỉ     | I           | Latin capital letter I with hook above                |
 * | U+1EC9   | ỉ     | i           | Latin small letter i with hook above                  |
 * | U+1ECA   | Ị     | I           | Latin capital letter I with dot below                 |
 * | U+1ECB   | ị     | i           | Latin small letter i with dot below                   |
 * | U+1ECC   | Ọ     | O           | Latin capital letter O with dot below                 |
 * | U+1ECD   | ọ     | o           | Latin small letter o with dot below                   |
 * | U+1ECE   | Ỏ     | O           | Latin capital letter O with hook above                |
 * | U+1ECF   | ỏ     | o           | Latin small letter o with hook above                  |
 * | U+1ED0   | Ố     | O           | Latin capital letter O with circumflex and acute      |
 * | U+1ED1   | ố     | o           | Latin small letter o with circumflex and acute        |
 * | U+1ED2   | Ồ     | O           | Latin capital letter O with circumflex and grave      |
 * | U+1ED3   | ồ     | o           | Latin small letter o with circumflex and grave        |
 * | U+1ED4   | Ổ     | O           | Latin capital letter O with circumflex and hook above |
 * | U+1ED5   | ổ     | o           | Latin small letter o with circumflex and hook above   |
 * | U+1ED6   | Ỗ     | O           | Latin capital letter O with circumflex and tilde      |
 * | U+1ED7   | ỗ     | o           | Latin small letter o with circumflex and tilde        |
 * | U+1ED8   | Ộ     | O           | Latin capital letter O with circumflex and dot below  |
 * | U+1ED9   | ộ     | o           | Latin small letter o with circumflex and dot below    |
 * | U+1EDA   | Ớ     | O           | Latin capital letter O with horn and acute            |
 * | U+1EDB   | ớ     | o           | Latin small letter o with horn and acute              |
 * | U+1EDC   | Ờ     | O           | Latin capital letter O with horn and grave            |
 * | U+1EDD   | ờ     | o           | Latin small letter o with horn and grave              |
 * | U+1EDE   | Ở     | O           | Latin capital letter O with horn and hook above       |
 * | U+1EDF   | ở     | o           | Latin small letter o with horn and hook above         |
 * | U+1EE0   | Ỡ     | O           | Latin capital letter O with horn and tilde            |
 * | U+1EE1   | ỡ     | o           | Latin small letter o with horn and tilde              |
 * | U+1EE2   | Ợ     | O           | Latin capital letter O with horn and dot below        |
 * | U+1EE3   | ợ     | o           | Latin small letter o with horn and dot below          |
 * | U+1EE4   | Ụ     | U           | Latin capital letter U with dot below                 |
 * | U+1EE5   | ụ     | u           | Latin small letter u with dot below                   |
 * | U+1EE6   | Ủ     | U           | Latin capital letter U with hook above                |
 * | U+1EE7   | ủ     | u           | Latin small letter u with hook above                  |
 * | U+1EE8   | Ứ     | U           | Latin capital letter U with horn and acute            |
 * | U+1EE9   | ứ     | u           | Latin small letter u with horn and acute              |
 * | U+1EEA   | Ừ     | U           | Latin capital letter U with horn and grave            |
 * | U+1EEB   | ừ     | u           | Latin small letter u with horn and grave              |
 * | U+1EEC   | Ử     | U           | Latin capital letter U with horn and hook above       |
 * | U+1EED   | ử     | u           | Latin small letter u with horn and hook above         |
 * | U+1EEE   | Ữ     | U           | Latin capital letter U with horn and tilde            |
 * | U+1EEF   | ữ     | u           | Latin small letter u with horn and tilde              |
 * | U+1EF0   | Ự     | U           | Latin capital letter U with horn and dot below        |
 * | U+1EF1   | ự     | u           | Latin small letter u with horn and dot below          |
 * | U+1EF2   | Ỳ     | Y           | Latin capital letter Y with grave                     |
 * | U+1EF3   | ỳ     | y           | Latin small letter y with grave                       |
 * | U+1EF4   | Ỵ     | Y           | Latin capital letter Y with dot below                 |
 * | U+1EF5   | ỵ     | y           | Latin small letter y with dot below                   |
 * | U+1EF6   | Ỷ     | Y           | Latin capital letter Y with hook above                |
 * | U+1EF7   | ỷ     | y           | Latin small letter y with hook above                  |
 * | U+1EF8   | Ỹ     | Y           | Latin capital letter Y with tilde                     |
 * | U+1EF9   | ỹ     | y           | Latin small letter y with tilde                       |
 */

// Currency signs:
{
  letter: /[\u00A3]/g,
  alternative: ""
}, {
  letter: /[\u20AC]/g,
  alternative: "E"
},
// Decompositions for Latin-1 Supplement:
{
  letter: /[\u00AA]/g,
  alternative: "a"
}, {
  letter: /[\u00BA]/g,
  alternative: "o"
}, {
  letter: /[\u00C0]/g,
  alternative: "A"
}, {
  letter: /[\u00C1]/g,
  alternative: "A"
}, {
  letter: /[\u00C2]/g,
  alternative: "A"
}, {
  letter: /[\u00C3]/g,
  alternative: "A"
}, {
  letter: /[\u00C4]/g,
  alternative: "A"
}, {
  letter: /[\u00C5]/g,
  alternative: "A"
}, {
  letter: /[\u00C6]/g,
  alternative: "AE"
}, {
  letter: /[\u00C7]/g,
  alternative: "C"
}, {
  letter: /[\u00C8]/g,
  alternative: "E"
}, {
  letter: /[\u00C9]/g,
  alternative: "E"
}, {
  letter: /[\u00CA]/g,
  alternative: "E"
}, {
  letter: /[\u00CB]/g,
  alternative: "E"
}, {
  letter: /[\u00CC]/g,
  alternative: "I"
}, {
  letter: /[\u00CD]/g,
  alternative: "I"
}, {
  letter: /[\u00CE]/g,
  alternative: "I"
}, {
  letter: /[\u00CF]/g,
  alternative: "I"
}, {
  letter: /[\u00D0]/g,
  alternative: "D"
}, {
  letter: /[\u00D1]/g,
  alternative: "N"
}, {
  letter: /[\u00D2]/g,
  alternative: "O"
}, {
  letter: /[\u00D3]/g,
  alternative: "O"
}, {
  letter: /[\u00D4]/g,
  alternative: "O"
}, {
  letter: /[\u00D5]/g,
  alternative: "O"
}, {
  letter: /[\u00D6]/g,
  alternative: "O"
}, {
  letter: /[\u00D8]/g,
  alternative: "O"
}, {
  letter: /[\u00D9]/g,
  alternative: "U"
}, {
  letter: /[\u00DA]/g,
  alternative: "U"
}, {
  letter: /[\u00DB]/g,
  alternative: "U"
}, {
  letter: /[\u00DC]/g,
  alternative: "U"
}, {
  letter: /[\u00DD]/g,
  alternative: "Y"
}, {
  letter: /[\u00DE]/g,
  alternative: "TH"
}, {
  letter: /[\u00DF]/g,
  alternative: "s"
}, {
  letter: /[\u00E0]/g,
  alternative: "a"
}, {
  letter: /[\u00E1]/g,
  alternative: "a"
}, {
  letter: /[\u00E2]/g,
  alternative: "a"
}, {
  letter: /[\u00E3]/g,
  alternative: "a"
}, {
  letter: /[\u00E4]/g,
  alternative: "a"
}, {
  letter: /[\u00E5]/g,
  alternative: "a"
}, {
  letter: /[\u00E6]/g,
  alternative: "ae"
}, {
  letter: /[\u00E7]/g,
  alternative: "c"
}, {
  letter: /[\u00E8]/g,
  alternative: "e"
}, {
  letter: /[\u00E9]/g,
  alternative: "e"
}, {
  letter: /[\u00EA]/g,
  alternative: "e"
}, {
  letter: /[\u00EB]/g,
  alternative: "e"
}, {
  letter: /[\u00EC]/g,
  alternative: "i"
}, {
  letter: /[\u00ED]/g,
  alternative: "i"
}, {
  letter: /[\u00EE]/g,
  alternative: "i"
}, {
  letter: /[\u00EF]/g,
  alternative: "i"
}, {
  letter: /[\u00F0]/g,
  alternative: "d"
}, {
  letter: /[\u00F1]/g,
  alternative: "n"
}, {
  letter: /[\u00F2]/g,
  alternative: "o"
}, {
  letter: /[\u00F3]/g,
  alternative: "o"
}, {
  letter: /[\u00F4]/g,
  alternative: "o"
}, {
  letter: /[\u00F5]/g,
  alternative: "o"
}, {
  letter: /[\u00F6]/g,
  alternative: "o"
}, {
  letter: /[\u00F8]/g,
  alternative: "o"
}, {
  letter: /[\u00F9]/g,
  alternative: "u"
}, {
  letter: /[\u00FA]/g,
  alternative: "u"
}, {
  letter: /[\u00FB]/g,
  alternative: "u"
}, {
  letter: /[\u00FC]/g,
  alternative: "u"
}, {
  letter: /[\u00FD]/g,
  alternative: "y"
}, {
  letter: /[\u00FE]/g,
  alternative: "th"
}, {
  letter: /[\u00FF]/g,
  alternative: "y"
},
// Decompositions for Latin Extended-A:
{
  letter: /[\u0100]/g,
  alternative: "A"
}, {
  letter: /[\u0101]/g,
  alternative: "a"
}, {
  letter: /[\u0102]/g,
  alternative: "A"
}, {
  letter: /[\u0103]/g,
  alternative: "a"
}, {
  letter: /[\u0104]/g,
  alternative: "A"
}, {
  letter: /[\u0105]/g,
  alternative: "a"
}, {
  letter: /[\u0106]/g,
  alternative: "C"
}, {
  letter: /[\u0107]/g,
  alternative: "c"
}, {
  letter: /[\u0108]/g,
  alternative: "C"
}, {
  letter: /[\u0109]/g,
  alternative: "c"
}, {
  letter: /[\u010A]/g,
  alternative: "C"
}, {
  letter: /[\u010B]/g,
  alternative: "c"
}, {
  letter: /[\u010C]/g,
  alternative: "C"
}, {
  letter: /[\u010D]/g,
  alternative: "c"
}, {
  letter: /[\u010E]/g,
  alternative: "D"
}, {
  letter: /[\u010F]/g,
  alternative: "d"
}, {
  letter: /[\u0110]/g,
  alternative: "D"
}, {
  letter: /[\u0111]/g,
  alternative: "d"
}, {
  letter: /[\u0112]/g,
  alternative: "E"
}, {
  letter: /[\u0113]/g,
  alternative: "e"
}, {
  letter: /[\u0114]/g,
  alternative: "E"
}, {
  letter: /[\u0115]/g,
  alternative: "e"
}, {
  letter: /[\u0116]/g,
  alternative: "E"
}, {
  letter: /[\u0117]/g,
  alternative: "e"
}, {
  letter: /[\u0118]/g,
  alternative: "E"
}, {
  letter: /[\u0119]/g,
  alternative: "e"
}, {
  letter: /[\u011A]/g,
  alternative: "E"
}, {
  letter: /[\u011B]/g,
  alternative: "e"
}, {
  letter: /[\u011C]/g,
  alternative: "G"
}, {
  letter: /[\u011D]/g,
  alternative: "g"
}, {
  letter: /[\u011E]/g,
  alternative: "G"
}, {
  letter: /[\u011F]/g,
  alternative: "g"
}, {
  letter: /[\u0120]/g,
  alternative: "G"
}, {
  letter: /[\u0121]/g,
  alternative: "g"
}, {
  letter: /[\u0122]/g,
  alternative: "G"
}, {
  letter: /[\u0123]/g,
  alternative: "g"
}, {
  letter: /[\u0124]/g,
  alternative: "H"
}, {
  letter: /[\u0125]/g,
  alternative: "h"
}, {
  letter: /[\u0126]/g,
  alternative: "H"
}, {
  letter: /[\u0127]/g,
  alternative: "h"
}, {
  letter: /[\u0128]/g,
  alternative: "I"
}, {
  letter: /[\u0129]/g,
  alternative: "i"
}, {
  letter: /[\u012A]/g,
  alternative: "I"
}, {
  letter: /[\u012B]/g,
  alternative: "i"
}, {
  letter: /[\u012C]/g,
  alternative: "I"
}, {
  letter: /[\u012D]/g,
  alternative: "i"
}, {
  letter: /[\u012E]/g,
  alternative: "I"
}, {
  letter: /[\u012F]/g,
  alternative: "i"
}, {
  letter: /[\u0130]/g,
  alternative: "I"
}, {
  letter: /[\u0131]/g,
  alternative: "i"
}, {
  letter: /[\u0132]/g,
  alternative: "IJ"
}, {
  letter: /[\u0133]/g,
  alternative: "ij"
}, {
  letter: /[\u0134]/g,
  alternative: "J"
}, {
  letter: /[\u0135]/g,
  alternative: "j"
}, {
  letter: /[\u0136]/g,
  alternative: "K"
}, {
  letter: /[\u0137]/g,
  alternative: "k"
}, {
  letter: /[\u0138]/g,
  alternative: "k"
}, {
  letter: /[\u0139]/g,
  alternative: "L"
}, {
  letter: /[\u013A]/g,
  alternative: "l"
}, {
  letter: /[\u013B]/g,
  alternative: "L"
}, {
  letter: /[\u013C]/g,
  alternative: "l"
}, {
  letter: /[\u013D]/g,
  alternative: "L"
}, {
  letter: /[\u013E]/g,
  alternative: "l"
}, {
  letter: /[\u013F]/g,
  alternative: "L"
}, {
  letter: /[\u0140]/g,
  alternative: "l"
}, {
  letter: /[\u0141]/g,
  alternative: "L"
}, {
  letter: /[\u0142]/g,
  alternative: "l"
}, {
  letter: /[\u0143]/g,
  alternative: "N"
}, {
  letter: /[\u0144]/g,
  alternative: "n"
}, {
  letter: /[\u0145]/g,
  alternative: "N"
}, {
  letter: /[\u0146]/g,
  alternative: "n"
}, {
  letter: /[\u0147]/g,
  alternative: "N"
}, {
  letter: /[\u0148]/g,
  alternative: "n"
}, {
  letter: /[\u0149]/g,
  alternative: "n"
}, {
  letter: /[\u014A]/g,
  alternative: "N"
}, {
  letter: /[\u014B]/g,
  alternative: "n"
}, {
  letter: /[\u014C]/g,
  alternative: "O"
}, {
  letter: /[\u014D]/g,
  alternative: "o"
}, {
  letter: /[\u014E]/g,
  alternative: "O"
}, {
  letter: /[\u014F]/g,
  alternative: "o"
}, {
  letter: /[\u0150]/g,
  alternative: "O"
}, {
  letter: /[\u0151]/g,
  alternative: "o"
}, {
  letter: /[\u0152]/g,
  alternative: "OE"
}, {
  letter: /[\u0153]/g,
  alternative: "oe"
}, {
  letter: /[\u0154]/g,
  alternative: "R"
}, {
  letter: /[\u0155]/g,
  alternative: "r"
}, {
  letter: /[\u0156]/g,
  alternative: "R"
}, {
  letter: /[\u0157]/g,
  alternative: "r"
}, {
  letter: /[\u0158]/g,
  alternative: "R"
}, {
  letter: /[\u0159]/g,
  alternative: "r"
}, {
  letter: /[\u015A]/g,
  alternative: "S"
}, {
  letter: /[\u015B]/g,
  alternative: "s"
}, {
  letter: /[\u015C]/g,
  alternative: "S"
}, {
  letter: /[\u015D]/g,
  alternative: "s"
}, {
  letter: /[\u015E]/g,
  alternative: "S"
}, {
  letter: /[\u015F]/g,
  alternative: "s"
}, {
  letter: /[\u0160]/g,
  alternative: "S"
}, {
  letter: /[\u0161]/g,
  alternative: "s"
}, {
  letter: /[\u0162]/g,
  alternative: "T"
}, {
  letter: /[\u0163]/g,
  alternative: "t"
}, {
  letter: /[\u0164]/g,
  alternative: "T"
}, {
  letter: /[\u0165]/g,
  alternative: "t"
}, {
  letter: /[\u0166]/g,
  alternative: "T"
}, {
  letter: /[\u0167]/g,
  alternative: "t"
}, {
  letter: /[\u0168]/g,
  alternative: "U"
}, {
  letter: /[\u0169]/g,
  alternative: "u"
}, {
  letter: /[\u016A]/g,
  alternative: "U"
}, {
  letter: /[\u016B]/g,
  alternative: "u"
}, {
  letter: /[\u016C]/g,
  alternative: "U"
}, {
  letter: /[\u016D]/g,
  alternative: "u"
}, {
  letter: /[\u016E]/g,
  alternative: "U"
}, {
  letter: /[\u016F]/g,
  alternative: "u"
}, {
  letter: /[\u0170]/g,
  alternative: "U"
}, {
  letter: /[\u0171]/g,
  alternative: "u"
}, {
  letter: /[\u0172]/g,
  alternative: "U"
}, {
  letter: /[\u0173]/g,
  alternative: "u"
}, {
  letter: /[\u0174]/g,
  alternative: "W"
}, {
  letter: /[\u0175]/g,
  alternative: "w"
}, {
  letter: /[\u0176]/g,
  alternative: "Y"
}, {
  letter: /[\u0177]/g,
  alternative: "y"
}, {
  letter: /[\u0178]/g,
  alternative: "Y"
}, {
  letter: /[\u0179]/g,
  alternative: "Z"
}, {
  letter: /[\u017A]/g,
  alternative: "z"
}, {
  letter: /[\u017B]/g,
  alternative: "Z"
}, {
  letter: /[\u017C]/g,
  alternative: "z"
}, {
  letter: /[\u017D]/g,
  alternative: "Z"
}, {
  letter: /[\u017E]/g,
  alternative: "z"
}, {
  letter: /[\u017F]/g,
  alternative: "s"
}, {
  letter: /[\u01A0]/g,
  alternative: "O"
}, {
  letter: /[\u01A1]/g,
  alternative: "o"
}, {
  letter: /[\u01AF]/g,
  alternative: "U"
}, {
  letter: /[\u01B0]/g,
  alternative: "u"
}, {
  letter: /[\u01CD]/g,
  alternative: "A"
}, {
  letter: /[\u01CE]/g,
  alternative: "a"
}, {
  letter: /[\u01CF]/g,
  alternative: "I"
}, {
  letter: /[\u01D0]/g,
  alternative: "i"
}, {
  letter: /[\u01D1]/g,
  alternative: "O"
}, {
  letter: /[\u01D2]/g,
  alternative: "o"
}, {
  letter: /[\u01D3]/g,
  alternative: "U"
}, {
  letter: /[\u01D4]/g,
  alternative: "u"
}, {
  letter: /[\u01D5]/g,
  alternative: "U"
}, {
  letter: /[\u01D6]/g,
  alternative: "u"
}, {
  letter: /[\u01D7]/g,
  alternative: "U"
}, {
  letter: /[\u01D8]/g,
  alternative: "u"
}, {
  letter: /[\u01D9]/g,
  alternative: "U"
}, {
  letter: /[\u01DA]/g,
  alternative: "u"
}, {
  letter: /[\u01DB]/g,
  alternative: "U"
}, {
  letter: /[\u01DC]/g,
  alternative: "u"
},
// Decompositions for Latin Extended-B:
{
  letter: /[\u0218]/g,
  alternative: "S"
}, {
  letter: /[\u0219]/g,
  alternative: "s"
}, {
  letter: /[\u021A]/g,
  alternative: "T"
}, {
  letter: /[\u021B]/g,
  alternative: "t"
},
// Vowels with diacritic (Chinese, Hanyu Pinyin):
{
  letter: /[\u0251]/g,
  alternative: "a"
}, {
  letter: /[\u1EA0]/g,
  alternative: "A"
}, {
  letter: /[\u1EA1]/g,
  alternative: "a"
}, {
  letter: /[\u1EA2]/g,
  alternative: "A"
}, {
  letter: /[\u1EA3]/g,
  alternative: "a"
}, {
  letter: /[\u1EA4]/g,
  alternative: "A"
}, {
  letter: /[\u1EA5]/g,
  alternative: "a"
}, {
  letter: /[\u1EA6]/g,
  alternative: "A"
}, {
  letter: /[\u1EA7]/g,
  alternative: "a"
}, {
  letter: /[\u1EA8]/g,
  alternative: "A"
}, {
  letter: /[\u1EA9]/g,
  alternative: "a"
}, {
  letter: /[\u1EAA]/g,
  alternative: "A"
}, {
  letter: /[\u1EAB]/g,
  alternative: "a"
}, {
  letter: /[\u1EA6]/g,
  alternative: "A"
}, {
  letter: /[\u1EAD]/g,
  alternative: "a"
}, {
  letter: /[\u1EAE]/g,
  alternative: "A"
}, {
  letter: /[\u1EAF]/g,
  alternative: "a"
}, {
  letter: /[\u1EB0]/g,
  alternative: "A"
}, {
  letter: /[\u1EB1]/g,
  alternative: "a"
}, {
  letter: /[\u1EB2]/g,
  alternative: "A"
}, {
  letter: /[\u1EB3]/g,
  alternative: "a"
}, {
  letter: /[\u1EB4]/g,
  alternative: "A"
}, {
  letter: /[\u1EB5]/g,
  alternative: "a"
}, {
  letter: /[\u1EB6]/g,
  alternative: "A"
}, {
  letter: /[\u1EB7]/g,
  alternative: "a"
}, {
  letter: /[\u1EB8]/g,
  alternative: "E"
}, {
  letter: /[\u1EB9]/g,
  alternative: "e"
}, {
  letter: /[\u1EBA]/g,
  alternative: "E"
}, {
  letter: /[\u1EBB]/g,
  alternative: "e"
}, {
  letter: /[\u1EBC]/g,
  alternative: "E"
}, {
  letter: /[\u1EBD]/g,
  alternative: "e"
}, {
  letter: /[\u1EBE]/g,
  alternative: "E"
}, {
  letter: /[\u1EBF]/g,
  alternative: "e"
}, {
  letter: /[\u1EC0]/g,
  alternative: "E"
}, {
  letter: /[\u1EC1]/g,
  alternative: "e"
}, {
  letter: /[\u1EC2]/g,
  alternative: "E"
}, {
  letter: /[\u1EC3]/g,
  alternative: "e"
}, {
  letter: /[\u1EC4]/g,
  alternative: "E"
}, {
  letter: /[\u1EC5]/g,
  alternative: "e"
}, {
  letter: /[\u1EC6]/g,
  alternative: "E"
}, {
  letter: /[\u1EC7]/g,
  alternative: "e"
}, {
  letter: /[\u1EC8]/g,
  alternative: "I"
}, {
  letter: /[\u1EC9]/g,
  alternative: "i"
}, {
  letter: /[\u1ECA]/g,
  alternative: "I"
}, {
  letter: /[\u1ECB]/g,
  alternative: "i"
}, {
  letter: /[\u1ECC]/g,
  alternative: "O"
}, {
  letter: /[\u1ECD]/g,
  alternative: "o"
}, {
  letter: /[\u1ECE]/g,
  alternative: "O"
}, {
  letter: /[\u1ECF]/g,
  alternative: "o"
}, {
  letter: /[\u1ED0]/g,
  alternative: "O"
}, {
  letter: /[\u1ED1]/g,
  alternative: "o"
}, {
  letter: /[\u1ED2]/g,
  alternative: "O"
}, {
  letter: /[\u1ED3]/g,
  alternative: "o"
}, {
  letter: /[\u1ED4]/g,
  alternative: "O"
}, {
  letter: /[\u1ED5]/g,
  alternative: "o"
}, {
  letter: /[\u1ED6]/g,
  alternative: "O"
}, {
  letter: /[\u1ED7]/g,
  alternative: "o"
}, {
  letter: /[\u1ED8]/g,
  alternative: "O"
}, {
  letter: /[\u1ED9]/g,
  alternative: "o"
}, {
  letter: /[\u1EDA]/g,
  alternative: "O"
}, {
  letter: /[\u1EDB]/g,
  alternative: "o"
}, {
  letter: /[\u1EDC]/g,
  alternative: "O"
}, {
  letter: /[\u1EDD]/g,
  alternative: "o"
}, {
  letter: /[\u1EDE]/g,
  alternative: "O"
}, {
  letter: /[\u1EDF]/g,
  alternative: "o"
}, {
  letter: /[\u1EE0]/g,
  alternative: "O"
}, {
  letter: /[\u1EE1]/g,
  alternative: "o"
}, {
  letter: /[\u1EE2]/g,
  alternative: "O"
}, {
  letter: /[\u1EE3]/g,
  alternative: "o"
}, {
  letter: /[\u1EE4]/g,
  alternative: "U"
}, {
  letter: /[\u1EE5]/g,
  alternative: "u"
}, {
  letter: /[\u1EE6]/g,
  alternative: "U"
}, {
  letter: /[\u1EE7]/g,
  alternative: "u"
}, {
  letter: /[\u1EE8]/g,
  alternative: "U"
}, {
  letter: /[\u1EE9]/g,
  alternative: "u"
}, {
  letter: /[\u1EEA]/g,
  alternative: "U"
}, {
  letter: /[\u1EEB]/g,
  alternative: "u"
}, {
  letter: /[\u1EEC]/g,
  alternative: "U"
}, {
  letter: /[\u1EED]/g,
  alternative: "u"
}, {
  letter: /[\u1EEE]/g,
  alternative: "U"
}, {
  letter: /[\u1EEF]/g,
  alternative: "u"
}, {
  letter: /[\u1EF0]/g,
  alternative: "U"
}, {
  letter: /[\u1EF1]/g,
  alternative: "u"
}, {
  letter: /[\u1EF2]/g,
  alternative: "Y"
}, {
  letter: /[\u1EF3]/g,
  alternative: "y"
}, {
  letter: /[\u1EF4]/g,
  alternative: "Y"
}, {
  letter: /[\u1EF5]/g,
  alternative: "y"
}, {
  letter: /[\u1EF6]/g,
  alternative: "Y"
}, {
  letter: /[\u1EF7]/g,
  alternative: "y"
}, {
  letter: /[\u1EF8]/g,
  alternative: "Y"
}, {
  letter: /[\u1EF9]/g,
  alternative: "y"
}];
const transliterationsPerLanguage = {
  /*
   * Language: German.
   * |   Code   | Glyph | Replacement |               Description               |
   * | -------- | ----- | ----------- | --------------------------------------- |
   * | U+00C4   | Ä     | Ae          | Latin capital letter A with diaeresis   |
   * | U+00E4   | ä     | ae          | Latin small letter a with diaeresis     |
   * | U+00D6   | Ö     | Oe          | Latin capital letter O with diaeresis   |
   * | U+00F6   | ö     | oe          | Latin small letter o with diaeresis     |
   * | U+00DC   | Ü     | Ue          | Latin capital letter U with diaeresis   |
   * | U+00FC   | ü     | ue          | Latin small letter u with diaeresis     |
   * | U+1E9E   | ẞ     | ss          | Latin big letter sharp s                | This letter is not in the original WP list, was added for consistency.
   * | U+00DF   | ß     | ss          | Latin small letter sharp s              |
   */
  de: [{
    letter: /[\u00C4]/g,
    alternative: "Ae"
  }, {
    letter: /[\u00E4]/g,
    alternative: "ae"
  }, {
    letter: /[\u00D6]/g,
    alternative: "Oe"
  }, {
    letter: /[\u00F6]/g,
    alternative: "oe"
  }, {
    letter: /[\u00DC]/g,
    alternative: "Ue"
  }, {
    letter: /[\u00FC]/g,
    alternative: "ue"
  }, {
    letter: /[\u1E9E]/g,
    alternative: "SS"
  }, {
    letter: /[\u00DF]/g,
    alternative: "ss"
  }],
  /*
   * Language: Danish.
   * |   Code   | Glyph | Replacement |               Description               |
      * | -------- | ----- | ----------- | --------------------------------------- |
      * | U+00C6   | Æ     | Ae          | Latin capital letter AE                 |
      * | U+00E6   | æ     | ae          | Latin small letter ae                   |
      * | U+00D8   | Ø     | Oe          | Latin capital letter O with stroke      |
      * | U+00F8   | ø     | oe          | Latin small letter o with stroke        |
      * | U+00C5   | Å     | Aa          | Latin capital letter A with ring above  |
      * | U+00E5   | å     | aa          | Latin small letter a with ring above    |
   */
  da: [{
    letter: /[\u00C6]/g,
    alternative: "Ae"
  }, {
    letter: /[\u00E6]/g,
    alternative: "ae"
  }, {
    letter: /[\u00D8]/g,
    alternative: "Oe"
  }, {
    letter: /[\u00F8]/g,
    alternative: "oe"
  }, {
    letter: /[\u00C5]/g,
    alternative: "Aa"
  }, {
    letter: /[\u00E5]/g,
    alternative: "aa"
  }],
  /*
   * Language: Catalan.
   * |   Code   | Glyph | Replacement |               Description               |
      * | -------- | ----- | ----------- | --------------------------------------- |
      * | U+00B7   | l·l   | ll          | Flown dot (between two Ls)              |
   */
  ca: [{
    letter: /[\u00B7]/g,
    alternative: "ll"
  }],
  /*
   * Language: Serbian and Bosnian.
   * |   Code   | Glyph | Replacement |               Description               |
      * | -------- | ----- | ----------- | --------------------------------------- |
      * | U+0110   | Đ     | DJ          | Latin capital letter D with stroke      |
      * | U+0111   | đ     | dj          | Latin small letter d with stroke        |
   */
  srAndBs: [{
    letter: /[\u0110]/g,
    alternative: "DJ"
  }, {
    letter: /[\u0111]/g,
    alternative: "dj"
  }]
};

/**
 * The function returning an array containing transliteration objects if those were specified for a given language.
 *
 * @param {string} language The language to return transliterations for.
 *
 * @returns {Array} An array containing language-specific transliteration objects.
 */
const getLanguageSpecificTransliterations = function (language) {
  switch (language) {
    case "de":
      return transliterationsPerLanguage.de;
    case "da":
      return transliterationsPerLanguage.da;
    case "ca":
      return transliterationsPerLanguage.ca;
    case "sr":
      return transliterationsPerLanguage.srAndBs;
    case "bs":
      return transliterationsPerLanguage.srAndBs;
    default:
      return [];
  }
};

/**
 * The function returning an array containing transliteration objects, based on the given locale, both language-specific and general.
 *
 * @param {string} locale The locale.
 *
 * @returns {Array} An array containing transliteration objects.
 */
function _default(locale) {
  if ((0, _lodash.isUndefined)(locale)) {
    return [];
  }
  let transliterationObjects = transliterationsGeneral;
  transliterationObjects = transliterationObjects.concat(getLanguageSpecificTransliterations((0, _getLanguage.default)(locale)));
  return transliterationObjects;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/config/wordBoundaries.js":
/*!**************************************************************!*\
  !*** ./node_modules/yoastseo/build/config/wordBoundaries.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Returns the word boundaries.
 * @returns {string[]} The array of word boundaries.
 */
function _default() {
  return [
  // Whitespace is always a word boundary.
  " ", "\\n", "\\r", "\\t",
  // NO-BREAK SPACE.
  "\u00a0",
  // \u06d4 - Urdu full stop
  "\u06d4",
  // \u061f - Arabic question mark
  "\u061f",
  // \u060C - Arabic comma
  "\u060C",
  // \u061B - Arabic semicolon
  "\u061B", " ", ".", ",", "'", "(", ")", "\"", "+", "-", ";", "!", "?", ":", "/", "»", "«", "‹", "›", "<", ">", "”", "“", "〝", "〞", "〟", "‟", "„"];
}

/***/ }),

/***/ "./node_modules/yoastseo/build/config/wordBoundariesWithoutPunctuation.js":
/*!********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/config/wordBoundariesWithoutPunctuation.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WORD_BOUNDARY_WITH_HYPHEN = exports.WORD_BOUNDARY_WITHOUT_HYPHEN = void 0;
/*
 * A regex string that can be used to split a string on whitespaces, en-dashes, and hyphens.
 */
const WORD_BOUNDARY_WITH_HYPHEN = exports.WORD_BOUNDARY_WITH_HYPHEN = "[\\s\\u2013\\u002d]";

/*
 * A regex string that can be used to split a string on whitespaces and en-dashes.
 */
const WORD_BOUNDARY_WITHOUT_HYPHEN = exports.WORD_BOUNDARY_WITHOUT_HYPHEN = "[\\s\\u2013]";

/***/ }),

/***/ "./node_modules/yoastseo/build/errors/invalidType.js":
/*!***********************************************************!*\
  !*** ./node_modules/yoastseo/build/errors/invalidType.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _util = _interopRequireDefault(__webpack_require__(/*! util */ "./node_modules/util/util.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Throws an invalid type error
 *
 * @param {string} message The message to show when the error is thrown
 *
 * @returns {void}
 */
function InvalidTypeError(message) {
  Error.captureStackTrace(this, this.constructor);
  this.name = this.constructor.name;
  this.message = message;
}
_util.default.inherits(InvalidTypeError, Error);
var _default = exports["default"] = InvalidTypeError;

/***/ }),

/***/ "./node_modules/yoastseo/build/errors/missingArgument.js":
/*!***************************************************************!*\
  !*** ./node_modules/yoastseo/build/errors/missingArgument.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _util = _interopRequireDefault(__webpack_require__(/*! util */ "./node_modules/util/util.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Error that means that an argument should be passed that wasn't passed.
 *
 * @constructor
 *
 * @param {string} message The message for this error.
 *
 * @returns {void}
 */
function MissingArgumentError(message) {
  Error.captureStackTrace(this, this.constructor);
  this.name = this.constructor.name;
  this.message = message;
}
_util.default.inherits(MissingArgumentError, Error);
var _default = exports["default"] = MissingArgumentError;

/***/ }),

/***/ "./node_modules/yoastseo/build/helpers/createMeasurementElement.js":
/*!*************************************************************************!*\
  !*** ./node_modules/yoastseo/build/helpers/createMeasurementElement.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.measureTextWidth = void 0;
const elementId = "yoast-measurement-element";

/**
 * Creates an hidden element with the purpose to calculate the sizes of elements and adds these elements to the body.
 *
 * @returns {HTMLElement} The created hidden element.
 */
const createMeasurementElement = function () {
  const hiddenElement = document.createElement("div");
  hiddenElement.id = elementId;

  // Styles to prevent unintended scrolling in Gutenberg.
  hiddenElement.style.position = "absolute";
  hiddenElement.style.left = "-9999em";
  hiddenElement.style.top = 0;
  hiddenElement.style.height = 0;
  hiddenElement.style.overflow = "hidden";
  hiddenElement.style.fontFamily = "arial, sans-serif";
  hiddenElement.style.fontSize = "20px";
  hiddenElement.style.fontWeight = "400";
  document.body.appendChild(hiddenElement);
  return hiddenElement;
};

/**
 * Measures the width of the text using a hidden element.
 *
 * @param {string} text The text to measure the width for.
 * @returns {number} The width in pixels.
 */
const measureTextWidth = function (text) {
  let element = document.getElementById(elementId);
  if (!element) {
    element = createMeasurementElement();
  }
  element.innerText = text;
  return element.offsetWidth;
};
exports.measureTextWidth = measureTextWidth;

/***/ }),

/***/ "./node_modules/yoastseo/build/helpers/errors.js":
/*!*******************************************************!*\
  !*** ./node_modules/yoastseo/build/helpers/errors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
exports.showTrace = showTrace;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Shows and error trace of the error message in the console if the console is available.
 *
 * @param {string} [errorMessage=""] The error message.
 * @returns {void}
 */
function showTrace(errorMessage) {
  if ((0, _lodash.isUndefined)(errorMessage)) {
    errorMessage = "";
  }
  if (!(0, _lodash.isUndefined)(console) && !(0, _lodash.isUndefined)(console.trace)) {
    console.trace(errorMessage);
  }
}
var _default = exports["default"] = {
  showTrace: showTrace
};

/***/ }),

/***/ "./node_modules/yoastseo/build/helpers/factory.js":
/*!********************************************************!*\
  !*** ./node_modules/yoastseo/build/helpers/factory.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * A mock factory function.
 *
 * @returns {void}
 */

/**
 * Factory prototype.
 *
 * @constructor
 */
const FactoryProto = function () {};

/**
 * Returns a mock element that lodash accepts as an element
 *
 * @returns {object} Mock HTML element.
 */
FactoryProto.prototype.buildMockElement = function () {
  const mockElement = [];
  mockElement.nodeType = 1;
  return mockElement;
};

/**
 * Returns a mock researcher
 *
 * @param {object}  expectedValue 		The expected value or values.
 * @param {boolean} multiValue    		True if multiple values are expected.
 * @param {boolean} hasMorphologyData	True if the researcher has access to morphology data.
 * @param {Object|boolean} config		Optional config to be used for an assessment.
 * @param {Object|boolean} helpers	Optional helpers to be used for an assessment.
 *
 * @returns {Researcher} Mock researcher.
 */
FactoryProto.prototype.buildMockResearcher = function (expectedValue, multiValue = false, hasMorphologyData = false, config = false, helpers = false) {
  if (multiValue && (typeof expectedValue === "object" || typeof helpers === "object" || typeof config === "object")) {
    return {
      /**
       * Return research results by research name for multi-value mock researchers.
       *
       * @param {string} research The name of the research.
       *
       * @returns {Object} The results of the research.
       */
      getResearch: function (research) {
        return expectedValue[research];
      },
      /**
       * Return whether the worker has the research.
       * @param {string} research The name of the research.
       * @returns {boolean} Whether the worker has the research.
       */
      hasResearch: function (research) {
        return !(0, _lodash.isUndefined)(expectedValue[research]);
      },
      /**
       * Adds a research.
       * @param {string} name The name of the research.
       * @param {Object} research The research to register.
       *
       * @returns {void}
       */
      addResearch: function (name, research) {
        expectedValue[name] = research;
      },
      /**
       * Check whether morphology data is available.
       *
       * @returns {boolean} True if the researcher has access to morphology data.
       */
      getData: function () {
        return hasMorphologyData;
      },
      /**
       * Return the helper to be used for the assessment.
       * @param {string} name The name of the helper.
       *
       * @returns {function} The helper for the assessment.
       */
      getHelper: function (name) {
        return helpers[name];
      },
      /**
       * Checks whether a helper with the given name exists.
       * @param {string} name The name to check.
       *
       * @returns {boolean} Trye if the helper exists.
       */
      hasHelper: function (name) {
        return !(0, _lodash.isUndefined)(helpers[name]);
      },
      /**
       * Adds a helper under the given name.
       * @param {string} name The name.
       * @param {function} helper The helper.
       *
       * @returns {void}
       */
      addHelper: function (name, helper) {
        if (!helpers) {
          helpers = {};
        }
        helpers[name] = helper;
      },
      /**
       * Return the config to be used for the assessment.
       * @param {string} name The name of the config.
       *
       * @returns {function} The config for the assessment.
       */
      getConfig: function (name) {
        return config[name];
      },
      /**
       * Checks if the config exists.
       * @param {string} name The name of the config
       *
       * @returns {boolean} Whether the config exists.
       */
      hasConfig: function (name) {
        return !(0, _lodash.isUndefined)(config[name]);
      },
      /**
       * Adds a configuration.
       * @param {string} name The name of the config.
       * @param {Object} researchConfig The config.
       *
       * @returns {void}
       */
      addConfig: function (name, researchConfig) {
        config[name] = researchConfig;
      }
    };
  }
  return {
    /**
     * Return research results.
     *
     * @returns {Object} The results of the research.
     */
    getResearch: function () {
      return expectedValue;
    },
    /**
     * Check whether morphology data is available.
     *
     * @returns {boolean} True if the researcher has access to morphology data.
     */
    getData: function () {
      return hasMorphologyData;
    },
    /**
     * Return the helpers to be used for the assessment.
     *
     * @returns {Object} The helpers for the assessment.
     */
    getHelper: function () {
      return helpers;
    },
    /**
     * Return whether the worker has the helper.
     *
     * @returns {boolean} Whether the worker has the helper.
     */
    hasHelper: function () {
      return expectedValue;
    },
    /**
     * Return the config to be used for the assessment.
     *
     * @returns {Object} The config for the assessment results.
     */
    getConfig: function () {
      return config;
    },
    /**
     * Return whether the worker has the config.
     * @param {string} research The name of the config.
     * @returns {boolean} Whether the worker has the research.
     */
    hasConfig: function (research) {
      return !(0, _lodash.isUndefined)(expectedValue[research]);
    }
  };
};

/**
 * This method repeats a string and returns a new string based on the string and the amount of repetitions.
 *
 * @param {string} string      String to repeat.
 * @param {int}    repetitions Number of repetitions.
 *
 * @returns {string} The result.
 */
FactoryProto.prototype.buildMockString = function (string, repetitions) {
  let resultString = "";
  string = string || "Test ";
  repetitions = repetitions || 1;
  for (let i = 0; i < repetitions; i++) {
    resultString += string;
  }
  return resultString;
};
const Factory = new FactoryProto();
var _default = exports["default"] = Factory;

/***/ }),

/***/ "./node_modules/yoastseo/build/helpers/formatNumber.js":
/*!*************************************************************!*\
  !*** ./node_modules/yoastseo/build/helpers/formatNumber.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Returns rounded number to fix floating point bug http://floating-point-gui.de
 * @param {number} number The unrounded number
 * @returns {number} Rounded number
 */
function _default(number) {
  if (Math.round(number) === number) {
    return Math.round(number);
  }
  return Math.round(number * 10) / 10;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/helpers/formatString.js":
/*!*************************************************************!*\
  !*** ./node_modules/yoastseo/build/helpers/formatString.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Formats a string with named parameters as defined in the given parameter mapping.
 *
 * E.g. `"Hello %par_1% and %par_2%"` plus the map `{ par_1: "world", par_2: "you!" }`
 * gives: `"Hello world and you!"`.
 *
 * @param {string} string           The string to be formatted.
 * @param {Object} formatMap        The mapping in the form of parameter - value pairs.
 * @param {string} [delimiter="%%"] The string used to delimit parameters in the to be formatted string.
 *
 * @returns {string} The formatted string.
 */
function _default(string, formatMap, delimiter = "%%") {
  delimiter = (0, _lodash.escapeRegExp)(delimiter);
  const parameterRegex = new RegExp(`${delimiter}(.+?)${delimiter}`, "g");
  let match;
  let formattedString = string;

  // Try to match and replace each occurrence of "%%something%%" in the string.
  while ((match = parameterRegex.exec(string)) !== null) {
    const key = match[1];
    // Create regex from parameter (e.g. "%%key%%")
    const replaceRegex = new RegExp(`${delimiter}${(0, _lodash.escapeRegExp)(key)}${delimiter}`, "g");
    // Replace occurrence (if parameter exists in the format map).
    if (key in formatMap) {
      formattedString = formattedString.replace(replaceRegex, formatMap[key]);
    }
  }
  return formattedString;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/helpers/getLanguagesWithWordComplexity.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/yoastseo/build/helpers/getLanguagesWithWordComplexity.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getLanguagesWithWordComplexity = getLanguagesWithWordComplexity;
/**
 * Returns an array of languages with Word complexity support.
 *
 * @returns {string[]} A list of languages that have Word complexity support.
 */
function getLanguagesWithWordComplexity() {
  return ["en", "es", "de", "fr"];
}

/***/ }),

/***/ "./node_modules/yoastseo/build/helpers/getLanguagesWithWordFormSupport.js":
/*!********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/helpers/getLanguagesWithWordFormSupport.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getLanguagesWithWordFormSupport = getLanguagesWithWordFormSupport;
/**
 * Checks which languages have morphology support inside YoastSEO.js.
 *
 * @returns {string[]} A list of languages that have morphology support.
 */
function getLanguagesWithWordFormSupport() {
  const supportedLanguages = ["en", "de", "es", "fr", "it", "nl", "ru", "id", "pt", "pl", "ar", "sv", "he", "hu", "nb", "tr", "cs", "sk", "el", "ja"];
  return supportedLanguages;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/helpers/htmlEntities.js":
/*!*************************************************************!*\
  !*** ./node_modules/yoastseo/build/helpers/htmlEntities.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.htmlEntitiesRegex = exports.htmlEntities = exports.hashedHtmlEntitiesRegexStart = exports.hashedHtmlEntitiesRegexEnd = exports.hashedHtmlEntities = void 0;
// Contains 1) special characters usually converted into HTML entities (cf. _wp_specialchars).
// And 2) their corresponding HTML entities, stripped from the initial ampersand (e.g. 'lt;' instead of '&lt;').
const htmlEntities = exports.htmlEntities = new Map([["amp;", "&"], ["lt;", "<"], ["gt;", ">"], ["quot;", '"'], ["apos;", "'"], ["ndash;", "–"], ["mdash;", "—"], ["copy;", "©"], ["reg;", "®"], ["trade;", "™"], ["pound;", "£"], ["yen;", "¥"], ["euro;", "€"], ["dollar;", "$"], ["deg;", "°"], ["asymp;", "≈"], ["ne;", "≠"], ["nbsp;", " "]]);

// Regex to find all HTML entities.
const htmlEntitiesRegex = exports.htmlEntitiesRegex = new RegExp("&(" + [...htmlEntities.keys()].join("|") + ")", "ig");

// Contains special characters along with their hashed HTML entities (e.g. '#amp;' instead of '&amp;' for the ampersand character '&').
const hashedHtmlEntities = exports.hashedHtmlEntities = new Map();
htmlEntities.forEach((value, key) => hashedHtmlEntities.set("#" + key, value));

// Regex to find hashed HTML entities attached to the beginning (hashedHtmlEntitiesRegexStart) or to the end of a string (hashedHtmlEntitiesRegexEnd).
const hashedHtmlEntitiesRegexStart = exports.hashedHtmlEntitiesRegexStart = new RegExp("^(" + [...hashedHtmlEntities.keys()].join("|") + ")");
const hashedHtmlEntitiesRegexEnd = exports.hashedHtmlEntitiesRegexEnd = new RegExp("(" + [...hashedHtmlEntities.keys()].join("|") + ")$");

/***/ }),

/***/ "./node_modules/yoastseo/build/helpers/includesAny.js":
/*!************************************************************!*\
  !*** ./node_modules/yoastseo/build/helpers/includesAny.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = includesAny;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Checks if any of the values is in the collection.
 *
 * @param {Object|array} collection The collection to check in.
 * @param {array}        values     The array of values.
 *
 * @returns {boolean} Whether a value was found in the collection.
 */
function includesAny(collection, values) {
  for (let i = 0; i < values.length; i++) {
    if ((0, _lodash.includes)(collection, values[i])) {
      return true;
    }
  }
  return false;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/helpers/index.js":
/*!******************************************************!*\
  !*** ./node_modules/yoastseo/build/helpers/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "createAnchorOpeningTag", ({
  enumerable: true,
  get: function () {
    return _shortlinker.createAnchorOpeningTag;
  }
}));
Object.defineProperty(exports, "formatNumber", ({
  enumerable: true,
  get: function () {
    return _formatNumber.default;
  }
}));
Object.defineProperty(exports, "getLanguagesWithWordComplexity", ({
  enumerable: true,
  get: function () {
    return _getLanguagesWithWordComplexity.getLanguagesWithWordComplexity;
  }
}));
Object.defineProperty(exports, "getLanguagesWithWordFormSupport", ({
  enumerable: true,
  get: function () {
    return _getLanguagesWithWordFormSupport.getLanguagesWithWordFormSupport;
  }
}));
exports.htmlEntities = void 0;
Object.defineProperty(exports, "measureTextWidth", ({
  enumerable: true,
  get: function () {
    return _createMeasurementElement.measureTextWidth;
  }
}));
var _createMeasurementElement = __webpack_require__(/*! ./createMeasurementElement */ "./node_modules/yoastseo/build/helpers/createMeasurementElement.js");
var _getLanguagesWithWordFormSupport = __webpack_require__(/*! ./getLanguagesWithWordFormSupport */ "./node_modules/yoastseo/build/helpers/getLanguagesWithWordFormSupport.js");
var _formatNumber = _interopRequireDefault(__webpack_require__(/*! ./formatNumber */ "./node_modules/yoastseo/build/helpers/formatNumber.js"));
var _getLanguagesWithWordComplexity = __webpack_require__(/*! ./getLanguagesWithWordComplexity */ "./node_modules/yoastseo/build/helpers/getLanguagesWithWordComplexity.js");
var _shortlinker = __webpack_require__(/*! ./shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var htmlEntities = _interopRequireWildcard(__webpack_require__(/*! ./htmlEntities */ "./node_modules/yoastseo/build/helpers/htmlEntities.js"));
exports.htmlEntities = htmlEntities;
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function (e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != typeof e && "function" != typeof e) return {
    default: e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n.default = e, t && t.set(e, n), n;
}
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/helpers/shortlinker/Shortlinker.js":
/*!************************************************************************!*\
  !*** ./node_modules/yoastseo/build/helpers/shortlinker/Shortlinker.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Shortlinker to handle appending parameters to a link.
 */
class Shortlinker {
  /**
   * Initialize the Shortlinker class.
   *
   * @param {Object} [config={}] Optional configuration.
   */
  constructor(config = {}) {
    this.configure(config);
  }

  /**
   * Saves the passed configuration.
   *
   * @param {Object} config             The configuration.
   * @param {Object} [config.params={}] The default params to create the query string with.
   *
   * @returns {void}
   */
  configure(config) {
    this._config = {
      params: {},
      ...config
    };
  }

  /**
   * Creates a query string from a params object.
   *
   * @param {Object} params Params for in the query string.
   *
   * @returns {string} URI encoded query string.
   */
  static createQueryString(params) {
    return Object.keys(params).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`).join("&");
  }

  /**
   * Creates a link by combining the params from the config and appending them to the url.
   *
   * @param {string} url         The base url.
   * @param {Object} [params={}] Optional params for in the url.
   *
   * @returns {string} The url with query string.
   */
  append(url, params = {}) {
    let link = encodeURI(url);
    const queryString = Shortlinker.createQueryString({
      ...this._config.params,
      ...params
    });
    if (queryString !== "") {
      link += "?" + queryString;
    }
    return link;
  }

  /**
   * Creates an anchor opening tag; uses the append function to create the url.
   *
   * @param {string} url         The base url.
   * @param {Object} [params={}] Optional params for in the url.
   *
   * @returns {string} The anchor opening tag.
   */
  createAnchorOpeningTag(url, params = {}) {
    return `<a href='${this.append(url, params)}' target='_blank'>`;
  }
}
exports["default"] = Shortlinker;

/***/ }),

/***/ "./node_modules/yoastseo/build/helpers/shortlinker/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/yoastseo/build/helpers/shortlinker/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var _singleton = __webpack_require__(/*! ./singleton */ "./node_modules/yoastseo/build/helpers/shortlinker/singleton.js");
Object.keys(_singleton).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _singleton[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _singleton[key];
    }
  });
});

/***/ }),

/***/ "./node_modules/yoastseo/build/helpers/shortlinker/singleton.js":
/*!**********************************************************************!*\
  !*** ./node_modules/yoastseo/build/helpers/shortlinker/singleton.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.configureShortlinker = configureShortlinker;
exports.createAnchorOpeningTag = createAnchorOpeningTag;
exports.createShortlink = createShortlink;
var _Shortlinker = _interopRequireDefault(__webpack_require__(/*! ./Shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/Shortlinker.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
// Set global scope.
let globalScope;

// In the browser, window exists so that is the global scope.
if (typeof window === "undefined") {
  // Inside a web worker, self exists so that is the global scope.
  if (typeof self === "undefined") {
    // Fall back tot the `global`, because that is the global scope in Node.JS.
    globalScope = __webpack_require__.g;
  } else {
    globalScope = self;
  }
} else {
  globalScope = window;
}
globalScope.yoast = globalScope.yoast || {};
globalScope.yoast.shortlinker = globalScope.yoast.shortlinker || null;

/**
 * Retrieves the Shortlinker instance.
 *
 * @returns {Shortlinker} The Shortlinker.
 */
function getShortlinker() {
  if (globalScope.yoast.shortlinker === null) {
    globalScope.yoast.shortlinker = new _Shortlinker.default();
  }
  return globalScope.yoast.shortlinker;
}

/**
 * Configures the Shortlinker instance.
 *
 * @param {Object} config             The configuration.
 * @param {Object} [config.params={}] The default params for in the url.
 *
 * @returns {void}
 */
function configureShortlinker(config) {
  getShortlinker().configure(config);
}

/**
 * Creates a link by combining the params from the config and appending them to the url.
 *
 * @param {string} url         The url.
 * @param {Object} [params={}] Optional extra params for in the url.
 *
 * @returns {string} The url with query string.
 */
function createShortlink(url, params = {}) {
  return getShortlinker().append(url, params);
}

/**
 * Creates an anchor opening tag.
 *
 * @param {string} url         The url.
 * @param {Object} [params={}] Optional extra params for in the url.
 *
 * @returns {string} The anchor opening tag.
 */
function createAnchorOpeningTag(url, params = {}) {
  return getShortlinker().createAnchorOpeningTag(url, params);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/index.js":
/*!**********************************************!*\
  !*** ./node_modules/yoastseo/build/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "AnalysisWebWorker", ({
  enumerable: true,
  get: function () {
    return _worker.AnalysisWebWorker;
  }
}));
Object.defineProperty(exports, "AnalysisWorkerWrapper", ({
  enumerable: true,
  get: function () {
    return _worker.AnalysisWorkerWrapper;
  }
}));
Object.defineProperty(exports, "App", ({
  enumerable: true,
  get: function () {
    return _app.default;
  }
}));
Object.defineProperty(exports, "Assessment", ({
  enumerable: true,
  get: function () {
    return _assessment.default;
  }
}));
Object.defineProperty(exports, "AssessmentResult", ({
  enumerable: true,
  get: function () {
    return _AssessmentResult.default;
  }
}));
Object.defineProperty(exports, "Assessor", ({
  enumerable: true,
  get: function () {
    return _assessor.default;
  }
}));
Object.defineProperty(exports, "ContentAssessor", ({
  enumerable: true,
  get: function () {
    return _contentAssessor.default;
  }
}));
Object.defineProperty(exports, "DIFFICULTY", ({
  enumerable: true,
  get: function () {
    return _getFleschReadingScore.DIFFICULTY;
  }
}));
Object.defineProperty(exports, "Factory", ({
  enumerable: true,
  get: function () {
    return _factory.default;
  }
}));
Object.defineProperty(exports, "Paper", ({
  enumerable: true,
  get: function () {
    return _Paper.default;
  }
}));
Object.defineProperty(exports, "Pluggable", ({
  enumerable: true,
  get: function () {
    return _pluggable.default;
  }
}));
Object.defineProperty(exports, "SeoAssessor", ({
  enumerable: true,
  get: function () {
    return _seoAssessor.default;
  }
}));
Object.defineProperty(exports, "TaxonomyAssessor", ({
  enumerable: true,
  get: function () {
    return _taxonomyAssessor.default;
  }
}));
exports.config = exports.bundledPlugins = exports.assessments = void 0;
Object.defineProperty(exports, "createWorker", ({
  enumerable: true,
  get: function () {
    return _worker.createWorker;
  }
}));
exports.values = exports.markers = exports.languageProcessing = exports.interpreters = exports.helpers = exports["default"] = void 0;
var _worker = __webpack_require__(/*! ./worker */ "./node_modules/yoastseo/build/worker/index.js");
var assessments = _interopRequireWildcard(__webpack_require__(/*! ./scoring/assessments */ "./node_modules/yoastseo/build/scoring/assessments/index.js"));
exports.assessments = assessments;
var bundledPlugins = _interopRequireWildcard(__webpack_require__(/*! ./bundledPlugins */ "./node_modules/yoastseo/build/bundledPlugins/index.js"));
exports.bundledPlugins = bundledPlugins;
var helpers = _interopRequireWildcard(__webpack_require__(/*! ./helpers */ "./node_modules/yoastseo/build/helpers/index.js"));
exports.helpers = helpers;
var markers = _interopRequireWildcard(__webpack_require__(/*! ./markers */ "./node_modules/yoastseo/build/markers/index.js"));
exports.markers = markers;
var interpreters = _interopRequireWildcard(__webpack_require__(/*! ./scoring/interpreters */ "./node_modules/yoastseo/build/scoring/interpreters/index.js"));
exports.interpreters = interpreters;
var config = _interopRequireWildcard(__webpack_require__(/*! ./config */ "./node_modules/yoastseo/build/config/index.js"));
exports.config = config;
var languageProcessing = _interopRequireWildcard(__webpack_require__(/*! ./languageProcessing */ "./node_modules/yoastseo/build/languageProcessing/index.js"));
exports.languageProcessing = languageProcessing;
var values = _interopRequireWildcard(__webpack_require__(/*! ./values */ "./node_modules/yoastseo/build/values/index.js"));
exports.values = values;
var _app = _interopRequireDefault(__webpack_require__(/*! ./app */ "./node_modules/yoastseo/build/app.js"));
var _assessor = _interopRequireDefault(__webpack_require__(/*! ./scoring/assessor */ "./node_modules/yoastseo/build/scoring/assessor.js"));
var _contentAssessor = _interopRequireDefault(__webpack_require__(/*! ./scoring/contentAssessor */ "./node_modules/yoastseo/build/scoring/contentAssessor.js"));
var _seoAssessor = _interopRequireDefault(__webpack_require__(/*! ./scoring/seoAssessor */ "./node_modules/yoastseo/build/scoring/seoAssessor.js"));
var _taxonomyAssessor = _interopRequireDefault(__webpack_require__(/*! ./scoring/taxonomyAssessor */ "./node_modules/yoastseo/build/scoring/taxonomyAssessor.js"));
var _pluggable = _interopRequireDefault(__webpack_require__(/*! ./pluggable */ "./node_modules/yoastseo/build/pluggable.js"));
var _Paper = _interopRequireDefault(__webpack_require__(/*! ./values/Paper */ "./node_modules/yoastseo/build/values/Paper.js"));
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ./values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _assessment = _interopRequireDefault(__webpack_require__(/*! ./scoring/assessments/assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _getFleschReadingScore = __webpack_require__(/*! ./languageProcessing/researches/getFleschReadingScore */ "./node_modules/yoastseo/build/languageProcessing/researches/getFleschReadingScore.js");
var _factory = _interopRequireDefault(__webpack_require__(/*! ./helpers/factory */ "./node_modules/yoastseo/build/helpers/factory.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function (e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != typeof e && "function" != typeof e) return {
    default: e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n.default = e, t && t.set(e, n), n;
}
/*
 * Everything exported here is put on the `yoast.analysis` global in the plugin.
 */
/*
 * Used for backwards compatibility reasons.
 * For new exports, please add it as a named dependency above instead.
 */
var _default = exports["default"] = {
  App: _app.default,
  Assessor: _assessor.default,
  ContentAssessor: _contentAssessor.default,
  TaxonomyAssessor: _taxonomyAssessor.default,
  Pluggable: _pluggable.default,
  Paper: _Paper.default,
  AssessmentResult: _AssessmentResult.default,
  AnalysisWebWorker: _worker.AnalysisWebWorker,
  AnalysisWorkerWrapper: _worker.AnalysisWorkerWrapper,
  createWorker: _worker.createWorker,
  assessments,
  bundledPlugins,
  config,
  helpers,
  markers,
  interpreters,
  languageProcessing,
  values
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/AbstractResearcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/AbstractResearcher.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _invalidType = _interopRequireDefault(__webpack_require__(/*! ../errors/invalidType */ "./node_modules/yoastseo/build/errors/invalidType.js"));
var _missingArgument = _interopRequireDefault(__webpack_require__(/*! ../errors/missingArgument */ "./node_modules/yoastseo/build/errors/missingArgument.js"));
var _altTagCount = _interopRequireDefault(__webpack_require__(/*! ./researches/altTagCount.js */ "./node_modules/yoastseo/build/languageProcessing/researches/altTagCount.js"));
var _countSentencesFromText = _interopRequireDefault(__webpack_require__(/*! ./researches/countSentencesFromText.js */ "./node_modules/yoastseo/build/languageProcessing/researches/countSentencesFromText.js"));
var _findKeywordInFirstParagraph = _interopRequireDefault(__webpack_require__(/*! ./researches/findKeywordInFirstParagraph.js */ "./node_modules/yoastseo/build/languageProcessing/researches/findKeywordInFirstParagraph.js"));
var _findKeyphraseInSEOTitle = _interopRequireDefault(__webpack_require__(/*! ./researches/findKeyphraseInSEOTitle */ "./node_modules/yoastseo/build/languageProcessing/researches/findKeyphraseInSEOTitle.js"));
var _findTransitionWords = _interopRequireDefault(__webpack_require__(/*! ./researches/findTransitionWords */ "./node_modules/yoastseo/build/languageProcessing/researches/findTransitionWords.js"));
var _functionWordsInKeyphrase = _interopRequireDefault(__webpack_require__(/*! ./researches/functionWordsInKeyphrase */ "./node_modules/yoastseo/build/languageProcessing/researches/functionWordsInKeyphrase.js"));
var _getAnchorsWithKeyphrase = _interopRequireDefault(__webpack_require__(/*! ./researches/getAnchorsWithKeyphrase */ "./node_modules/yoastseo/build/languageProcessing/researches/getAnchorsWithKeyphrase.js"));
var _getFleschReadingScore = _interopRequireDefault(__webpack_require__(/*! ./researches/getFleschReadingScore */ "./node_modules/yoastseo/build/languageProcessing/researches/getFleschReadingScore.js"));
var _getKeywordDensity = _interopRequireWildcard(__webpack_require__(/*! ./researches/getKeywordDensity.js */ "./node_modules/yoastseo/build/languageProcessing/researches/getKeywordDensity.js"));
var _getLinks = _interopRequireDefault(__webpack_require__(/*! ./researches/getLinks.js */ "./node_modules/yoastseo/build/languageProcessing/researches/getLinks.js"));
var _getLinkStatistics = _interopRequireDefault(__webpack_require__(/*! ./researches/getLinkStatistics */ "./node_modules/yoastseo/build/languageProcessing/researches/getLinkStatistics.js"));
var _getParagraphs = _interopRequireDefault(__webpack_require__(/*! ./researches/getParagraphs */ "./node_modules/yoastseo/build/languageProcessing/researches/getParagraphs.js"));
var _getParagraphLength = _interopRequireDefault(__webpack_require__(/*! ./researches/getParagraphLength.js */ "./node_modules/yoastseo/build/languageProcessing/researches/getParagraphLength.js"));
var _getPassiveVoiceResult = _interopRequireDefault(__webpack_require__(/*! ./researches/getPassiveVoiceResult */ "./node_modules/yoastseo/build/languageProcessing/researches/getPassiveVoiceResult.js"));
var _getProminentWordsForInsights = _interopRequireDefault(__webpack_require__(/*! ./researches/getProminentWordsForInsights */ "./node_modules/yoastseo/build/languageProcessing/researches/getProminentWordsForInsights.js"));
var _getProminentWordsForInternalLinking = _interopRequireDefault(__webpack_require__(/*! ./researches/getProminentWordsForInternalLinking */ "./node_modules/yoastseo/build/languageProcessing/researches/getProminentWordsForInternalLinking.js"));
var _getSentenceBeginnings = _interopRequireDefault(__webpack_require__(/*! ./researches/getSentenceBeginnings */ "./node_modules/yoastseo/build/languageProcessing/researches/getSentenceBeginnings.js"));
var _getSubheadingTextLengths = _interopRequireDefault(__webpack_require__(/*! ./researches/getSubheadingTextLengths.js */ "./node_modules/yoastseo/build/languageProcessing/researches/getSubheadingTextLengths.js"));
var _h1s = _interopRequireDefault(__webpack_require__(/*! ./researches/h1s */ "./node_modules/yoastseo/build/languageProcessing/researches/h1s.js"));
var _imageCount = _interopRequireDefault(__webpack_require__(/*! ./researches/imageCount.js */ "./node_modules/yoastseo/build/languageProcessing/researches/imageCount.js"));
var _keyphraseLength = _interopRequireDefault(__webpack_require__(/*! ./researches/keyphraseLength */ "./node_modules/yoastseo/build/languageProcessing/researches/keyphraseLength.js"));
var _keywordCount = _interopRequireWildcard(__webpack_require__(/*! ./researches/keywordCount */ "./node_modules/yoastseo/build/languageProcessing/researches/keywordCount.js"));
var _keywordCountInUrl = __webpack_require__(/*! ./researches/keywordCountInUrl */ "./node_modules/yoastseo/build/languageProcessing/researches/keywordCountInUrl.js");
var _matchKeywordInSubheadings = _interopRequireDefault(__webpack_require__(/*! ./researches/matchKeywordInSubheadings */ "./node_modules/yoastseo/build/languageProcessing/researches/matchKeywordInSubheadings.js"));
var _metaDescriptionKeyword = _interopRequireDefault(__webpack_require__(/*! ./researches/metaDescriptionKeyword */ "./node_modules/yoastseo/build/languageProcessing/researches/metaDescriptionKeyword.js"));
var _metaDescriptionLength = _interopRequireDefault(__webpack_require__(/*! ./researches/metaDescriptionLength.js */ "./node_modules/yoastseo/build/languageProcessing/researches/metaDescriptionLength.js"));
var _getWordForms = _interopRequireDefault(__webpack_require__(/*! ./researches/getWordForms */ "./node_modules/yoastseo/build/languageProcessing/researches/getWordForms.js"));
var _pageTitleWidth = _interopRequireDefault(__webpack_require__(/*! ./researches/pageTitleWidth.js */ "./node_modules/yoastseo/build/languageProcessing/researches/pageTitleWidth.js"));
var _readingTime = _interopRequireDefault(__webpack_require__(/*! ./researches/readingTime */ "./node_modules/yoastseo/build/languageProcessing/researches/readingTime.js"));
var _sentences = _interopRequireDefault(__webpack_require__(/*! ./researches/sentences */ "./node_modules/yoastseo/build/languageProcessing/researches/sentences.js"));
var _videoCount = _interopRequireDefault(__webpack_require__(/*! ./researches/videoCount */ "./node_modules/yoastseo/build/languageProcessing/researches/videoCount.js"));
var _wordCountInText = _interopRequireDefault(__webpack_require__(/*! ./researches/wordCountInText.js */ "./node_modules/yoastseo/build/languageProcessing/researches/wordCountInText.js"));
var _memoizedSentenceTokenizer = _interopRequireDefault(__webpack_require__(/*! ./helpers/sentence/memoizedSentenceTokenizer */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/memoizedSentenceTokenizer.js"));
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function (e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != typeof e && "function" != typeof e) return {
    default: e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n.default = e, t && t.set(e, n), n;
}
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
// All researches in alphabetical order.

// All helpers.

/**
 * The researcher contains all the researches, helpers, data, and config.
 */
class AbstractResearcher {
  /**
   * Constructor
   * @param {Paper} paper The Paper object that is needed within the researches.
   *
   * @constructor
   */
  constructor(paper) {
    this.paper = paper;

    // We expose the deprecated keywordCountInUrl for backwards compatibility.
    this.defaultResearches = {
      altTagCount: _altTagCount.default,
      countSentencesFromText: _countSentencesFromText.default,
      findKeywordInFirstParagraph: _findKeywordInFirstParagraph.default,
      findKeyphraseInSEOTitle: _findKeyphraseInSEOTitle.default,
      findTransitionWords: _findTransitionWords.default,
      functionWordsInKeyphrase: _functionWordsInKeyphrase.default,
      getAnchorsWithKeyphrase: _getAnchorsWithKeyphrase.default,
      getFleschReadingScore: _getFleschReadingScore.default,
      getKeyphraseCount: _keywordCount.default,
      getKeyphraseDensity: _getKeywordDensity.default,
      getKeywordDensity: _getKeywordDensity.getKeywordDensity,
      getLinks: _getLinks.default,
      getLinkStatistics: _getLinkStatistics.default,
      getParagraphs: _getParagraphs.default,
      getParagraphLength: _getParagraphLength.default,
      getProminentWordsForInsights: _getProminentWordsForInsights.default,
      getProminentWordsForInternalLinking: _getProminentWordsForInternalLinking.default,
      getSentenceBeginnings: _getSentenceBeginnings.default,
      getSubheadingTextLengths: _getSubheadingTextLengths.default,
      h1s: _h1s.default,
      imageCount: _imageCount.default,
      keyphraseLength: _keyphraseLength.default,
      keywordCount: _keywordCount.keywordCount,
      keywordCountInSlug: _keywordCountInUrl.keywordCountInSlug,
      keywordCountInUrl: _keywordCountInUrl.keywordCountInUrl,
      matchKeywordInSubheadings: _matchKeywordInSubheadings.default,
      metaDescriptionKeyword: _metaDescriptionKeyword.default,
      metaDescriptionLength: _metaDescriptionLength.default,
      morphology: _getWordForms.default,
      pageTitleWidth: _pageTitleWidth.default,
      readingTime: _readingTime.default,
      sentences: _sentences.default,
      wordCountInText: _wordCountInText.default,
      videoCount: _videoCount.default,
      getPassiveVoiceResult: _getPassiveVoiceResult.default
    };
    this._data = {};
    this.customResearches = {};
    this.helpers = {
      memoizedTokenizer: _memoizedSentenceTokenizer.default
    };
    this.config = {
      areHyphensWordBoundaries: true
    };
  }

  /**
   * Set the Paper associated with the Researcher.
   *
   * @param {Paper} paper The Paper to use within the Researcher.
   *
   * @throws {InvalidTypeError} Parameter needs to be an instance of the Paper object.
   *
   * @returns {void}
   */
  setPaper(paper) {
    this.paper = paper;
  }

  /**
   * Add a custom research that will be available within the Researcher.
   *
   * @param {string}   name     A name to reference the research by.
   * @param {function} research The function to be added to the Researcher.
   *
   * @throws {MissingArgument}  Research name cannot be empty.
   * @throws {InvalidTypeError} The research requires a valid Function callback.
   *
   * @returns {void}
   */
  addResearch(name, research) {
    if ((0, _lodash.isUndefined)(name) || (0, _lodash.isEmpty)(name)) {
      throw new _missingArgument.default("Research name cannot be empty");
    }
    if (!(research instanceof Function)) {
      throw new _invalidType.default("The research requires a Function callback.");
    }
    this.customResearches[name] = research;
  }

  /**
   * Add research data to the researcher by the research name.
   *
   * @param {string} research The identifier of the research.
   * @param {Object} data     The data object.
   *
   * @returns {void}.
   */
  addResearchData(research, data) {
    this._data[research] = data;
  }

  /**
   * Add a custom helper that will be available within the Researcher.
   *
   * @param {string}   name     A name to reference the helper by.
   * @param {function} helper   The function to be added to the Researcher.
   *
   * @throws {MissingArgument}  Helper name cannot be empty.
   * @throws {InvalidTypeError} The helper requires a valid Function callback.
   *
   * @returns {void}
   */
  addHelper(name, helper) {
    if ((0, _lodash.isUndefined)(name) || (0, _lodash.isEmpty)(name)) {
      throw new _missingArgument.default("Helper name cannot be empty");
    }
    if (!(helper instanceof Function)) {
      throw new _invalidType.default("The research requires a Function callback.");
    }
    this.helpers[name] = helper;
  }

  /**
   * Add a custom configuration that will be available within the Researcher.
   *
   * @param {string}  name     A name to reference the helper by.
   * @param {*}       config   The configuration to be added to the Researcher.
   *
   * @throws {MissingArgument}  Configuration name and the configuration itself cannot be empty.
   *
   * @returns {void}
   */
  addConfig(name, config) {
    if ((0, _lodash.isUndefined)(name) || (0, _lodash.isEmpty)(name)) {
      throw new _missingArgument.default("Failed to add the custom researcher config. Config name cannot be empty.");
    }
    if ((0, _lodash.isUndefined)(config) || (0, _lodash.isEmpty)(config) && config === Object(config)) {
      throw new _missingArgument.default("Failed to add the custom researcher config. Config cannot be empty.");
    }
    this.config[name] = config;
  }

  /**
   * Check whether the research is known by the Researcher.
   *
   * @param {string} name The name to reference the research by.
   *
   * @returns {boolean} Whether or not the research is known by the Researcher.
   */
  hasResearch(name) {
    return Object.keys(this.getAvailableResearches()).filter(function (research) {
      return research === name;
    }).length > 0;
  }

  /**
   * Check whether the helper is known by the Researcher.
   *
   * @param {string} name The name to reference the helper by.
   *
   * @returns {boolean} Whether or not the helper is known by the Researcher.
   */
  hasHelper(name) {
    return Object.keys(this.getAvailableHelpers()).filter(function (helper) {
      return helper === name;
    }).length > 0;
  }

  /**
   * Check whether the config is known by the Researcher.
   *
   * @param {string} name The name to reference the config by.
   *
   * @returns {boolean} Whether or not the config is known by the Researcher.
   */
  hasConfig(name) {
    return Object.keys(this.getAvailableConfig()).filter(function (config) {
      return config === name;
    }).length > 0;
  }

  /**
   * Check whether the research data is known by the Researcher.
   *
   * @param {string} name The name to reference the research data by.
   *
   * @returns {boolean} Whether or not the research data is known by the Researcher.
   */
  hasResearchData(name) {
    return Object.keys(this.getAvailableResearchData()).filter(function (data) {
      return data === name;
    }).length > 0;
  }

  /**
   * Return all available researches.
   *
   * @returns {Object} An object containing all available researches.
   */
  getAvailableResearches() {
    return (0, _lodash.merge)(this.defaultResearches, this.customResearches);
  }

  /**
   * Return all available helpers.
   *
   * @returns {Object} An object containing all available helpers.
   */
  getAvailableHelpers() {
    return this.helpers;
  }

  /**
   * Return all available configuration.
   *
   * @returns {Object} An object containing all available configuration.
   */
  getAvailableConfig() {
    return this.config;
  }

  /**
   * Return all available research data.
   *
   * @returns {Object} An object containing all available research data.
   */
  getAvailableResearchData() {
    return this._data;
  }

  /**
   * Return the Research by name.
   *
   * @param {string} name The name to reference the research by.
   *
   * @returns {*} Returns the result of the research or false if research does not exist.
   *
   * @throws {MissingArgument} Research name cannot be empty.
   */
  getResearch(name) {
    if ((0, _lodash.isUndefined)(name) || (0, _lodash.isEmpty)(name)) {
      throw new _missingArgument.default("Research name cannot be empty");
    }
    if (!this.hasResearch(name)) {
      return false;
    }
    return this.getAvailableResearches()[name](this.paper, this);
  }

  /**
   * Return the research data from a research data provider by research name.
   *
   * @param {string} research The identifier of the research.
   *
   * @returns {*} The data provided by the provider, false if the data do not exist
   */
  getData(research) {
    if (this.hasResearchData(research)) {
      return this._data[research];
    }
    return false;
  }

  /**
   * Return language specific configuration by configuration name.
   *
   * @param {string} name The name of the configuration.
   *
   * @returns {*} The configuration, false if the configuration does not exist.
   */
  getConfig(name) {
    if (this.hasConfig(name)) {
      return this.config[name];
    }
    return false;
  }

  /**
   * Return language specific helper by helper name.
   *
   * @param {string} name The name of the helper.
   *
   * @returns {*} The helper, false if the helper does not exist.
   */
  getHelper(name) {
    if (this.hasHelper(name)) {
      return this.helpers[name];
    }
    return false;
  }
}
exports["default"] = AbstractResearcher;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/highlighting/getMarkingsInSentence.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/highlighting/getMarkingsInSentence.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _Mark = _interopRequireDefault(__webpack_require__(/*! ../../../values/Mark */ "./node_modules/yoastseo/build/values/Mark.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const markStart = "<yoastmark class='yoast-text-mark'>";
const markEnd = "</yoastmark>";

/**
 * Adds `yoastmark` tags to the keyphrase matches in the sentence.
 *
 * This is a helper for search-based highlighting.
 *
 * @param {Sentence}	sentence	The sentence to add the `yoastmark` tags to.
 * @param {Token[]}		matches		The array of the keyphrase matches.
 *
 * @returns {string} The sentence with the added `yoastmark` tags.
 */
const createMarksForSentence = (sentence, matches) => {
  const tokens = sentence.tokens;
  const newTokens = [];
  for (let i = tokens.length - 1; i >= 0; i--) {
    const token = tokens[i];
    if (matches.some(match => match.sourceCodeRange.startOffset === token.sourceCodeRange.startOffset || match.sourceCodeRange.endOffset === token.sourceCodeRange.endOffset)) {
      newTokens.unshift(markStart, token.text, markEnd);
    } else {
      newTokens.unshift(token.text);
    }
  }
  const markedSentence = newTokens.join("");
  // Merge consecutive markings into one marking.
  return markedSentence.replace(new RegExp("</yoastmark>([ \u00A0]?)<yoastmark class='yoast-text-mark'>", "ig"), "$1");
};

/**
 * Merges consecutive and overlapping markings into one marking.
 *
 * This is a helper for position-based highlighting.
 *
 * @param {Mark[]}	markings	An array of markings to merge.
 *
 * @returns {Mark[]} An array of markings where consecutive and overlapping markings are merged.
 */
const mergeConsecutiveAndOverlappingMarkings = markings => {
  const newMarkings = [];

  // Sort markings by start offset. This is probably redundant, but for extra safety.
  markings.sort(function (a, b) {
    return a.getPositionStart() - b.getPositionStart();
  });
  markings.forEach(marking => {
    if (newMarkings.length === 0) {
      newMarkings.push(marking);
      return;
    }
    const lastMarking = newMarkings[newMarkings.length - 1];
    // Adding 1 to the position end, with the assumption that the language uses spaces.
    // When we adapt Japanese to use this helper, this check should also be adapted.
    if (lastMarking.getPositionEnd() + 1 === marking.getPositionStart() || marking.getPositionStart() <= lastMarking.getPositionEnd()) {
      // The marking is consecutive to the last marking, so we extend the last marking to include the new marking.
      lastMarking.setPositionEnd(marking.getPositionEnd());
      lastMarking.setBlockPositionEnd(marking.getBlockPositionEnd());
    } else {
      // The marking is not consecutive to the last marking, so we add it to the array by itself.
      newMarkings.push(marking);
    }
  });
  return newMarkings;
};

/**
 * Gets the Mark objects of all keyphrase matches in the sentence.
 * Currently, this function creates Mark objects compatible for both search-based and position-based highlighting.
 * In a pure position-based highlighting, we don't need to provide 'marked' and 'original' when creating the Mark object.
 *
 * @param {Sentence}	sentence			The sentence to check.
 * @param {Token[]}		matchesInSentence	An array containing the keyphrase matches in the sentence.
 *
 * @returns {Mark[]} The array of Mark objects of the keyphrase matches in the sentence.
 */
function getMarkingsInSentence(sentence, matchesInSentence) {
  if (matchesInSentence.length === 0) {
    return [];
  }

  // Create the marked sentence that is used for search-based highlighting.
  const markedSentence = createMarksForSentence(sentence, matchesInSentence);

  /*
   * Note that there is a paradigm shift:
   * With search-based highlighting, there would be one Mark object for the entire sentence.
   * With position-based highlighting, there is a Mark object for each match.
   * Hence, in order to be backwards compatible with search-based highlighting,
   * all Mark objects for a sentence have the same markedSentence.
   */
  const markings = matchesInSentence.map(token => {
    const startOffset = token.sourceCodeRange.startOffset;
    const endOffset = token.sourceCodeRange.endOffset;
    return new _Mark.default({
      position: {
        startOffset: startOffset,
        endOffset: endOffset,
        // Relative to start of block positions.
        startOffsetBlock: startOffset - (sentence.parentStartOffset || 0),
        endOffsetBlock: endOffset - (sentence.parentStartOffset || 0),
        // The client id of the block the match was found in.
        clientId: sentence.parentClientId || "",
        // The attribute id of the Yoast sub-block the match was found in.
        attributeId: sentence.parentAttributeId || "",
        // Whether the match was found in the first section of the Yoast sub-block.
        isFirstSection: sentence.isParentFirstSectionOfBlock || false
      },
      marked: markedSentence,
      original: sentence.text
    });
  });
  return mergeConsecutiveAndOverlappingMarkings(markings);
}
var _default = exports["default"] = getMarkingsInSentence;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/html/getFieldsToMark.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/html/getFieldsToMark.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getFieldsToMark = getFieldsToMark;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _getSubheadings = __webpack_require__(/*! ./getSubheadings */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/getSubheadings.js");
/**
 * Gets the part of the html that we want to apply the marking to.
 *
 * @param {array}   marks  The array of mark objects.
 * @param {string}  html   The html of the page where we want to apply the marking to.
 *
 * @returns {{selectedHTML: *[], fieldsToMark: *}} The selected part of the html we want to apply the marking to.
 */
function getFieldsToMark(marks, html) {
  const fieldsToMark = (0, _lodash.uniq)((0, _lodash.flatten)(marks.map(mark => {
    if (!(0, _lodash.isUndefined)(mark.getFieldsToMark())) {
      return mark.getFieldsToMark();
    }
  })));
  const selectedHTML = [];
  fieldsToMark.forEach(field => {
    if (field === "heading") {
      const subheadings = (0, _getSubheadings.getSubheadings)(html);
      subheadings.forEach(subheading => {
        selectedHTML.push(subheading[0]);
      });
    }
  });
  return {
    fieldsToMark,
    selectedHTML
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/html/getSubheadingTexts.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/html/getSubheadingTexts.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Returns An array of found subheadings including the following text.
 *
 * @param {string} text The text to analyze from.
 *
 * @returns {Array} An array of found subheadings including the following text.
 */
function _default(text) {
  // Match all the subheadings.
  const subheadings = [...text.matchAll(new RegExp("<h([1-6])(?:[^>]+)?>(.*?)<\\/h\\1>", "ig"))];
  const foundSubheadings = [];
  subheadings.forEach((subheading, i) => {
    // Retrieve the current subheading string.
    const subheadingString = subheading[0];
    // Retrieve the current subheading index.
    const currentMatchIndex = subheading.index;
    // Retrieve the next subheading.
    const nextSubheading = subheadings[i + 1];
    let nextMatchIndex;

    // Check if there is a next subheading.
    if ((0, _lodash.isUndefined)(nextSubheading)) {
      // If there is no next subheading, the next match index is the index of the last character in the text.
      nextMatchIndex = subheading.input.length;
    } else {
      // Retrieve the index of the next subheading.
      nextMatchIndex = nextSubheading.index;
    }

    // Retrieve the text following the current subheading.
    const textFollowingCurrentSubheading = subheading.input.slice(currentMatchIndex + subheadingString.length, nextMatchIndex);
    foundSubheadings.push({
      subheading: subheadingString,
      text: textFollowingCurrentSubheading,
      index: currentMatchIndex
    });
  });
  return foundSubheadings;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/html/getSubheadings.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/html/getSubheadings.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
exports.getSubheadingContents = getSubheadingContents;
exports.getSubheadingContentsTopLevel = getSubheadingContentsTopLevel;
exports.getSubheadings = getSubheadings;
exports.getSubheadingsTopLevel = getSubheadingsTopLevel;
exports.removeSubheadingsTopLevel = removeSubheadingsTopLevel;
/**
 * Gets all subheadings from the text and returns these in an array.
 *
 * @param {string} text The text to return the headings from.
 *
 * @returns {Array<string[]>} Matches of subheadings in the text, first key is everything including tags,
 *                            second is the heading level, third is the content of the subheading.
 */
function getSubheadings(text) {
  const subheadings = [];
  const regex = /<h([1-6])(?:[^>]+)?>(.*?)<\/h\1>/ig;
  let match;
  while ((match = regex.exec(text)) !== null) {
    subheadings.push(match);
  }
  return subheadings;
}

/**
 * Gets all the level 2 and 3 subheadings from the text and returns these in an array.
 *
 * @param {string} text The text to return the headings from.
 *
 * @returns {Array<string[]>} Matches of subheadings in the text, first key is everything including tags,
 *                            second is the heading level, third is the content of the subheading.
 */
function getSubheadingsTopLevel(text) {
  const subheadings = [];
  const regex = /<h([2-3])(?:[^>]+)?>(.*?)<\/h\1>/ig;
  let match;
  while ((match = regex.exec(text)) !== null) {
    subheadings.push(match);
  }
  return subheadings;
}

/**
 * Gets the content of subheadings in the text.
 *
 * @param {string} text The text to get the subheading contents from.
 *
 * @returns {string[]} A list of all the subheadings with their content.
 */
function getSubheadingContents(text) {
  const subheadings = getSubheadings(text);
  return subheadings.map(subheading => subheading[0]);
}

/**
 * Gets the content of subheadings h2 and h3 in the text.
 *
 * @param {string} text The text to get the subheading contents from.
 *
 * @returns {string[]} A list of all the subheadings with their content.
 */
function getSubheadingContentsTopLevel(text) {
  const subheadings = getSubheadingsTopLevel(text);

  // Only return the entire string matched, not the rest of the outputs of the regex.exec function.
  return subheadings.map(subheading => subheading[0]);
}

/**
 * Removes all level 2 and 3 subheadings from the text.
 *
 * @param {string} text The text to remove the headings from.
 *
 * @returns {string} The text with removed subheadings.
 */
function removeSubheadingsTopLevel(text) {
  const regex = /<h([2-3])(?:[^>]+)?>(.*?)<\/h\1>/ig;
  return text.replace(regex, "");
}
var _default = exports["default"] = {
  getSubheadings: getSubheadings,
  getSubheadingsTopLevel: getSubheadingsTopLevel,
  getSubheadingContents: getSubheadingContents,
  getSubheadingContentsTopLevel: getSubheadingContentsTopLevel,
  removeSubheadingsTopLevel: removeSubheadingsTopLevel
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/html/html.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/html/html.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.inlineElements = exports.getBlocks = exports["default"] = exports.blockElements = void 0;
exports.isBlockElement = isBlockElement;
exports.isInlineElement = isInlineElement;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _core = _interopRequireDefault(__webpack_require__(/*! tokenizer2/core */ "./node_modules/tokenizer2/core.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const blockElements = exports.blockElements = ["address", "article", "aside", "blockquote", "canvas", "dd", "div", "dl", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "li", "main", "nav", "noscript", "ol", "output", "p", "pre", "section", "table", "tfoot", "ul", "video"];
const inlineElements = exports.inlineElements = ["b", "big", "i", "small", "tt", "abbr", "acronym", "cite", "code", "dfn", "em", "kbd", "strong", "samp", "time", "var", "a", "bdo", "br", "img", "map", "object", "q", "script", "span", "sub", "sup", "button", "input", "label", "select", "textarea"];
const blockElementsRegex = new RegExp("^(" + blockElements.join("|") + ")$", "i");
const inlineElementsRegex = new RegExp("^(" + inlineElements.join("|") + ")$", "i");
const blockElementStartRegex = new RegExp("^<(" + blockElements.join("|") + ")[^>]*?>$", "i");
const blockElementEndRegex = new RegExp("^</(" + blockElements.join("|") + ")[^>]*?>$", "i");
const inlineElementStartRegex = new RegExp("^<(" + inlineElements.join("|") + ")[^>]*>$", "i");
const inlineElementEndRegex = new RegExp("^</(" + inlineElements.join("|") + ")[^>]*>$", "i");
const otherElementStartRegex = /^<([^>\s/]+)[^>]*>$/;
const otherElementEndRegex = /^<\/([^>\s]+)[^>]*>$/;
const contentRegex = /^[^<]+$/;
const greaterThanContentRegex = /^<[^><]*$/;
const commentRegex = /<!--(.|[\r\n])*?-->/g;
let tokens = [];
let htmlBlockTokenizer;

/**
 * Creates a tokenizer to tokenize HTML into blocks.
 *
 * @returns {void}
 */
function createTokenizer() {
  tokens = [];
  htmlBlockTokenizer = (0, _core.default)(function (token) {
    tokens.push(token);
  });
  htmlBlockTokenizer.addRule(contentRegex, "content");
  htmlBlockTokenizer.addRule(greaterThanContentRegex, "greater-than-sign-content");
  htmlBlockTokenizer.addRule(blockElementStartRegex, "block-start");
  htmlBlockTokenizer.addRule(blockElementEndRegex, "block-end");
  htmlBlockTokenizer.addRule(inlineElementStartRegex, "inline-start");
  htmlBlockTokenizer.addRule(inlineElementEndRegex, "inline-end");
  htmlBlockTokenizer.addRule(otherElementStartRegex, "other-element-start");
  htmlBlockTokenizer.addRule(otherElementEndRegex, "other-element-end");
}

/**
 * Returns whether or not the given element name is a block element.
 *
 * @param {string} htmlElementName The name of the HTML element.
 * @returns {boolean} Whether or not it is a block element.
 */
function isBlockElement(htmlElementName) {
  return blockElementsRegex.test(htmlElementName);
}

/**
 * Returns whether or not the given element name is an inline element.
 *
 * @param {string} htmlElementName The name of the HTML element.
 * @returns {boolean} Whether or not it is an inline element.
 */
function isInlineElement(htmlElementName) {
  return inlineElementsRegex.test(htmlElementName);
}

/**
 * Splits a text into blocks based on HTML block elements.
 *
 * @param {string} text The text to split.
 * @returns {Array} A list of blocks based on HTML block elements.
 */
function getBlocks(text) {
  const blocks = [];
  let depth = 0,
    blockStartTag = "",
    currentBlock = "",
    blockEndTag = "";

  // Remove all comments because it is very hard to tokenize them.
  text = text.replace(commentRegex, "");
  createTokenizer();
  htmlBlockTokenizer.onText(text);
  htmlBlockTokenizer.end();
  (0, _lodash.forEach)(tokens, function (token, i) {
    const nextToken = tokens[i + 1];
    switch (token.type) {
      case "content":
      case "greater-than-sign-content":
      case "inline-start":
      case "inline-end":
      case "other-tag":
      case "other-element-start":
      case "other-element-end":
      case "greater than sign":
        if (!nextToken || depth === 0 && (nextToken.type === "block-start" || nextToken.type === "block-end")) {
          currentBlock += token.src;
          blocks.push(currentBlock);
          blockStartTag = "";
          currentBlock = "";
          blockEndTag = "";
        } else {
          currentBlock += token.src;
        }
        break;
      case "block-start":
        if (depth !== 0) {
          if (currentBlock.trim() !== "") {
            blocks.push(currentBlock);
          }
          currentBlock = "";
          blockEndTag = "";
        }
        depth++;
        blockStartTag = token.src;
        break;
      case "block-end":
        depth--;
        blockEndTag = token.src;

        /*
         * We try to match the most deep blocks so discard any other blocks that have been started but not
         * finished.
         */
        if ("" !== blockStartTag && "" !== blockEndTag) {
          blocks.push(blockStartTag + currentBlock + blockEndTag);
        } else if ("" !== currentBlock.trim()) {
          blocks.push(currentBlock);
        }
        blockStartTag = "";
        currentBlock = "";
        blockEndTag = "";
        break;
    }

    // Handles HTML with too many closing tags.
    if (depth < 0) {
      depth = 0;
    }
  });
  return blocks;
}
const memoizedGetBlocks = exports.getBlocks = (0, _lodash.memoize)(getBlocks);
var _default = exports["default"] = {
  blockElements: blockElements,
  inlineElements: inlineElements,
  isBlockElement: isBlockElement,
  isInlineElement: isInlineElement,
  getBlocks: memoizedGetBlocks
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _htmlparser = _interopRequireDefault(__webpack_require__(/*! htmlparser2 */ "./node_modules/htmlparser2/lib/index.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * This file is used for HTML parsing for assessment that not use the HTML Parser.
 * We use a (simpler) external library, which can be found here: https://github.com/fb55/htmlparser2.
 */

/**
 * The array containing the text parts without ignored HTML blocks.
 * @type {string[]}
 */
let textArray = [];
/**
 * Whether we are currently in an ignored HTML block.
 * @type {boolean}
 */
let inIgnorableBlock = false;
/**
 * The stack of currently ignored tags, when we are in an ignorable HTML block.
 * @type {string[]}
 */
let ignoreStack = [];

/**
 * The HTML tags that should be ignored.
 * @type {string[]}
 */
const IGNORED_TAGS = ["script", "style", "code", "pre", "blockquote", "textarea"];
/**
 * The classes of HTML elements that should be ignored.
 * @type {string[]}
 */
const IGNORED_CLASSES = ["yoast-table-of-contents", "yoast-reading-time__wrapper", "elementor-button-wrapper", "elementor-divider", "elementor-spacer", "elementor-custom-embed", "elementor-icon-wrapper", "elementor-icon-box-wrapper", "elementor-counter", "elementor-progress-wrapper", "elementor-alert", "elementor-soundcloud-wrapper", "elementor-shortcode", "elementor-menu-anchor", "elementor-title"];

/**
 * Parses the text.
 */
const parser = new _htmlparser.default.Parser({
  /**
   * Handles the opening tag.
   * If we are in an ignorable block, disregard the tag.
   * If the opening tag is included in the `IGNORED_TAGS` array, or the class is in the `IGNORED_CLASSES` array,
   * set `inIgnorableBlock` to true and add the tag to the `ignoreStack`.
   * Otherwise, push the tag to the `textArray`.
   *
   * @param {string} tagName The tag name.
   * @param {object} nodeValue The attribute with the keys and values of the tag.
   *
   * @returns {void}
   */
  onopentag: function (tagName, nodeValue) {
    if (inIgnorableBlock) {
      ignoreStack.push(tagName);
      return;
    }
    const classNames = nodeValue.class ? nodeValue.class.split(" ") : [];
    if (IGNORED_TAGS.includes(tagName) || classNames.some(className => IGNORED_CLASSES.includes(className))) {
      inIgnorableBlock = true;
      ignoreStack.push(tagName);
      return;
    }
    const nodeValueType = Object.keys(nodeValue);
    let nodeValueString = "";
    nodeValueType.forEach(function (node) {
      // Build the tag again.
      nodeValueString += " " + node + "='" + nodeValue[node] + "'";
    });
    textArray.push("<" + tagName + nodeValueString + ">");
  },
  /**
   * Handles the text that doesn't contain opening or closing tags.
   * If `inIgnorableBlock` is false, the text gets pushed to the `textArray` array.
   *
   * @param {string} text The text that doesn't contain opening or closing tags.
   *
   * @returns {void}
   */
  ontext: function (text) {
    if (!inIgnorableBlock) {
      textArray.push(text);
    }
  },
  /**
   * Handles the closing tag.
   * If the closing tag is the last tag on the `ignoreStack`, jump out of the ignorable block.
   * Otherwise, if we are not currently in an ignorable block, push the tag to the `textArray`.
   *
   * @param {string} tagName The tag name.
   *
   * @returns {void}
   */
  onclosetag: function (tagName) {
    if (ignoreStack.length === 1 && ignoreStack[0] === tagName) {
      inIgnorableBlock = false;
      ignoreStack = [];
      return;
    }
    if (inIgnorableBlock) {
      ignoreStack.pop();
      return;
    }
    textArray.push("</" + tagName + ">");
  }
}, {
  decodeEntities: true
});

/**
 * Calls htmlparser2 and returns the text without HTML blocks that we do not want to consider for the content analysis.
 * Note that this function will soon be deprecated in favour of our own HTML parser.
 *
 * @param {string} text The text to parse.
 *
 * @returns {string} The text without the HTML blocks.
 */
function _default(text) {
  // Return the globals to their starting values.
  textArray = [];
  inIgnorableBlock = false;
  ignoreStack = [];
  parser.write(text);
  // Make sure to complete the process of parsing and reset the parser to avoid side effects.
  parser.parseComplete();
  return textArray.join("");
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/html/matchParagraphs.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/html/matchParagraphs.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _html = __webpack_require__(/*! ./html */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/html.js");
/**
 * Matches the paragraphs in <p>-tags and returns the text in them.
 *
 * @param {string} text The text to match paragraph in.
 *
 * @returns {array} An array containing all paragraphs texts.
 */
const getParagraphsInTags = function (text) {
  let paragraphs = [];
  // Matches everything between the <p> and </p> tags.
  const regex = /<p(?:[^>]+)?>(.*?)<\/p>/ig;
  let match;
  while ((match = regex.exec(text)) !== null) {
    paragraphs.push(match);
  }

  // Returns only the text from within the paragraph tags.
  paragraphs = (0, _lodash.map)(paragraphs, function (paragraph) {
    return paragraph[1];
  });
  return paragraphs.filter(paragraph => paragraph.length > 0);
};

/**
 * Returns an array with all paragraphs from the text.
 *
 * @param {string} text The text to match paragraph in.
 *
 * @returns {Array} The array containing all paragraphs from the text.
 */
function _default(text) {
  let paragraphs = getParagraphsInTags(text);
  if (paragraphs.length > 0) {
    return paragraphs;
  }

  // If no <p> tags found, split on double linebreaks.
  let blocks = (0, _html.getBlocks)(text);
  blocks = (0, _lodash.filter)(blocks, function (block) {
    // Match explicit paragraph tags, or if a block has no HTML tags.
    return 0 !== block.indexOf("<h");
  });
  paragraphs = (0, _lodash.flatMap)(blocks, function (block) {
    return block.split("\n\n");
  });
  if (paragraphs.length > 0) {
    return paragraphs;
  }

  // If no paragraphs are found, return an array containing the entire text.
  return [text];
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/html/normalizeHTML.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/html/normalizeHTML.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Replaces single quotes around HTML attribute values with double quotes.
 * Double quotes are the standard, but we convert these to single quotes when parsing the HTML in `yoastseo` package.
 * Here, we change them back to double quotes so by parsing the HTML and then outputting it again.
 * Note that this function does more than just replacing single quotes with double quotes. It also restores corrupted HTML.
 * @param {string} str The input string.
 *
 * @returns {string} The string with single quotes around HTML attributes replaced with double quotes.
 */
function _default(str) {
  const doc = new DOMParser().parseFromString(str, "text/html");
  const normalizedHTML = doc.body.innerHTML;

  // Replace `&nbsp;` with an actual non breaking space (U+00A0).
  return normalizedHTML.replace(/&nbsp;/g, "\u00A0");
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/image/getAltAttribute.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/image/getAltAttribute.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _stripSpaces = _interopRequireDefault(__webpack_require__(/*! ../sanitize/stripSpaces.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripSpaces.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Checks for an alt attribute in the image and returns its content.
 *
 * @param {Node} imageNode Text string to match the alt attribute.
 * @returns {String} The contents of the alt attribute, empty if none is set.
 */
function _default(imageNode) {
  let alt = "";
  if (imageNode.name === "img") {
    alt = (0, _stripSpaces.default)(imageNode.attributes.alt || "");
    alt = alt.replace(/&quot;/g, "\"");
    alt = alt.replace(/&#039;/g, "'");
  }
  return alt;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/image/getImagesInTree.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/image/getImagesInTree.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Checks the tree for images.
 *
 * @param {Paper}       paper       The paper to check for images.
 *
 * @returns {Array} Array containing all images in the tree
 */
function _default(paper) {
  const tree = paper.getTree();
  if (!tree) {
    return [];
  }
  return tree.findAll(node => node.name === "img");
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/image/imageInText.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/image/imageInText.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
exports.imageRegex = void 0;
var _matchStringWithRegex = _interopRequireDefault(__webpack_require__(/*! ../regex/matchStringWithRegex.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/regex/matchStringWithRegex.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module stringProcessing/imageInText */

/**
 * @returns {object} A precompiled regex for recognizing self closing image tags.
 */
const imageRegex = exports.imageRegex = new RegExp("<img(?:[^>]+)?>(</img>)*", "ig");

/**
 * Checks the text for images.
 *
 * @param {string} text The text string to check for images
 * @returns {Array} Array containing all types of found images
 */
function _default(text) {
  return (0, _matchStringWithRegex.default)(text, imageRegex);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "filterShortcodesFromHTML", ({
  enumerable: true,
  get: function () {
    return _filterShortcodesFromTree.filterShortcodesFromHTML;
  }
}));
Object.defineProperty(exports, "matchStringWithRegex", ({
  enumerable: true,
  get: function () {
    return _matchStringWithRegex.default;
  }
}));
Object.defineProperty(exports, "normalize", ({
  enumerable: true,
  get: function () {
    return _quotes.normalize;
  }
}));
Object.defineProperty(exports, "removeHtmlBlocks", ({
  enumerable: true,
  get: function () {
    return _htmlParser.default;
  }
}));
var _matchStringWithRegex = _interopRequireDefault(__webpack_require__(/*! ./regex/matchStringWithRegex */ "./node_modules/yoastseo/build/languageProcessing/helpers/regex/matchStringWithRegex.js"));
var _quotes = __webpack_require__(/*! ./sanitize/quotes */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/quotes.js");
var _filterShortcodesFromTree = __webpack_require__(/*! ./sanitize/filterShortcodesFromTree */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/filterShortcodesFromTree.js");
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ./html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/language/getLanguage.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/language/getLanguage.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * The function getting the language part of the locale.
 *
 * @param {string} locale The locale.
 * @returns {string} The language part of the locale.
 */
function _default(locale) {
  return locale.split("_")[0];
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/link/checkNofollow.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/link/checkNofollow.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _htmlparser = _interopRequireDefault(__webpack_require__(/*! htmlparser2 */ "./node_modules/htmlparser2/lib/index.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module stringProcessing/checkNofollow */

// We use an external library, which can be found here: https://github.com/fb55/htmlparser2.

/**
 * Checks if a link has a `rel` attribute with a `nofollow` value. If it has, returns Nofollow, otherwise Dofollow.
 *
 * @param {string} anchorHTML The anchor HTML to check against.
 * @returns {string} Returns Dofollow or Nofollow.
 */
function _default(anchorHTML) {
  let linkFollow = "Dofollow";
  const parser = new _htmlparser.default.Parser({
    /**
     * Detects if there is a `nofollow` value in the `rel` attribute of a link.
     *
     * @param {string} tagName The tag name.
     * @param {object} attributes The tag attributes with the names and values of each attribute found.
     * @returns {void}
     */
    onopentag: function (tagName, attributes) {
      if (tagName !== "a" || !attributes.rel) {
        return;
      }
      if (attributes.rel.toLowerCase().split(/\s/).includes("nofollow")) {
        linkFollow = "Nofollow";
      }
    }
  });
  parser.write(anchorHTML);
  parser.end();
  return linkFollow;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/link/getAnchorsFromText.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/link/getAnchorsFromText.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/** @module stringProcessing/getAnchorsFromText */

/**
 * Check for anchors in the text string and returns them in an array.
 *
 * @param {String} text The text to check for matches.
 *
 * @returns {Array} The matched links in text.
 */
function _default(text) {
  let matches;

  /*
    * Regex matches everything between <a> and </a>.
    *
    * There must be:
    * - at least one whitespace after the starting `<a`, otherwise it matches `<abbr` tags.
    * - followed by at least one not `>`, to match any attributes that are given.
    *   This could be one or zero (`*`), but an anchor tag without an `href` attribute does not make sense.
    *   The regex could be more precise here, by checking for the `href`, but this is less complex.
    * - losing tag of the opening tag `>`.
    * - content of the anchor tag. Any character, including line separators (`[\n\r\u2028\u2029]`).
    * - the closing anchor tag.
   */
  matches = text.match(/<a[\s]+(?:[^>]+)>((?:.|[\n\r\u2028\u2029])*?)<\/a>/ig);
  if (matches === null) {
    matches = [];
  }
  return matches;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/link/getLinkType.js":
/*!************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/link/getLinkType.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _url = _interopRequireDefault(__webpack_require__(/*! ../url/url */ "./node_modules/yoastseo/build/languageProcessing/helpers/url/url.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module stringProcess/getLinkType */

/**
 * Determines the type of link.
 *
 * @param {string} 	anchor 				String with anchor element.
 * @param {string} 	siteUrlOrDomain		URL or domain to match against.
 *
 * @returns {string} The link type (other, external or internal).
 */
function _default(anchor, siteUrlOrDomain) {
  const anchorUrl = _url.default.getFromAnchorTag(anchor);

  /**
   * A link is "Other" if:
   * - The protocol is neither null, nor http, nor https.
   * - The link is a relative fragment URL (starts with #), because it won't navigate to another page.
   */
  const protocol = _url.default.getProtocol(anchorUrl);
  if (protocol && !_url.default.protocolIsHttpScheme(protocol) || _url.default.isRelativeFragmentURL(anchorUrl)) {
    return "other";
  }
  if (_url.default.isInternalLink(anchorUrl, siteUrlOrDomain)) {
    return "internal";
  }
  return "external";
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/match/findKeywordFormsInString.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/match/findKeywordFormsInString.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.findWordFormsInString = exports.findTopicFormsInString = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _matchTextWithArray = _interopRequireDefault(__webpack_require__(/*! ./matchTextWithArray.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/matchTextWithArray.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Matches forms of words in the keyphrase against a given text.
 *
 * @param {Array}       keywordForms    The array with word forms of all (content) words from the keyphrase in a shape
 *                                      [ [ form1, form2, ... ], [ form1, form2, ... ] ].
 * @param {string}      text            The string to match the word forms against.
 * @param {string}      locale          The locale of the paper.
 * @param {function}    matchWordCustomHelper The helper function to match word in text.
 *
 * @returns {Object} The number and the percentage of the keyphrase words that were matched in the text by at least one form,
 * and the lowest number of positions of the matches.
 */
const findWordFormsInString = function (keywordForms, text, locale, matchWordCustomHelper) {
  const wordNumber = keywordForms.length;
  const foundWords = Array(wordNumber);
  let positions = [];
  let matches = [];
  for (let i = 0; i < wordNumber; i++) {
    const matchedKeyphrase = (0, _matchTextWithArray.default)(text, keywordForms[i], locale, matchWordCustomHelper);
    foundWords[i] = matchedKeyphrase.count > 0 ? 1 : 0;
    positions.push(matchedKeyphrase.position);
    matches = matches.concat(matchedKeyphrase.matches);
  }
  const foundNumberOfWords = (0, _lodash.sum)(foundWords);
  const result = {
    countWordMatches: foundNumberOfWords,
    percentWordMatches: 0,
    matches: matches
  };
  if (wordNumber > 0) {
    result.percentWordMatches = Math.round(foundNumberOfWords / wordNumber * 100);
  }
  // Filtered out negative number, i.e. -1.
  positions = positions.filter(position => position >= 0);
  result.position = positions.length === 0 ? -1 : Math.min(...positions);
  return result;
};

/**
 * Matches forms of words in the keyphrase and in the synonyms against a given text.
 *
 * @param {Object}      topicForms       The object with word forms of all (content) words from the keyphrase and eventually synonyms,
 * comes in a shape {
 *                     keyphraseForms: [[ form1, form2, ... ], [ form1, form2, ... ]],
 *                     synonymsForms: [
 *                          [[ form1, form2, ... ], [ form1, form2, ... ]],
 *                          [[ form1, form2, ... ], [ form1, form2, ... ]],
 *                          [[ form1, form2, ... ], [ form1, form2, ... ]],
 *                     ],
 *                  }
 * @param {string}      text                    The string to match the word forms against.
 * @param {boolean}     useSynonyms             Whether to use synonyms as if it was keyphrase or not (depends on the assessment).
 * @param {string}      locale                  The locale of the paper.
 * @param {function}    matchWordCustomHelper   The language-specific helper function to match word in text.
 *
 * @returns {Object} The number and the percentage for the keyphrase words or synonyms that were matched in the text by at least one form,
 * and whether the keyphrase or a synonym was matched.
 */
exports.findWordFormsInString = findWordFormsInString;
const findTopicFormsInString = function (topicForms, text, useSynonyms, locale, matchWordCustomHelper) {
  // First check if the keyword is found in the text
  let result = findWordFormsInString(topicForms.keyphraseForms, text, locale, matchWordCustomHelper);
  result.keyphraseOrSynonym = "keyphrase";

  // If a full match found with the keyword or if no synonyms are supplied or supposed to be used, return the keyphrase search result.
  if (result.percentWordMatches === 100 || useSynonyms === false || (0, _lodash.isEmpty)(topicForms.synonymsForms)) {
    return result;
  }

  // Collect results of matching of every synonym with the text.
  const resultsSynonyms = [];
  for (let i = 0; i < topicForms.synonymsForms.length; i++) {
    const synonym = topicForms.synonymsForms[i];
    resultsSynonyms[i] = findWordFormsInString(synonym, text, locale, matchWordCustomHelper);
  }

  // Find which synonym occurred most fully.
  const foundSynonyms = resultsSynonyms.map(resultSynonyms => resultSynonyms.percentWordMatches);
  const bestSynonymIndex = foundSynonyms.indexOf(Math.max(...foundSynonyms));

  // If the best synonym showed lower results than the keyword, return the keyword.
  if (result.percentWordMatches >= resultsSynonyms[bestSynonymIndex].percentWordMatches) {
    return result;
  }

  // If the best synonym showed better results than the keyword, return the synonym.
  result = resultsSynonyms[bestSynonymIndex];
  result.keyphraseOrSynonym = "synonym";
  return result;
};
exports.findTopicFormsInString = findTopicFormsInString;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/match/isDoubleQuoted.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/match/isDoubleQuoted.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _doubleQuotes = _interopRequireDefault(__webpack_require__(/*! ../sanitize/doubleQuotes */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/doubleQuotes.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Checks if the keyphrase is double-quoted.
 * @param {string} keyphrase The keyphrase to check.
 * @returns {boolean} Whether the keyphrase is double-quoted.
 */
const isDoubleQuoted = keyphrase => {
  return (0, _lodash.includes)(_doubleQuotes.default, keyphrase[0]) && (0, _lodash.includes)(_doubleQuotes.default, keyphrase[keyphrase.length - 1]);
};
var _default = exports["default"] = isDoubleQuoted;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/match/matchTextWithArray.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/match/matchTextWithArray.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _matchTextWithWord = _interopRequireDefault(__webpack_require__(/*! ./matchTextWithWord */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/matchTextWithWord.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module stringProcessing/matchTextWithArray */

/**
 * Matches strings from an array against a given text.
 *
 * @param {String}      text                    The text to match.
 * @param {Array}       array                   The array with strings to match.
 * @param {String}      [locale = "en_EN"]      The locale of the text to get transliterations.
 * @param {function}    matchWordCustomHelper   The language-specific helper function to match word in text.
 *
 * @returns {Object} An array with all matches of the text, the number of the matches, and the lowest number of positions of the matches.
 */
function _default(text, array, locale = "en_EN", matchWordCustomHelper) {
  let count = 0;
  let matches = [];
  let positions = [];
  (0, _lodash.uniq)(array).forEach(function (wordToMatch) {
    const occurrence = (0, _matchTextWithWord.default)(text, wordToMatch, locale, matchWordCustomHelper);
    count += occurrence.count;
    matches = matches.concat(occurrence.matches);
    positions.push(occurrence.position);
  });

  // Filtered out negative number, i.e. -1.
  positions = positions.filter(position => position >= 0);
  return {
    count: count,
    matches: matches,
    position: positions.length === 0 ? -1 : Math.min(...positions)
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/match/matchTextWithTransliteration.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/match/matchTextWithTransliteration.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _addWordboundary = _interopRequireDefault(__webpack_require__(/*! ../word/addWordboundary.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/addWordboundary.js"));
var _stripSpaces = _interopRequireDefault(__webpack_require__(/*! ../sanitize/stripSpaces.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripSpaces.js"));
var _transliterate = _interopRequireDefault(__webpack_require__(/*! ../transliterate/transliterate.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/transliterate/transliterate.js"));
var _transliterateWPstyle = _interopRequireDefault(__webpack_require__(/*! ../transliterate/transliterateWPstyle.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/transliterate/transliterateWPstyle.js"));
var _specialCharacterMappings = __webpack_require__(/*! ../transliterate/specialCharacterMappings */ "./node_modules/yoastseo/build/languageProcessing/helpers/transliterate/specialCharacterMappings.js");
var _index = __webpack_require__(/*! ../../index */ "./node_modules/yoastseo/build/languageProcessing/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Creates a regex from the keyword with included wordboundaries.
 *
 * @param {string} keyword  The keyword to create a regex from.
 * @param {string} language The language used to determine the word boundary.
 *
 * @returns {RegExp} Regular expression of the keyword with word boundaries.
 */
const toRegex = function (keyword, language) {
  keyword = (0, _addWordboundary.default)(keyword, false, "", language);
  return new RegExp(keyword, "ig");
};

/**
 * Matches a string with and without transliteration.
 * @param {string} text The text to match.
 * @param {string} keyword The keyword to match in the text.
 * @param {string} locale The locale used for transliteration.
 * @returns {Array} All matches from the original as the transliterated text and keyword.
 */
function _default(text, keyword, locale) {
  const language = (0, _index.getLanguage)(locale);
  let keywordRegex = toRegex(keyword, language);
  if (language === "tr") {
    const turkishMappings = (0, _specialCharacterMappings.replaceTurkishIsMemoized)(keyword);
    keywordRegex = new RegExp(turkishMappings.map(x => (0, _addWordboundary.default)(x)).join("|"), "ig");
  }
  const matches = text.match(keywordRegex) || [];
  text = text.replace(keywordRegex, "");
  const transliterateKeyword = (0, _transliterate.default)(keyword, locale);
  const transliterateKeywordRegex = toRegex(transliterateKeyword, language);
  const transliterateMatches = text.match(transliterateKeywordRegex) || [];
  let combinedArray = matches.concat(transliterateMatches);
  const transliterateWPKeyword = (0, _transliterateWPstyle.default)(keyword, locale);
  if (!(transliterateWPKeyword === transliterateKeyword)) {
    const transliterateWPKeywordRegex = toRegex(transliterateWPKeyword, language);
    const transliterateWPMatches = text.match(transliterateWPKeywordRegex) || [];
    combinedArray = combinedArray.concat(transliterateWPMatches);
  }
  return (0, _lodash.map)(combinedArray, function (match) {
    return (0, _stripSpaces.default)(match);
  });
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/match/matchTextWithWord.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/match/matchTextWithWord.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _stripNonTextTags = _interopRequireDefault(__webpack_require__(/*! ../sanitize/stripNonTextTags.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripNonTextTags.js"));
var _stripSpaces = _interopRequireDefault(__webpack_require__(/*! ../sanitize/stripSpaces.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripSpaces.js"));
var _removePunctuation = _interopRequireDefault(__webpack_require__(/*! ../sanitize/removePunctuation.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removePunctuation.js"));
var _unifyWhitespace = __webpack_require__(/*! ../sanitize/unifyWhitespace.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/unifyWhitespace.js");
var _matchTextWithTransliteration = _interopRequireDefault(__webpack_require__(/*! ./matchTextWithTransliteration.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/matchTextWithTransliteration.js"));
var _quotes = __webpack_require__(/*! ../sanitize/quotes.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/quotes.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module stringProcessing/matchTextWithWord */

/**
 * Returns the number of matches in a given string
 *
 * @param {string}      text                    The text to use for matching the wordToMatch.
 * @param {string}      wordToMatch             The word to match in the text.
 * @param {string}      locale   				The locale used for transliteration.
 * @param {function}    matchWordCustomHelper  	The helper function to match word in text.
 *
 * @returns {Object} An array with all matches of the text, the number of the matches, and the lowest number of positions of the matches.
 */
function _default(text, wordToMatch, locale, matchWordCustomHelper) {
  text = (0, _stripNonTextTags.default)(text);
  text = (0, _unifyWhitespace.unifyAllSpaces)(text);
  text = (0, _quotes.normalize)(text);
  wordToMatch = (0, _quotes.normalize)(wordToMatch);
  let matches = matchWordCustomHelper ? matchWordCustomHelper(text, wordToMatch) : (0, _matchTextWithTransliteration.default)(text, wordToMatch, locale);
  matches = (0, _lodash.map)(matches, function (keyword) {
    return (0, _stripSpaces.default)((0, _removePunctuation.default)(keyword));
  });

  // Create an array of positions of matches to determine where in the text the wordToMatch occurred first.
  const positions = (0, _lodash.map)(matches, function (keyword) {
    return text.indexOf(keyword);
  });
  return {
    count: matches.length,
    matches: matches,
    position: positions.length === 0 ? -1 : Math.min(...positions)
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/match/matchWordFormsWithSentence.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/match/matchWordFormsWithSentence.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.tokenizeKeyphraseFormsForExactMatching = exports["default"] = void 0;
var _matchTextWithTransliteration = _interopRequireDefault(__webpack_require__(/*! ./matchTextWithTransliteration */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/matchTextWithTransliteration.js"));
var _splitIntoTokens = _interopRequireDefault(__webpack_require__(/*! ../word/splitIntoTokens */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/splitIntoTokens.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Tokenizes the word form of the keyphrase for exact matching. This function gets the word form and tokenizes it.
 * This function assumes that if a keyphrase needs to be matched exactly, there will be only one word form.
 * This is the result of how the focus keyphrase is processed in buildTopicStems.js in the buildStems function.
 *
 * @param {(string[])}  wordForms 					The word forms to tokenize.
 * @param {function}	customSplitIntoTokensHelper	A custom helper to split sentences into tokens.
 *
 * @returns {string[]} The tokenized word forms.
 */
const tokenizeKeyphraseFormsForExactMatching = (wordForms, customSplitIntoTokensHelper) => {
  // Tokenize word form of the keyphrase.
  const wordFormText = wordForms[0];
  return customSplitIntoTokensHelper ? customSplitIntoTokensHelper(wordFormText) : (0, _splitIntoTokens.default)(wordFormText);
};

/**
 * Gets the exact matches of the keyphrase.
 * Exact matching happens when the user puts the keyphrase in double quotes.
 *
 * @param {Sentence}	sentence					The sentence to match the word forms with.
 * @param {string[]}	wordForms					The word forms to match.
 * @param {string}		locale						The locale used in the analysis.
 * @param {function}	customSplitIntoTokensHelper	A custom helper to split sentences into tokens.
 *
 * @returns {{count: number, matches: Token[]}} Object containing the number of the exact matches and the matched tokens.
 */
exports.tokenizeKeyphraseFormsForExactMatching = tokenizeKeyphraseFormsForExactMatching;
const findExactMatchKeyphraseInSentence = (sentence, wordForms, locale, customSplitIntoTokensHelper) => {
  const result = {
    count: 0,
    matches: []
  };
  // Tokenize word forms of the keyphrase.
  const keyphraseTokens = tokenizeKeyphraseFormsForExactMatching(wordForms, customSplitIntoTokensHelper);
  const sentenceTokens = sentence.tokens;

  // Initialize the index of the word token of the keyphrase.
  let indexOfWordInKeyphrase = 0;
  // Initialize the index of the word token of the sentence.
  let indexOfWordInSentence = 0;
  let currentMatch = [];

  // Check if the tokenized word forms occur in the same order in the sentence tokens.
  while (indexOfWordInSentence < sentenceTokens.length) {
    // If the current sentence token matches the current word token of the keyphrase, add it to the current match.
    const sentenceTokenText = sentenceTokens[indexOfWordInSentence].text;
    const keyphraseTokenText = keyphraseTokens[indexOfWordInKeyphrase];
    const foundMatches = (0, _matchTextWithTransliteration.default)(sentenceTokenText.toLowerCase(), keyphraseTokenText.toLowerCase(), locale);
    if (foundMatches.length > 0) {
      currentMatch.push(sentenceTokens[indexOfWordInSentence]);
      indexOfWordInKeyphrase++;
    } else {
      indexOfWordInKeyphrase = 0;
      currentMatch = [];
    }

    /*
     * If the current match has the same length as the keyphrase tokens, the keyphrase forms have been matched.
     * Add the current match to the matches array and reset the index of the word in keyphrase and the current match.
     */
    if (currentMatch.length === keyphraseTokens.length) {
      result.matches.push(...currentMatch);
      result.count++;
      indexOfWordInKeyphrase = 0;
      currentMatch = [];
    }
    indexOfWordInSentence++;
  }
  return result;
};

/**
 * Matches a word form of the keyphrase with the tokens from the sentence.
 *
 * With this approach, we transliterate the word form of the keyphrase before matching it with the sentence tokens.
 * However, we don't do the transliteration step for the sentence tokens.
 * As a result, for example, the word form "acción" from the keyphrase will match the word "accion" in the sentence.
 * But, the word form "accion" from the keyphrase will NOT match the word "acción" in the sentence.
 *
 * @param {Token[]}	tokens		The array of tokens to check.
 * @param {string}	wordForm	The word form of the keyphrase.
 * @param {string}	locale		The locale used in the analysis.
 *
 * @returns {Token[]}	The array of the matched tokens.
 */
const matchWordFormInTokens = (tokens, wordForm, locale) => {
  let matches = [];
  tokens.forEach(token => {
    const occurrence = (0, _matchTextWithTransliteration.default)(token.text, wordForm, locale);
    if (occurrence.length > 0) {
      matches = matches.concat(token);
    }
  });
  return matches;
};

/**
 * Finds keyphrase forms in a sentence.
 *
 * @param {Sentence|string}	sentence				The sentence to check.
 * @param {string[]}		wordForms				The word forms of the keyphrase to check.
 * @param {string}			locale					The locale used in the analysis.
 * @param {function}		matchWordCustomHelper	Custom function to match a word form with sentence.
 *
 * @returns {{count: number, matches: (Token|string)[]}} Object containing the number of the matches and the matched tokens.
 */
const matchWordFormsInSentence = (sentence, wordForms, locale, matchWordCustomHelper) => {
  const result = {
    count: 0,
    matches: []
  };
  wordForms.forEach(wordForm => {
    let occurrences = [];
    if (matchWordCustomHelper) {
      occurrences = matchWordCustomHelper(sentence, wordForm);
    } else {
      const tokens = sentence.tokens.slice();
      occurrences = matchWordFormInTokens(tokens, wordForm, locale);
    }
    result.count += occurrences.length;
    result.matches = result.matches.concat(occurrences);
  });
  return result;
};

/**
 * Matches the word forms of a keyphrase with a sentence object from the html parser.
 *
 * @param {Sentence|string}	sentence					The sentence to match against the word forms of a keyphrase.
 * @param {string[]}		wordForms					The array of word forms of the keyphrase.
 * E.g. If the keyphrase is "key word", then (if Premium is activated) this will be [ "key", "keys" ] OR [ "word", "words" ]
 * The forms are retrieved higher up (among others in keywordCount.js) with researcher.getResearch( "morphology" ).
 * @param {string}			locale						The locale used for transliteration.
 * @param {function}		matchWordCustomHelper		Custom function to match a word form with sentence.
 * @param {boolean}			useExactMatching			Whether to match the keyphrase forms exactly or not.
 * 														Exact match is used when the keyphrase is enclosed in double quotes.
 * @param {function}		customSplitIntoTokensHelper	A custom helper to split sentences into tokens.
 *
 * @returns {{count: number, matches: (Token|string)[]}} Object containing the number of the matches and the matched tokens.
 */
const matchWordFormsWithSentence = (sentence, wordForms, locale, matchWordCustomHelper, useExactMatching = false, customSplitIntoTokensHelper) => {
  /*
   * Only use `findExactMatchKeyphraseInSentence` when the custom helper is not available.
   * When the custom helper is available, the step for the exact matching happens in the helper.
   */
  if (useExactMatching && !matchWordCustomHelper) {
    return findExactMatchKeyphraseInSentence(sentence, wordForms, locale, customSplitIntoTokensHelper);
  }
  return matchWordFormsInSentence(sentence, wordForms, locale, matchWordCustomHelper);
};
var _default = exports["default"] = matchWordFormsWithSentence;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/match/processExactMatchRequest.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/match/processExactMatchRequest.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = processExactMatchRequest;
var _isDoubleQuoted = _interopRequireDefault(__webpack_require__(/*! ./isDoubleQuoted */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/isDoubleQuoted.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Checks if exact match functionality is requested by enclosing the keyphrase in double quotation marks.
 *
 * @param {string}  keyphrase       The keyphrase to check. This must be the keyphrase accessed directly from the Paper.
 *
 * @returns {Object} Whether the exact match functionality is requested and the keyword stripped from double quotes.
 */
function processExactMatchRequest(keyphrase) {
  const exactMatchRequest = {
    exactMatchRequested: false,
    keyphrase: keyphrase
  };

  // Check if only exact match processing is requested by the user. If so, strip the quotation marks from the keyphrase.
  if ((0, _isDoubleQuoted.default)(keyphrase)) {
    exactMatchRequest.keyphrase = keyphrase.substring(1, keyphrase.length - 1);
    exactMatchRequest.exactMatchRequested = true;
  }
  return exactMatchRequest;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/baseStemmer.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/morphology/baseStemmer.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = baseStemmer;
/**
 * Base stemmer that does not stem.
 * This is exported to allow for comparing if a stemmer is the base stemmer.
 *
 * @param {string} word The word to stem.
 *
 * @returns {string} The stemmed word.
 */
function baseStemmer(word) {
  return word;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/buildFormRule.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/morphology/buildFormRule.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = buildFormRule;
/**
 * Checks if the input word qualifies for the input regex and if so builds a required form.
 * This function is used for other more specific functions.
 *
 * @param {string} word The word to build forms for.
 * @param {Array} regexes The regex-based array of rules to compare the word against.
 *
 * @returns {string} The newly built form of the word.
 */
function buildFormRule(word, regexes) {
  if (regexes.includes(null)) {
    return word;
  }
  for (let i = 0; i < regexes.length; i++) {
    if (regexes[i].reg.test(word) === true) {
      return word.replace(regexes[i].reg, regexes[i].repl);
    }
  }
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/buildTopicStems.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/morphology/buildTopicStems.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StemOriginalPair = StemOriginalPair;
exports.TopicPhrase = TopicPhrase;
exports.buildStems = void 0;
exports.collectStems = collectStems;
exports.primeLanguageSpecificData = void 0;
var _getWords = _interopRequireDefault(__webpack_require__(/*! ../word/getWords.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
var _quotes = __webpack_require__(/*! ../sanitize/quotes */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/quotes.js");
var _wordBoundariesWithoutPunctuation = __webpack_require__(/*! ../../../config/wordBoundariesWithoutPunctuation */ "./node_modules/yoastseo/build/config/wordBoundariesWithoutPunctuation.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _isDoubleQuoted = _interopRequireDefault(__webpack_require__(/*! ../match/isDoubleQuoted */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/isDoubleQuoted.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * A topic phrase (i.e., a keyphrase or synonym) with stem-original pairs for the words in the topic phrase.
 *
 * @param {StemOriginalPair[]} stemOriginalPairs The stem-original pairs for the words in the topic phrase.
 * @param {boolean}            exactMatch        Whether the topic phrase is an exact match.
 *
 * @constructor
 */
function TopicPhrase(stemOriginalPairs = [], exactMatch = false) {
  this.stemOriginalPairs = stemOriginalPairs;
  this.exactMatch = exactMatch;
}

/**
 * Returns all stems in the topic phrase.
 *
 * @returns {string[]|[]} The stems in the topic phrase or empty array if the topic phrase is exact match.
 */
TopicPhrase.prototype.getStems = function () {
  // An exact match keyphrase doesn't have stems.
  if (this.exactMatch) {
    return [];
  }
  return this.stemOriginalPairs.map(stemOriginalPair => stemOriginalPair.stem);
};

/**
 * A stem-original pair ƒor a word in a topic phrase.
 *
 * @param {string} stem     The stem of the topic phrase word.
 * @param {string} original The original word form the topic phrase (unsanitized)
 *
 * @constructor
 */
function StemOriginalPair(stem, original) {
  this.stem = stem;
  this.original = original;
}

/**
 * Analyzes the focus keyword string or one synonym phrase.
 * Checks if morphology is requested or if the user wants to match the exact string.
 * If morphology is required, the module finds a stem for all words (if no function words list is available), or
 * for all content words (i.e., excluding prepositions, articles, conjunctions, if the function words list is available).
 *
 * @param {string}   keyphrase     				The keyphrase of the paper (or a synonym phrase) to get stem for.
 * @param {function} stemmer       				The language-specific stemmer.
 * @param {string[]} functionWords 				The language-specific function words.
 * @param {boolean}	 areHyphensWordBoundaries	Whether hyphens should be treated as word boundaries.
 *
 * @returns {TopicPhrase} Object with an array of StemOriginalPairs of all (content) words in the keyphrase or synonym
 * phrase and information about whether the keyphrase/synonym should be matched exactly.
 */
const buildStems = function (keyphrase, stemmer, functionWords, areHyphensWordBoundaries) {
  if ((0, _lodash.isUndefined)(keyphrase) || keyphrase === "") {
    return new TopicPhrase();
  }

  // If the keyphrase is embedded in double quotation marks, return the keyprhase itself, without the outermost quotation marks.
  if ((0, _isDoubleQuoted.default)(keyphrase)) {
    keyphrase = keyphrase.substring(1, keyphrase.length - 1);
    return new TopicPhrase([new StemOriginalPair((0, _lodash.escapeRegExp)(keyphrase), keyphrase)], true);
  }

  /*
   * 	If hyphens should be treated as word boundaries, pass a custom word boundary regex string that includes whitespaces,
   *  hyphens (u002d), and en-dashes (u2013). Otherwise, pass a regex that includes only whitespaces and en-dashes.
   */
  let keyphraseWords = areHyphensWordBoundaries ? (0, _getWords.default)(keyphrase, _wordBoundariesWithoutPunctuation.WORD_BOUNDARY_WITH_HYPHEN) : (0, _getWords.default)(keyphrase, _wordBoundariesWithoutPunctuation.WORD_BOUNDARY_WITHOUT_HYPHEN);

  // Filter function words from the keyphrase. Don't filter if the keyphrase only consists of function words.
  const wordsWithoutFunctionWords = keyphraseWords.filter(word => !functionWords.includes(word));
  if (wordsWithoutFunctionWords.length > 0) {
    keyphraseWords = wordsWithoutFunctionWords;
  }

  // Return a stem-original pair with a stem.
  const stemOriginalPairs = keyphraseWords.map(word => {
    return new StemOriginalPair(stemmer((0, _quotes.normalizeSingle)((0, _lodash.escapeRegExp)(word))), word);
  });
  return new TopicPhrase(stemOriginalPairs);
};

/**
 * Builds stems of words of the keyphrase and of each synonym phrase.
 *
 * @param {string}   keyphrase     				The paper's keyphrase.
 * @param {string[]} synonyms     				The paper's synonyms.
 * @param {function} stemmer       				The language-specific stemmer (if available).
 * @param {string[]} functionWords 				The language-specific function words.
 * @param {boolean}	 areHyphensWordBoundaries	Whether hyphens should be treated as word boundaries.
 *
 * @returns {Object} Object with an array of stems of words in the keyphrase and an array of arrays of stems of words in the synonyms.
 */
exports.buildStems = buildStems;
const collectKeyphraseAndSynonymsStems = function (keyphrase, synonyms, stemmer, functionWords, areHyphensWordBoundaries) {
  const keyphraseStems = buildStems(keyphrase, stemmer, functionWords, areHyphensWordBoundaries);
  const synonymsStems = synonyms.map(synonym => buildStems(synonym, stemmer, functionWords, areHyphensWordBoundaries));
  return {
    keyphraseStems,
    synonymsStems
  };
};

/**
 * Caches stems depending on the currently available stemmer and functionWords and (separately) keyphrase and synonyms.
 * In this way, if the stemmer and functionWords remain the same in multiple calls of this function, the function
 * that collects actual stems only needs to check if the keyphrase and synonyms also remain the
 * same to return the cached result. The joining of keyphrase and synonyms for this function is needed,
 * because by default memoize caches by the first key only, which in the current case would mean that the function would
 * return the cached forms if the keyphrase has not changed (without checking if synonyms were changed).
 *
 * @param {function} stemmer       				The language-specific stemmer (if available).
 * @param {string[]} functionWords 				The language-specific function words.
 * @param {boolean}	 areHyphensWordBoundaries	Whether hyphens should be treated as word boundaries.
 *
 * @returns {function} The function that collects the stems for a given set of keyphrase, synonyms, stemmer and functionWords.
 */
const primeLanguageSpecificData = exports.primeLanguageSpecificData = (0, _lodash.memoize)((stemmer, functionWords, areHyphensWordBoundaries) => {
  return (0, _lodash.memoize)((keyphrase, synonyms) => {
    return collectKeyphraseAndSynonymsStems(keyphrase, synonyms, stemmer, functionWords, areHyphensWordBoundaries);
  }, (keyphrase, synonyms) => {
    return keyphrase + "," + synonyms.join(",");
  });
});

/**
 * Retrieves stems of words of the keyphrase and of each synonym phrase using the function that caches
 * the results of previous calls of this function.
 *
 * @param {string}      keyphrase       			The paper's keyphrase.
 * @param {string[]}    synonyms        			The paper's synonyms.
 * @param {function}    stemmer         			The language-specific stemmer (if available).
 * @param {string[]}    functionWords   			The language-specific function words.
 * @param {boolean}		areHyphensWordBoundaries	Whether hyphens should be treated as word boundaries.
 *
 * @returns {Object} Object with an array of stems of words in the keyphrase and an array of arrays of stems of words in the synonyms.
 */
function collectStems(keyphrase, synonyms, stemmer, functionWords, areHyphensWordBoundaries) {
  const collectStemsWithLanguageSpecificData = primeLanguageSpecificData(stemmer, functionWords, areHyphensWordBoundaries);
  return collectStemsWithLanguageSpecificData(keyphrase, synonyms);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/createRulesFromArrays.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/morphology/createRulesFromArrays.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.createSingleRuleFromArray = exports.createRulesFromArrays = void 0;
/**
 * Creates an object with a regex and a replacement pair to be processed.
 *
 * @param {Array}   rule        A pair or triplet of strings of which the first one is the regex to match
 *                              and the second (and the third) is the replacement.
 * @param {string}  [flags=i]   The regex flags to use.
 *
 * @returns {{ reg: RegExp, repl: string }|{ reg: RegExp, repl1: string, repl2: string }|null} Object to be used in the regex-based rules.
 */
const createSingleRuleFromArray = function (rule, flags = "i") {
  if (rule.length === 2) {
    return {
      reg: new RegExp(rule[0], flags),
      repl: rule[1]
    };
  }
  if (rule.length === 3) {
    return {
      reg: new RegExp(rule[0], flags),
      repl1: rule[1],
      repl2: rule[2]
    };
  }
  return null;
};

/**
 * Creates an array of objects with a regex and a replacement pair to be processed.
 *
 * @param {Array}   rules       An array with pairs or triplets of strings of which the first one is the regex to match
 *                              and the second (and the third) is the replacement.
 * @param {string} [flags=i]    The regex flags to use.
 *
 * @returns {Array} Array of objects to be used in the regex-based rules.
 */
exports.createSingleRuleFromArray = createSingleRuleFromArray;
const createRulesFromArrays = function (rules, flags = "i") {
  return rules.map(rule => createSingleRuleFromArray(rule, flags));
};
exports.createRulesFromArrays = createRulesFromArrays;
var _default = exports["default"] = createRulesFromArrays;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/exceptionListHelpers.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/morphology/exceptionListHelpers.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.checkExceptionListWithTwoStems = checkExceptionListWithTwoStems;
exports.checkIfWordEndingIsOnExceptionList = checkIfWordEndingIsOnExceptionList;
exports.checkIfWordIsOnListThatCanHavePrefix = checkIfWordIsOnListThatCanHavePrefix;
var _flattenSortLength = _interopRequireDefault(__webpack_require__(/*! ./flattenSortLength */ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/flattenSortLength.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Checks whether the word ends in one of the words in an exception list that is a simple array.
 *
 * @param {string}	    word            The word to check.
 * @param {string[]}	exceptionList	The list of exceptions.
 *
 * @returns {boolean}	Whether the checked word ends in one of the words in the exception list.
 */
function checkIfWordEndingIsOnExceptionList(word, exceptionList) {
  for (let i = 0; i < exceptionList.length; i++) {
    if (word.endsWith(exceptionList[i])) {
      return true;
    }
  }
  return false;
}

/**
 * Checks whether a word is on the list of words that can have a prefix or not. Before checking the list, checks whether the word has a prefix
 * and if it does, removes it.
 *
 * @param {string}	 	word					The word to check.
 * @param {string[]}	exceptionList			The list of exceptions.
 * @param {Object}		prefixesObject	        An Object that contains the arrays of prefixes.
 *
 * @returns {boolean}	Whether the word was found on the exception list or not.
 */
function checkIfWordIsOnListThatCanHavePrefix(word, exceptionList, prefixesObject) {
  const prefixes = (0, _flattenSortLength.default)(prefixesObject);

  // Check whether the inputted word starts with one of the prefixes
  const foundPrefix = prefixes.find(prefix => word.startsWith(prefix));
  let stemmedWordWithoutPrefix = "";
  if (typeof foundPrefix === "string") {
    stemmedWordWithoutPrefix = word.slice(foundPrefix.length);
    // At least 3 characters left after prefix deletion so that e.g. "be" is not treated as a prefix if found in the word "berg".
    if (stemmedWordWithoutPrefix.length > 2) {
      word = stemmedWordWithoutPrefix;
    }
  }
  return exceptionList.includes(word);
}

/**
 * Checks whether the word ends in one of the words in an exception list with two stems.
 *
 * @param {Array} exceptionListWithTwoStems The exception list with two stems.
 * @param {string} word	The word to check.
 *
 * @returns {string} The stem.
 */
function checkExceptionListWithTwoStems(exceptionListWithTwoStems, word) {
  for (const stemSet of exceptionListWithTwoStems) {
    const foundStem = stemSet.find(stemWord => word.endsWith(stemWord));
    if (foundStem) {
      const precedingLexicalMaterial = word.slice(0, word.length - foundStem.length);
      return precedingLexicalMaterial + stemSet[0];
    }
  }
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/findMatchingEndingInArray.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/morphology/findMatchingEndingInArray.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = findMatchingEndingInArray;
/**
 * Loops through an array of word endings and returns the longest ending that was matched at the end of the string.
 *
 * @param {string}      string       The string to check.
 * @param {string[]}    endings    The word endings to check.
 * @returns {string}    The longest matched ending.
 */
function findMatchingEndingInArray(string, endings) {
  const matches = [];
  for (const i in endings) {
    if (string.endsWith(endings[i])) {
      matches.push(endings[i]);
    }
  }
  const longest = matches.sort(function (a, b) {
    return b.length - a.length;
  })[0];
  if (longest) {
    return longest;
  }
  return "";
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/flattenSortLength.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/morphology/flattenSortLength.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = flattenSortLength;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Returns combined list of strings/words, sorted by length (descending).
 *
 * @param {Object} dataWords The words data that is going to be sorted.
 *
 * @returns {Array<string>} All words, sorted by length (descending).
 */
function flattenSortLength(dataWords) {
  const allWords = (0, _lodash.flatten)(Object.values(dataWords));
  return allWords.sort((a, b) => b.length - a.length || a.localeCompare(b));
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/getAllWordsFromPaper.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/morphology/getAllWordsFromPaper.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _getAltAttribute = _interopRequireDefault(__webpack_require__(/*! ../image/getAltAttribute */ "./node_modules/yoastseo/build/languageProcessing/helpers/image/getAltAttribute.js"));
var _quotes = __webpack_require__(/*! ../sanitize/quotes */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/quotes.js");
var _parseSlug = _interopRequireDefault(__webpack_require__(/*! ../url/parseSlug */ "./node_modules/yoastseo/build/languageProcessing/helpers/url/parseSlug.js"));
var _getWords = _interopRequireDefault(__webpack_require__(/*! ../word/getWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
var _getImagesInTree = _interopRequireDefault(__webpack_require__(/*! ../image/getImagesInTree */ "./node_modules/yoastseo/build/languageProcessing/helpers/image/getImagesInTree.js"));
var _wordBoundariesWithoutPunctuation = __webpack_require__(/*! ../../../config/wordBoundariesWithoutPunctuation */ "./node_modules/yoastseo/build/config/wordBoundariesWithoutPunctuation.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Gets all words found in the text, title, slug and meta description of a given paper.
 *
 * @param {Paper} 	paper     					The paper for which to get the words.
 * @param {boolean}	areHyphensWordBoundaries	Whether hyphens should be treated as word boundaries.
 *
 * @returns {string[]} All words found.
 */
function _default(paper, areHyphensWordBoundaries) {
  const paperText = paper.getText();
  const altTagsInText = (0, _getImagesInTree.default)(paper).map(image => (0, _getAltAttribute.default)(image));
  const paperContent = [paperText, paper.getTitle(), paper.getSlug(), (0, _parseSlug.default)(paper.getSlug()), paper.getDescription(), altTagsInText.join(" ")].join(" ");

  /*
      * If hyphens should be treated as word boundaries, pass a custom word boundary regex string that includes whitespaces,
      * hyphens (u002d), and en-dashes (u2013). Otherwise, pass a regex that includes only whitespaces and en-dashes.
  	 */
  const words = areHyphensWordBoundaries ? (0, _getWords.default)(paperContent, _wordBoundariesWithoutPunctuation.WORD_BOUNDARY_WITH_HYPHEN) : (0, _getWords.default)(paperContent, _wordBoundariesWithoutPunctuation.WORD_BOUNDARY_WITHOUT_HYPHEN);
  return words.map(word => (0, _quotes.normalizeSingle)((0, _lodash.escapeRegExp)(word)));
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/regexHelpers.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/morphology/regexHelpers.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.applyAllReplacements = applyAllReplacements;
exports.doesWordMatchRegex = doesWordMatchRegex;
exports.searchAndReplaceWithRegex = searchAndReplaceWithRegex;
/**
 * Checks whether a word is matched with a regex.
 *
 * @param {string} word		The word to check.
 * @param {string} regex	The regex.
 *
 * @returns {boolean}		Whether or not there was a match.
 */
function doesWordMatchRegex(word, regex) {
  const regexObject = RegExp(regex);
  return regexObject.test(word);
}

/**
 * Loops through a nested array with pairs of regexes and replacements, and performs the needed replacement if a match is found.
 *
 * @param {string} word 						The word that may need to be modified.
 * @param {[][]} groupOfRegexAndReplacements 	The array with the regexes and the required replacements.
 *
 * @returns {?string} The modified stem or null if no match was found.
 */
function searchAndReplaceWithRegex(word, groupOfRegexAndReplacements) {
  for (const regexAndReplacement of groupOfRegexAndReplacements) {
    if (word.search(new RegExp(regexAndReplacement[0])) !== -1) {
      word = word.replace(new RegExp(regexAndReplacement[0]), regexAndReplacement[1]);
      return word;
    }
  }
}

/**
 * Loops through a nested array of regexes and replacement pairs, and applies all replacements for which a match is found.
 *
 * @param {string}  word                        The word that may need to be modified.
 * @param {[][]}    listOfRegexAndReplacement   The array with the regexes and the replacements.
 *
 * @returns {string} The modified word.
 */
function applyAllReplacements(word, listOfRegexAndReplacement) {
  listOfRegexAndReplacement.forEach(function (setOfRegexAndReplacement) {
    word = word.replace(new RegExp(setOfRegexAndReplacement[0]), setOfRegexAndReplacement[1]);
  });
  return word;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/stemHelpers.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/morphology/stemHelpers.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.removeSuffixFromFullForm = removeSuffixFromFullForm;
exports.removeSuffixesFromFullForm = removeSuffixesFromFullForm;
/**
 * Checks whether the word starts with one of the words in a given list and ends in one of the suffixes
 * in a given suffixes list. If so, deletes the suffix.
 *
 * @param {string[]}    list  The list of words to check against.
 * @param {string[]}    suffixes    The suffixes that needs to be deleted.
 * @param {string}      word        The word to check.
 * @returns {string}	The stemmed word.
 */
function removeSuffixesFromFullForm(list, suffixes, word) {
  for (let i = 0; i < list.length; i++) {
    if (word.startsWith(list[i])) {
      const suffixRetrieved = word.substring(list[i].length);
      for (let j = 0; j < suffixes.length; j++) {
        if (suffixes[j] === suffixRetrieved) {
          return word.slice(0, -suffixRetrieved.length);
        }
      }
    }
  }
}

/**
 * Checks whether the word is in a given list of exceptions and if so, deletes a given suffix.
 *
 * @param {string[]}    exceptions  The exception list.
 * @param {string}      suffix      The suffix that needs to be deleted.
 * @param {string}      word        The word to check.
 *
 * @returns {string} The stemmed word.
 */
function removeSuffixFromFullForm(exceptions, suffix, word) {
  for (let i = 0; i < exceptions.length; i++) {
    if (word.endsWith(exceptions[i])) {
      return word.slice(0, -suffix.length);
    }
  }
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/stemPrefixedFunctionWords.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/morphology/stemPrefixedFunctionWords.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.stemPrefixedFunctionWords = stemPrefixedFunctionWords;
/**
 * An object containing the stem and the prefix.
 *
 * @typedef {Object} 	StemAndPrefixPair
 * @property {string}	stem The word without the basic prefixes.
 * @property {string}	prefix The prefix that was matched.
 */

/**
 * Strips function word prefixes from the word.
 *
 * @param {string} word The word to strip the basic prefixes from.
 * @param {RegExp} regex The regular expression to match the function word prefixes.
 * @returns {StemAndPrefixPair} The word without the function word prefixes that was stripped,
 * or the original word if the word is not prefixed.
 */
function stemPrefixedFunctionWords(word, regex) {
  /*
  	 * If a word starts with one of the prefixes, we strip it.
   */
  let stemmedWord = word;
  let prefix = "";
  const isPrefixed = word.match(regex);
  if (isPrefixed) {
    prefix = isPrefixed[0];
    stemmedWord = word.slice(prefix.length);
  }
  return {
    stem: stemmedWord,
    prefix: prefix
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/directPrecedenceException.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/directPrecedenceException.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _getWords = _interopRequireDefault(__webpack_require__(/*! ../../word/getWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Checks whether the participle is directly preceded by a word from the direct precedence exception list.
 * If this is the case, the clause is not passive.
 *
 * @param {string} clause 		The clause that contains the participle.
 * @param {string} participle   The participle.
 * @param {Array} cannotDirectlyPrecedePassiveParticipleList List of words which cannot directly precede a passive participle.
 *
 * @returns {boolean} Returns true if a word from the direct precedence exception list is directly preceding
 *                    the participle, otherwise returns false.
 */
function _default(clause, participle, cannotDirectlyPrecedePassiveParticipleList = []) {
  // Break the sentence part up into words and convert to lower case.
  const wordsInClause = (0, _getWords.default)(clause).map(word => word.toLowerCase());

  // Search the participle in the word list.
  const participleIndex = wordsInClause.indexOf(participle.toLowerCase());

  /*
   * There can be no exception in the following situations:
   *
   * -1 The participle is not found.
   *  0 There is no word before the participle.
   */
  if (participleIndex < 1) {
    return false;
  }
  const wordPrecedingParticiple = wordsInClause[participleIndex - 1];

  // Check if the word preceding the participle is in the exceptions list.
  return (0, _lodash.includes)(cannotDirectlyPrecedePassiveParticipleList, wordPrecedingParticiple);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/freeAuxiliaryParticipleOrder/getClausesSplitOnStopWords.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/freeAuxiliaryParticipleOrder/getClausesSplitOnStopWords.js ***!
  \*****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _stripSpaces = _interopRequireDefault(__webpack_require__(/*! ../../../sanitize/stripSpaces.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripSpaces.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Strips spaces from the auxiliary matches.
 *
 * @param {Array} matches A list with matches of auxiliaries.
 * @returns {Array} A list with matches with spaces removed.
 */
function sanitizeMatches(matches) {
  return (0, _lodash.map)(matches, function (match) {
    return (0, _stripSpaces.default)(match);
  });
}

/**
 * Splits sentences into clauses based on stopwords.
 *
 * @param {string} sentence The sentence to split.
 * @param {Array} stopwords The array with matched stopwords.
 *
 * @returns {Array} The array with clauses.
 */
function splitOnStopWords(sentence, stopwords) {
  const clauses = [];

  // Split the sentence on each found stopword and push this part in an array.
  (0, _lodash.forEach)(stopwords, function (stopword) {
    const clause = sentence.split(stopword);
    if (!(0, _lodash.isEmpty)(clause[0])) {
      clauses.push(clause[0]);
    }
    const startIndex = sentence.indexOf(stopword);
    const endIndex = sentence.length;
    sentence = (0, _stripSpaces.default)(sentence.substring(startIndex, endIndex));
  });

  // Push the remainder of the sentence in the clauses array.
  clauses.push(sentence);
  return clauses;
}

/**
 *
 * Splits sentences into clauses based on stopCharacter.
 *
 * @param {string}  sentence        The sentence to split.
 * @param {regex}   stopCharacter   The stop characters regex.
 *
 * @returns {Array} The array with clauses.
 */
function splitOnStopCharacter(sentence, stopCharacter) {
  const clauses = sentence.split(stopCharacter);

  // Strip space in the beginning of the clause, if any.
  for (let i = 0; i < clauses.length; i++) {
    if (clauses[i][0] === " ") {
      clauses[i] = clauses[i].substring(1, clauses[i].length);
    }
  }
  return clauses;
}

/**
 * Creates clauses based on split sentences.

 * @param {Array}   clauses   The array with clauses.
 * @param {Object}  options    The language-specific regexes and Clause class.
 *
 * @returns {Array} The array with sentence parts.
 */
function createClauseObjects(clauses, options) {
  const clauseObjects = [];
  (0, _lodash.forEach)(clauses, function (clause) {
    const foundAuxiliaries = sanitizeMatches(clause.match(options.regexes.auxiliaryRegex || []));
    // If a clause doesn't have an auxiliary, we don't need it, so it can be filtered out.
    if (foundAuxiliaries.length !== 0) {
      clauseObjects.push(new options.Clause(clause, foundAuxiliaries));
    }
  });
  return clauseObjects;
}

/**
 * Splits the sentence into clauses based on stopwords.
 *
 * @param {string} sentence The text to split into clauses.
 * @param {Object} options The language-specific regexes and Clause class.
 *
 * @returns {Array} The array with clauses.
 */
function getClausesSplitOnStopWords(sentence, options) {
  const auxiliaryRegex = options.regexes.auxiliaryRegex;
  // First check if there is an auxiliary in the sentence.
  if (sentence.match(auxiliaryRegex) === null) {
    return [];
  }
  let clauses;
  const stopwords = sentence.match(options.regexes.stopwordRegex) || [];
  // Split sentences based on stop words
  clauses = splitOnStopWords(sentence, stopwords);

  // 	Split sentences based on stop characters, only if the regex is available and if the sentence is not yet split from the previous check
  if (typeof options.regexes.stopCharacterRegex !== "undefined" && clauses.length === 1) {
    clauses = splitOnStopCharacter(sentence, options.regexes.stopCharacterRegex);
  }
  return createClauseObjects(clauses, options);
}
var _default = exports["default"] = getClausesSplitOnStopWords;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/freeAuxiliaryParticipleOrder/nonDirectParticiplePrecedenceException.js":
/*!*****************************************************************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/freeAuxiliaryParticipleOrder/nonDirectParticiplePrecedenceException.js ***!
  \*****************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _createRegexFromArray = _interopRequireDefault(__webpack_require__(/*! ../../../regex/createRegexFromArray.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/regex/createRegexFromArray.js"));
var _getIndicesWithRegex = _interopRequireDefault(__webpack_require__(/*! ../getIndicesWithRegex.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/getIndicesWithRegex.js"));
var _indices = __webpack_require__(/*! ../../../word/indices.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/indices.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Checks whether there are any exception words in between the auxiliary and participle. If there are, it doesn't return a passive.
 *
 * @param {string} clause 											The clause that contains the participle.
 * @param {string} participle 										The participle in the clause.
 * @param {string[]} auxiliaries 									One or more auxiliaries in the clause.
 * @param {string[]} cannotBeBetweenPassiveAuxiliaryAndParticiple 	The list of words that cannot be between the auxiliary and participle.
 *
 * @returns {boolean} Returns true if a word from the 'cannot be between passive auxiliary and participle' exception list
 * appears anywhere in between the last (closest to participle) auxiliary and the participle.
 */
function _default(clause, participle, auxiliaries, cannotBeBetweenPassiveAuxiliaryAndParticiple) {
  const auxiliariesUnique = (0, _lodash.uniq)(auxiliaries);
  const auxiliaryIndices = (0, _indices.getIndicesByWordListSorted)(auxiliariesUnique, clause);
  const participleIndex = clause.indexOf(participle);
  const nonDirectParticiplePrecendenceExceptionRegex = (0, _createRegexFromArray.default)(cannotBeBetweenPassiveAuxiliaryAndParticiple);

  // This exception is only applicable for passive constructions in which the auxiliary precedes the participle.
  const matches = auxiliaryIndices.filter(auxiliaryIndex => auxiliaryIndex.index < participleIndex);

  // If there are no auxiliaries before the participle, this exception is not applicable.
  if (matches.length === 0) {
    return false;
  }

  // We pick the auxiliary closest to the participle, since that is most likely the one belonging to the participle.
  const participleAuxiliary = matches[matches.length - 1];
  const precedenceExceptionIndices = (0, _getIndicesWithRegex.default)(clause, nonDirectParticiplePrecendenceExceptionRegex);

  // Check whether there are any precendence words between the auxiliary and the participle.
  const remainingPrecedenceExceptionIndices = precedenceExceptionIndices.filter(precedenceExceptionIndex => precedenceExceptionIndex.index > participleAuxiliary.index && precedenceExceptionIndex.index < participleIndex);
  return remainingPrecedenceExceptionIndices.length > 0;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/getClauses.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/getClauses.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _indices = __webpack_require__(/*! ../../word/indices */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/indices.js");
var _stripSpaces = _interopRequireDefault(__webpack_require__(/*! ../../sanitize/stripSpaces.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripSpaces.js"));
var _quotes = __webpack_require__(/*! ../../sanitize/quotes.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/quotes.js");
var _getIndicesWithRegex = _interopRequireDefault(__webpack_require__(/*! ./getIndicesWithRegex.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/getIndicesWithRegex.js"));
var _includesIndex = _interopRequireDefault(__webpack_require__(/*! ../../word/includesIndex */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/includesIndex.js"));
var _followsIndex = _interopRequireDefault(__webpack_require__(/*! ../../word/followsIndex */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/followsIndex.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Gets stop characters to determine sentence breakers.
 *
 * @param {string} sentence The sentence to get the stop characters from.
 * @param {RegExp} stopCharacterRegex Regex to match the stop characters.
 *
 * @returns {Array} The array with stop characters.
 */
const getStopCharacters = function (sentence, stopCharacterRegex) {
  let match;
  const matches = [];
  stopCharacterRegex.lastIndex = 0;
  while ((match = stopCharacterRegex.exec(sentence)) !== null) {
    matches.push({
      index: match.index,
      match: match[0]
    });
  }
  return matches;
};

/**
 * Filters auxiliaries preceded by a reflexive pronoun.
 *
 * @param {string} text The text part in which to check.
 * @param {Array} auxiliaryMatches The auxiliary matches for which to check.
 * @param {RegExp} directPrecedenceExceptionRegex The regex needed to find the right auxiliaries.
 *
 * @returns {Array} The filtered list of auxiliary indices.
 */
const auxiliaryPrecedenceExceptionFilter = function (text, auxiliaryMatches, directPrecedenceExceptionRegex) {
  const directPrecedenceExceptionMatches = (0, _getIndicesWithRegex.default)(text, directPrecedenceExceptionRegex);
  (0, _lodash.forEach)(auxiliaryMatches, function (auxiliaryMatch) {
    if ((0, _includesIndex.default)(directPrecedenceExceptionMatches, auxiliaryMatch.index)) {
      auxiliaryMatches = auxiliaryMatches.filter(function (auxiliaryObject) {
        return auxiliaryObject.index !== auxiliaryMatch.index;
      });
    }
  });
  return auxiliaryMatches;
};

/**
 * Filters auxiliaries followed by a word on the followingAuxiliaryExceptionWords list.
 *
 * @param {string} text The text part in which to check.
 * @param {Array} auxiliaryMatches The auxiliary matches for which to check.
 * @param {RegExp} followingAuxiliaryExceptionRegex The regex needed to find the right auxiliaries.
 *
 * @returns {Array} The filtered list of auxiliary indices.
 */
const followingAuxiliaryExceptionFilter = function (text, auxiliaryMatches, followingAuxiliaryExceptionRegex) {
  const followingAuxiliaryExceptionMatches = (0, _getIndicesWithRegex.default)(text, followingAuxiliaryExceptionRegex);
  (0, _lodash.forEach)(auxiliaryMatches, function (auxiliaryMatch) {
    if ((0, _followsIndex.default)(followingAuxiliaryExceptionMatches, auxiliaryMatch)) {
      auxiliaryMatches = auxiliaryMatches.filter(function (auxiliaryObject) {
        return auxiliaryObject.index !== auxiliaryMatch.index;
      });
    }
  });
  return auxiliaryMatches;
};

/**
 * Filters auxiliaries preceded by an elided word (e.g., s') on the elisionAuxiliaryExceptionWords list.
 *
 * @param {string} text The text part in which to check.
 * @param {Array} auxiliaryMatches The auxiliary matches for which to check.
 * @param {RegExp} elisionAuxiliaryExceptionRegex Regex to match the elisionAuxiliary exception.
 *
 * @returns {Array} The filtered list of auxiliary indices.
 */
const elisionAuxiliaryExceptionFilter = function (text, auxiliaryMatches, elisionAuxiliaryExceptionRegex) {
  const elisionAuxiliaryExceptionMatches = (0, _getIndicesWithRegex.default)(text, elisionAuxiliaryExceptionRegex);
  (0, _lodash.forEach)(auxiliaryMatches, function (auxiliaryMatch) {
    if ((0, _includesIndex.default)(elisionAuxiliaryExceptionMatches, auxiliaryMatch.index, false)) {
      auxiliaryMatches = auxiliaryMatches.filter(function (auxiliaryObject) {
        return auxiliaryObject.index !== auxiliaryMatch.index;
      });
    }
  });
  return auxiliaryMatches;
};

/**
 * Gets the indices of sentence breakers (auxiliaries, stopwords and stop characters;
 * in English also active verbs) to determine clauses.
 * Indices are filtered because there could be duplicate matches, like "even though" and "though".
 * In addition, 'having' will be matched both as a -ing verb as well as an auxiliary.
 *
 * @param {string} sentence The sentence to check for indices of sentence breakers.
 * @param {Object} options The language options for which to match the sentence breakers.
 *
 * @returns {Array} The array with valid indices to use for determining clauses.
 */
const getSentenceBreakers = function (sentence, options) {
  sentence = sentence.toLocaleLowerCase();
  const {
    regexes
  } = options;
  let auxiliaryIndices = (0, _indices.getIndicesByWordList)(options.auxiliaries, sentence);
  const stopCharacterIndices = getStopCharacters(sentence, regexes.stopCharacterRegex);
  let stopwordIndices = (0, _indices.getIndicesByWordList)(options.stopwords, sentence);

  // Check in options if there are other stopword indices created based on language-specific rules.
  if (options.otherStopWordIndices && options.otherStopWordIndices.length > 0) {
    stopwordIndices = stopwordIndices.concat(options.otherStopWordIndices);
  }
  if (typeof regexes.directPrecedenceExceptionRegex !== "undefined") {
    // Filters auxiliaries matched in the sentence based on a precedence exception filter.
    auxiliaryIndices = auxiliaryPrecedenceExceptionFilter(sentence, auxiliaryIndices, regexes.directPrecedenceExceptionRegex);
  }
  if (typeof regexes.elisionAuxiliaryExceptionRegex !== "undefined") {
    // Filters auxiliaries matched in the sentence based on a elision exception filter.
    auxiliaryIndices = elisionAuxiliaryExceptionFilter(sentence, auxiliaryIndices, regexes.elisionAuxiliaryExceptionRegex);
  }
  let totalIndices = auxiliaryIndices.concat(stopwordIndices, stopCharacterIndices);
  totalIndices = (0, _indices.filterIndices)(totalIndices);
  return (0, _indices.sortIndices)(totalIndices);
};

/**
 * Gets the auxiliaries from a sentence.
 *
 * @param {string} sentencePart The part of the sentence to match for auxiliaries.
 * @param {object} regexes The regexes needed to find the auxiliaries.
 *
 * @returns {Array} All formatted matches from the sentence part.
 */
const getAuxiliaryMatches = function (sentencePart, regexes) {
  const {
    auxiliaryRegex,
    directPrecedenceExceptionRegex,
    followingAuxiliaryExceptionRegex
  } = regexes;
  let auxiliaryMatches = sentencePart.match(auxiliaryRegex) || [];
  if (typeof directPrecedenceExceptionRegex !== "undefined" || typeof followingAuxiliaryExceptionRegex !== "undefined") {
    // An array with the matched auxiliaries and their indices.
    let auxiliaryMatchIndices = (0, _indices.getIndicesByWordList)(auxiliaryMatches, sentencePart);
    if (typeof directPrecedenceExceptionRegex !== "undefined") {
      // Filters auxiliaries matched in the sentence part based on a precedence exception filter.
      auxiliaryMatchIndices = auxiliaryPrecedenceExceptionFilter(sentencePart, auxiliaryMatchIndices, directPrecedenceExceptionRegex);
    }
    // Filters auxiliaries matched in the sentence part based on a exception filter for words following the auxiliary.
    auxiliaryMatchIndices = followingAuxiliaryExceptionFilter(sentencePart, auxiliaryMatchIndices, followingAuxiliaryExceptionRegex);

    // An array with the matched auxiliary verbs (without indices).
    auxiliaryMatches = [];
    (0, _lodash.forEach)(auxiliaryMatchIndices, function (auxiliaryMatchIndex) {
      auxiliaryMatches.push(auxiliaryMatchIndex.match);
    });
  }
  return (0, _lodash.map)(auxiliaryMatches, function (auxiliaryMatch) {
    return (0, _stripSpaces.default)(auxiliaryMatch);
  });
};

/**
 * Gets the clauses from a sentence by determining sentence breakers.
 *
 * @param {string} sentence The sentence to split up into clauses.
 * @param {object} options The language options for which to get the clauses.
 *
 * @returns {Array} The array with all clauses that have an auxiliary.
 */
const getClauses = function (sentence, options) {
  const clauses = [];
  const auxiliaryRegex = options.regexes.auxiliaryRegex;
  sentence = (0, _quotes.normalizeSingle)(sentence);

  // First check if there is an auxiliary in the sentence.
  if (sentence.match(auxiliaryRegex) === null) {
    return clauses;
  }
  const indices = getSentenceBreakers(sentence, options);
  // Get the words after the found auxiliary.
  for (let i = 0; i < indices.length; i++) {
    let endIndex = sentence.length;
    if (!(0, _lodash.isUndefined)(indices[i + 1])) {
      endIndex = indices[i + 1].index;
    }

    // Cut the sentence from the current index to the endIndex (start of next breaker, of end of sentence).
    const clause = (0, _stripSpaces.default)(sentence.substring(indices[i].index, endIndex));
    const auxiliaryMatches = getAuxiliaryMatches(clause, options.regexes);
    // If a clause doesn't have an auxiliary, we don't need it, so it can be filtered out.
    if (auxiliaryMatches.length !== 0) {
      const foundClause = new options.Clause(clause, auxiliaryMatches);
      clauses.push(foundClause);
    }
  }
  return clauses;
};

/**
 * Split the sentence into clauses based on auxiliaries.
 *
 * @param {string} sentence The sentence to split in parts.
 * @param {Object} options The language options for which to get the clauses.
 *
 * @returns {Array} A list with clauses.
 */
function _default(sentence, options) {
  return getClauses(sentence, options);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/getIndicesWithRegex.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/getIndicesWithRegex.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Matches words from a list in sentence parts and returns them and their indices.
 *
 * @param {string} sentencePart The sentence part to match the words in.
 * @param {RegExp} regex The regex used for matching.
 * @returns {Array} The list of result objects.
 */
function _default(sentencePart, regex) {
  const results = [];
  /* Decided to use a for loop here so that we could retrieve all matches while keeping result objects intact.
  For every match there is in the sentence part, an object with the match and its index will be pushed into
  the results array. */
  for (let match = regex.exec(sentencePart); match !== null; match = regex.exec(sentencePart)) {
    results.push({
      match: match[0],
      index: match.index
    });
  }
  return results;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/matchRegularParticiples.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/matchRegularParticiples.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = regularParticiples;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Returns words that have been determined to be a regular participle.
 *
 * @param {string} word         The word to check.
 * @param {RegExp[]} regexes    The regular participle regexes to match.
 *
 * @returns {Array} A list with the matches.
 */
function regularParticiples(word, regexes) {
  // Matches word with language-specific participle regexes.
  let matches = [];
  regexes.forEach(function (regex) {
    const match = word.match(regex);
    if (match !== null) {
      matches.push(match);
    }
  });
  matches = (0, _lodash.flattenDeep)(matches);
  return matches;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/precedenceException.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/precedenceException.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _getWords = _interopRequireDefault(__webpack_require__(/*! ../../word/getWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Checks whether a word from the precedence exception list occurs anywhere in the clause before the participle.
 * If this is the case, the sentence part is not passive.
 *
 * @param {string} clause 		The clause that contains the participle.
 * @param {string} participle   The participle.
 * @param {Array} cannotBeBetweenPassiveAuxiliaryAndParticipleList  List of words which cannot be between auxiliary and participle.
 *
 * @returns {boolean} Returns true if a word from the precedence exception list occurs anywhere in the
 *                    sentence part before the participle, otherwise returns false.
 */
function _default(clause, participle, cannotBeBetweenPassiveAuxiliaryAndParticipleList = []) {
  // Break the sentence part up into words and convert to lower case.
  const wordsInClause = (0, _getWords.default)(clause).map(word => word.toLowerCase());

  // Search the participle in the word list.
  const participleIndex = wordsInClause.indexOf(participle.toLowerCase());

  /*
   * There can be no exception in the following situations:
   *
   * -1 The participle is not found.
   *  0 There is no word before the participle.
   */
  if (participleIndex < 1) {
    return false;
  }

  // Check if the words preceding the participle are in the exceptions list.
  for (let i = 0; i < participleIndex; i++) {
    if ((0, _lodash.includes)(cannotBeBetweenPassiveAuxiliaryAndParticipleList, wordsInClause[i])) {
      return true;
    }
  }
  return false;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/prominentWords/determineProminentWords.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/prominentWords/determineProminentWords.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.collapseProminentWordsOnStem = collapseProminentWordsOnStem;
exports["default"] = void 0;
exports.filterProminentWords = filterProminentWords;
exports.getProminentWords = getProminentWords;
exports.getProminentWordsFromPaperAttributes = getProminentWordsFromPaperAttributes;
exports.retrieveAbbreviations = retrieveAbbreviations;
exports.sortProminentWords = sortProminentWords;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _getWords = _interopRequireDefault(__webpack_require__(/*! ../word/getWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
var _quotes = __webpack_require__(/*! ../sanitize/quotes */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/quotes.js");
var _ProminentWord = _interopRequireDefault(__webpack_require__(/*! ../../values/ProminentWord */ "./node_modules/yoastseo/build/languageProcessing/values/ProminentWord.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const specialCharacters = /[1234567890‘’“”"'.…?!:;,¿¡«»&*@#±^%$|~=+§`[\](){}⟨⟩<>/\\–\-\u2014\u00d7\s]/g;

/**
 * Returns only those prominent words that occur more than a certain number of times and do not consist of special characters.
 *
 * @param {ProminentWord[]} prominentWords A list of prominent words.
 * @param {int} [minimalNumberOfOccurrences] A minimal number of occurrences that is needed for a relevant prominentWord, default 2.
 *
 * @returns {ProminentWord[]} Only relevant words.
 */
function filterProminentWords(prominentWords, minimalNumberOfOccurrences = 2) {
  prominentWords = prominentWords.filter(function (word) {
    return word.getOccurrences() >= minimalNumberOfOccurrences && word.getWord().replace(specialCharacters, "") !== "";
  });
  return prominentWords;
}

/**
 * Sorts prominent words based on their number of occurrences and length.
 *
 * @param {ProminentWord[]} prominentWords The prominent words to sort.
 *
 * @returns {void}
 */
function sortProminentWords(prominentWords) {
  prominentWords.sort(function (wordA, wordB) {
    const difference = wordB.getOccurrences() - wordA.getOccurrences();
    // The word with the highest number of occurrences comes first.
    if (difference !== 0) {
      return difference;
    }

    // In case of a tie on occurrence number, the alphabetically first word comes first.
    return wordA.getStem().localeCompare(wordB.getStem());
  });
}

/**
 * Collapses prominent words that have the same stem.
 *
 * @param {ProminentWord[]} prominentWords All prominentWords.
 *
 * @returns {ProminentWord[]} The original array with collapsed duplicates.
 */
function collapseProminentWordsOnStem(prominentWords) {
  if (prominentWords.length === 0) {
    return [];
  }

  // Sort the input array by stem
  prominentWords.sort(function (wordA, wordB) {
    return wordA.getStem().localeCompare(wordB.getStem());
  });
  const collapsedProminentWords = [];
  let previousWord = new _ProminentWord.default(prominentWords[0].getWord(), prominentWords[0].getStem(), prominentWords[0].getOccurrences());
  for (let i = 1; i < prominentWords.length; i++) {
    const currentWord = new _ProminentWord.default(prominentWords[i].getWord(), prominentWords[i].getStem(), prominentWords[i].getOccurrences());

    /*
     * Compare the stem of the current word in the loop with the previously available stem.
     * If they are equal, the word should be collapsed.
     * When collapsing, the numbers of occurrences get summed.
     * If the stem happens to equal the real word that occurred in the text, we can be sure it's ok to display it
     * to the customer. So, the stem reassigns the word.
     */
    if (currentWord.getStem() === previousWord.getStem()) {
      previousWord.setOccurrences(previousWord.getOccurrences() + currentWord.getOccurrences());
      if (currentWord.getWord() === previousWord.getStem() || currentWord.getWord().toLocaleLowerCase() === previousWord.getStem()) {
        previousWord.setWord(currentWord.getWord());
      }
    } else {
      collapsedProminentWords.push(previousWord);
      previousWord = currentWord;
    }
  }
  collapsedProminentWords.push(previousWord);
  return collapsedProminentWords;
}

/**
 * Retrieves a list of all abbreviations from the text. Returns an empty array if the input text is empty.
 *
 * @param {string} text A text.
 *
 * @returns {string[]} A list of abbreviations from the list.
 */
function retrieveAbbreviations(text) {
  const words = (0, _getWords.default)((0, _quotes.normalizeSingle)(text));
  const abbreviations = [];
  words.forEach(function (word) {
    if (word.length > 1 && word.length < 5 && word === word.toLocaleUpperCase()) {
      abbreviations.push(word.toLocaleLowerCase());
    }
  });
  return (0, _lodash.uniq)(abbreviations);
}

/**
 * Computes prominent words from an array of words. In order to do so, checks whether the word is included in the list of
 * function words and determines the number of occurrences for every word. Then checks if any two words have the same stem
 * and if so collapses over them.
 *
 * @param {string[]} words          The words to determine relevance for.
 * @param {string[]} abbreviations  Abbreviations that should not be stemmed.
 * @param {Function} stemmer        The available stemmer.
 * @param {Array} functionWords     The available function words list.
 *
 * @returns {ProminentWord[]} All prominent words sorted and filtered for this text.
 */
function computeProminentWords(words, abbreviations, stemmer, functionWords) {
  if (words.length === 0) {
    return [];
  }
  const uniqueContentWords = (0, _lodash.uniq)(words.filter(word => !functionWords.includes(word.trim())));
  const prominentWords = [];
  uniqueContentWords.forEach(function (word) {
    if (abbreviations.includes(word)) {
      prominentWords.push(new _ProminentWord.default(word.toLocaleUpperCase(), word, words.filter(element => element === word).length));
    } else {
      prominentWords.push(new _ProminentWord.default(word, stemmer(word), words.filter(element => element === word).length));
    }
  });
  return collapseProminentWordsOnStem(prominentWords);
}

/**
 * Caches prominent words depending on text words.
 * Only the words and abbreviations are used as the cache key as the stemmer and function words
 * are config and shouldn't change in the scope of one request.
 *
 * @param {string[]} words          The words to determine relevance for.
 * @param {string[]} abbreviations  Abbreviations that should not be stemmed.
 * @param {Function} stemmer        The available stemmer.
 * @param {Array} functionWords     The available function words list.
 *
 * @returns {function} The function that collects prominent words for a given set of text words, language and morphologyData.
 */
const computeProminentWordsMemoized = (0, _lodash.memoize)((words, abbreviations, stemmer, functionWords) => {
  return computeProminentWords(words, abbreviations, stemmer, functionWords);
}, (words, abbreviations) => {
  return words.join(",") + "," + abbreviations.join(",");
});

/**
 * Gets prominent words from the paper text.
 *
 * @param {string} text             The text to retrieve the prominent words from.
 * @param {string[]} abbreviations  The abbreviations that occur in the text and attributes of the paper.
 * @param {Function} stemmer        The available stemmer.
 * @param {Array} functionWords     The available function words list.
 * @param {function} getWordsCustomHelper   The custom helper to get words.
 *
 * @returns {ProminentWord[]} All prominent words sorted and filtered for this text.
 */
function getProminentWords(text, abbreviations, stemmer, functionWords, getWordsCustomHelper) {
  if (text === "") {
    return [];
  }
  const words = getWordsCustomHelper ? getWordsCustomHelper((0, _quotes.normalizeSingle)(text).toLocaleLowerCase()) : (0, _getWords.default)((0, _quotes.normalizeSingle)(text).toLocaleLowerCase());
  return computeProminentWordsMemoized(words, abbreviations, stemmer, functionWords);
}

/**
 * Gets prominent words from keyphrase and synonyms, metadescription, title, and subheadings.
 *
 * @param {string[]} attributes     The array with attributes to process.
 * @param {string[]} abbreviations  The abbreviations that occur in the text and attributes of the paper.
 * @param {Function} stemmer        The available stemmer.
 * @param {Array} functionWords     The available function words list.
 * @param {function} getWordsCustomHelper   The custom helper to get words.
 *
 * @returns {ProminentWord[]} Prominent words from the paper attributes.
 */
function getProminentWordsFromPaperAttributes(attributes, abbreviations, stemmer, functionWords, getWordsCustomHelper) {
  const wordsFromAttributes = getWordsCustomHelper ? getWordsCustomHelper(attributes.join(" ").toLocaleLowerCase()) : (0, _getWords.default)(attributes.join(" ").toLocaleLowerCase());
  return computeProminentWords(wordsFromAttributes, abbreviations, stemmer, functionWords);
}
var _default = exports["default"] = {
  getProminentWords,
  getProminentWordsFromPaperAttributes,
  filterProminentWords,
  sortProminentWords,
  collapseProminentWordsOnStem,
  retrieveAbbreviations
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/regex/createRegexFromArray.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/regex/createRegexFromArray.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _addWordboundary = _interopRequireDefault(__webpack_require__(/*! ../word/addWordboundary.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/addWordboundary.js"));
var _replaceDiacritics = _interopRequireDefault(__webpack_require__(/*! ../transliterate/replaceDiacritics */ "./node_modules/yoastseo/build/languageProcessing/helpers/transliterate/replaceDiacritics.js"));
var _sanitizeString = _interopRequireDefault(__webpack_require__(/*! ../sanitize/sanitizeString */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/sanitizeString.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module stringProcessing/createRegexFromArray */

/**
 * Creates a regex of combined strings from the input array.
 *
 * @param {string[]} array                      The array with strings
 * @param {boolean} [disableWordBoundary=false] Boolean indicating whether or not to disable word boundaries.
 * @param {string} [extraBoundary=""]           A string that is used as extra boundary for the regex.
 * @param {boolean} [doReplaceDiacritics=false] If set to true, it replaces diacritics. Defaults to false.
 *
 * @returns {RegExp} regex                              The regex created from the array.
 */
function _default(array, disableWordBoundary = false, extraBoundary = "", doReplaceDiacritics = false) {
  array = (0, _lodash.map)(array, function (string) {
    if (doReplaceDiacritics) {
      string = (0, _replaceDiacritics.default)(string);
    }
    string = (0, _sanitizeString.default)(string);
    if (disableWordBoundary) {
      return string;
    }
    return (0, _addWordboundary.default)(string, true, extraBoundary);
  });
  const regexString = "(" + array.join(")|(") + ")";
  return new RegExp(regexString, "ig");
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/regex/createRegexFromDoubleArray.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/regex/createRegexFromDoubleArray.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _addWordboundary = _interopRequireDefault(__webpack_require__(/*! ../word/addWordboundary.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/addWordboundary.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module stringProcessing/createRegexFromDoubleArray */

/**
 * Creates a regex string of combined strings from the input array.
 *
 * @param {array} array The array containing the various parts of a transition word combination.
 *
 * @returns {array} The array with replaced entries.
 */
const wordCombinationToRegexString = function (array) {
  array = array.map(function (word) {
    return (0, _addWordboundary.default)(word);
  });
  return array.join("(.*?)");
};

/**
 * Creates a regex of combined strings from the input array, containing arrays with two entries.
 *
 * @param {array} array The array containing arrays.
 *
 * @returns {RegExp} The regex created from the array.
 */
function _default(array) {
  array = array.map(function (wordCombination) {
    return wordCombinationToRegexString(wordCombination);
  });
  const regexString = "(" + array.join(")|(") + ")";
  return new RegExp(regexString, "ig");
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/regex/matchStringWithRegex.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/regex/matchStringWithRegex.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/** @module stringProcessing/matchStringWithRegex */

/**
 * Checks a string with a regex, return all matches found with that regex.
 *
 * @param {String} 		text        The text to match.
 * @param {object} 		regex  		A compiled regular expression.
 *
 * @returns {Array} Array with matches, empty array if no matches found.
 */
function _default(text, regex) {
  let matches = text.match(regex);
  if (matches === null) {
    matches = [];
  }
  return matches;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/doubleQuotes.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/doubleQuotes.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Returns an array with double quotes.
 *
 * Japanese-specific quotes:
 * U300c - left corner bracket.
 * U300d - right corner bracket.
 * U300e - left white corner bracket.
 * U300f - right white corner bracket.
 *
 * @returns {string[]} The array with double quotes..
 */
var _default = exports["default"] = ["“", "”", "〝", "〞", "〟", "‟", "„", "\"", "\u300c", "\u300d", "\u300e", "\u300f"];

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/filterShortcodesFromTree.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/filterShortcodesFromTree.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.filterShortcodesFromHTML = exports["default"] = void 0;
/**
 * Creates a regex to filter shortcodes from HTML.
 * @param {string[]} shortcodeTags The tags of the shortcodes to filter.
 * @returns {RegExp} The regex to recognize the shortcodes.
 */
const createShortcodeTagsRegex = shortcodeTags => {
  const shortcodeTagsRegexString = `\\[\\/?(${shortcodeTags.join("|")})[^\\]]*\\]`;
  return new RegExp(shortcodeTagsRegexString, "g");
};

/**
 * Filters shortcodes from HTML string.
 * @param {string} html The HTML to filter.
 * @param {string[]} shortcodeTags The tags of the shortcodes to filter.
 * @returns {string} The filtered HTML.
 */
const filterShortcodesFromHTML = (html, shortcodeTags) => {
  if (!shortcodeTags || shortcodeTags.length === 0) {
    return html;
  }
  const shortcodeTagsRegex = createShortcodeTagsRegex(shortcodeTags);
  return html.replace(shortcodeTagsRegex, "");
};

/**
 * Checks if a token is part of an opening shortcode.
 * @param {Token[]} tokens The tokens to check.
 * @param {number} index The index of the current token.
 * @returns {boolean} Whether the token is part of an opening shortcode.
 */
exports.filterShortcodesFromHTML = filterShortcodesFromHTML;
const tokenIsPartOfOpeningShortcode = (tokens, index) => {
  return tokens[index - 1] && tokens[index - 1].text === "[";
};

/**
 * Checks if a token is part of a closing shortcode.
 * @param {Token[]} tokens The tokens to check.
 * @param {number} index The index of the current token.
 * @returns {boolean} Whether the token is part of a closing shortcode.
 */
const tokenIsPartOfClosingShortcode = (tokens, index) => {
  return tokens[index - 1] && tokens[index - 1].text === "/" && tokens[index - 2] && tokens[index - 2].text === "[";
};

/**
 * Checks if a token is part of a shortcode.
 * @param {Token[]} tokens The tokens to check.
 * @param {number} index The index of the current token.
 * @param {string[]} shortcodeTags An array of active shortcode tags.
 * @param {boolean} encounteredClosingBracket Whether a closing bracket has been encountered (while looping backwards through the tokens).
 * @returns {boolean} Whether the token is part of a shortcode.
 */
const tokenIsShortcode = (tokens, index, shortcodeTags, encounteredClosingBracket) => {
  return encounteredClosingBracket && shortcodeTags.includes(tokens[index].text) && (tokenIsPartOfOpeningShortcode(tokens, index) || tokenIsPartOfClosingShortcode(tokens, index));
};

/**
 * Filters shortcodes from a sentence.
 * @param {Sentence} sentence The sentence to filter.
 * @param {string[]} shortcodeTags The tags of the shortcodes to filter.
 * @param {RegExp} shortcodeTagsRegex The regex to filter the shortcodes.
 * @returns {void}
 *
 */
const filterShortcodesFromSentence = (sentence, shortcodeTags, shortcodeTagsRegex) => {
  const tokens = sentence.tokens;
  let encounteredClosingBracket = false;
  // traverse through tokens backwards
  for (let i = tokens.length - 1; i >= 0; i--) {
    if (tokens[i].text === "]") {
      encounteredClosingBracket = true;
    }
    if (tokenIsShortcode(tokens, i, shortcodeTags, encounteredClosingBracket)) {
      while (tokens[i].text !== "]") {
        tokens.splice(i, 1);
      }
      tokens.splice(i, 1);
      encounteredClosingBracket = false;
      while (tokens[i - 1] && "[/".includes(tokens[i - 1].text)) {
        tokens.splice(i - 1, 1);
        i--;
      }
    }
  }
  sentence.tokens = tokens;
  sentence.text = sentence.text.replace(shortcodeTagsRegex, "");
};

/**
 * A recursive function that filters shortcodes from sentences.
 * @param {Node} tree The tree to filter.
 * @param {string[]} shortcodeTags The tags of the shortcodes to filter.
 * @param {RegExp} shortcodeTagsRegex The regex to filter the shortcodes.
 * @returns {void}
 */
const filterShortcodesFromSentences = (tree, shortcodeTags, shortcodeTagsRegex) => {
  if (tree.sentences) {
    tree.sentences.forEach(sentence => {
      filterShortcodesFromSentence(sentence, shortcodeTags, shortcodeTagsRegex);
    });
  }
  if (tree.childNodes) {
    tree.childNodes.forEach(childNode => {
      filterShortcodesFromSentences(childNode, shortcodeTags, shortcodeTagsRegex);
    });
  }
};

/**
 * Filters shortcodes from the tree.
 * @param {Node} tree The tree to filter.
 * @param {string[]} shortcodeTags The tags of the shortcodes to filter.
 * @returns {void}
 */
const filterShortcodesFromTree = (tree, shortcodeTags) => {
  if (!shortcodeTags || shortcodeTags.length === 0) {
    return;
  }
  const shortcodeTagsRegex = createShortcodeTagsRegex(shortcodeTags);
  filterShortcodesFromSentences(tree, shortcodeTags, shortcodeTagsRegex);
};
var _default = exports["default"] = filterShortcodesFromTree;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/mergeListItems.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/mergeListItems.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.mergeListItems = mergeListItems;
/**
 * Removes list-related html tags in a text to be used for the keyphrase distribution assessment.
 * That way, lists with single words don't result in a skewed keyphrase distribution result.
 *
 * @param {string}  text    The text in which to remove the list structures.
 *
 * @returns {string} The text with all list structures removed.
 */
function mergeListItems(text) {
  const listTags = /<\/?(o|ul)(?:[^>]+)?>/g;
  const listItemTags = /\s?<\/?li(?:[^>]+)?>\s?/g;

  /*
   * Steps:
   * 1) Remove all ul and ol tags.
   * 2) Replace all li tags with spaces to avoid list items being stuck together.
   * 3) Replace multiple instances of whitespace with a single instance.
   */
  text = text.replace(listTags, "");
  text = text.replace(listItemTags, " ");
  text = text.replace(/\s+/g, " ");
  return text;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/parseSynonyms.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/parseSynonyms.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _stripSpaces = _interopRequireDefault(__webpack_require__(/*! ./stripSpaces.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripSpaces.js"));
var _removePunctuationExceptQuotes = _interopRequireDefault(__webpack_require__(/*! ./removePunctuationExceptQuotes.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removePunctuationExceptQuotes.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module stringProcessing/parseSynonyms */

/**
 * Parses synonyms from a comma-separated string into an array.
 *
 * @param {String} synonyms The text to match
 *
 * @returns {Array} An array with all synonyms.
 */
function _default(synonyms) {
  let synonymsSplit = synonyms.split(",");
  synonymsSplit = synonymsSplit.map(synonym => (0, _removePunctuationExceptQuotes.default)((0, _stripSpaces.default)(synonym))).filter(synonym => synonym);
  return synonymsSplit;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/quotes.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/quotes.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.SINGLE_QUOTES_REGEX = exports.SINGLE_QUOTES_ARRAY = void 0;
exports.normalize = normalizeQuotes;
exports.normalizeDouble = normalizeDoubleQuotes;
exports.normalizeSingle = normalizeSingleQuotes;
const SINGLE_QUOTES_ARRAY = exports.SINGLE_QUOTES_ARRAY = ["'", "‘", "’", "‛", "`", "‹", "›"];
const SINGLE_QUOTES_REGEX = exports.SINGLE_QUOTES_REGEX = new RegExp("[" + SINGLE_QUOTES_ARRAY.join("") + "]", "g");

/**
 * Normalizes single quotes to 'regular' quotes.
 *
 * @param {string} text Text to normalize.
 * @returns {string} The normalized text.
 */
function normalizeSingleQuotes(text) {
  return text.replace(SINGLE_QUOTES_REGEX, "'");
}

/**
 * Normalizes double quotes to 'regular' quotes.
 *
 * @param {string} text Text to normalize.
 * @returns {string} The normalized text.
 */
function normalizeDoubleQuotes(text) {
  return text.replace(/[“”〝〞〟‟„『』«»]/g, "\"");
}

/**
 * Normalizes quotes to 'regular' quotes.
 *
 * @param {string} text Text to normalize.
 * @returns {string} The normalized text.
 */
function normalizeQuotes(text) {
  return normalizeDoubleQuotes(normalizeSingleQuotes(text));
}
var _default = exports["default"] = {
  normalizeSingle: normalizeSingleQuotes,
  normalizeDouble: normalizeDoubleQuotes,
  normalize: normalizeQuotes
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removeEmailAddresses.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removeEmailAddresses.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
const emailRegex = new RegExp("[^\\s@]+@[^\\s@]+\\.[^\\s@]+", "igm");

/**
 * Removes email addresses from a text.
 *
 * @param {string} text The text to remove emails from.
 *
 * @returns {string} The text without email addresses.
 */
function _default(text) {
  return text.replace(emailRegex, "");
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removePunctuation.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removePunctuation.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
exports.punctuationRegexString = exports.punctuationRegexStart = exports.punctuationRegexEnd = exports.punctuationList = void 0;
var _unifyWhitespace = __webpack_require__(/*! ./unifyWhitespace */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/unifyWhitespace.js");
/**
 * String containing all the characters that we consider punctuation.
 * Characters that can also be used as control characters in regular expressions (like `-` and `(`) are escaped.
 * @type {string}
 */
const punctuationRegexString = exports.punctuationRegexString = "\\–\\-\\(\\)_\\[\\]’‘“”〝〞〟‟„\"'.?!:;,¿¡«»‹›\u2014\u00d7\u002b\u0026\u06d4\u061f\u060C\u061B\u3002\uff61" + "\uff01\u203c\uff1f\u2047\u2049\u2048\u2025\u2026\u30fb\u30fc\u3001\u3003\u3004\u3006\u3007\u3008\u3009\u300a\u300b\u300c\u300d\u300e" + "\u300f\u3010\u3011\u3012\u3013\u3014\u3015\u3016\u3017\u3018\u3019\u301a\u301b\u301c\u301d\u301e\u301f\u3020\u3036\u303c\u303d\uff5b" + "\uff5d\uff5c\uff5e\uff5f\uff60\uff62\uff63\uff64\uff3b\uff3d\uff65\uffe5\uff04\uff05\uff20\uff06\uff07\uff08\uff09\uff0a\uff0f\uff1a" + "\uff1b\uff1c\uff1e\uff3c\\<>";

/**
 * Array containing all the characters that we consider punctuation.
 * Characters that can also be used as control characters in regular expressions (like `-` and `(`) are escaped.
 * @type {string[]}
 */
const punctuationList = exports.punctuationList = punctuationRegexString.split("");
const punctuationRegexStart = exports.punctuationRegexStart = new RegExp("^[" + punctuationRegexString + "]+");
const punctuationRegexEnd = exports.punctuationRegexEnd = new RegExp("[" + punctuationRegexString + "]+$");

/*
 * \u2014 - em-dash
 * \u00d7 - multiplication sign
 * \u002b - plus sign
 * \u0026 - ampersand
 * \u06d4 - Urdu full stop
 * \u061f - Arabic question mark
 * \u060C - Arabic comma
 * \u061B - Arabic semicolon
 */

/**
 * Replaces punctuation characters from the given text string.
 *
 * @param {String} text The text to remove the punctuation characters for.
 *
 * @returns {String} The sanitized text.
 */
function _default(text) {
  // Unify whitespaces and non-breaking spaces.
  text = (0, _unifyWhitespace.unifyNonBreakingSpace)(text);

  // Remove &amp from the string. In some editors (a.o. Block and Elementor) the ampersand (&) is transformed into &amp.
  // If it is not removed, then it is returned as "amp" and counted as a word in assessments downstream.
  text = text.replace("\u0026amp", "");

  /*
   * Remove backslash from the beginning and end of a word/text.
   * When a string such as `This is a \"calico\" cat` enters the Paper,
   * the Paper adds two extra backslash in front of the original backslash.
   * After the text is split into words, we also need to remove those backslashes from the word.
   * Otherwise, it will be problematic when word boundary regex is added to the word.
   */
  const backslashRegex = new RegExp("(\\\\)", "g");
  text = text.replace(backslashRegex, "");
  text = text.replace(punctuationRegexStart, "");
  text = text.replace(punctuationRegexEnd, "");
  return text;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removePunctuationExceptQuotes.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removePunctuationExceptQuotes.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
// Replace all other punctuation characters at the beginning or at the end of a word.
const punctuationRegexString = "[\\–\\-\\(\\)_\\[\\]’'.?!:;,¿¡«»‹›\u2014\u00d7\u002b\u0026<>]+";
const punctuationRegexStart = new RegExp("^" + punctuationRegexString);
const punctuationRegexEnd = new RegExp(punctuationRegexString + "$");

/**
 * Replaces punctuation characters at the beginning and end of a given text string.
 *
 * @param {String} text The text to remove the punctuation characters for.
 *
 * @returns {String} The sanitized text.
 */
function _default(text) {
  text = text.replace(punctuationRegexStart, "");
  text = text.replace(punctuationRegexEnd, "");
  return text;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removeURLs.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removeURLs.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
const urlRegex = new RegExp("(ftp|http(s)?:\\/\\/.)(www\\\\.)?[-a-zA-Z0-9@:%._\\/+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:;%_\\/+.~#?&()=]*)" + "|www\\.[-a-zA-Z0-9@:%._\\/+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:;%_\\/+.~#?&()=]*)", "igm");
/**
 * This regex is used to match URLs, whether they are embedded in tags or not.
 * It doesn't match domain names (e.g. "yoast.com" in "We got so much traffic on yoast.com after the latest release").
 *
 * @param {string} text The text to remove URLs from.
 *
 * @returns {string} The text without URLs.
 */
function _default(text) {
  return text.replace(urlRegex, "");
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/sanitizeLineBreakTag.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/sanitizeLineBreakTag.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Replaces line break tag that contains an attribute with paragraph tag.
 * Line break tags with attribute aren't properly sanitized using wordpress `autop` function.
 *
 * @param {string} text The text to sanitize.
 *
 * @returns {string} The sanitized text.
 */
function _default(text) {
  return text.replace(/<br.*?>\s*<.*?br.*?>/gm, "</p><p>");
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/sanitizeString.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/sanitizeString.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _stripHTMLTags = __webpack_require__(/*! ./stripHTMLTags.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripHTMLTags.js");
var _unifyWhitespace = __webpack_require__(/*! ./unifyWhitespace */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/unifyWhitespace.js");
/**
 * Sanitizes the text before we use the text for the analysis.
 *
 * @param {String} text The text to be sanitized.
 *
 * @returns {String} The sanitized text.
 */
function _default(text) {
  // Unify whitespaces and non-breaking spaces.
  text = (0, _unifyWhitespace.unifyAllSpaces)(text);
  // Strip the tags and multiple spaces.
  text = (0, _stripHTMLTags.stripFullTags)(text);
  return text;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripHTMLTags.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripHTMLTags.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.stripIncompleteTags = exports.stripFullTags = exports.stripBlockTagsAtStartEnd = exports["default"] = void 0;
var _stripSpaces = _interopRequireDefault(__webpack_require__(/*! ./stripSpaces.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripSpaces.js"));
var _html = __webpack_require__(/*! ../html/html.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/html.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module stringProcessing/stripHTMLTags */

const blockElementStartRegex = new RegExp("^<(" + _html.blockElements.join("|") + ")[^>]*?>", "i");
const blockElementEndRegex = new RegExp("</(" + _html.blockElements.join("|") + ")[^>]*?>$", "i");

/**
 * Strip incomplete tags within a text. Strips an end tag at the beginning of a string and the start tag at the end of a
 * start of a string.
 *
 * @param {String} text The text to strip the HTML-tags from at the begin and end.
 * @returns {String} The text without HTML-tags at the begin and end.
 */
const stripIncompleteTags = function (text) {
  text = text.replace(/^(<\/([^>]+)>)+/i, "");
  text = text.replace(/(<([^/>]+)>)+$/i, "");
  return text;
};

/**
 * Removes the block element tags at the beginning and end of a string and returns this string.
 *
 * @param {string} text The unformatted string.
 * @returns {string} The text with removed HTML begin and end block elements
 */
exports.stripIncompleteTags = stripIncompleteTags;
const stripBlockTagsAtStartEnd = function (text) {
  text = text.replace(blockElementStartRegex, "");
  text = text.replace(blockElementEndRegex, "");
  return text;
};

/**
 * Strip HTML-tags from text
 *
 * @param {String} text The text to strip the HTML-tags from.
 * @returns {String} The text without HTML-tags.
 */
exports.stripBlockTagsAtStartEnd = stripBlockTagsAtStartEnd;
const stripFullTags = function (text) {
  text = text.replace(/(<([^>]+)>)/ig, " ");
  text = (0, _stripSpaces.default)(text);
  return text;
};
exports.stripFullTags = stripFullTags;
var _default = exports["default"] = {
  stripFullTags: stripFullTags,
  stripIncompleteTags: stripIncompleteTags,
  stripBlockTagsAtStartEnd: stripBlockTagsAtStartEnd
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripNonTextTags.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripNonTextTags.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _stripSpaces = _interopRequireDefault(__webpack_require__(/*! ./stripSpaces.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripSpaces.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module stringProcessing/stripNonTextTags */

/**
 * Strips all tags from the text, except li, p, dd and h1-h6 tags from the text that contain content to check.
 *
 * @param {string} text The text to strip tags from
 * @returns {string} The text stripped of tags, except for li, p, dd and h1-h6 tags.
 */
function _default(text) {
  text = text.replace(/<(?!li|\/li|p|\/p|h1|\/h1|h2|\/h2|h3|\/h3|h4|\/h4|h5|\/h5|h6|\/h6|dd).*?>/g, "");
  text = (0, _stripSpaces.default)(text);
  return text;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripNumbers.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripNumbers.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _stripSpaces = _interopRequireDefault(__webpack_require__(/*! ./stripSpaces.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripSpaces.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module stringProcessing/stripNumbers */

/**
 * Removes all words comprised only of numbers.
 *
 * @param {string} text to remove words
 * @returns {string} The text with 'numberonly' words removed.
 */
function _default(text) {
  // Remove "words" comprised only of numbers
  text = text.replace(/\b[0-9]+\b/g, "");
  text = (0, _stripSpaces.default)(text);
  if (text === ".") {
    text = "";
  }
  return text;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripSpaces.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripSpaces.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/** @module stringProcessing/stripSpaces */

/**
 * Replaces multiple spaces with a single space.
 * Removes spaces followed by a period (if there's no text after the period) and spaces in the beginning or end of a string.
 *
 * @param {String} text The text to strip spaces from.
 * @returns {String} The text with stripped spaces.
 */
function _default(text) {
  // Replaces multiple spaces with a single space.
  text = text.replace(/\s{2,}/g, " ");
  // Replaces space(s) followed by a period, if the period is the last character, with only the period.
  text = text.replace(/\s\.$/, ".");
  // Removes first/last character if it's a space.
  text = text.replace(/^\s+|\s+$/g, "");
  // Replaces spaces followed by a Japanese period with only the period.
  text = text.replace(/\s。/g, "。");
  // Replaces spaces after a Japanese period with only the period.
  text = text.replace(/。\s/g, "。");
  return text;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripWordBoundaries.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripWordBoundaries.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.stripWordBoundariesStart = exports.stripWordBoundariesEverywhere = exports.stripWordBoundariesEnd = exports["default"] = void 0;
/*
 * \u00a0 - No-break space
 * \u06d4 - Urdu full stop
 * \u061f - Arabic question mark
 * \u060C - Arabic comma
 * \u061B - Arabic semicolon
 */
const wordBoundary = "[ \\u00a0\\u06d4\\u061f\\u060C\\u061B \\n\\r\\t.,'()\"+\\-;!?:/»«‹›<>]";
const wordBoundaryStart = new RegExp("^(" + wordBoundary + "+)", "ig");
const wordBoundaryEnd = new RegExp("(" + wordBoundary + "+$)", "ig");

/**
 * Strip word boundary markers from text in the beginning
 *
 * @param {String} text The text to strip word boundary markers from.
 *
 * @returns {String} The text without double word boundary markers.
 */
const stripWordBoundariesStart = function (text) {
  // Remove first character if word boundary
  text = text.replace(wordBoundaryStart, "");
  return text;
};

/**
 * Strip word boundary markers from text in the end
 *
 * @param {String} text The text to strip word boundary markers from.
 *
 * @returns {String} The text without double word boundary markers.
 */
exports.stripWordBoundariesStart = stripWordBoundariesStart;
const stripWordBoundariesEnd = function (text) {
  // Remove last character if word boundary
  text = text.replace(wordBoundaryEnd, "");
  return text;
};

/**
 * Strip word boundary markers from text in the beginning and in the end
 *
 * @param {String} text The text to strip word boundary markers from.
 *
 * @returns {String} The text without word boundary markers.
 */
exports.stripWordBoundariesEnd = stripWordBoundariesEnd;
const stripWordBoundariesEverywhere = function (text) {
  // Remove first/last character if word boundary
  text = text.replace(wordBoundaryStart, "");
  text = text.replace(wordBoundaryEnd, "");
  return text;
};
exports.stripWordBoundariesEverywhere = stripWordBoundariesEverywhere;
var _default = exports["default"] = {
  stripWordBoundariesStart: stripWordBoundariesStart,
  stripWordBoundariesEnd: stripWordBoundariesEnd,
  stripWordBoundariesEverywhere: stripWordBoundariesEverywhere
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/unifyWhitespace.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/unifyWhitespace.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.unifyWhiteSpace = exports.unifyNonBreakingSpace = exports.unifyEmDash = exports.unifyAllSpaces = exports["default"] = void 0;
/** @module stringProcessing/unifyWhitespace */

/**
 * Replaces a non-breaking space with a normal space.
 *
 * @param {string} text The string to replace the non-breaking space in.
 *
 * @returns {string} The text with unified spaces.
 */
const unifyNonBreakingSpace = function (text) {
  return text.replace(/&nbsp;/g, " ");
};

/**
 * Replaces an em dash with a normal space.
 *
 * @param {string} text The string to replace the em dash in.
 *
 * @returns {string} The text with unified spaces.
 */
exports.unifyNonBreakingSpace = unifyNonBreakingSpace;
const unifyEmDash = function (text) {
  return text.replace(/\u2014/g, " ");
};

/**
 * Replaces all whitespace characters with a normal space.
 *
 * @param {string} text The string to replace the whitespace characters in.
 *
 * @returns {string} The text with unified spaces.
 */
exports.unifyEmDash = unifyEmDash;
const unifyWhiteSpace = function (text) {
  return text.replace(/\s/g, " ");
};

/**
 * Converts all whitespace to spaces.
 *
 * @param {string} text The text to replace spaces.
 *
 * @returns {string} The text with unified spaces.
 */
exports.unifyWhiteSpace = unifyWhiteSpace;
const unifyAllSpaces = function (text) {
  text = unifyNonBreakingSpace(text);
  text = unifyEmDash(text);
  return unifyWhiteSpace(text);
};
exports.unifyAllSpaces = unifyAllSpaces;
var _default = exports["default"] = {
  unifyNonBreakingSpace: unifyNonBreakingSpace,
  unifyEmDash: unifyEmDash,
  unifyWhiteSpace: unifyWhiteSpace,
  unifyAllSpaces: unifyAllSpaces
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/SentenceTokenizer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sentence/SentenceTokenizer.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _core = _interopRequireDefault(__webpack_require__(/*! tokenizer2/core */ "./node_modules/tokenizer2/core.js"));
var _quotes = __webpack_require__(/*! ../sanitize/quotes.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/quotes.js");
var _abbreviations = _interopRequireDefault(__webpack_require__(/*! ../../languages/en/config/abbreviations */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/abbreviations.js"));
var _createRegexFromArray = _interopRequireDefault(__webpack_require__(/*! ../regex/createRegexFromArray */ "./node_modules/yoastseo/build/languageProcessing/helpers/regex/createRegexFromArray.js"));
var _wordBoundaries = _interopRequireDefault(__webpack_require__(/*! ../../../config/wordBoundaries */ "./node_modules/yoastseo/build/config/wordBoundaries.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
// All characters that indicate a sentence delimiter.
const fullStop = ".";
const fullStopRegex = new RegExp("^[" + fullStop + "]$");
const smallerThanContentRegex = /^<[^><]*$/;
const htmlStartRegex = /^<([^>\s/]+)[^>]*>$/mi;
const htmlEndRegex = /^<\/([^>\s]+)[^>]*>$/mi;
const blockStartRegex = /^\s*[[({]\s*$/;
const blockEndRegex = /^\s*[\])}]\s*$/;
const abbreviationsPreparedForRegex = _abbreviations.default.map(abbreviation => abbreviation.replace(".", "\\."));
const abbreviationsRegex = (0, _createRegexFromArray.default)(abbreviationsPreparedForRegex);
const wordBoundariesForRegex = "(^|$|[" + (0, _wordBoundaries.default)().map(boundary => "\\" + boundary).join("") + "])";
const lastCharacterPartOfInitialsRegex = new RegExp(wordBoundariesForRegex + "[A-Za-z]$");

// Constants to be used in isValidTagPair.
// A regex to get the tag type.
const tagTypeRegex = /<\/?([^\s]+?)(\s|>)/;
// Semantic tags (as opposed to style tags) are tags that are used to structure the text.
const semanticTags = ["p", "div", "h1", "h2", "h3", "h4", "h5", "h6", "span", "li", "main"];

/**
 * Class for tokenizing a (html) text into sentences.
 */
class SentenceTokenizer {
  /**
   * Constructor
   * @constructor
   */
  constructor() {
    /*
           * \u2026 - ellipsis.
           * \u06D4 - Urdu full stop.
           * \u061f - Arabic question mark.
          */
    this.sentenceDelimiters = "”〞〟„』›»’‛`\"?!\u2026\u06d4\u061f";
  }

  /**
   * Gets the sentence delimiters.
   *
   * @returns {string} The sentence delimiters.
   */
  getSentenceDelimiters() {
    return this.sentenceDelimiters;
  }

  /**
   * Returns whether or not a certain character is a number.
   *
   * @param {string} character The character to check.
   * @returns {boolean} Whether or not the character is a capital letter.
   */
  isNumber(character) {
    return !(0, _lodash.isNaN)(parseInt(character, 10));
  }

  /**
   * Returns whether or not a given HTML tag is a break tag.
   *
   * @param {string} htmlTag The HTML tag to check.
   * @returns {boolean} Whether or not the given HTML tag is a break tag.
   */
  isBreakTag(htmlTag) {
    return /<\/?br/.test(htmlTag);
  }

  /**
   * Returns whether or not a given character is quotation mark.
   *
   * @param {string} character The character to check.
   * @returns {boolean} Whether or not the given character is a quotation mark.
   */
  isQuotation(character) {
    character = (0, _quotes.normalize)(character);
    return "'" === character || "\"" === character;
  }

  /**
   * A mock definition of this function. This function is only used in extensions for languages that use an ordinal dot.
   *
   * @returns {boolean} Always returns false as it is a language specific implementation if a language has an ordinal dot.
   */
  endsWithOrdinalDot() {
    return false;
  }

  /**
   * Returns whether or not a given character is a punctuation mark that can be at the beginning
   * of a sentence, like ¿ and ¡ used in Spanish.
   *
   * @param {string} character The character to check.
   * @returns {boolean} Whether or not the given character is a punctuation mark.
   */
  isPunctuation(character) {
    return "¿" === character || "¡" === character;
  }

  /**
   * Removes duplicate whitespace from a given text.
   *
   * @param {string} text The text with duplicate whitespace.
   * @returns {string} The text without duplicate whitespace.
   */
  removeDuplicateWhitespace(text) {
    return text.replace(/\s+/, " ");
  }

  /**
   * Returns whether or not a certain character is a capital letter.
   *
   * @param {string} character The character to check.
   * @returns {boolean} Whether or not the character is a capital letter.
   */
  isCapitalLetter(character) {
    return character !== character.toLocaleLowerCase();
  }

  /**
   * Checks whether the given character is a smaller than sign.
   *
   * This function is used to make sure that tokenizing the content after
   * the smaller than sign works as expected.
   * E.g. 'A sentence. < Hello world!' = ['A sentence.', '< Hello world!'].
   *
   * @param {string} character The character to check.
   * @returns {boolean} Whether the character is a smaller than sign ('<') or not.
   */
  isSmallerThanSign(character) {
    return character === "<";
  }

  /**
   * Retrieves the next two characters from an array with the two next tokens.
   *
   * @param {Array} nextTokens The two next tokens. Might be undefined.
   * @returns {string} The next two characters.
   */
  getNextTwoCharacters(nextTokens) {
    let next = "";
    if (!(0, _lodash.isUndefined)(nextTokens[0])) {
      next += nextTokens[0].src;
    }
    if (!(0, _lodash.isUndefined)(nextTokens[1])) {
      next += nextTokens[1].src;
    }
    next = this.removeDuplicateWhitespace(next);
    return next;
  }

  /**
   * Checks whether a character is from a language that's written from right to left.
   * These languages don't have capital letter forms. Therefore any letter from these languages is a
   * potential sentence beginning.
   *
   * @param {string} letter The letter to check.
   *
   * @returns {boolean} Whether the letter is from an LTR language.
   */
  isLetterFromSpecificLanguage(letter) {
    const ltrLetterRanges = [
    // Hebrew characters.
    /^[\u0590-\u05fe]+$/i,
    // Arabic characters (used for Arabic, Farsi, Urdu).
    /^[\u0600-\u06FF]+$/i,
    // Additional Farsi characters.
    /^[\uFB8A\u067E\u0686\u06AF]+$/i];
    return ltrLetterRanges.some(ltrLetterRange => ltrLetterRange.test(letter));
  }

  /**
   * Checks if the sentenceBeginning beginning is a valid beginning.
   *
   * @param {string} sentenceBeginning The beginning of the sentence to validate.
   * @returns {boolean} Returns true if it is a valid beginning, false if it is not.
   */
  isValidSentenceBeginning(sentenceBeginning) {
    return this.isCapitalLetter(sentenceBeginning) || this.isLetterFromSpecificLanguage(sentenceBeginning) || this.isNumber(sentenceBeginning) || this.isQuotation(sentenceBeginning) || this.isPunctuation(sentenceBeginning) || this.isSmallerThanSign(sentenceBeginning);
  }

  /**
   * Checks if the token is a valid sentence start.
   *
   * @param {Object} token The token to validate.
   * @returns {boolean} Returns true if the token is valid sentence start, false if it is not.
   */
  isSentenceStart(token) {
    return !(0, _lodash.isUndefined)(token) && ("html-start" === token.type || "html-end" === token.type || "block-start" === token.type);
  }

  /**
   * Checks if the token is a valid sentence ending. A valid sentence ending is either a full stop or another
   * delimiter such as "?", "!", etc.
   *
   * @param {Object} token The token to validate.
   * @returns {boolean} Returns true if the token is valid sentence ending, false if it is not.
   */
  isSentenceEnding(token) {
    return !(0, _lodash.isUndefined)(token) && (token.type === "full-stop" || token.type === "sentence-delimiter");
  }

  /**
   * Checks if a full stop is part of a person's initials.
   *
   * Tests if tokens exist. Then tests if the tokens are of the right type.
   * For previous token, it checks if the sentence ends with a single letter.
   * For nextToken it checks if it is a single letter.
   * Checks if next token is followed by a full stop.
   *
   * @param {object} token The current token (must be a full stop).
   * @param {object} previousToken The token before the full stop.
   * @param {object} nextToken The token following the full stop.
   * @param {object} secondToNextToken The second token after the full stop.
   * @returns {boolean} True if a full stop is part of a person's initials, False if the full stop is not part of a person's initials.
   */
  isPartOfPersonInitial(token, previousToken, nextToken, secondToNextToken) {
    return !(0, _lodash.isUndefined)(token) && !(0, _lodash.isUndefined)(nextToken) && !(0, _lodash.isUndefined)(secondToNextToken) && !(0, _lodash.isUndefined)(previousToken) && token.type === "full-stop" && previousToken.type === "sentence" && lastCharacterPartOfInitialsRegex.test(previousToken.src) && nextToken.type === "sentence" && nextToken.src.trim().length === 1 && secondToNextToken.type === "full-stop";
  }

  /**
   * Tokens that represent a '<', followed by content until it enters another '<' or '>'
   * gets another pass by the tokenizer.
   *
   * @param {Object} token A token of type 'smaller-than-sign-content'.
   * @param {string[]} tokenSentences The current array of found sentences. Sentences may get added by this method.
   * @param {string} currentSentence The current sentence. Sentence parts may get appended by this method.
   * @returns {{tokenSentences, currentSentence}} The found sentences and the current sentence, appended when necessary.
   */
  tokenizeSmallerThanContent(token, tokenSentences, currentSentence) {
    /*
    	Remove the '<' from the text, to avoid matching this rule
    	recursively again and again.
    	We add it again later on.
    */
    const localText = token.src.substring(1);

    // Tokenize the current smaller-than-content token without the first '<'.
    const tokenizerResult = this.createTokenizer();
    this.tokenize(tokenizerResult.tokenizer, localText);
    const localSentences = this.getSentencesFromTokens(tokenizerResult.tokens, false);
    localSentences[0] = (0, _lodash.isUndefined)(localSentences[0]) ? "<" : "<" + localSentences[0];

    /*
     * When the first sentence has a valid sentence beginning.
     * Add the currently build sentence to the sentences.
     * Start building the next sentence.
     */
    if (this.isValidSentenceBeginning(localSentences[0])) {
      tokenSentences.push(currentSentence);
      currentSentence = "";
    }
    currentSentence += localSentences[0];
    if (localSentences.length > 1) {
      /*
      	There is a new sentence after the first,
      	add and reset the current sentence.
       */
      tokenSentences.push(currentSentence);
      currentSentence = "";

      // Remove the first sentence (we do not need to add it again).
      localSentences.shift();
      // Last sentence gets special treatment.
      const lastSentence = localSentences.pop();

      // Add the remaining found sentences.
      localSentences.forEach(sentence => {
        tokenSentences.push(sentence);
      });
      const sentenceEndRegex = new RegExp("[" + fullStop + this.getSentenceDelimiters() + "]$");

      // Check if the last sentence has a valid sentence ending.
      if (lastSentence.match(sentenceEndRegex)) {
        // If so, add it as a sentence.
        tokenSentences.push(lastSentence);
      } else {
        // If not, start making a new one.
        currentSentence = lastSentence;
      }
    }
    return {
      tokenSentences,
      currentSentence
    };
  }

  /**
   * Creates a tokenizer.
   *
   * @returns {Object} The tokenizer and the tokens.
   */
  createTokenizer() {
    const sentenceDelimiterRegex = new RegExp("^[" + this.getSentenceDelimiters() + "]$");
    const sentenceRegex = new RegExp("^[^" + fullStop + this.getSentenceDelimiters() + "<\\(\\)\\[\\]]+$");
    const tokens = [];
    const tokenizer = (0, _core.default)(function (token) {
      tokens.push(token);
    });
    tokenizer.addRule(fullStopRegex, "full-stop");
    tokenizer.addRule(smallerThanContentRegex, "smaller-than-sign-content");
    tokenizer.addRule(htmlStartRegex, "html-start");
    tokenizer.addRule(htmlEndRegex, "html-end");
    tokenizer.addRule(blockStartRegex, "block-start");
    tokenizer.addRule(blockEndRegex, "block-end");
    tokenizer.addRule(sentenceDelimiterRegex, "sentence-delimiter");
    tokenizer.addRule(sentenceRegex, "sentence");
    return {
      tokenizer,
      tokens
    };
  }

  /**
   * Tokenizes the given text using the given tokenizer.
   *
   * @param {Object} tokenizer The tokenizer to use.
   * @param {string} text The text to tokenize.
   * @returns {void}
   */
  tokenize(tokenizer, text) {
    tokenizer.onText(text);
    try {
      tokenizer.end();
    } catch (e) {
      console.error("Tokenizer end error:", e, e.tokenizer2);
    }
  }

  /**
   * Checks if a string ends with an abbreviation.
   * @param {string} currentSentence A (part of) a sentence.
   * @returns {boolean} True if the string ends with an abbreviation that is in abbreviations.js. Otherwise, False.
   */
  endsWithAbbreviation(currentSentence) {
    const matchedAbbreviations = currentSentence.match(abbreviationsRegex);
    if (!matchedAbbreviations) {
      return false;
    }
    const lastAbbreviation = matchedAbbreviations.pop();
    return currentSentence.endsWith(lastAbbreviation);
  }

  /**
   * Checks whether the given tokens are a valid html tag pair.
   * Note that this method is not a full html tag validator. It should be replaced with a better solution once the html parser is implemented.
   *
   * @param {object} firstToken   The first token to check. It is asserted that this token contains/is an opening html tag.
   * @param {object} lastToken    The last token to check. It is asserted that this token contains/is a closing html tag.
   *
   * @returns {boolean} True if the tokens are a valid html tag pair. Otherwise, False.
   */
  isValidTagPair(firstToken, lastToken) {
    const firstTokenText = firstToken.src;
    const lastTokenText = lastToken.src;

    // Get the tag types.
    const firstTagType = firstTokenText.match(tagTypeRegex)[1];
    const lastTagType = lastTokenText.match(tagTypeRegex)[1];

    // Check if the tags are the same and if they are a semantic tag (p, div, h1, h2, h3, h4, h5, h6, span).
    return firstTagType === lastTagType && semanticTags.includes(firstTagType);
  }

  /**
   * Returns an array of sentences for a given array of tokens, assumes that the text has already been split into blocks.
   *
   * @param {Object[]} tokenArray The tokens from the sentence tokenizer.
   * @param {boolean} [trimSentences=true] Whether to trim the sentences at the end or not.
   *
   * @returns {string[]} A list of sentences.
   */
  getSentencesFromTokens(tokenArray, trimSentences = true) {
    let tokenSentences = [],
      currentSentence = "",
      nextSentenceStart,
      sliced;

    // Drop the first and last HTML tag if both are present.
    do {
      sliced = false;
      const firstToken = tokenArray[0];
      const lastToken = tokenArray[tokenArray.length - 1];
      if (firstToken && lastToken && firstToken.type === "html-start" && lastToken.type === "html-end" && this.isValidTagPair(firstToken, lastToken)) {
        tokenArray = tokenArray.slice(1, tokenArray.length - 1);
        sliced = true;
      }
    } while (sliced && tokenArray.length > 1);
    tokenArray.forEach((token, i) => {
      let hasNextSentence, nextCharacters, tokenizeResults;
      const nextToken = tokenArray[i + 1];
      const previousToken = tokenArray[i - 1];
      const secondToNextToken = tokenArray[i + 2];
      nextCharacters = this.getNextTwoCharacters([nextToken, secondToNextToken]);

      // For a new sentence we need to check the next two characters.
      hasNextSentence = nextCharacters.length >= 2;
      nextSentenceStart = hasNextSentence ? nextCharacters[1] : "";
      switch (token.type) {
        case "html-start":
        case "html-end":
          if (this.isBreakTag(token.src)) {
            tokenSentences.push(currentSentence);
            currentSentence = "";
          } else {
            currentSentence += token.src;
          }
          break;
        case "smaller-than-sign-content":
          tokenizeResults = this.tokenizeSmallerThanContent(token, tokenSentences, currentSentence);
          tokenSentences = tokenizeResults.tokenSentences;
          currentSentence = tokenizeResults.currentSentence;
          break;
        case "sentence":
          currentSentence += token.src;
          break;
        case "sentence-delimiter":
          currentSentence += token.src;

          /*
              * Only split text into sentences if:
              * the next token is defined, AND
              * the next token type is neither "block-end" nor "sentence-delimiter", AND
              * the next token first character is a white space
             */
          if (!(0, _lodash.isUndefined)(nextToken) && "block-end" !== nextToken.type && "sentence-delimiter" !== nextToken.type && this.isCharacterASpace(nextToken.src[0])) {
            // Don't split on quotation marks unless they're preceded by a full stop.
            if (this.isQuotation(token.src) && previousToken && previousToken.src !== ".") {
              break;
            }
            /*
                   * Only split on ellipsis or quotation marks when:
                * a) There is a next sentence, and the next character is a valid sentence beginning preceded by a white space, OR
                * b) The next token is a sentence start
               */
            if (this.isQuotation(token.src) || token.src === "…") {
              currentSentence = this.getValidSentence(hasNextSentence, nextSentenceStart, nextCharacters, nextToken, tokenSentences, currentSentence);
            } else {
              tokenSentences.push(currentSentence);
              currentSentence = "";
            }
          }
          break;
        case "full-stop":
          currentSentence += token.src;
          nextCharacters = this.getNextTwoCharacters([nextToken, secondToNextToken]);

          // For a new sentence we need to check the next two characters.
          hasNextSentence = nextCharacters.length >= 2;
          nextSentenceStart = hasNextSentence ? nextCharacters[1] : "";

          // If the current sentence ends with an abbreviation, the full stop does not split the sentence.
          if (this.endsWithAbbreviation(currentSentence)) {
            break;
          }

          // It should not split the text if the first character of the potential next sentence is a number.
          if (hasNextSentence && this.isNumber(nextCharacters[0])) {
            break;
          }

          // If the full stop is part of a person's initials, don't split sentence.
          if (this.isPartOfPersonInitial(token, previousToken, nextToken, secondToNextToken)) {
            break;
          }

          // If the full stop is an ordinal dot (in German), then don't break the sentence.
          // This check should be done after  hasNextSentence && this.isNumber( nextCharacters[ 0 ] ) (above).
          // Because otherwise it could break before that test.
          if (this.endsWithOrdinalDot(currentSentence)) {
            break;
          }

          /*
           * Only split on full stop when:
           * a) There is a next sentence, and the next character is a valid sentence beginning preceded by a white space, OR
           * b) The next token is a sentence start
           */
          currentSentence = this.getValidSentence(hasNextSentence, nextSentenceStart, nextCharacters, nextToken, tokenSentences, currentSentence);
          break;
        case "block-start":
          currentSentence += token.src;
          break;
        case "block-end":
          currentSentence += token.src;
          nextCharacters = this.getNextTwoCharacters([nextToken, secondToNextToken]);

          // For a new sentence we need to check the next two characters.
          hasNextSentence = nextCharacters.length >= 2;
          nextSentenceStart = hasNextSentence ? nextCharacters[0] : "";

          /* Don't split if:
           * - The next character is a number. For example: IPv4-numbers.
           * - The block end is preceded by a valid sentence ending, but not followed by a valid sentence beginning.
           */
          if (hasNextSentence && this.isNumber(nextCharacters[0]) || this.isSentenceEnding(previousToken) && !(this.isValidSentenceBeginning(nextSentenceStart) || this.isSentenceStart(nextToken))) {
            break;
          }

          /*
           * Split if:
           * - The block end is preceded by a sentence ending and followed by a valid sentence beginning.
           */
          if (this.isSentenceEnding(previousToken) && (this.isSentenceStart(nextToken) || this.isValidSentenceBeginning(nextSentenceStart))) {
            tokenSentences.push(currentSentence);
            currentSentence = "";
          }
          break;
      }
    });
    if ("" !== currentSentence) {
      tokenSentences.push(currentSentence);
    }
    if (trimSentences) {
      tokenSentences = (0, _lodash.map)(tokenSentences, function (sentence) {
        return sentence.trim();
      });
    }
    return tokenSentences;
  }

  /**
   * Gets the current sentence when:
   * a) There is a next sentence, and the next character is a valid sentence beginning preceded by a white space, OR
   * b) The next token is a sentence start
   *
   * @param {boolean} hasNextSentence     Whether the next characters are more than two.
   * @param {string} nextSentenceStart    The second character of the next characters.
   * @param {string} nextCharacters       The string values of the next two tokens.
   * @param {object} nextToken            The next token object.
   * @param {array} tokenSentences        The array of pushed valid sentences.
   * @param {string} currentSentence      The current sentence.
   *
   * @returns {string} The current sentence.
   */
  getValidSentence(hasNextSentence, nextSentenceStart, nextCharacters, nextToken, tokenSentences, currentSentence) {
    if (hasNextSentence && this.isValidSentenceBeginning(nextSentenceStart) && this.isCharacterASpace(nextCharacters[0]) || this.isSentenceStart(nextToken)) {
      tokenSentences.push(currentSentence);
      currentSentence = "";
    }
    return currentSentence;
  }

  /**
   * Checks if the character is a whitespace.
   *
   * @param {string} character    The character to check.
   * @returns {boolean}   Whether the character is a whitespace.
   */
  isCharacterASpace(character) {
    return /\s/.test(character);
  }
}
exports["default"] = SentenceTokenizer;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/countSentences.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sentence/countSentences.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _getSentences = _interopRequireDefault(__webpack_require__(/*! ./getSentences.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentences.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module stringProcessing/countSentences */

/**
 * Counts the number of sentences in a given string.
 *
 * @param {string}      text                The text used to count sentences.
 * @param {function}    memoizedTokenizer   The memoized sentence tokenizer.
 *
 * @returns {number} The number of sentences in the text.
 */
function _default(text, memoizedTokenizer) {
  const sentences = (0, _getSentences.default)(text, memoizedTokenizer);
  let sentenceCount = 0;
  for (let i = 0; i < sentences.length; i++) {
    sentenceCount++;
  }
  return sentenceCount;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentences.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentences.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _html = __webpack_require__(/*! ../html/html.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/html.js");
var _imageInText = __webpack_require__(/*! ../image/imageInText */ "./node_modules/yoastseo/build/languageProcessing/helpers/image/imageInText.js");
var _stripHTMLTags = __webpack_require__(/*! ../sanitize/stripHTMLTags */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripHTMLTags.js");
var _unifyWhitespace = __webpack_require__(/*! ../sanitize/unifyWhitespace */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/unifyWhitespace.js");
var _memoizedSentenceTokenizer = _interopRequireDefault(__webpack_require__(/*! ./memoizedSentenceTokenizer */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/memoizedSentenceTokenizer.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
// Lodash imports.

// Internal dependencies.

// Character classes.
const newLines = "\n\r|\n|\r";

// Regular expressions.
const newLineRegex = new RegExp(newLines);
const paragraphTagsRegex = new RegExp("^(<p>|</p>)$");

/**
 * Returns sentences in a string.
 *
 * @param {String}      text                The string to count sentences in.
 * @param {function}    memoizedTokenizer   The memoized sentence tokenizer.
 *
 * @returns {Array} Sentences found in the text.
 */
function _default(text, memoizedTokenizer = _memoizedSentenceTokenizer.default) {
  // We don't remove the other HTML tags here since removing them might lead to incorrect results when running the sentence tokenizer.
  // Unify only non-breaking spaces and not the other whitespaces since a whitespace could signify a sentence break or a new line.
  text = (0, _unifyWhitespace.unifyNonBreakingSpace)(text);
  /*
   * Remove images from text before tokenizing it into sentences.
   * This is necessary since the highlighting feature doesn't work if the yoastmark tags are enclosing a sentence starting with an image.
   * This step is done here so that applying highlight in captions is possible for all assessments that use this helper.
   */
  text = text.replace(_imageInText.imageRegex, "");
  let blocks = (0, _html.getBlocks)(text);

  // Split each block on newlines.
  blocks = (0, _lodash.flatMap)(blocks, function (block) {
    return block.split(newLineRegex);
  });

  /*
   * Filter blocks that contain only paragraph tags. This step is necessary
   * since switching between editors might add extra paragraph tags with a new line tag in the end
   * that are incorrectly converted into separate blocks.
   */
  blocks = blocks.filter(block => !paragraphTagsRegex.test(block));

  /*
   * We use the `map` method followed by `flat` instead of `flatMap` because `flatMap` would override the second
   * argument of the memoizedTokenizer with the index of the iteratee.
   */
  let sentences = blocks.map(block => memoizedTokenizer(block)).flat();

  /*
   * Strip block tags from the start and/or the end of each sentence and whitespaces if present.
   * After tokenized, sometimes there are still block tags present in the beginning/end of a sentence.
   * Unstripped, these tags could potentially break the highlighting functionality.
   */
  sentences = sentences.map(sentence => (0, _stripHTMLTags.stripBlockTagsAtStartEnd)(sentence).trim());
  return (0, _lodash.filter)(sentences, (0, _lodash.negate)(_lodash.isEmpty));
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentencesFromTree.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentencesFromTree.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Retrieves the start offset for a given node.
 * @param {Node} node The current node.
 * @returns {number} The start offset.
 */
function getStartOffset(node) {
  return node.sourceCodeLocation && (node.sourceCodeLocation.startTag && node.sourceCodeLocation.startTag.endOffset || node.sourceCodeLocation.startOffset) || 0;
}

/**
 * Retrieves the parent node for a given node.
 * @param {Paper} 	paper 	The current paper.
 * @param {Node} 	node 	The current node.
 * @returns {Node} The parent node.
 */
function getParentNode(paper, node) {
  // Includes a fallback so that if a parent node cannot be found for an implicit paragraph, we use the current node as the parent node.
  return paper.getTree().findAll(treeNode => treeNode.childNodes && treeNode.childNodes.includes(node))[0] || node;
}

/**
 * Gets all the sentences from paragraph and heading nodes.
 * These two node types are the nodes that should contain sentences for the analysis.
 *
 * @param {Paper} paper The paper to get the sentences from.
 *
 * @returns {Sentence[]} The array of sentences retrieved from paragraph and heading nodes plus sourceCodeLocation of the parent node.
 */
function _default(paper) {
  // Get all nodes that have a sentence property which is not an empty array.
  const tree = paper.getTree().findAll(treeNode => !!treeNode.sentences);
  return tree.flatMap(node => node.sentences.map(sentence => {
    let parentNode = node;

    // For implicit paragraphs, base the details on the parent of this node.
    if (node.isImplicit) {
      parentNode = getParentNode(paper, node);
    }
    return {
      ...sentence,
      // The parent node's start offset is the start offset of the parent node if it doesn't have a `startTag` property.
      parentStartOffset: getStartOffset(parentNode),
      // The block client id of the parent node.
      parentClientId: parentNode.clientId || "",
      // The attribute id of the parent node, if available, otherwise an empty string.
      // Only used for position-based highlighting in sub-blocks of Yoast blocks.
      parentAttributeId: node.attributeId || "",
      // Whether the parent node is the first section of Yoast sub-blocks. Only used for position-based highlighting.
      isParentFirstSectionOfBlock: node.isFirstSection || false
    };
  }));
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/memoizedSentenceTokenizer.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sentence/memoizedSentenceTokenizer.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _SentenceTokenizer = _interopRequireDefault(__webpack_require__(/*! ./SentenceTokenizer */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/SentenceTokenizer.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Returns the sentences from a certain text.
 *
 * @param {string} text 					The text to retrieve sentences from.
 * @param {boolean} [trimSentences=true] 	Whether to trim whitespace from the beginning and end of the sentences or not.
 *
 * @returns {Array<string>} The list of sentences in the text.
 */
function getSentenceTokenizer(text, trimSentences = true) {
  const sentenceTokenizer = new _SentenceTokenizer.default();
  const {
    tokenizer,
    tokens
  } = sentenceTokenizer.createTokenizer();
  sentenceTokenizer.tokenize(tokenizer, text);
  return tokens.length === 0 ? [] : sentenceTokenizer.getSentencesFromTokens(tokens, trimSentences);
}

/*
 * The second argument to the memoize function is a so-called resolver function.
 * It creates a cache key consisting of a combination of all arguments to a function.
 * This is needed because by default, only the first argument to a function is used as the map cache key by the memoize function.
 * This means that a function is only re-run if the value of the first argument changes.
 * We want to re-run the getSentenceTokenizer function also when only the second argument changes to prevent cache collisions.
 * @see https://lodash.com/docs/4.17.15#memoize
 */
var _default = exports["default"] = (0, _lodash.memoize)(getSentenceTokenizer, (...args) => JSON.stringify(args));

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/sentencesLength.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/sentence/sentencesLength.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _countWords = _interopRequireDefault(__webpack_require__(/*! ../word/countWords.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/countWords.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _stripHTMLTags = __webpack_require__(/*! ../sanitize/stripHTMLTags.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripHTMLTags.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Returns an array with the length of each sentence.
 *
 * @param {Array} sentences Array with sentences from text.
 * @param {Researcher} 	researcher 	The researcher to use for analysis.
 *
 * @returns {Array} Array with the length of each sentence.
 */
function _default(sentences, researcher) {
  const sentencesWordCount = [];
  (0, _lodash.forEach)(sentences, function (sentence) {
    // For counting words we want to omit the HTMLtags.
    const strippedSentence = (0, _stripHTMLTags.stripFullTags)(sentence);
    // A helper to count characters for languages that don't count number of words for text length.
    const countCharacters = researcher.getHelper("customCountLength");
    const length = countCharacters ? countCharacters(strippedSentence) : (0, _countWords.default)(strippedSentence);
    if (length <= 0) {
      return;
    }
    sentencesWordCount.push({
      sentence: sentence,
      sentenceLength: length
    });
  });
  return sentencesWordCount;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/syllables/DeviationFragment.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/syllables/DeviationFragment.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Represents a partial deviation when counting syllables
 *
 * @param {Object} options Extra options about how to match this fragment.
 * @param {string} options.location The location in the word where this deviation can occur.
 * @param {string} options.word The actual string that should be counted differently.
 * @param {number} options.syllables The amount of syllables this fragment has.
 * @param {string[]} [options.notFollowedBy] A list of characters that this fragment shouldn't be followed with.
 * @param {string[]} [options.alsoFollowedBy] A list of characters that this fragment could be followed with.
 *
 * @constructor
 */
function DeviationFragment(options) {
  this._location = options.location;
  this._fragment = options.word;
  this._syllables = options.syllables;
  this._regex = null;
  this._options = (0, _lodash.pick)(options, ["notFollowedBy", "alsoFollowedBy"]);
}

/**
 * Creates a regex that matches this fragment inside a word.
 *
 * @returns {void}
 */
DeviationFragment.prototype.createRegex = function () {
  let regexString = "";
  const options = this._options;
  let fragment = this._fragment;
  if (!(0, _lodash.isUndefined)(options.notFollowedBy)) {
    fragment += "(?![" + options.notFollowedBy.join("") + "])";
  }
  if (!(0, _lodash.isUndefined)(options.alsoFollowedBy)) {
    fragment += "[" + options.alsoFollowedBy.join("") + "]?";
  }
  switch (this._location) {
    case "atBeginning":
      regexString = "^" + fragment;
      break;
    case "atEnd":
      regexString = fragment + "$";
      break;
    case "atBeginningOrEnd":
      regexString = "(^" + fragment + ")|(" + fragment + "$)";
      break;
    default:
      regexString = fragment;
      break;
  }
  this._regex = new RegExp(regexString);
};

/**
 * Returns the regex that matches this fragment inside a word.
 *
 * @returns {RegExp} The regexp that matches this fragment.
 */
DeviationFragment.prototype.getRegex = function () {
  if (null === this._regex) {
    this.createRegex();
  }
  return this._regex;
};

/**
 * Returns whether or not this fragment occurs in a word.
 *
 * @param {string} word The word to match the fragment in.
 * @returns {boolean} Whether or not this fragment occurs in a word.
 */
DeviationFragment.prototype.occursIn = function (word) {
  const regex = this.getRegex();
  return regex.test(word);
};

/**
 * Removes this fragment from the given word.
 *
 * @param {string} word The word to remove this fragment from.
 * @returns {string} The modified word.
 */
DeviationFragment.prototype.removeFrom = function (word) {
  // Replace by a space to keep the remaining parts separated.
  return word.replace(this._fragment, " ");
};

/**
 * Returns the amount of syllables for this fragment.
 *
 * @returns {number} The amount of syllables for this fragment.
 */
DeviationFragment.prototype.getSyllables = function () {
  return this._syllables;
};
var _default = exports["default"] = DeviationFragment;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/syllables/countSyllables.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/syllables/countSyllables.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _getWords = _interopRequireDefault(__webpack_require__(/*! ../word/getWords.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _syllableCountIterator = _interopRequireDefault(__webpack_require__(/*! ./syllableCountIterator.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/syllables/syllableCountIterator.js"));
var _DeviationFragment = _interopRequireDefault(__webpack_require__(/*! ./DeviationFragment */ "./node_modules/yoastseo/build/languageProcessing/helpers/syllables/DeviationFragment.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module stringProcessing/countSyllables */

/**
 * Counts vowel groups inside a word.
 *
 * @param {string} word         A text with words to count syllables.
 * @param {Object} syllables    The syllables data for the specific language.
 *
 * @returns {number} the syllable count.
 */
const countVowelGroups = function (word, syllables) {
  let numberOfSyllables = 0;
  const vowelRegex = new RegExp("[^" + syllables.vowels + "]", "ig");
  const foundVowels = word.split(vowelRegex);
  const filteredWords = (0, _lodash.filter)(foundVowels, function (vowel) {
    return vowel !== "";
  });
  numberOfSyllables += filteredWords.length;
  return numberOfSyllables;
};

/**
 * Counts the syllables using vowel exclusions. These are used for groups of vowels that are more or less
 * than 1 syllable.
 *
 * @param {String} word         The word to count syllables of.
 * @param {Object} syllables    The syllables data for the specific language.
 *
 * @returns {number} The number of syllables found in the given word.
 */
const countVowelDeviations = function (word, syllables) {
  const syllableCountIterator = new _syllableCountIterator.default(syllables);
  return syllableCountIterator.countSyllables(word);
};

/**
 * Returns the number of syllables for the word if it is in the list of full word deviations.
 *
 * @param {String} word         The word to retrieve the syllables for.
 * @param {Object} syllables    The syllables data for the specific language.
 *
 * @returns {number} The number of syllables found.
 */
const countFullWordDeviations = function (word, syllables) {
  const fullWordDeviations = syllables.deviations.words.full;
  const deviation = (0, _lodash.find)(fullWordDeviations, function (fullWordDeviation) {
    return fullWordDeviation.word === word;
  });
  if (!(0, _lodash.isUndefined)(deviation)) {
    return deviation.syllables;
  }
  return 0;
};

/**
 * Creates an array of deviation fragments for a certain locale.
 *
 * @param {Object} syllableConfig Syllable config for a certain locale.
 * @returns {DeviationFragment[]} A list of deviation fragments
 */
function createDeviationFragments(syllableConfig) {
  let deviationFragments = [];
  const deviations = syllableConfig.deviations;
  deviationFragments = (0, _lodash.flatMap)(deviations.words.fragments, function (fragments, fragmentLocation) {
    return (0, _lodash.map)(fragments, function (fragment) {
      fragment.location = fragmentLocation;
      return new _DeviationFragment.default(fragment);
    });
  });
  return deviationFragments;
}
const createDeviationFragmentsMemoized = (0, _lodash.memoize)(createDeviationFragments);

/**
 * Counts syllables in partial exclusions. If these are found, returns the number of syllables found, and the modified word.
 * The word is modified so the excluded part isn't counted by the normal syllable counter.
 *
 * @param {String} word 		The word to count syllables of.
 * @param {Object} syllables    The syllables data for the specific language.
 *
 * @returns {object} The number of syllables found and the modified word.
 */
const countPartialWordDeviations = function (word, syllables) {
  const deviationFragments = createDeviationFragmentsMemoized(syllables);
  let remainingParts = word;
  let syllableCount = 0;
  (0, _lodash.forEach)(deviationFragments, function (deviationFragment) {
    if (deviationFragment.occursIn(remainingParts)) {
      remainingParts = deviationFragment.removeFrom(remainingParts);
      syllableCount += deviationFragment.getSyllables();
    }
  });
  return {
    word: remainingParts,
    syllableCount: syllableCount
  };
};

/**
 * Count the number of syllables in a word, using vowels and exceptions.
 *
 * @param {String} word         The word to count the number of syllables of.
 * @param {Object} syllables    The syllables data for the specific language.
 *
 * @returns {number} The number of syllables found in a word.
 */
const countUsingVowels = function (word, syllables) {
  let syllableCount = 0;
  syllableCount += countVowelGroups(word, syllables);
  if (!(0, _lodash.isUndefined)(syllables.deviations) && !(0, _lodash.isUndefined)(syllables.deviations.vowels)) {
    syllableCount += countVowelDeviations(word, syllables);
  }
  return syllableCount;
};

/**
 * Counts the number of syllables in a word.
 *
 * @param {string} word         The word to count syllables of.
 * @param {Object} syllables    The syllables data for the specific language.
 *
 * @returns {number} The syllable count for the word.
 */
const countSyllablesInWord = function (word, syllables) {
  let syllableCount = 0;
  if (!(0, _lodash.isUndefined)(syllables.deviations) && !(0, _lodash.isUndefined)(syllables.deviations.words)) {
    if (!(0, _lodash.isUndefined)(syllables.deviations.words.full)) {
      const fullWordExclusion = countFullWordDeviations(word, syllables);
      if (fullWordExclusion !== 0) {
        return fullWordExclusion;
      }
    }
    if (!(0, _lodash.isUndefined)(syllables.deviations.words.fragments)) {
      const partialExclusions = countPartialWordDeviations(word, syllables);
      word = partialExclusions.word;
      syllableCount += partialExclusions.syllableCount;
    }
  }
  syllableCount += countUsingVowels(word, syllables);
  return syllableCount;
};

/**
 * Counts the number of syllables in a text per word based on vowels.
 * Uses exclusion words for words that cannot be matched with vowel matching.
 *
 * @param {String} text         The text to count the syllables of.
 * @param {Object} syllables    The syllables data for the specific language.
 *
 * @returns {int} The total number of syllables found in the text.
 */
const countSyllablesInText = function (text, syllables) {
  text = text.toLocaleLowerCase();
  const words = (0, _getWords.default)(text);
  const syllableCounts = (0, _lodash.map)(words, function (word) {
    return countSyllablesInWord(word, syllables);
  });
  return (0, _lodash.sum)(syllableCounts);
};
var _default = exports["default"] = countSyllablesInText;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/syllables/syllableCountIterator.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/syllables/syllableCountIterator.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _syllableCountStep = _interopRequireDefault(__webpack_require__(/*! ./syllableCountStep.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/syllables/syllableCountStep.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Creates a syllable count iterator.
 *
 * @param {object} config The config object containing an array with syllable exclusions.
 * @constructor
 */
const SyllableCountIterator = function (config) {
  this.countSteps = [];
  if (!(0, _lodash.isUndefined)(config)) {
    this.createSyllableCountSteps(config.deviations.vowels);
  }
};

/**
 * Creates a syllable count step object for each exclusion.
 *
 * @param {object} syllableCounts The object containing all exclusion syllables including the multipliers.
 * @returns {void}
 */
SyllableCountIterator.prototype.createSyllableCountSteps = function (syllableCounts) {
  (0, _lodash.forEach)(syllableCounts, function (syllableCountStep) {
    this.countSteps.push(new _syllableCountStep.default(syllableCountStep));
  }.bind(this));
};

/**
 * Returns all available count steps.
 *
 * @returns {Array} All available count steps.
 */
SyllableCountIterator.prototype.getAvailableSyllableCountSteps = function () {
  return this.countSteps;
};

/**
 * Counts the syllables for all the steps and returns the total syllable count.
 *
 * @param {String} word The word to count syllables in.
 * @returns {number} The number of syllables found based on exclusions.
 */
SyllableCountIterator.prototype.countSyllables = function (word) {
  let syllableCount = 0;
  (0, _lodash.forEach)(this.countSteps, function (step) {
    syllableCount += step.countSyllables(word);
  });
  return syllableCount;
};
var _default = exports["default"] = SyllableCountIterator;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/syllables/syllableCountStep.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/syllables/syllableCountStep.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _createRegexFromArray = _interopRequireDefault(__webpack_require__(/*! ../regex/createRegexFromArray.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/regex/createRegexFromArray.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Constructs a language syllable regex that contains a regex for matching syllable exclusion.
 *
 * @param {object} syllableRegex The object containing the syllable exclusions.
 * @constructor
 */
const SyllableCountStep = function (syllableRegex) {
  this._hasRegex = false;
  this._regex = "";
  this._multiplier = "";
  this.createRegex(syllableRegex);
};

/**
 * Returns if a valid regex has been set.
 *
 * @returns {boolean} True if a regex has been set, false if not.
 */
SyllableCountStep.prototype.hasRegex = function () {
  return this._hasRegex;
};

/**
 * Creates a regex based on the given syllable exclusions, and sets the multiplier to use.
 *
 * @param {object} syllableRegex The object containing the syllable exclusions and multiplier.
 * @returns {void}
 */
SyllableCountStep.prototype.createRegex = function (syllableRegex) {
  if (!(0, _lodash.isUndefined)(syllableRegex) && !(0, _lodash.isUndefined)(syllableRegex.fragments)) {
    this._hasRegex = true;
    this._regex = (0, _createRegexFromArray.default)(syllableRegex.fragments, true);
    this._multiplier = syllableRegex.countModifier;
  }
};

/**
 * Returns the stored regular expression.
 *
 * @returns {RegExp} The stored regular expression.
 */
SyllableCountStep.prototype.getRegex = function () {
  return this._regex;
};

/**
 * Matches syllable exclusions in a given word and the returns the number found multiplied with the
 * given multiplier.
 *
 * @param {String} word The word to match for syllable exclusions.
 * @returns {number} The amount of syllables found.
 */
SyllableCountStep.prototype.countSyllables = function (word) {
  if (this._hasRegex) {
    const match = word.match(this._regex) || [];
    return match.length * this._multiplier;
  }
  return 0;
};
var _default = exports["default"] = SyllableCountStep;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/transform/transformWordsWithHyphens.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/transform/transformWordsWithHyphens.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Splits words from an array that contain hyphens and adds the elements to the array if they are not yet there.
 *
 * @param {Array} array The array to check and modify.
 *
 * @returns {Array} A new array with the elements containing hyphens split.
 */
function _default(array) {
  let newArray = array;
  array.forEach(element => {
    element = element.split("-");
    if (element.length > 0 && element.filter(unit => !array.includes(unit)).length > 0) {
      newArray = newArray.concat(element);
    }
  });
  return newArray;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/transliterate/replaceDiacritics.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/transliterate/replaceDiacritics.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _diacritics = _interopRequireDefault(__webpack_require__(/*! ../../../config/diacritics.js */ "./node_modules/yoastseo/build/config/diacritics.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module stringProcessing/replaceDiacritics */

/**
 * Replaces all diacritics from the text based on the diacritics removal map.
 *
 * @param {string} text The text to remove diacritics from.
 *
 * @returns {string} The text with all diacritics replaced.
 */
function _default(text) {
  const map = (0, _diacritics.default)();
  for (let i = 0; i < map.length; i++) {
    text = text.replace(map[i].letters, map[i].base);
  }
  return text;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/transliterate/specialCharacterMappings.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/transliterate/specialCharacterMappings.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.arraysDifference = arraysDifference;
exports.arraysOverlap = arraysOverlap;
exports.combinations = combinations;
exports.getIndicesOfCharacter = getIndicesOfCharacter;
exports.getIndicesOfWords = getIndicesOfWords;
exports.replaceTurkishIs = replaceTurkishIs;
exports.replaceTurkishIsMemoized = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _getWords = _interopRequireDefault(__webpack_require__(/*! ../word/getWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Gets positions of the first character of a word in the input text.
 *
 * @param {string} text The original text, for which the indices of word beginnings need to be determined.
 *
 * @returns {Array} indices The array of indices in the text at which words start.
 */
function getIndicesOfWords(text) {
  const indices = [];
  const words = (0, _getWords.default)(text);
  let startSearchFrom = 0;
  words.forEach(function (word) {
    const currentIndex = text.indexOf(word, startSearchFrom);
    indices.push(currentIndex);
    startSearchFrom = currentIndex + word.length;
  });
  return indices;
}

/**
 * Gets indices of a specific character in the input text.
 *
 * @param {string} text             The original text, for which the indices of specific characters have to be determined.
 * @param {string} characterToFind  The character that needs to be found in the text.
 *
 * @returns {Array} indices The array of indices in the text at which the characterToFind occurs.
 */
function getIndicesOfCharacter(text, characterToFind) {
  const indices = [];
  if (text.indexOf(characterToFind) > -1) {
    for (let i = 0; i < text.length; i++) {
      if (text[i] === characterToFind) {
        indices.push(i);
      }
    }
  }
  return indices;
}

/**
 * Compares two arrays of which the second array is the sub-array of the first array.
 * Returns the array of elements of the first array which are not in the second array.
 *
 * @param {Array} bigArray The array with all elements.
 * @param {Array} subarray The array with some elements from the bigArray.
 *
 * @returns {Array} difference An array of all elements of bigArray which are not in subarray.
 */
function arraysDifference(bigArray, subarray) {
  return (0, _lodash.filter)(bigArray, function (element) {
    return !(0, _lodash.includes)(subarray, element);
  });
}

/**
 * Compares two arrays and returns the array of elements that occur in both arrays.
 *
 * @param {Array} firstArray    The first array with elements to compare.
 * @param {Array} secondArray   The second array with elements to compare.
 *
 * @returns {Array} overlap An array of all elements of firstArray which are also in secondArray.
 */
function arraysOverlap(firstArray, secondArray) {
  return (0, _lodash.filter)(firstArray, function (element) {
    return (0, _lodash.includes)(secondArray, element);
  });
}

/**
 * Generates all possible combinations of the elements of an array (treated as unique).
 * https://gist.github.com/jpillora/4435759
 *
 * @param {Array} collection The array with elements that should be combined.
 *
 * @returns {Array} result An array of all possible combinations of elements of the original array.
 */
function combinations(collection) {
  /**
   * A recursive function that iterates through all elements of an array to produce its combinations.
   *
   * @param {Array} xs        The array to start accumulating with.
   * @param {Array} array     The array with elements that should be combined.
   *
   * @returns {Array} result An array of all possible combinations of elements of the original array.
   */
  function acc(xs, array) {
    const x = xs[0];
    if (typeof x === "undefined") {
      return array;
    }
    for (let i = 0, l = array.length; i < l; ++i) {
      array.push(array[i].concat(x));
    }
    return acc(xs.slice(1), array);
  }
  return acc(collection, [[]]).slice(1).concat([[]]);
}

/**
 * Replaces characters on specified indices in the input text.
 *
 * @param {string} text         The original text, for which the characters have to be substituted.
 * @param {Array} indices       The array of indices that have to be substituted.
 * @param {string} substitute   The character that is used to substitute in the text.
 *
 * @returns {string} result The string of the original text with the characters on specified indices are substituted with the substitute character.
 */
function replaceCharactersByIndex(text, indices, substitute) {
  const modifiedTextSplitByLetter = text.split("");
  indices.forEach(function (index) {
    modifiedTextSplitByLetter.splice(index, 1, substitute);
  });
  return modifiedTextSplitByLetter.join("");
}

/**
 * Generates upper and lower case for Turkish strings that contain characters İ or ı, which appear to not be processed correctly by regexes.
 *
 * @param {string} text The text to build possible upper and lower case alternatives.
 *
 * @returns {Array} An array of strings that contains all possible upper and lower case alternatives of the original string
 */
function replaceTurkishIs(text) {
  // Get indices of all occurrences of İ, I, i, or ı.
  const indicesOfAllIs = getIndicesOfCharacter(text, "İ").concat(getIndicesOfCharacter(text, "I"), getIndicesOfCharacter(text, "i"), getIndicesOfCharacter(text, "ı"));
  indicesOfAllIs.sort();

  // If there are no Is return the text
  if (indicesOfAllIs.length === 0) {
    return [text];
  }
  const indicesOfIsInWordBeginnings = arraysOverlap(getIndicesOfWords(text), indicesOfAllIs);
  const results = [];

  // First round of creating combinations: assign which indices will be replaced by İ
  const combinationsDottedI = combinations(indicesOfIsInWordBeginnings);
  combinationsDottedI.forEach(function (oneCombinationDottedI) {
    // If the combination is full array, just add it to results immediately without going through the rest of iterations.
    if ((0, _lodash.isEqual)(oneCombinationDottedI, indicesOfIsInWordBeginnings)) {
      results.push([oneCombinationDottedI, [], [], []]);
    } else {
      const indicesNotDottedI = arraysDifference(indicesOfIsInWordBeginnings, oneCombinationDottedI);

      // Second round of creating combinations: assign which indices will be replaced by I
      const combinationsDotlessI = combinations(indicesNotDottedI);
      combinationsDotlessI.forEach(function (oneCombinationDotlessI) {
        // If the combination is full array, just add it to results immediately without going through the rest of iterations.
        if ((0, _lodash.isEqual)(oneCombinationDotlessI, indicesNotDottedI)) {
          results.push([oneCombinationDottedI, oneCombinationDotlessI, [], []]);
        } else {
          const indicesSmalli = arraysDifference(indicesNotDottedI, oneCombinationDotlessI);

          // Third round of creating combinations: assign which indices will be replaced by i
          const combinationsDottedi = combinations(indicesSmalli);
          combinationsDottedi.forEach(function (oneCombinationDottedi) {
            // If the combination is full array, just add it to results immediately without going through the rest of iterations.
            if ((0, _lodash.isEqual)(oneCombinationDottedi, indicesSmalli)) {
              results.push([oneCombinationDottedI, oneCombinationDotlessI, oneCombinationDottedi, []]);
            } else {
              const oneCombinationDotlessi = arraysDifference(indicesSmalli, oneCombinationDottedi);
              results.push([oneCombinationDottedI, oneCombinationDotlessI, oneCombinationDottedi, oneCombinationDotlessi]);
            }
          });
        }
      });
    }
  });
  const textAlternations = [];
  results.forEach(function (result) {
    const toDottedI = replaceCharactersByIndex(text, result[0], "İ");
    const toDotlessI = replaceCharactersByIndex(toDottedI, result[1], "I");
    const toDottedi = replaceCharactersByIndex(toDotlessI, result[2], "i");
    const toDotlessi = replaceCharactersByIndex(toDottedi, result[3], "ı");
    textAlternations.push(toDotlessi);
  });
  return textAlternations;
}
const replaceTurkishIsMemoized = exports.replaceTurkishIsMemoized = (0, _lodash.memoize)(replaceTurkishIs);

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/transliterate/transliterate.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/transliterate/transliterate.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _getTransliterations = _interopRequireDefault(__webpack_require__(/*! ../../../config/getTransliterations.js */ "./node_modules/yoastseo/build/config/getTransliterations.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Replaces all special characters from the text based on the transliterations map.
 *
 * @param {string} text     The text to remove special characters from.
 * @param {string} locale   The locale.
 *
 * @returns {string} The text with all special characters replaced.
 */
function _default(text, locale) {
  const map = (0, _getTransliterations.default)(locale);
  for (let i = 0; i < map.length; i++) {
    text = text.replace(map[i].letter, map[i].alternative);
  }
  return text;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/transliterate/transliterateWPstyle.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/transliterate/transliterateWPstyle.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _transliterationsWPstyle = _interopRequireDefault(__webpack_require__(/*! ../../../config/transliterationsWPstyle.js */ "./node_modules/yoastseo/build/config/transliterationsWPstyle.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Replaces all special characters from the text based on the transliterations map specific for WP
 * (and different from the one used by YoastSEO.js).
 *
 * @param {string} text     The text to remove special characters from.
 * @param {string} locale   The locale.
 *
 * @returns {string} The text with all special characters replaced.
 */
function _default(text, locale) {
  const map = (0, _transliterationsWPstyle.default)(locale);
  for (let i = map.length - 1; i >= 0; i--) {
    text = text.replace(map[i].letter, map[i].alternative);
  }
  return text;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/url/parseSlug.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/url/parseSlug.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Parses the slug by transforming hyphens and underscores into white space.
 *
 * @param {string} slug The slug to parse
 *
 * @returns {string} The parsed slug.
 */
function _default(slug) {
  return slug.replace(/[-_]/ig, " ");
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/url/url.js":
/*!***************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/url/url.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _url = _interopRequireDefault(__webpack_require__(/*! url */ "./node_modules/url/url.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const urlFromAnchorRegex = /href=(["'])([^"']+)\1/i;
/**
 * Removes a hash from a URL, assumes a well formed URL.
 *
 * @param {string} url The URL to remove a hash from.
 * @returns {string} The URL without the hash.
 */
function removeHash(url) {
  return url.split("#")[0];
}

/**
 * Removes all query args from a URL, assumes a well formed URL.
 *
 * @param {string} url The URL to remove the query args from.
 * @returns {string} The URL without the query args.
 */
function removeQueryArgs(url) {
  return url.split("?")[0];
}

/**
 * Removes the trailing slash of a URL.
 *
 * @param {string} url The URL to remove the trailing slash from.
 * @returns {string} A URL without a trailing slash.
 */
function removeTrailingSlash(url) {
  return url.replace(/\/$/, "");
}

/**
 * Adds a trailing slash to a URL if it is not present.
 *
 * @param {string} url The URL to add a trailing slash to.
 * @returns {string} A URL with a trailing slash.
 */
function addTrailingSlash(url) {
  return removeTrailingSlash(url) + "/";
}

/**
 * Retrieves the URL from an anchor tag.
 *
 * @param {string} anchorTag An anchor tag.
 * @returns {string} The URL in the anchor tag.
 */
function getFromAnchorTag(anchorTag) {
  const urlMatch = urlFromAnchorRegex.exec(anchorTag);
  return urlMatch === null ? "" : urlMatch[2];
}

/**
 * Returns whether or not the given URLs are equal.
 *
 * @param {string} urlA The first URL to compare.
 * @param {string} urlB The second URL to compare.
 *
 * @returns {boolean} Whether or not the given URLs are equal.
 */
function areEqual(urlA, urlB) {
  // Make sure we are comparing URLs without query arguments and hashes.
  urlA = removeQueryArgs(removeHash(urlA));
  urlB = removeQueryArgs(removeHash(urlB));
  return addTrailingSlash(urlA) === addTrailingSlash(urlB);
}

/**
 * Returns the domain name of a URL.
 *
 * @param {string} url The URL to retrieve the domain name of.
 * @returns {string} The domain name of the URL.
 */
function getHostname(url) {
  url = _url.default.parse(url);
  return url.hostname;
}

/**
 * Returns the protocol of a URL.
 *
 * Note that the colon (http:) is also part of the protocol, conform to node's url.parse api.
 *
 * @param {string} url The URL to retrieve the protocol of.
 * @returns {string|null} The protocol of the URL or null if no protocol is present.
 */
function getProtocol(url) {
  return _url.default.parse(url).protocol;
}

/**
 * Determine whether an anchor URL is internal.
 *
 * @param {string} anchorUrl 		The anchor URL to test.
 * @param {string} siteUrlOrDomain  The current site's URL or domain.
 *
 * @returns {boolean} Whether or not the anchor URL is internal.
 */
function isInternalLink(anchorUrl, siteUrlOrDomain) {
  const parsedAnchorUrl = _url.default.parse(anchorUrl, false, true);
  const anchorUrlHostName = parsedAnchorUrl.hostname;

  // Check if the anchor URL starts with a single slash.
  if (anchorUrl.indexOf("//") === -1 && anchorUrl.indexOf("/") === 0) {
    return true;
  }

  // Check if the anchor URL starts with a # indicating a fragment.
  if (anchorUrl.indexOf("#") === 0) {
    return false;
  }

  // No host of the anchor URL indicates an internal link.
  if (!anchorUrlHostName) {
    return true;
  }

  // If the siteUrlOrDomain variable is a domain, it would be idential to the anchor URL's hostname in case of an internal link.
  if (anchorUrlHostName === siteUrlOrDomain) {
    return true;
  }

  // If the siteUrlOrDomain variable is a URL and it shares the hostname with the anchor URL, it's an internal link.
  const parsedSiteUrlOrDomain = _url.default.parse(siteUrlOrDomain);
  const siteUrlOrDomainHostName = parsedSiteUrlOrDomain.hostname;
  return anchorUrlHostName === siteUrlOrDomainHostName;
}

/**
 * Checks whether the protocol is either HTTP: or HTTPS:.
 *
 * @param {string} protocol The protocol to test.
 *
 * @returns {boolean} Whether the protocol is http(s):.
 */
function protocolIsHttpScheme(protocol) {
  if (!protocol) {
    return false;
  }
  return protocol === "http:" || protocol === "https:";
}

/**
 * Determines whether the link is a relative fragment URL.
 *
 * @param {string} url The URL to test.
 *
 * @returns {boolean} Whether the link is a relative fragment URL.
 */
function isRelativeFragmentURL(url) {
  return url.indexOf("#") === 0;
}
var _default = exports["default"] = {
  removeHash: removeHash,
  removeQueryArgs: removeQueryArgs,
  removeTrailingSlash: removeTrailingSlash,
  addTrailingSlash: addTrailingSlash,
  getFromAnchorTag: getFromAnchorTag,
  areEqual: areEqual,
  getHostname: getHostname,
  getProtocol: getProtocol,
  isInternalLink: isInternalLink,
  protocolIsHttpScheme: protocolIsHttpScheme,
  isRelativeFragmentURL: isRelativeFragmentURL
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/word/addWordboundary.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/word/addWordboundary.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Returns a string that can be used in a regex to match a matchString with word boundaries.
 *
 * @param {string}  matchString                 The string to generate a regex string for.
 * @param {boolean} [positiveLookAhead=false]   Boolean indicating whether or not to include a positive look ahead
 * for the word boundaries at the end.
 * @param {string} [extraWordBoundary=""]       Extra characters to match a word boundary on.
 * @param {string} [language=""]                The language used to determine the word boundary.
 *
 * @returns {string} A regex string that matches the matchString with word boundaries.
 */
function _default(matchString, positiveLookAhead = false, extraWordBoundary = "", language = "") {
  let wordBoundary, wordBoundaryEnd;
  if (language === "id") {
    wordBoundary = "[ \\u00a0\\n\\r\\t.,()”“〝〞〟‟„\"+;!¡?¿:/»«‹›" + extraWordBoundary + "<>";
  } else {
    /*
     * \u00a0 - no-break space
     * \u2014 - em dash
           * \u06d4 - Urdu full stop
           * \u061f - Arabic question mark
           * \u060C - Arabic comma
           * \u061B - Arabic semicolon
           */
    wordBoundary = "[ \\u00a0\\u2014\\u06d4\\u061f\\u060C\\u061B\\n\\r\\t.,()”“〝〞〟‟„\"+\\-;!¡?¿:/»«‹›" + extraWordBoundary + "<>";
  }
  const wordBoundaryStart = "(^|" + wordBoundary + "'‘’‛`])";
  if (positiveLookAhead) {
    wordBoundaryEnd = "($|((?=" + wordBoundary + "]))|((['‘’‛`])(" + wordBoundary + "])))";
  } else {
    wordBoundaryEnd = "($|(" + wordBoundary + "])|((['‘’‛`])(" + wordBoundary + "])))";
  }
  return wordBoundaryStart + matchString + wordBoundaryEnd;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/word/areWordsInSentence.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/word/areWordsInSentence.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = areWordsInSentence;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _getWords = _interopRequireDefault(__webpack_require__(/*! ./getWords.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Checks if one or more words of a list occur in a sentence.
 *
 * @param {Array} words The list of words.
 * @param {string} sentence The sentence to match against.
 * @returns {Boolean} Whether the sentence contains the word.
 */
function areWordsInSentence(words, sentence) {
  const matches = (0, _lodash.filter)((0, _getWords.default)(sentence), function (word) {
    return words.includes(word.toLocaleLowerCase());
  });
  return matches.length !== 0;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/word/countMetaDescriptionLength.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/word/countMetaDescriptionLength.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Check the length of the description.
 *
 * @param {string}  date          The date.
 * @param {string}  description   The meta description.
 *
 * @returns {number} The length of the description.
 */
function _default(date, description) {
  let descriptionLength = description.length;
  /* If the meta description is preceded by a date, two spaces and a hyphen (" - ") are added as well. Therefore,
  three needs to be added to the total length. */
  if (date !== "" && descriptionLength > 0) {
    descriptionLength += date.length + 3;
  }
  return descriptionLength;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/word/countWords.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/word/countWords.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _getWords = _interopRequireDefault(__webpack_require__(/*! ./getWords.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module stringProcessing/countWords */

/**
 * Calculates the word count of a certain text.
 *
 * @param {string} text The text to be counted.
 *
 * @returns {number} The word count of the given text.
 */
function _default(text) {
  return (0, _getWords.default)(text).length;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/word/createPunctuationTokens.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/word/createPunctuationTokens.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _removePunctuation = __webpack_require__(/*! ../sanitize/removePunctuation */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removePunctuation.js");
var _htmlEntities = __webpack_require__(/*! ../../../helpers/htmlEntities */ "./node_modules/yoastseo/build/helpers/htmlEntities.js");
/**
 * Removes punctuation from the beginning and end of a word token, and creates separate tokens from them.
 *
 * @param {string[]} rawTokens	The tokens that may contain punctuation at the beginning and end of words.
 *
 * @returns {string[]} The tokens with the punctuation moved into separate tokens.
 */
const createPunctuationTokens = rawTokens => {
  const tokenTexts = [];
  rawTokens.forEach(token => {
    // Pretokens contains all that occurs before the first letter of the token.
    const preTokens = [];
    // Posttokens contains all that occurs after the last letter of the token.
    const postTokens = [];

    // Add all punctuation marks that occur before the first letter of the token to the pretokens array.
    // Also, prevent matching with a hashed HTML entity in the beginning of the token.
    while (_removePunctuation.punctuationRegexStart.test(token) && !_htmlEntities.hashedHtmlEntitiesRegexStart.test(token)) {
      preTokens.push(token[0]);
      token = token.slice(1);
    }
    // Add all punctuation marks that occur after the last letter of the token to the posttokens array.
    // Also, prevent matching with a hashed HTML entity at the end of the token.
    while (_removePunctuation.punctuationRegexEnd.test(token) && !_htmlEntities.hashedHtmlEntitiesRegexEnd.test(token)) {
      // Using unshift here because we are iterating from the end of the string to the beginning,
      // and we want to keep the order of the punctuation marks.
      // Therefore, we add them to the start of the array.
      postTokens.unshift(token[token.length - 1]);
      token = token.slice(0, -1);
    }
    let currentTokens = [...preTokens, token, ...postTokens];
    currentTokens = currentTokens.filter(x => x !== "");
    tokenTexts.push(...currentTokens);
  });
  return tokenTexts;
};
var _default = exports["default"] = createPunctuationTokens;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/word/filterWordsFromArray.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/word/filterWordsFromArray.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = filterWordsFromArray;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Filters certain words from an array of words.
 *
 * @param {Array} array The words to check.
 * @param {Array} words The words to filter.
 *
 * @returns {Array} The original array with the certain words filtered out.
 */
function filterWordsFromArray(array, words = []) {
  return (0, _lodash.filter)(array, function (word) {
    return !(0, _lodash.includes)(words, word.trim().toLocaleLowerCase());
  });
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/word/followsIndex.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/word/followsIndex.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Checks whether a given word is followed by any word from a given list.
 *
 * @param {Array} followingWords    The array of objects with matches and indices.
 * @param {Object} match            The object with the match and index to test the following words for.
 *
 * @returns {boolean} Returns true if the match is followed by a given word, otherwise returns false.
 */
function _default(followingWords, match) {
  if ((0, _lodash.isEmpty)(followingWords)) {
    return false;
  }

  // The followingWordIndices include the preceding space.
  const wordAfterMatchIndex = match.index + match.match.length;
  const followingWordsIndices = [];
  (0, _lodash.forEach)(followingWords, function (followingWord) {
    followingWordsIndices.push(followingWord.index);
  });
  return (0, _lodash.includes)(followingWordsIndices, wordAfterMatchIndex);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getAllWordsFromTree.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/word/getAllWordsFromTree.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _getSentencesFromTree = _interopRequireDefault(__webpack_require__(/*! ../sentence/getSentencesFromTree */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentencesFromTree.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _removePunctuation = _interopRequireDefault(__webpack_require__(/*! ../sanitize/removePunctuation */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removePunctuation.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Gets the words from the tree, i.e. from the paragraph and heading nodes.
 * These two node types are the nodes that should contain words for the analysis.
 *
 * @param {Paper} paper The paper to get the tree and words from.
 *
 * @returns {String[]} Array of words retrieved from the tree.
 */
function _default(paper) {
  const sentences = (0, _getSentencesFromTree.default)(paper);
  // Get all the tokens from each sentence.
  const tokens = sentences.map(sentence => sentence.tokens);
  let words = (0, _lodash.flatMap)(tokens).map(token => token.text);
  // Remove punctuation and spaces.
  words = words.map(token => (0, _removePunctuation.default)(token));

  // Filter out empty tokens.
  return words.filter(word => word.trim() !== "");
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _sanitizeString = _interopRequireDefault(__webpack_require__(/*! ../sanitize/sanitizeString */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/sanitizeString.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _removePunctuation = _interopRequireWildcard(__webpack_require__(/*! ../sanitize/removePunctuation.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removePunctuation.js"));
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function (e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != typeof e && "function" != typeof e) return {
    default: e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n.default = e, t && t.set(e, n), n;
}
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module stringProcessing/countWords */

const punctuationRegex = new RegExp(`([${_removePunctuation.punctuationRegexString}])`, "g");

/**
 * Returns an array with words used in the text.
 *
 * @param {string} text The text to be counted.
 * @param {string} [wordBoundaryRegexString=\\s] The regex string for the word boundary that should be used to split the text into words.
 * @param {boolean} [shouldRemovePunctuation=true] If punctuation should be removed. Defaults to `true`.
 *
 * @returns {Array} The array with all words.
 */
function _default(text, wordBoundaryRegexString = "\\s", shouldRemovePunctuation = true) {
  // Unify whitespaces and non-breaking spaces, remove table of content and strip the tags and multiple spaces.
  text = (0, _sanitizeString.default)(text);
  if (text === "") {
    return [];
  }
  const wordBoundaryRegex = new RegExp(wordBoundaryRegexString, "g");
  let words = text.split(wordBoundaryRegex);
  if (shouldRemovePunctuation) {
    words = words.map(_removePunctuation.default);
  } else {
    // If punctuation is not removed, punctuation marks are tokenized as if they were words.
    words = (0, _lodash.flatMap)(words, word => {
      const newWord = word.replace(punctuationRegex, " $1 ");
      return newWord.split(" ");
    });
  }
  return (0, _lodash.filter)(words, function (word) {
    return word.trim() !== "";
  });
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/word/includesIndex.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/word/includesIndex.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Checks whether a given word is directly preceded by a word from a list of words.
 *
 * @param {Array} precedingWords    The array of objects with matches and indices.
 * @param {number} matchIndex       The index of the word for which to check whether it's preceded by one of the other words.
 * @param {boolean} addSpace        True if a space should be added.
 *
 * @returns {boolean} Returns true if the match is preceded by a given word, otherwise returns false.
 */
function _default(precedingWords, matchIndex, addSpace = true) {
  /*
  1 if there is a space between the match and the preceding word
  (because the end word boundary is not included in the match).
  0 if the preceding word is a contraction.
  */
  const space = addSpace ? 1 : 0;
  if ((0, _lodash.isEmpty)(precedingWords)) {
    return false;
  }
  const precedingWordsEndIndices = [];
  (0, _lodash.forEach)(precedingWords, function (precedingWord) {
    const precedingWordsEndIndex = precedingWord.index + precedingWord.match.length + space;
    precedingWordsEndIndices.push(precedingWordsEndIndex);
  });
  return (0, _lodash.includes)(precedingWordsEndIndices, matchIndex);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/word/indices.js":
/*!********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/word/indices.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.filterIndices = exports["default"] = void 0;
exports.getIndicesByWord = getIndicesByWord;
exports.sortIndices = exports.getIndicesByWordListSorted = exports.getIndicesByWordList = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _stripSpaces = _interopRequireDefault(__webpack_require__(/*! ../sanitize/stripSpaces.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripSpaces.js"));
var _matchWordInSentence = __webpack_require__(/*! ./matchWordInSentence.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/matchWordInSentence.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Returns the indices of a string in a text. If it is found multiple times, it will return multiple indices.
 *
 * @param {string} word The word to find in the text.
 * @param {string} text The text to check for the given word.
 *
 * @returns {Array} All indices found.
 */
function getIndicesByWord(word, text) {
  let startIndex = 0;
  const searchStringLength = word.length;
  let index;
  const indices = [];
  while ((index = text.indexOf(word, startIndex)) > -1) {
    // Check if the previous and next character are word boundaries to determine if a complete word was detected
    const isPreviousCharacterWordBoundary = (0, _matchWordInSentence.characterInBoundary)(text[index - 1]) || index === 0;
    const isNextCharacterWordBoundary = (0, _matchWordInSentence.characterInBoundary)(text[index + searchStringLength]) || text.length === index + searchStringLength;
    if (isPreviousCharacterWordBoundary && isNextCharacterWordBoundary) {
      indices.push({
        index: index,
        match: word
      });
    }
    startIndex = index + searchStringLength;
  }
  return indices;
}

/**
 * Matches string with an array, returns the word and the index it was found on.
 *
 * @param {Array} words The array with strings to match.
 * @param {string} text The text to match the strings from the array to.
 *
 * @returns {Array} The array with words, containing the index of the match and the matched string.
 * Returns an empty array if none are found.
 */
const getIndicesByWordList = function (words, text) {
  let matchedWords = [];
  (0, _lodash.forEach)(words, function (word) {
    word = (0, _stripSpaces.default)(word);
    if (!(0, _matchWordInSentence.isWordInSentence)(word, text)) {
      return;
    }
    matchedWords = matchedWords.concat(getIndicesByWord(word, text));
  });
  return matchedWords;
};

/**
 * Sorts the array on the index property of each entry.
 *
 * @param {Array} indices The array with indices.
 *
 * @returns {Array} The sorted array with indices.
 */
exports.getIndicesByWordList = getIndicesByWordList;
const sortIndices = function (indices) {
  return indices.sort(function (a, b) {
    return a.index - b.index;
  });
};

/**
 * Filters duplicate entries if the indices overlap.
 *
 * @param {Array} indices The array with indices to be filtered.
 *
 * @returns {Array} The filtered array.
 */
exports.sortIndices = sortIndices;
const filterIndices = function (indices) {
  indices = sortIndices(indices);
  const filtered = [];
  for (let i = 0; i < indices.length; i++) {
    // If the next index is within the range of the current index and the length of the word, remove it
    // This makes sure we don't match combinations twice, like "even though" and "though".
    if (!(0, _lodash.isUndefined)(indices[i + 1]) && indices[i + 1].index < indices[i].index + indices[i].match.length) {
      filtered.push(indices[i]);

      // Adds 1 to i, so we skip the next index that is overlapping with the current index.
      i++;
      continue;
    }
    filtered.push(indices[i]);
  }
  return filtered;
};

/**
 * Matches string with an array, returns the word and the index it was found on, and sorts the match instances based on
 * the index property of the match.
 *
 * @param {Array} words The array with strings to match.
 * @param {string} text The text to match the strings from the array to.
 *
 * @returns {Array} The array with words, containing the index of the match and the matched string.
 * Returns an empty array if none are found.
 */
exports.filterIndices = filterIndices;
const getIndicesByWordListSorted = function (words, text) {
  let matchedWords = [];
  (0, _lodash.forEach)(words, function (word) {
    word = (0, _stripSpaces.default)(word);
    if (!(0, _matchWordInSentence.isWordInSentence)(word, text)) {
      return matchedWords;
    }
    matchedWords = matchedWords.concat(getIndicesByWord(word, text));
  });
  matchedWords = matchedWords.sort(function (a, b) {
    if (a.index < b.index) {
      return -1;
    }
    if (a.index > b.index) {
      return 1;
    }
    return 0;
  });
  return matchedWords;
};
exports.getIndicesByWordListSorted = getIndicesByWordListSorted;
var _default = exports["default"] = {
  getIndicesByWord,
  getIndicesByWordList,
  filterIndices,
  sortIndices,
  getIndicesByWordListSorted
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/word/markWordsInSentences.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/word/markWordsInSentences.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.deConstructAnchor = exports.collectMarkingsInSentence = void 0;
exports.markWordsInASentence = markWordsInASentence;
exports.markWordsInSentences = markWordsInSentences;
exports.reConstructAnchor = void 0;
var _matchTextWithArray = _interopRequireDefault(__webpack_require__(/*! ../match/matchTextWithArray */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/matchTextWithArray.js"));
var _createRegexFromArray = _interopRequireDefault(__webpack_require__(/*! ../regex/createRegexFromArray */ "./node_modules/yoastseo/build/languageProcessing/helpers/regex/createRegexFromArray.js"));
var _addMarkSingleWord = _interopRequireDefault(__webpack_require__(/*! ../../../markers/addMarkSingleWord */ "./node_modules/yoastseo/build/markers/addMarkSingleWord.js"));
var _Mark = _interopRequireDefault(__webpack_require__(/*! ../../../values/Mark */ "./node_modules/yoastseo/build/values/Mark.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _getAnchorsFromText = _interopRequireDefault(__webpack_require__(/*! ../link/getAnchorsFromText */ "./node_modules/yoastseo/build/languageProcessing/helpers/link/getAnchorsFromText.js"));
var _quotes = __webpack_require__(/*! ../sanitize/quotes */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/quotes.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
// Regex to deconstruct an anchor into open tag, content and close tag.
const anchorDeconstructionRegex = /(<a[\s]+[^>]+>)([^]*?)(<\/a>)/;

/**
 * Deconstructs an anchor to the opening tag and the content. The content is the anchor text.
 * We don't return the closing tag since the value would always be the same, i.e. </a>.
 *
 * @param {string} anchor An anchor of the shape <a ...>...</a>.
 *
 * @returns {object} An object containing the opening tag and the content.
 */
const deConstructAnchor = function (anchor) {
  // The const array mirrors the anchorDeconstructionRegex, using a comma to access the first element without a name.
  const [, openTag, content] = anchor.match(anchorDeconstructionRegex);
  return {
    openTag: openTag,
    content: content
  };
};

/**
 * Reconstructs an anchor from an openTag, the content, and the closing tag.
 *
 * @param {string} openTag The opening tag of the anchor. Must be of the shape <a ...>.
 * @param {string} content The text of the anchor.
 *
 * @returns {string} An anchor.
 */
exports.deConstructAnchor = deConstructAnchor;
const reConstructAnchor = function (openTag, content) {
  return `${openTag}${content}</a>`;
};

/**
 * Gets the anchors and marks the anchors' text if the words are found in it.
 *
 * @param {string} sentence The sentence to retrieve the anchors from.
 * @param {RegExp} wordsRegex The regex of the words.
 *
 * @returns {Object} The anchors and the marked anchors.
 */
exports.reConstructAnchor = reConstructAnchor;
const getMarkedAnchors = function (sentence, wordsRegex) {
  // Retrieve the anchors.
  const anchors = (0, _getAnchorsFromText.default)(sentence);
  // For every anchor, apply the markings only to the anchor tag.
  const markedAnchors = anchors.map(anchor => {
    // Retrieve the open tag and the content/anchor text.
    const {
      openTag,
      content
    } = deConstructAnchor(anchor);

    // Apply the marking to the anchor text if there is a match.
    const markedAnchorText = content.replace(wordsRegex, x => (0, _addMarkSingleWord.default)(x));

    // Create a new anchor tag with a (marked) anchor text.
    return reConstructAnchor(openTag, markedAnchorText);
  });
  return {
    anchors,
    markedAnchors
  };
};

/**
 * Adds marks to a sentence and merges marks if those are only separated by a space
 * (e.g., if highlighting words "ballet" and "shoes" in a sentence "I have a lot of ballet shoes and other paraphernalia."
 * the marks will be put around "ballet shoes" together, not "`ballet` `shoes`".)
 *
 * @param {string}    sentence               The sentence to mark words in.
 * @param {[string]}  wordsFoundInSentence   The words to mark in the sentence.
 * @param {function}  matchWordCustomHelper  The language-specific helper function to match word in text.
 *
 * @returns {string} The sentence with marks.
 */
const collectMarkingsInSentence = function (sentence, wordsFoundInSentence, matchWordCustomHelper) {
  const allWordsFound = [];
  wordsFoundInSentence.forEach(word => {
    // Check if the word in `wordsFoundInSentence` contains single quote(s).
    const matchedSingleQuotes = word.match(_quotes.SINGLE_QUOTES_REGEX);
    if (matchedSingleQuotes) {
      /*
       * If yes, make all different combinations of the word with different types of single quotes in the array.
       * Later, a regex will be created for all words that were found in the sentence including their variations.
       *
       * For example:
       * `wordsFoundInSentence`: [ "red", "panda’s" ]
       * For the word "panda’s", we'll create the following variations:
       * "panda's", "panda‘s", "panda’s", "panda‛s", "panda`s", "panda‹s", "panda›s"
       * And those variations will be added to `allWordsFound`.
       */
      _quotes.SINGLE_QUOTES_ARRAY.forEach(singleQuote => {
        matchedSingleQuotes.forEach(matchedSingleQuote => {
          allWordsFound.push((0, _lodash.escapeRegExp)(word.replace(new RegExp(matchedSingleQuote, "g"), singleQuote)));
        });
      });
    } else {
      allWordsFound.push((0, _lodash.escapeRegExp)(word));
    }
  });

  // If a language has a custom helper to match words, we disable the word boundary when creating the regex.
  const wordsRegex = matchWordCustomHelper ? (0, _createRegexFromArray.default)(allWordsFound, true) : (0, _createRegexFromArray.default)(allWordsFound);

  // Retrieve the anchors and mark the anchors' text if the words are found in the anchors' text.
  const {
    anchors,
    markedAnchors
  } = getMarkedAnchors(sentence, wordsRegex);
  let markup = sentence.replace(wordsRegex, function (x) {
    return (0, _addMarkSingleWord.default)(x);
  });

  /**
   * In 'markup', we apply the markings also inside the anchor's attribute if there is a match, on top of
   * marking the anchor's text.
   * The step below is to replace the incorrectly marked anchors with the marked anchors that we want:
   * where the markings are only applied in the anchor's text.
   */
  if (anchors.length > 0) {
    const markupAnchors = (0, _getAnchorsFromText.default)(markup);
    for (let i = 0; i < markupAnchors.length; i++) {
      markup = markup.replace(markupAnchors[i], markedAnchors[i]);
    }
  }

  /*
   * If two marks are separated by only a space, remove the closing tag of the first mark and the opening tag of the
   * second mark so that the two marks can be combined into one.
   */
  return markup.replace(new RegExp("</yoastmark> <yoastmark class='yoast-text-mark'>", "ig"), " ");
};

/**
 * Adds marks to a sentence.
 *
 * @param {string}      sentence                The sentence in which we want to apply highlighting.
 * @param {Array}       wordsFoundInSentence    The words to highlight in a sentence.
 * @param {function}    matchWordCustomHelper   The language-specific helper function to match word in text.
 * @returns {Mark[]}  The array of Mark objects of each sentence.
 */
exports.collectMarkingsInSentence = collectMarkingsInSentence;
function markWordsInASentence(sentence, wordsFoundInSentence, matchWordCustomHelper) {
  return [new _Mark.default({
    original: sentence,
    marked: collectMarkingsInSentence(sentence, wordsFoundInSentence, matchWordCustomHelper)
  })];
}

/**
 * Adds marks to an array of sentences.
 *
 * @param {[string]}    wordsToMark The words to mark.
 * @param {[string]}    sentences   The sentences in which to mark these words.
 * @param {string}      locale      The locale.
 * @param {function}    matchWordCustomHelper   The language-specific helper function to match word in text.
 *
 * @returns {[string]} The sentences with marks.
 */
function markWordsInSentences(wordsToMark, sentences, locale, matchWordCustomHelper) {
  let wordsFoundInSentence = [];
  let markings = [];
  sentences.forEach(function (sentence) {
    wordsFoundInSentence = (0, _matchTextWithArray.default)(sentence, wordsToMark, locale, matchWordCustomHelper).matches;
    if (wordsFoundInSentence.length > 0) {
      markings = markings.concat(markWordsInASentence(sentence, wordsFoundInSentence, matchWordCustomHelper));
    }
  });
  return markings;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/word/matchWordInSentence.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/word/matchWordInSentence.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isWordInSentence = exports["default"] = exports.characterInBoundary = void 0;
var _wordBoundaries = _interopRequireDefault(__webpack_require__(/*! ../../../config/wordBoundaries.js */ "./node_modules/yoastseo/build/config/wordBoundaries.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _addWordboundary = _interopRequireDefault(__webpack_require__(/*! ./addWordboundary.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/addWordboundary.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const wordBoundaries = (0, _wordBoundaries.default)();
/**
 * Checks whether a character is present in the list of word boundaries.
 *
 * @param {string} character The character to look for.
 * @returns {boolean} Whether or not the character is present in the list of word boundaries.
 */
const characterInBoundary = function (character) {
  return (0, _lodash.includes)(wordBoundaries, character);
};

/**
 * Checks whether a word is present in a sentence.
 *
 * @param {string} word The word to search for in the sentence.
 * @param {string} sentence The sentence to look through.
 * @returns {boolean} Whether or not the word is present in the sentence.
 */
exports.characterInBoundary = characterInBoundary;
const isWordInSentence = function (word, sentence) {
  // To ensure proper matching, make everything lowercase.
  word = word.toLocaleLowerCase();
  sentence = sentence.toLocaleLowerCase();

  // Escape regex in word, since we use regex characters like in abbreviations ("e.g.").
  const wordWithBoundaries = (0, _addWordboundary.default)((0, _lodash.escapeRegExp)(word));
  let occurrenceStart = sentence.search(new RegExp(wordWithBoundaries, "ig"));
  // Return false if no match has been found.
  if (occurrenceStart === -1) {
    return false;
  }
  /*
  If there is a word boundary before the matched word, the regex includes this word boundary in the match.
  This means that occurrenceStart is the index of the word boundary before the match. Therefore 1 has to
  be added to occurrenceStart, except when there is no word boundary before the match (i.e. at the start
  of a sentence).
   */
  if (occurrenceStart > 0) {
    occurrenceStart += 1;
  }
  const occurrenceEnd = occurrenceStart + word.length;

  // Check if the previous and next character are word boundaries to determine if a complete word was detected
  const previousCharacter = characterInBoundary(sentence[occurrenceStart - 1]) || occurrenceStart === 0;
  const nextCharacter = characterInBoundary(sentence[occurrenceEnd]) || occurrenceEnd === sentence.length;
  return previousCharacter && nextCharacter;
};
exports.isWordInSentence = isWordInSentence;
var _default = exports["default"] = {
  characterInBoundary,
  isWordInSentence
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/helpers/word/splitIntoTokens.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/helpers/word/splitIntoTokens.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _createPunctuationTokens = _interopRequireDefault(__webpack_require__(/*! ./createPunctuationTokens */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/createPunctuationTokens.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/*
*  The following regex is used to split a text into tokens.
 * The regex matches word separators. A word separator is either a whitespace, a slash, a
 * tab, a non-breaking space, a hyphen, an en-dash or an em-dash.
 * Opening and closing square brackets are added to deal correctly with shortcodes downstream.
 * The regex is used to split a text into tokens.
 * Do not add punctuation marks to this regex, as they are handled separately inside `createPunctuationTokens()`.
 * The word separator explicitly only contains characters that split two words and not a word and a space.
 * - A space is a word separator because it separates two words if it occurs between them. For example: "foo bar"
 * - A tab is a word separator because it separates two words if it occurs between them. For example: "foo	bar"
 * - A non-breaking space (u00A0) is a word separator because it separates two words if it occurs between them. For example: "foo\u00A0bar".
 * - An en-dash (u2013), an em-dash (u2014), and a hyphen (u002d) are word separators because they separate two words if they occur between them.
 *   For example: "foo–bar".
 * Note that &nbsp; is added here as #nbsp; -- we transform the & to # to prevent parse5 from converting it to a space and messing up highlighting.
 */
const WORD_SEPARATORS_REGEX = /([\s\t\u00A0\u2013\u2014\u002d[\]]|#nbsp;)/;

/**
 * Tokenizes a text similarly to `getWords`, but in a way that's suitable for the HTML parser.
 * 1. It does not normalize whitespace.
 * This operation is too risky for the HTML parser because it may throw away characters and as a result, the token positions are corrupted.
 * 2. It does not remove punctuation marks but keeps them.
 *
 * This algorithm splits the text by word separators: tokens that are the border between two words.
 * This algorithm separates punctuation marks from words and keeps them as separate tokens.
 * It only splits them off if they appear at the start or the end of a word.
 *
 * @param {string} text The text to tokenize.
 *
 * @returns {string[]} 	An array of tokens.
 */
const splitIntoTokens = text => {
  if (!text) {
    return [];
  }

  // Split the sentence string into tokens. Those tokens are unrefined as they may contain punctuation.
  const rawTokens = text.split(WORD_SEPARATORS_REGEX).filter(x => x !== "");

  // Remove punctuation from the beginning and end of word tokens, and make them into separate tokens.
  return (0, _createPunctuationTokens.default)(rawTokens);
};
var _default = exports["default"] = splitIntoTokens;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "AbstractResearcher", ({
  enumerable: true,
  get: function () {
    return _AbstractResearcher.default;
  }
}));
Object.defineProperty(exports, "areWordsInSentence", ({
  enumerable: true,
  get: function () {
    return _areWordsInSentence.default;
  }
}));
Object.defineProperty(exports, "baseStemmer", ({
  enumerable: true,
  get: function () {
    return _baseStemmer.default;
  }
}));
Object.defineProperty(exports, "buildFormRule", ({
  enumerable: true,
  get: function () {
    return _buildFormRule.default;
  }
}));
Object.defineProperty(exports, "collectMarkingsInSentence", ({
  enumerable: true,
  get: function () {
    return _markWordsInSentences.collectMarkingsInSentence;
  }
}));
Object.defineProperty(exports, "countMetaDescriptionLength", ({
  enumerable: true,
  get: function () {
    return _countMetaDescriptionLength.default;
  }
}));
Object.defineProperty(exports, "createRegexFromArray", ({
  enumerable: true,
  get: function () {
    return _createRegexFromArray.default;
  }
}));
Object.defineProperty(exports, "createRulesFromArrays", ({
  enumerable: true,
  get: function () {
    return _createRulesFromArrays.default;
  }
}));
Object.defineProperty(exports, "createSingleRuleFromArray", ({
  enumerable: true,
  get: function () {
    return _createRulesFromArrays.createSingleRuleFromArray;
  }
}));
Object.defineProperty(exports, "directPrecedenceException", ({
  enumerable: true,
  get: function () {
    return _directPrecedenceException.default;
  }
}));
exports.exceptionListHelpers = void 0;
Object.defineProperty(exports, "findMatchingEndingInArray", ({
  enumerable: true,
  get: function () {
    return _findMatchingEndingInArray.default;
  }
}));
Object.defineProperty(exports, "findWordFormsInString", ({
  enumerable: true,
  get: function () {
    return _findKeywordFormsInString.findWordFormsInString;
  }
}));
Object.defineProperty(exports, "flattenSortLength", ({
  enumerable: true,
  get: function () {
    return _flattenSortLength.default;
  }
}));
Object.defineProperty(exports, "getClauses", ({
  enumerable: true,
  get: function () {
    return _getClauses.default;
  }
}));
Object.defineProperty(exports, "getClausesSplitOnStopWords", ({
  enumerable: true,
  get: function () {
    return _getClausesSplitOnStopWords.default;
  }
}));
Object.defineProperty(exports, "getFieldsToMark", ({
  enumerable: true,
  get: function () {
    return _getFieldsToMark.getFieldsToMark;
  }
}));
Object.defineProperty(exports, "getLanguage", ({
  enumerable: true,
  get: function () {
    return _getLanguage.default;
  }
}));
Object.defineProperty(exports, "getSentences", ({
  enumerable: true,
  get: function () {
    return _getSentences.default;
  }
}));
Object.defineProperty(exports, "getWords", ({
  enumerable: true,
  get: function () {
    return _getWords.default;
  }
}));
exports.helpers = void 0;
Object.defineProperty(exports, "imageInText", ({
  enumerable: true,
  get: function () {
    return _imageInText.default;
  }
}));
Object.defineProperty(exports, "indices", ({
  enumerable: true,
  get: function () {
    return _indices.default;
  }
}));
exports.languageHelpers = exports.languageConfigs = void 0;
Object.defineProperty(exports, "markWordsInSentences", ({
  enumerable: true,
  get: function () {
    return _markWordsInSentences.markWordsInSentences;
  }
}));
Object.defineProperty(exports, "matchRegularParticiples", ({
  enumerable: true,
  get: function () {
    return _matchRegularParticiples.default;
  }
}));
Object.defineProperty(exports, "mergeListItems", ({
  enumerable: true,
  get: function () {
    return _mergeListItems.mergeListItems;
  }
}));
Object.defineProperty(exports, "nonDirectPrecedenceException", ({
  enumerable: true,
  get: function () {
    return _nonDirectParticiplePrecedenceException.default;
  }
}));
Object.defineProperty(exports, "normalizeHTML", ({
  enumerable: true,
  get: function () {
    return _normalizeHTML.default;
  }
}));
Object.defineProperty(exports, "normalizeSingle", ({
  enumerable: true,
  get: function () {
    return _quotes.normalizeSingle;
  }
}));
Object.defineProperty(exports, "parseSynonyms", ({
  enumerable: true,
  get: function () {
    return _parseSynonyms.default;
  }
}));
Object.defineProperty(exports, "precedenceException", ({
  enumerable: true,
  get: function () {
    return _precedenceException.default;
  }
}));
exports.regexHelpers = void 0;
Object.defineProperty(exports, "removePunctuation", ({
  enumerable: true,
  get: function () {
    return _removePunctuation.default;
  }
}));
Object.defineProperty(exports, "replaceDiacritics", ({
  enumerable: true,
  get: function () {
    return _replaceDiacritics.default;
  }
}));
exports.researches = void 0;
Object.defineProperty(exports, "sanitizeString", ({
  enumerable: true,
  get: function () {
    return _sanitizeString.default;
  }
}));
exports.stemHelpers = void 0;
Object.defineProperty(exports, "stripBlockTagsAtStartEnd", ({
  enumerable: true,
  get: function () {
    return _stripHTMLTags.stripBlockTagsAtStartEnd;
  }
}));
Object.defineProperty(exports, "stripHTMLTags", ({
  enumerable: true,
  get: function () {
    return _stripHTMLTags.stripFullTags;
  }
}));
Object.defineProperty(exports, "stripSpaces", ({
  enumerable: true,
  get: function () {
    return _stripSpaces.default;
  }
}));
Object.defineProperty(exports, "transliterate", ({
  enumerable: true,
  get: function () {
    return _transliterate.default;
  }
}));
Object.defineProperty(exports, "unifyAllSpaces", ({
  enumerable: true,
  get: function () {
    return _unifyWhitespace.unifyAllSpaces;
  }
}));
exports.values = void 0;
var _replaceDiacritics = _interopRequireDefault(__webpack_require__(/*! ./helpers/transliterate/replaceDiacritics */ "./node_modules/yoastseo/build/languageProcessing/helpers/transliterate/replaceDiacritics.js"));
var _transliterate = _interopRequireDefault(__webpack_require__(/*! ./helpers/transliterate/transliterate */ "./node_modules/yoastseo/build/languageProcessing/helpers/transliterate/transliterate.js"));
var _createRegexFromArray = _interopRequireDefault(__webpack_require__(/*! ./helpers/regex/createRegexFromArray */ "./node_modules/yoastseo/build/languageProcessing/helpers/regex/createRegexFromArray.js"));
var _imageInText = _interopRequireDefault(__webpack_require__(/*! ./helpers/image/imageInText */ "./node_modules/yoastseo/build/languageProcessing/helpers/image/imageInText.js"));
var _stripSpaces = _interopRequireDefault(__webpack_require__(/*! ./helpers/sanitize/stripSpaces */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripSpaces.js"));
var _baseStemmer = _interopRequireDefault(__webpack_require__(/*! ./helpers/morphology/baseStemmer */ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/baseStemmer.js"));
var _getWords = _interopRequireDefault(__webpack_require__(/*! ./helpers/word/getWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
var _AbstractResearcher = _interopRequireDefault(__webpack_require__(/*! ./AbstractResearcher */ "./node_modules/yoastseo/build/languageProcessing/AbstractResearcher.js"));
var _flattenSortLength = _interopRequireDefault(__webpack_require__(/*! ./helpers/morphology/flattenSortLength */ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/flattenSortLength.js"));
var _indices = _interopRequireDefault(__webpack_require__(/*! ./helpers/word/indices */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/indices.js"));
var _buildFormRule = _interopRequireDefault(__webpack_require__(/*! ./helpers/morphology/buildFormRule */ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/buildFormRule.js"));
var _createRulesFromArrays = _interopRequireWildcard(__webpack_require__(/*! ./helpers/morphology/createRulesFromArrays */ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/createRulesFromArrays.js"));
var _matchRegularParticiples = _interopRequireDefault(__webpack_require__(/*! ./helpers/passiveVoice/periphrastic/matchRegularParticiples */ "./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/matchRegularParticiples.js"));
var _directPrecedenceException = _interopRequireDefault(__webpack_require__(/*! ./helpers/passiveVoice/periphrastic/directPrecedenceException */ "./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/directPrecedenceException.js"));
var _precedenceException = _interopRequireDefault(__webpack_require__(/*! ./helpers/passiveVoice/periphrastic/precedenceException */ "./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/precedenceException.js"));
var _nonDirectParticiplePrecedenceException = _interopRequireDefault(__webpack_require__(/*! ./helpers/passiveVoice/periphrastic/freeAuxiliaryParticipleOrder/nonDirectParticiplePrecedenceException */ "./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/freeAuxiliaryParticipleOrder/nonDirectParticiplePrecedenceException.js"));
var _findMatchingEndingInArray = _interopRequireDefault(__webpack_require__(/*! ./helpers/morphology/findMatchingEndingInArray */ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/findMatchingEndingInArray.js"));
var regexHelpers = _interopRequireWildcard(__webpack_require__(/*! ./helpers/morphology/regexHelpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/regexHelpers.js"));
exports.regexHelpers = regexHelpers;
var exceptionListHelpers = _interopRequireWildcard(__webpack_require__(/*! ./helpers/morphology/exceptionListHelpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/exceptionListHelpers.js"));
exports.exceptionListHelpers = exceptionListHelpers;
var stemHelpers = _interopRequireWildcard(__webpack_require__(/*! ./helpers/morphology/stemHelpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/stemHelpers.js"));
exports.stemHelpers = stemHelpers;
var values = _interopRequireWildcard(__webpack_require__(/*! ./values */ "./node_modules/yoastseo/build/languageProcessing/values/index.js"));
exports.values = values;
var _areWordsInSentence = _interopRequireDefault(__webpack_require__(/*! ./helpers/word/areWordsInSentence */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/areWordsInSentence.js"));
var _getClauses = _interopRequireDefault(__webpack_require__(/*! ./helpers/passiveVoice/periphrastic/getClauses */ "./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/getClauses.js"));
var _getClausesSplitOnStopWords = _interopRequireDefault(__webpack_require__(/*! ./helpers/passiveVoice/periphrastic/freeAuxiliaryParticipleOrder/getClausesSplitOnStopWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/passiveVoice/periphrastic/freeAuxiliaryParticipleOrder/getClausesSplitOnStopWords.js"));
var _stripHTMLTags = __webpack_require__(/*! ./helpers/sanitize/stripHTMLTags */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripHTMLTags.js");
var _sanitizeString = _interopRequireDefault(__webpack_require__(/*! ./helpers/sanitize/sanitizeString */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/sanitizeString.js"));
var _unifyWhitespace = __webpack_require__(/*! ./helpers/sanitize/unifyWhitespace */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/unifyWhitespace.js");
var _removePunctuation = _interopRequireDefault(__webpack_require__(/*! ./helpers/sanitize/removePunctuation */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removePunctuation.js"));
var _normalizeHTML = _interopRequireDefault(__webpack_require__(/*! ./helpers/html/normalizeHTML */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/normalizeHTML.js"));
var _countMetaDescriptionLength = _interopRequireDefault(__webpack_require__(/*! ./helpers/word/countMetaDescriptionLength */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/countMetaDescriptionLength.js"));
var _getLanguage = _interopRequireDefault(__webpack_require__(/*! ./helpers/language/getLanguage */ "./node_modules/yoastseo/build/languageProcessing/helpers/language/getLanguage.js"));
var _getSentences = _interopRequireDefault(__webpack_require__(/*! ./helpers/sentence/getSentences */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentences.js"));
var _getFieldsToMark = __webpack_require__(/*! ./helpers/html/getFieldsToMark */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/getFieldsToMark.js");
var _quotes = __webpack_require__(/*! ./helpers/sanitize/quotes */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/quotes.js");
var _parseSynonyms = _interopRequireDefault(__webpack_require__(/*! ./helpers/sanitize/parseSynonyms */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/parseSynonyms.js"));
var _mergeListItems = __webpack_require__(/*! ./helpers/sanitize/mergeListItems */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/mergeListItems.js");
var _findKeywordFormsInString = __webpack_require__(/*! ./helpers/match/findKeywordFormsInString */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/findKeywordFormsInString.js");
var _markWordsInSentences = __webpack_require__(/*! ./helpers/word/markWordsInSentences */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/markWordsInSentences.js");
var helpers = _interopRequireWildcard(__webpack_require__(/*! ./helpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/index.js"));
exports.helpers = helpers;
var researches = _interopRequireWildcard(__webpack_require__(/*! ./researches */ "./node_modules/yoastseo/build/languageProcessing/researches/index.js"));
exports.researches = researches;
var _checkIfWordIsComplex = _interopRequireDefault(__webpack_require__(/*! ./languages/en/helpers/checkIfWordIsComplex */ "./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/checkIfWordIsComplex.js"));
var _checkIfWordIsComplex2 = _interopRequireDefault(__webpack_require__(/*! ./languages/de/helpers/checkIfWordIsComplex */ "./node_modules/yoastseo/build/languageProcessing/languages/de/helpers/checkIfWordIsComplex.js"));
var _checkIfWordIsComplex3 = _interopRequireDefault(__webpack_require__(/*! ./languages/es/helpers/checkIfWordIsComplex */ "./node_modules/yoastseo/build/languageProcessing/languages/es/helpers/checkIfWordIsComplex.js"));
var _checkIfWordIsComplex4 = _interopRequireDefault(__webpack_require__(/*! ./languages/fr/helpers/checkIfWordIsComplex */ "./node_modules/yoastseo/build/languageProcessing/languages/fr/helpers/checkIfWordIsComplex.js"));
var _wordComplexity = _interopRequireDefault(__webpack_require__(/*! ./languages/en/config/wordComplexity */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/wordComplexity.js"));
var _wordComplexity2 = _interopRequireDefault(__webpack_require__(/*! ./languages/de/config/wordComplexity */ "./node_modules/yoastseo/build/languageProcessing/languages/de/config/wordComplexity.js"));
var _wordComplexity3 = _interopRequireDefault(__webpack_require__(/*! ./languages/es/config/wordComplexity */ "./node_modules/yoastseo/build/languageProcessing/languages/es/config/wordComplexity.js"));
var _wordComplexity4 = _interopRequireDefault(__webpack_require__(/*! ./languages/fr/config/wordComplexity */ "./node_modules/yoastseo/build/languageProcessing/languages/fr/config/wordComplexity.js"));
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function (e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != typeof e && "function" != typeof e) return {
    default: e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n.default = e, t && t.set(e, n), n;
}
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const languageHelpers = exports.languageHelpers = {
  wordComplexityHelperEnglish: _checkIfWordIsComplex.default,
  wordComplexityHelperGerman: _checkIfWordIsComplex2.default,
  wordComplexityHelperSpanish: _checkIfWordIsComplex3.default,
  wordComplexityHelperFrench: _checkIfWordIsComplex4.default
};
const languageConfigs = exports.languageConfigs = {
  wordComplexityConfigEnglish: _wordComplexity.default,
  wordComplexityConfigGerman: _wordComplexity2.default,
  wordComplexityConfigSpanish: _wordComplexity3.default,
  wordComplexityConfigFrench: _wordComplexity4.default
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/de/config/wordComplexity.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/de/config/wordComplexity.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
// This is a config for the Word Complexity assessment. As such, this helper is not bundled in Yoast SEO.
var _default = exports["default"] = {
  wordLength: 10
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/de/helpers/checkIfWordIsComplex.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/de/helpers/checkIfWordIsComplex.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = checkIfWordIsComplex;
const suffixes = "(en|e|s)$";
const suffixesRegex = new RegExp(suffixes);

/**
 * Checks if a word is complex.
 * This is a helper for the Word Complexity assessment. As such, this helper is not bundled in Yoast SEO.
 *
 * @param {object}	config The configuration needed for assessing the word's complexity, e.g., the frequency list.
 * @param {string}	word The word to check.
 * @param {object}	premiumData The object that contains data for the assessment including the frequency list.
 *
 * @returns {boolean} Whether or not a word is complex.
 */
function checkIfWordIsComplex(config, word, premiumData) {
  const lengthLimit = config.wordLength;
  const frequencyList = premiumData.frequencyList.list;
  // All words are converted to lower case before processing to avoid excluding complex words that start with a capital letter.
  word = word.toLowerCase();

  // The German word is not complex if its length is 10 characters or fewer.
  if (word.length <= lengthLimit) {
    return false;
  }

  // The word is not complex if it's in the frequency list.
  if (frequencyList.includes(word)) {
    return false;
  }

  /*
  * If a word is longer than 10 characters and has a plural ending in -e, -s, or -en, we remove the ending
  * and check if the singular form can be found in the frequency list.
  * The word is not complex if the singular form is in the list.
  */
  if (suffixesRegex.test(word)) {
    word = word.replace(suffixesRegex, "");
    return !frequencyList.includes(word);
  }
  return true;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/Researcher.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/Researcher.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _yoastseo = __webpack_require__(/*! yoastseo */ "./node_modules/yoastseo/build/index.js");
var _firstWordExceptions = _interopRequireDefault(__webpack_require__(/*! ./config/firstWordExceptions */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/firstWordExceptions.js"));
var _functionWords = __webpack_require__(/*! ./config/functionWords */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/functionWords.js");
var _stopWords = _interopRequireDefault(__webpack_require__(/*! ./config/stopWords */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/stopWords.js"));
var _transitionWords = _interopRequireDefault(__webpack_require__(/*! ./config/transitionWords */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/transitionWords.js"));
var _twoPartTransitionWords = _interopRequireDefault(__webpack_require__(/*! ./config/twoPartTransitionWords */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/twoPartTransitionWords.js"));
var _syllables = _interopRequireDefault(__webpack_require__(/*! ./config/syllables.json */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/syllables.json"));
var _getClauses = _interopRequireDefault(__webpack_require__(/*! ./helpers/getClauses */ "./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/getClauses.js"));
var _getStemmer = _interopRequireDefault(__webpack_require__(/*! ./helpers/getStemmer */ "./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/getStemmer.js"));
var _calculateFleschReadingScore = _interopRequireDefault(__webpack_require__(/*! ./helpers/calculateFleschReadingScore */ "./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/calculateFleschReadingScore.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const {
  AbstractResearcher
} = _yoastseo.languageProcessing;

// All config

// All helpers

/**
 * The researcher contains all the researches, helpers, data, and config.
 */
class Researcher extends AbstractResearcher {
  /**
   * Constructor
   * @param {Paper} paper The Paper object that is needed within the researches.
   * @constructor
   */
  constructor(paper) {
    super(paper);
    Object.assign(this.config, {
      language: "en",
      passiveConstructionType: "periphrastic",
      firstWordExceptions: _firstWordExceptions.default,
      functionWords: _functionWords.all,
      stopWords: _stopWords.default,
      transitionWords: _transitionWords.default,
      twoPartTransitionWords: _twoPartTransitionWords.default,
      syllables: _syllables.default
    });
    Object.assign(this.helpers, {
      getClauses: _getClauses.default,
      getStemmer: _getStemmer.default,
      fleschReadingScore: _calculateFleschReadingScore.default
    });
  }
}
exports["default"] = Researcher;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/abbreviations.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/config/abbreviations.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Returns a list with abbreviations. Originally created for use in yoastseo/src/languageProcessing/helpers/sentence/SentenceTokenizer.js
 * Abbreviations were originally sourced from: https://github.com/Yoast/YoastSEO.js/issues/698
 * IMPORTANT! For the use in the SentenceTokenizer it is important that:
 * - all abbreviations end in a full stop.
 * - all abbreviations should contain more than one letter to prevent clashes with the check for initials.
 * @type {Array} The list with abbreviations.
 */
var _default = exports["default"] = ["A.D.", "Adm.", "Adv.", "B.C.", "Br.", "Brig.", "Cmrd.", "Col.", "Cpl.", "Cpt.", "Dr.", "Esq.", "Fr.", "Gen.", "Gov.", "Hon.", "Jr.", "Lieut.", "Lt.", "Maj.", "Mr.", "Mrs.", "Ms.", "Msgr.", "Mx.", "No.", "Pfc.", "Pr.", "Prof.", "Pvt.", "Rep.", "Reps.", "Rev.", "Rt. Hon.", "Sen.", "Sens.", "Sgt.", "Sps.", "Sr.", "St.", "vs.", "i.e.", "e.g.", "viz.", "Mt."];

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/firstWordExceptions.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/config/firstWordExceptions.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Returns an array with exceptions for the sentence beginning researcher.
 * @type {Array} The array filled with exceptions.
 */
var _default = exports["default"] = [
// Definite articles:
"the",
// Indefinite articles:
"a", "an",
// Numbers 1-10:
"one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten",
// Demonstrative pronouns:
"this", "that", "these", "those"];

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/functionWords.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/config/functionWords.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.nonNouns = exports.filteredAtEnding = exports.filteredAtBeginningAndEnding = exports.filteredAnywhere = exports["default"] = exports.cannotDirectlyPrecedePassiveParticiple = exports.cannotBeBetweenPassiveAuxiliaryAndParticiple = exports.all = void 0;
var _passiveVoiceAuxiliaries = __webpack_require__(/*! ./internal/passiveVoiceAuxiliaries.js */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/internal/passiveVoiceAuxiliaries.js");
var _transitionWords = __webpack_require__(/*! ./transitionWords.js */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/transitionWords.js");
var _transformWordsWithHyphens = _interopRequireDefault(__webpack_require__(/*! ../../../helpers/transform/transformWordsWithHyphens */ "./node_modules/yoastseo/build/languageProcessing/helpers/transform/transformWordsWithHyphens.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const articles = ["the", "an", "a"];
const cardinalNumerals = ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty", "hundred", "hundreds", "thousand", "thousands", "million", "millions", "billion", "billions"];
const ordinalNumerals = ["first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth", "eleventh", "twelfth", "thirteenth", "fourteenth", "fifteenth", "sixteenth", "seventeenth", "eighteenth", "nineteenth", "twentieth"];
const personalPronounsNominative = ["i", "you", "he", "she", "it", "we", "they"];
const personalPronounsAccusative = ["me", "him", "us", "them"];
const demonstrativePronouns = ["this", "that", "these", "those"];
const possessivePronouns = ["my", "your", "his", "her", "its", "their", "our", "mine", "yours", "hers", "theirs", "ours"];
const quantifiers = ["all", "some", "many", "lot", "lots", "ton", "tons", "bit", "no", "every", "enough", "little", "much", "more", "most", "plenty", "several", "few", "fewer", "kind", "kinds"];
const reflexivePronouns = ["myself", "yourself", "himself", "herself", "itself", "oneself", "ourselves", "yourselves", "themselves"];
const indefinitePronouns = ["none", "nobody", "everyone", "everybody", "someone", "somebody", "anyone", "anybody", "nothing", "everything", "something", "anything", "each", "other", "whatever", "whichever", "whoever", "whomever", "whomsoever", "whosoever", "others", "neither", "both", "either", "any", "such"];
const indefinitePronounsPossessive = ["one's", "nobody's", "everyone's", "everybody's", "someone's", "somebody's", "anyone's", "anybody's", "nothing's", "everything's", "something's", "anything's", "whoever's", "others'", "other's", "another's", "neither's", "either's"];
const interrogativeDeterminers = ["which", "what", "whose"];
const interrogativePronouns = ["who", "whom"];
const interrogativeProAdverbs = ["where", "how", "why", "whether", "wherever", "whyever", "wheresoever", "whensoever", "howsoever", "whysoever", "whatsoever", "whereso", "whomso", "whenso", "howso", "whyso", "whoso", "whatso"];
const pronominalAdverbs = ["therefor", "therein", "hereby", "hereto", "wherein", "therewith", "herewith", "wherewith", "thereby"];
const locativeAdverbs = ["there", "here", "whither", "thither", "hither", "whence", "thence"];
const adverbialGenitives = ["always", "once", "twice", "thrice"];
const otherAuxiliaries = ["can", "cannot", "can't", "could", "couldn't", "could've", "dare", "dares", "dared", "do", "don't", "does", "doesn't", "did", "didn't", "done", "have", "haven't", "had", "hadn't", "has", "hasn't", "i've", "you've", "we've", "they've", "i'd", "you'd", "he'd", "she'd", "it'd", "we'd", "they'd", "would", "wouldn't", "would've", "may", "might", "must", "need", "needn't", "needs", "ought", "shall", "shalln't", "shan't", "should", "shouldn't", "will", "won't", "i'll", "you'll", "he'll", "she'll", "it'll", "we'll", "they'll", "there's", "there're", "there'll", "here's", "here're", "there'll"];
const copula = ["appear", "appears", "appeared", "become", "becomes", "became", "come", "comes", "came", "keep", "keeps", "kept", "remain", "remains", "remained", "stay", "stays", "stayed", "turn", "turns", "turned"];

// These verbs should only be included at the beginning of combinations.
const continuousVerbs = ["doing", "daring", "having", "appearing", "becoming", "coming", "keeping", "remaining", "staying", "saying", "asking", "stating", "seeming", "letting", "making", "setting", "showing", "putting", "adding", "going", "using", "trying", "containing"];
const prepositions = ["in", "from", "with", "under", "throughout", "atop", "for", "on", "of", "to", "aboard", "about", "above", "abreast", "absent", "across", "adjacent", "after", "against", "along", "alongside", "amid", "mid", "among", "apropos", "apud", "around", "as", "astride", "at", "ontop", "afore", "tofore", "behind", "ahind", "below", "ablow", "beneath", "neath", "beside", "between", "atween", "beyond", "ayond", "by", "chez", "circa", "spite", "down", "except", "into", "less", "like", "minus", "near", "nearer", "nearest", "anear", "notwithstanding", "off", "onto", "opposite", "out", "outen", "over", "past", "per", "pre", "qua", "sans", "sithence", "through", "thru", "truout", "toward", "underneath", "up", "upon", "upside", "versus", "via", "vis-à-vis", "without", "ago", "apart", "aside", "aslant", "away", "withal", "towards", "amidst", "amongst", "midst", "whilst"];

// Many prepositional adverbs are already listed as preposition.
const prepositionalAdverbs = ["back", "within", "forward", "backward", "ahead"];
const coordinatingConjunctions = ["and", "or", "and/or", "yet"];

// 'sooner' is part of 'no sooner...than', 'just' is part of 'just as...so',
// 'Only' is part of 'not only...but also'.
const correlativeConjunctions = ["sooner", "just", "only"];
const subordinatingConjunctions = ["if", "even"];

// These verbs are frequently used in interviews to indicate questions and answers.
// 'Claim','claims', 'state' and 'states' are not included, because these words are also nouns.
const interviewVerbs = ["say", "says", "said", "claimed", "ask", "asks", "asked", "stated", "explain", "explains", "explained", "think", "thinks", "talks", "talked", "announces", "announced", "tells", "told", "discusses", "discussed", "suggests", "suggested", "understands", "understood"];

// These transition words were not included in the list for the transition word assessment for various reasons.
const additionalTransitionWords = ["again", "definitely", "eternally", "expressively", "instead", "expressly", "immediately", "including", "instantly", "namely", "naturally", "next", "notably", "now", "nowadays", "ordinarily", "positively", "truly", "ultimately", "uniquely", "usually", "almost", "maybe", "probably", "granted", "initially", "too", "actually", "already", "e.g", "i.e", "often", "regularly", "simply", "optionally", "perhaps", "sometimes", "likely", "never", "ever", "else", "inasmuch", "provided", "currently", "incidentally", "elsewhere", "particular", "recently", "relatively", "f.i", "clearly", "apparently"];
const intensifiers = ["highly", "very", "really", "extremely", "absolutely", "completely", "totally", "utterly", "quite", "somewhat", "seriously", "fairly", "fully", "amazingly"];

/* These verbs convey little meaning. 'Show', 'shows', 'uses', 'meaning', 'set', 'sets'
 are not included, because these words could be relevant nouns.

 */
const delexicalizedVerbs = ["seem", "seems", "seemed", "let", "let's", "lets", "make", "makes", "made", "want", "showed", "shown", "go", "goes", "went", "gone", "take", "takes", "took", "taken", "put", "puts", "use", "used", "try", "tries", "tried", "mean", "means", "meant", "called", "based", "add", "adds", "added", "contain", "contains", "contained", "consist", "consists", "consisted", "ensure", "ensures", "ensured"];

// These adjectives and adverbs are so general, they should never be suggested as a (single) keyword.
// Keyword combinations containing these adjectives/adverbs are fine.
const generalAdjectivesAdverbs = ["new", "newer", "newest", "old", "older", "oldest", "previous", "good", "well", "better", "best", "big", "bigger", "biggest", "easy", "easier", "easiest", "fast", "faster", "fastest", "far", "hard", "harder", "hardest", "least", "own", "large", "larger", "largest", "long", "longer", "longest", "low", "lower", "lowest", "high", "higher", "highest", "regular", "simple", "simpler", "simplest", "small", "smaller", "smallest", "tiny", "tinier", "tiniest", "short", "shorter", "shortest", "main", "actual", "nice", "nicer", "nicest", "real", "same", "able", "certain", "usual", "so-called", "mainly", "mostly", "recent", "anymore", "complete", "lately", "possible", "commonly", "constantly", "continually", "directly", "easily", "nearly", "slightly", "somewhere", "estimated", "latest", "different", "similar", "widely", "bad", "worse", "worst", "great", "specific", "available", "average", "awful", "awesome", "basic", "beautiful", "busy", "current", "entire", "everywhere", "important", "major", "multiple", "normal", "necessary", "obvious", "partly", "special", "last", "early", "earlier", "earliest", "young", "younger", "youngest"];
const interjections = ["oh", "wow", "tut-tut", "tsk-tsk", "ugh", "whew", "phew", "yeah", "yea", "shh", "oops", "ouch", "aha", "yikes"];

// These words and abbreviations are frequently used in recipes in lists of ingredients.
const recipeWords = ["tbs", "tbsp", "spk", "lb", "qt", "pk", "bu", "oz", "pt", "mod", "doz", "hr", "f.g", "ml", "dl", "cl", "l", "mg", "g", "kg", "quart"];
const timeWords = ["seconds", "minute", "minutes", "hour", "hours", "day", "days", "week", "weeks", "month", "months", "year", "years", "today", "tomorrow", "yesterday"];

// 'People' should only be removed in combination with 'some', 'many' and 'few' (and is therefore not yet included in the list below).
const vagueNouns = ["thing", "things", "way", "ways", "matter", "case", "likelihood", "ones", "piece", "pieces", "stuff", "times", "part", "parts", "percent", "instance", "instances", "aspect", "aspects", "item", "items", "idea", "theme", "person", "instance", "instances", "detail", "details", "factor", "factors", "difference", "differences"];

// 'No' is already included in the quantifier list.
const miscellaneous = ["not", "yes", "sure", "top", "bottom", "ok", "okay", "amen", "aka", "etc", "etcetera", "sorry", "please"];
const titlesPreceding = ["ms", "mss", "mrs", "mr", "dr", "prof"];
const titlesFollowing = ["jr", "sr"];

// These word categories are filtered at the ending of word combinations.
const filteredAtEnding = exports.filteredAtEnding = (0, _transformWordsWithHyphens.default)([].concat(ordinalNumerals, continuousVerbs, generalAdjectivesAdverbs));

// These word categories are filtered at the beginning and ending of word combinations.
const filteredAtBeginningAndEnding = exports.filteredAtBeginningAndEnding = (0, _transformWordsWithHyphens.default)([].concat(articles, prepositions, coordinatingConjunctions, demonstrativePronouns, intensifiers, quantifiers, possessivePronouns));

// These word categories are filtered everywhere within word combinations.
const filteredAnywhere = exports.filteredAnywhere = (0, _transformWordsWithHyphens.default)([].concat(_transitionWords.singleWords, adverbialGenitives, personalPronounsNominative, personalPronounsAccusative, reflexivePronouns, interjections, cardinalNumerals, _passiveVoiceAuxiliaries.filteredAuxiliaries, otherAuxiliaries, copula, interviewVerbs, delexicalizedVerbs, indefinitePronouns, correlativeConjunctions, subordinatingConjunctions, interrogativeDeterminers, interrogativePronouns, interrogativeProAdverbs, locativeAdverbs, miscellaneous, prepositionalAdverbs, pronominalAdverbs, recipeWords, timeWords, vagueNouns));

// These categories are used in the passive voice assessment. If they directly precede a participle, the sentence part is not passive.
const cannotDirectlyPrecedePassiveParticiple = exports.cannotDirectlyPrecedePassiveParticiple = (0, _transformWordsWithHyphens.default)([].concat(articles, prepositions, demonstrativePronouns, possessivePronouns, ordinalNumerals, continuousVerbs, quantifiers));

/*
These categories are used in the passive voice assessment. If they appear between an auxiliary and a participle,
the sentence part is not passive.
*/
const cannotBeBetweenPassiveAuxiliaryAndParticiple = exports.cannotBeBetweenPassiveAuxiliaryAndParticiple = (0, _transformWordsWithHyphens.default)([].concat(otherAuxiliaries, copula, interviewVerbs, delexicalizedVerbs));

/**
  * These categories consist of function words that are not nouns.
  * They are used in the inclusive language to recognize overgeneralizing phrases such as "the aged".
  * @type{string[]}
  */
const nonNouns = exports.nonNouns = (0, _transformWordsWithHyphens.default)([].concat(articles, cardinalNumerals, ordinalNumerals, demonstrativePronouns, possessivePronouns, reflexivePronouns, personalPronounsNominative, personalPronounsAccusative, quantifiers, indefinitePronouns, continuousVerbs, indefinitePronounsPossessive, interrogativeDeterminers, interrogativePronouns, interrogativeProAdverbs, pronominalAdverbs, locativeAdverbs, adverbialGenitives, prepositionalAdverbs, _passiveVoiceAuxiliaries.filteredAuxiliaries, _passiveVoiceAuxiliaries.notFilteredAuxiliaries, otherAuxiliaries, copula, prepositions, coordinatingConjunctions, correlativeConjunctions, subordinatingConjunctions, interviewVerbs, _transitionWords.singleWords, additionalTransitionWords, intensifiers, delexicalizedVerbs, interjections, generalAdjectivesAdverbs, recipeWords, miscellaneous, titlesFollowing));

// This export contains all of the above words.
const all = exports.all = (0, _transformWordsWithHyphens.default)([].concat(articles, cardinalNumerals, ordinalNumerals, demonstrativePronouns, possessivePronouns, reflexivePronouns, personalPronounsNominative, personalPronounsAccusative, quantifiers, indefinitePronouns, continuousVerbs, indefinitePronounsPossessive, interrogativeDeterminers, interrogativePronouns, interrogativeProAdverbs, pronominalAdverbs, locativeAdverbs, adverbialGenitives, prepositionalAdverbs, _passiveVoiceAuxiliaries.filteredAuxiliaries, _passiveVoiceAuxiliaries.notFilteredAuxiliaries, otherAuxiliaries, copula, prepositions, coordinatingConjunctions, correlativeConjunctions, subordinatingConjunctions, interviewVerbs, _transitionWords.singleWords, additionalTransitionWords, intensifiers, delexicalizedVerbs, interjections, generalAdjectivesAdverbs, recipeWords, vagueNouns, miscellaneous, timeWords, titlesPreceding, titlesFollowing));
var _default = exports["default"] = {
  filteredAtEnding,
  filteredAtBeginningAndEnding,
  filteredAnywhere,
  cannotDirectlyPrecedePassiveParticiple,
  cannotBeBetweenPassiveAuxiliaryAndParticiple,
  all
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/internal/passiveVoiceAuxiliaries.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/config/internal/passiveVoiceAuxiliaries.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.notFilteredAuxiliaries = exports.filteredAuxiliaries = exports["default"] = exports.all = void 0;
// These auxiliaries are filtered from the beginning of word combinations in the prominent words.
const filteredAuxiliaries = exports.filteredAuxiliaries = ["am", "is", "are", "was", "were", "been", "get", "gets", "got", "gotten", "be", "she's", "he's", "it's", "i'm", "we're", "they're", "you're", "that's", "isn't", "weren't", "wasn't", "aren't"];

// These auxiliaries are not filtered from the beginning of word combinations in the prominent words.
const notFilteredAuxiliaries = exports.notFilteredAuxiliaries = ["being", "getting", "having", "what's"];
const all = exports.all = filteredAuxiliaries.concat(notFilteredAuxiliaries);
var _default = exports["default"] = all;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/internal/passiveVoiceIrregulars.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/config/internal/passiveVoiceIrregulars.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Returns a list of en irregulars.
 *
 * @type {string[]} English irregulars.
 */
var _default = exports["default"] = ["arisen", "awoken", "reawoken", "babysat", "backslid", "backslidden", "beat", "beaten", "become", "begun", "bent", "unbent", "bet", "bid", "outbid", "rebid", "underbid", "overbid", "bidden", "bitten", "blown", "bought", "overbought", "bound", "unbound", "rebound", "broadcast", "rebroadcast", "broken", "brought", "browbeat", "browbeaten", "built", "prebuilt", "rebuilt", "overbuilt", "burnt", "burst", "bust", "cast", "miscast", "recast", "caught", "chosen", "clung", "come", "overcome", "cost", "crept", "cut", "undercut", "recut", "daydreamt", "dealt", "misdealt", "redealt", "disproven", "done", "predone", "outdone", "misdone", "redone", "overdone", "undone", "drawn", "outdrawn", "redrawn", "overdrawn", "dreamt", "driven", "outdriven", "drunk", "outdrunk", "overdrunk", "dug", "dwelt", "eaten", "overeaten", "fallen", "felt", "fit", "refit", "retrofit", "flown", "outflown", "flung", "forbidden", "forecast", "foregone", "foreseen", "foretold", "forgiven", "forgotten", "forsaken", "fought", "outfought", "found", "frostbitten", "frozen", "unfrozen", "given", "gone", "undergone",
//	Is also auxiliary: "got",
"gotten", "ground", "reground", "grown", "outgrown", "regrown", "had", "handwritten", "heard", "reheard", "misheard", "overheard", "held", "hewn", "hidden", "unhidden", "hit", "hung", "rehung", "overhung", "unhung", "hurt", "inlaid", "input", "interwound", "interwoven", "jerry-built", "kept", "knelt", "knit", "reknit", "unknit", "known", "laid", "mislaid", "relaid", "overlaid", "lain", "underlain", "leant", "leapt", "outleapt", "learnt", "unlearnt", "relearnt", "mislearnt", "left", "lent", "let", "lip-read", "lit", "relit", "lost", "made", "premade", "remade", "meant", "met", "mown", "offset", "paid", "prepaid", "repaid", "overpaid", "partaken", "proofread", "proven", "put", "quick-frozen", "quit", "read", "misread", "reread", "retread", "rewaken", "rid", "ridden", "outridden", "overridden", "risen", "roughcast", "run", "outrun", "rerun", "overrun", "rung", "said", "sand-cast", "sat", "outsat", "sawn", "seen", "overseen", "sent", "resent", "set", "preset", "reset", "misset", "sewn", "resewn", "oversewn", "unsewn", "shaken", "shat", "shaven", "shit", "shone", "outshone", "shorn", "shot", "outshot", "overshot", "shown", "shrunk", "preshrunk", "shut", "sight-read", "slain", "slept", "outslept", "overslept", "slid", "slit", "slung", "unslung", "slunk", "smelt", "outsmelt", "snuck", "sold", "undersold", "presold", "outsold", "resold", "oversold", "sought", "sown", "spat", "spelt", "misspelt", "spent", "underspent", "outspent", "misspent", "overspent", "spilt", "overspilt", "spit", "split", "spoilt", "spoken", "outspoken", "misspoken", "overspoken", "spread", "sprung", "spun", "unspun", "stolen", "stood", "understood", "misunderstood", "strewn", "stricken", "stridden", "striven", "struck", "strung", "unstrung", "stuck", "unstuck", "stung", "stunk", "sublet", "sunburnt", "sung", "outsung", "sunk", "sweat", "swept", "swollen", "sworn", "outsworn", "swum", "outswum", "swung", "taken", "undertaken", "mistaken", "retaken", "overtaken", "taught", "mistaught", "retaught", "telecast", "test-driven", "test-flown", "thought", "outthought", "rethought", "overthought", "thrown", "outthrown", "overthrown", "thrust", "told", "retold", "torn", "retorn", "trod", "trodden", "typecast", "typeset", "upheld", "upset", "waylaid", "wept", "wet", "rewet", "withdrawn", "withheld", "withstood", "woken", "won", "rewon", "worn", "reworn", "wound", "rewound", "overwound", "unwound", "woven", "rewoven", "unwoven", "written", "typewritten", "underwritten", "outwritten", "miswritten", "rewritten", "overwritten", "wrung"];

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/internal/passiveVoiceNonVerbEndingEd.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/config/internal/passiveVoiceNonVerbEndingEd.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Returns a list of verbs not ending in `ed`.
 *
 * @returns {string[]} English verbs not ending in `ed`.
 */
var _default = exports["default"] = ["ablebodied", "abovementioned", "absentminded", "accoladed", "accompanied", "acculturized", "accursed", "acerated", "acerbated", "acetylized", "achromatised", "achromatized", "acidified", "acned", "actualised", "adrenalised", "adulated", "adversed", "aestheticised", "affectioned", "affined", "affricated", "aforementioned", "agerelated", "aggrieved", "airbed", "aircooled", "airspeed", "alcoholized", "alcoved", "alkalised", "allianced", "aluminized", "alveolated", "ambered", "ammonified", "amplified", "anagrammatised", "anagrammatized", "anathematised", "aniseed", "ankled", "annualized", "anonymised", "anthologized", "antlered", "anucleated", "anviled", "anvilshaped", "apostrophised", "apostrophized", "appliqued", "apprized", "arbitrated", "armored", "articled", "ashamed", "assented", "atomised", "atrophied", "auricled", "auriculated", "aurified", "autopsied", "axled", "babied", "backhoed", "badmannered", "badtempered", "balustered", "baned", "barcoded", "bareboned", "barefooted", "barelegged", "barnacled", "based", "bayoneted", "beadyeyed", "beaked", "beaned", "beatified", "beautified", "beavered", "bed", "bedamned", "bedecked", "behoved", "belated", "bellbottomed", "bellshaped", "benighted", "bequeathed", "berried", "bespectacled", "bewhiskered", "bighearted", "bigmouthed", "bigoted", "bindweed", "binucleated", "biopsied", "bioturbed", "biped", "bipinnated", "birdfeed", "birdseed", "bisegmented", "bitterhearted", "blabbermouthed", "blackhearted", "bladed", "blankminded", "blearyeyed", "bleed", "blissed", "blobbed", "blondhaired", "bloodied", "bloodred", "bloodshed", "blueblooded", "boatshaped", "bobsled", "bodied", "boldhearted", "boogied", "boosed", "bosomed", "bottlefed", "bottlefeed", "bottlenecked", "bouldered", "bowlegged", "bowlshaped", "brandied", "bravehearted", "breastfed", "breastfeed", "breed", "brighteyed", "brindled", "broadhearted", "broadleaved", "broadminded", "brokenhearted", "broomed", "broomweed", "buccaned", "buckskinned", "bucktoothed", "buddied", "buffaloed", "bugeyed", "bugleweed", "bugweed", "bulletined", "bunked", "busied", "butterfingered", "cabbed", "caddied", "cairned", "calcified", "canalized", "candied", "cannulated", "canoed", "canopied", "canvased", "caped", "capsulated", "cassocked", "castellated", "catabolised", "catheterised", "caudated", "cellmediated", "cellulosed", "certified", "chagrined", "chambered", "chested", "chevroned", "chickenfeed", "chickenhearted", "chickweed", "chilblained", "childbed", "chinned", "chromatographed", "ciliated", "cindered", "cingulated", "circumstanced", "cisgendered", "citrullinated", "clappered", "clarified", "classified", "clawshaped", "claysized", "cleanhearted", "clearminded", "clearsighted", "cliched", "clodded", "cloistered", "closefisted", "closehearted", "closelipped", "closemouthed", "closeted", "cloudseed", "clubfooted", "clubshaped", "clued", "cockeyed", "codified", "coed", "coevolved", "coffined", "coiffed", "coinfected", "coldblooded", "coldhearted", "collateralised", "colonialised", "colorcoded", "colorised", "colourised", "columned", "commoditized", "compactified", "companioned", "complexioned", "conceited", "concerned", "concussed", "coneshaped", "congested", "contented", "convexed", "coralled", "corymbed", "cottonseed", "countrified", "countrybred", "courtmartialled", "coved", "coveralled", "cowshed", "cozied", "cragged", "crayoned", "credentialed", "creed", "crenulated", "crescentshaped", "cressweed", "crewed", "cricked", "crispated", "crossbarred", "crossbed", "crossbred", "crossbreed", "crossclassified", "crosseyed", "crossfertilised", "crossfertilized", "crossindexed", "crosslegged", "crossshaped", "crossstratified", "crossstriated", "crotched", "crucified", "cruelhearted", "crutched", "cubeshaped", "cubified", "cuckolded", "cucumbershaped", "cumbered", "cuminseed", "cupshaped", "curated", "curded", "curfewed", "curlicued", "curlycued", "curried", "curtsied", "cyclized", "cylindershaped", "damed", "dandified", "dangered", "darkhearted", "daybed", "daylighted", "deacidified", "deacylated", "deadhearted", "deadlined", "deaminized", "deathbed", "decalcified", "decertified", "deckbed", "declassified", "declutched", "decolourated", "decreed", "deed", "deeprooted", "deepseated", "defensed", "defied", "deflexed", "deglamorised", "degunkified", "dehumidified", "deified", "deled", "delegitimised", "demoded", "demystified", "denasalized", "denazified", "denied", "denitrified", "denticulated", "deseed", "desexualised", "desposited", "detoxified", "deuced", "devitrified", "dewlapped", "dezincified", "diagonalised", "dialogued", "died", "digitated", "dignified", "dilled", "dimwitted", "diphthonged", "disaffected", "disaggregated", "disarrayed", "discalced", "discolorated", "discolourated", "discshaped", "diseased", "disembodied", "disencumbered", "disfranchised", "diskshaped", "disproportionated", "disproportioned", "disqualified", "distempered", "districted", "diversified", "diverticulated", "divested", "divvied", "dizzied", "dogged", "dogsbodied", "dogsled", "domeshaped", "domiciled", "dormered", "doublebarrelled", "doublestranded", "doublewalled", "downhearted", "duckbilled", "eared", "echeloned", "eddied", "edified", "eggshaped", "elasticated", "electrified", "elegized", "embed", "embodied", "emceed", "empaneled", "empanelled", "emptyhearted", "emulsified", "engined", "ennobled", "envied", "enzymecatalysed", "enzymecatalyzed", "epitomised", "epoxidized", "epoxied", "etherised", "etherized", "evilhearted", "evilminded", "exceed", "excited", "exemplified", "exponentiated", "expurgated", "extravasated", "extraverted", "extroverted", "fabled", "facelifted", "facsimiled", "fainthearted", "falcated", "falsehearted", "falsified", "famed", "fancified", "fanged", "fanshaped", "fantasied", "farsighted", "fated", "fatted", "fazed", "featherbed", "fed", "federalized", "feeblehearted", "feebleminded", "feeblewitted", "feed", "fendered", "fenestrated", "ferried", "fevered", "fibered", "fibred", "ficklehearted", "fiercehearted", "figged", "filigreed", "filterfeed", "fireweed", "firmhearted", "fissured", "flanged", "flanneled", "flannelled", "flatbed", "flatfooted", "flatted", "flawed", "flaxenhaired", "flaxseed", "flaxweed", "flighted", "floodgenerated", "flowerbed", "fluidised", "fluidized", "flurried", "fobbed", "fonded", "forcefeed", "foreshortened", "foresighted", "forkshaped", "formfeed", "fortified", "fortressed", "foulmouthed", "foureyed", "foxtailed", "fractionalised", "fractionalized", "frankhearted", "freed", "freehearted", "freespirited", "frenzied", "friezed", "frontiered", "fructified", "frumped", "fullblooded", "fullbodied", "fullfledged", "fullhearted", "funnelshaped", "furnaced", "gaitered", "galleried", "gangliated", "ganglionated", "gangrened", "gargoyled", "gasified", "gaunted", "gauntleted", "gauzed", "gavelled", "gelatinised", "gemmed", "genderized", "gentled", "gentlehearted", "gerrymandered", "gladhearted", "glamored", "globed", "gloried", "glorified", "glycosylated", "goateed", "gobletshaped", "godspeed", "goodhearted", "goodhumored", "goodhumoured", "goodnatured", "goodtempered", "goosed", "goosenecked", "goutweed", "grainfed", "grammaticalized", "grapeseed", "gratified", "graved", "gravelbed", "grayhaired", "greathearted", "greed", "greenweed", "grommeted", "groundspeed", "groved", "gruffed", "guiled", "gulled", "gumshoed", "gunkholed", "gussied", "guyed", "gyrostabilized", "hackneyed", "hagged", "haired", "halfcivilized", "halfhearted", "halfwitted", "haloed", "handballed", "handfed", "handfeed", "hardcoded", "hardhearted", "hardnosed", "hared", "harelipped", "hasted", "hatred", "haunched", "hawkeyed", "hayseed", "hayweed", "hearsed", "hearted", "heartshaped", "heavenlyminded", "heavyfooted", "heavyhearted", "heed", "heired", "heisted", "helicoptered", "helmed", "helmeted", "hemagglutinated", "hemolyzed", "hempseed", "hempweed", "heparinised", "heparinized", "herbed", "highheeled", "highminded", "highpriced", "highspeed", "highspirited", "hilled", "hipped", "hispanicised", "hocked", "hoed", "hogweed", "holstered", "homaged", "hoodooed", "hoofed", "hooknosed", "hooved", "horned", "horrified", "horseshoed", "horseweed", "hotbed", "hotblooded", "hothearted", "hotted", "hottempered", "hued", "humansized", "humidified", "humped", "hundred", "hutched", "hyperinflated", "hyperpigmented", "hyperstimulated", "hypertrophied", "hyphened", "hypophysectomised", "hypophysectomized", "hypopigmented", "hypostatised", "hysterectomized", "iconified", "iconised", "iconized", "ideologised", "illbred", "illconceived", "illdefined", "illdisposed", "illequipped", "illfated", "illfavored", "illfavoured", "illflavored", "illfurnished", "illhumored", "illhumoured", "illimited", "illmannered", "illnatured", "illomened", "illproportioned", "illqualified", "illscented", "illtempered", "illumed", "illusioned", "imbed", "imbossed", "imbued", "immatured", "impassioned", "impenetrated", "imperfected", "imperialised", "imperturbed", "impowered", "imputed", "inarticulated", "inbred", "inbreed", "incapsulated", "incased", "incrustated", "incrusted", "indebted", "indeed", "indemnified", "indentured", "indigested", "indisposed", "inexperienced", "infrared", "intensified", "intentioned", "interbedded", "interbred", "interbreed", "interluded", "introverted", "inured", "inventoried", "iodinated", "iodised", "irked", "ironfisted", "ironweed", "itchweed", "ivied", "ivyweed", "jagged", "jellified", "jerseyed", "jetlagged", "jetpropelled", "jeweled", "jewelled", "jewelweed", "jiggered", "jimmyweed", "jimsonweed", "jointweed", "joyweed", "jungled", "juried", "justiceweed", "justified", "karstified", "kerchiefed", "kettleshaped", "kibbled", "kidneyshaped", "kimonoed", "kindhearted", "kindred", "kingsized", "kirtled", "knacked", "knapweed", "kneed", "knobbed", "knobweed", "knopweed", "knotweed", "lakebed", "lakeweed", "lamed", "lamellated", "lanceshaped", "lanceted", "landbased", "lapeled", "lapelled", "largehearted", "lariated", "lased", "latticed", "lauded", "lavaged", "lavendered", "lawned", "led", "lefteyed", "legitimatised", "legitimatized", "leisured", "lensshaped", "leveed", "levied", "lichened", "lichenized", "lidded", "lifesized", "lightfingered", "lightfooted", "lighthearted", "lightminded", "lightspeed", "lignified", "likeminded", "lilylivered", "limbed", "linearised", "linearized", "linefeed", "linseed", "lionhearted", "liquefied", "liquified", "lithified", "liveried", "lobbied", "located", "locoweed", "longarmed", "longhaired", "longhorned", "longlegged", "longnecked", "longsighted", "longwinded", "lopsided", "loudmouthed", "louvered", "louvred", "lowbred", "lowpriced", "lowspirited", "lozenged", "lunated", "lyrated", "lysinated", "maced", "macroaggregated", "macrodissected", "maculated", "madweed", "magnified", "maidenweed", "maladapted", "maladjusted", "malnourished", "malrotated", "maned", "mannered", "manuevered", "manyhued", "manyshaped", "manysided", "masted", "mealymouthed", "meanspirited", "membered", "membraned", "metaled", "metalized", "metallised", "metallized", "metamerized", "metathesized", "meted", "methylated", "mettled", "microbrecciated", "microminiaturized", "microstratified", "middleaged", "midsized", "miffed", "mildhearted", "milkweed", "miniskirted", "misactivated", "misaligned", "mischiefed", "misclassified", "misdeed", "misdemeaned", "mismannered", "misnomered", "misproportioned", "miswired", "mitred", "mitted", "mittened", "moneyed", "monocled", "mononucleated", "monospaced", "monotoned", "monounsaturated", "mortified", "moseyed", "motorised", "motorized", "moussed", "moustached", "muddied", "mugweed", "multiarmed", "multibarreled", "multibladed", "multicelled", "multichambered", "multichanneled", "multichannelled", "multicoated", "multidirected", "multiengined", "multifaceted", "multilaminated", "multilaned", "multilayered", "multilobed", "multilobulated", "multinucleated", "multipronged", "multisegmented", "multisided", "multispeed", "multistemmed", "multistoried", "multitalented", "multitoned", "multitowered", "multivalued", "mummied", "mummified", "mustached", "mustachioed", "mutinied", "myelinated", "mystified", "mythicised", "naked", "narcotised", "narrowminded", "natured", "neaped", "nearsighted", "necrosed", "nectared", "need", "needleshaped", "newfangled", "newlywed", "nibbed", "nimblewitted", "nippled", "nixed", "nobled", "noduled", "noised", "nonaccented", "nonactivated", "nonadsorbed", "nonadulterated", "nonaerated", "nonaffiliated", "nonaliased", "nonalienated", "nonaligned", "nonarchived", "nonarmored", "nonassociated", "nonattenuated", "nonblackened", "nonbreastfed", "nonbrecciated", "nonbuffered", "nonbuttered", "noncarbonated", "noncarbonized", "noncatalogued", "noncatalyzed", "noncategorized", "noncertified", "nonchlorinated", "nonciliated", "noncircumcised", "noncivilized", "nonclassified", "noncoated", "noncodified", "noncoerced", "noncommercialized", "noncommissioned", "noncompacted", "noncompiled", "noncomplicated", "noncomposed", "noncomputed", "noncomputerized", "nonconcerted", "nonconditioned", "nonconfirmed", "noncongested", "nonconjugated", "noncooled", "noncorrugated", "noncoupled", "noncreated", "noncrowded", "noncultured", "noncurated", "noncushioned", "nondecoded", "nondecomposed", "nondedicated", "nondeferred", "nondeflated", "nondegenerated", "nondegraded", "nondelegated", "nondelimited", "nondelineated", "nondemarcated", "nondeodorized", "nondeployed", "nonderivatized", "nonderived", "nondetached", "nondetailed", "nondifferentiated", "nondigested", "nondigitized", "nondilapidated", "nondilated", "nondimensionalised", "nondimensionalized", "nondirected", "nondisabled", "nondisciplined", "nondispersed", "nondisputed", "nondisqualified", "nondisrupted", "nondisseminated", "nondissipated", "nondissolved", "nondistressed", "nondistributed", "nondiversified", "nondiverted", "nondocumented", "nondomesticated", "nondoped", "nondrafted", "nondrugged", "nondubbed", "nonducted", "nonearthed", "noneclipsed", "nonedged", "nonedited", "nonelasticized", "nonelectrified", "nonelectroplated", "nonelectroporated", "nonelevated", "noneliminated", "nonelongated", "nonembedded", "nonembodied", "nonemphasized", "nonencapsulated", "nonencoded", "nonencrypted", "nonendangered", "nonengraved", "nonenlarged", "nonenriched", "nonentangled", "nonentrenched", "nonepithelized", "nonequilibrated", "nonestablished", "nonetched", "nonethoxylated", "nonethylated", "nonetiolated", "nonexaggerated", "nonexcavated", "nonexhausted", "nonexperienced", "nonexpired", "nonfabricated", "nonfalsified", "nonfeathered", "nonfeatured", "nonfed", "nonfederated", "nonfeed", "nonfenestrated", "nonfertilized", "nonfilamented", "nonfinanced", "nonfinished", "nonfinned", "nonfissured", "nonflagellated", "nonflagged", "nonflared", "nonflavored", "nonfluidized", "nonfluorinated", "nonfluted", "nonforested", "nonformalized", "nonformatted", "nonfragmented", "nonfragranced", "nonfranchised", "nonfreckled", "nonfueled", "nonfumigated", "nonfunctionalized", "nonfunded", "nongalvanized", "nongated", "nongelatinized", "nongendered", "nongeneralized", "nongenerated", "nongifted", "nonglazed", "nonglucosated", "nonglucosylated", "nonglycerinated", "nongraded", "nongrounded", "nonhalogenated", "nonhandicapped", "nonhospitalised", "nonhospitalized", "nonhydrated", "nonincorporated", "nonindexed", "noninfected", "noninfested", "noninitialized", "noninitiated", "noninoculated", "noninseminated", "noninstitutionalized", "noninsured", "nonintensified", "noninterlaced", "noninterpreted", "nonintroverted", "noninvestigated", "noninvolved", "nonirrigated", "nonisolated", "nonisomerized", "nonissued", "nonitalicized", "nonitemized", "noniterated", "nonjaded", "nonlabelled", "nonlaminated", "nonlateralized", "nonlayered", "nonlegalized", "nonlegislated", "nonlesioned", "nonlexicalized", "nonliberated", "nonlichenized", "nonlighted", "nonlignified", "nonlimited", "nonlinearized", "nonlinked", "nonlobed", "nonlobotomized", "nonlocalized", "nonlysed", "nonmachined", "nonmalnourished", "nonmandated", "nonmarginalized", "nonmassaged", "nonmatriculated", "nonmatted", "nonmatured", "nonmechanized", "nonmedicated", "nonmedullated", "nonmentioned", "nonmetabolized", "nonmetallized", "nonmetastasized", "nonmetered", "nonmethoxylated", "nonmilled", "nonmineralized", "nonmirrored", "nonmodeled", "nonmoderated", "nonmodified", "nonmonetized", "nonmonitored", "nonmortgaged", "nonmotorized", "nonmottled", "nonmounted", "nonmultithreaded", "nonmutilated", "nonmyelinated", "nonnormalized", "nonnucleated", "nonobjectified", "nonobligated", "nonoccupied", "nonoiled", "nonopinionated", "nonoxygenated", "nonpaginated", "nonpaired", "nonparalyzed", "nonparameterized", "nonparasitized", "nonpasteurized", "nonpatterned", "nonphased", "nonphosphatized", "nonphosphorized", "nonpierced", "nonpigmented", "nonpiloted", "nonpipelined", "nonpitted", "nonplussed", "nonpuffed", "nonrandomized", "nonrated", "nonrefined", "nonregistered", "nonregulated", "nonrelated", "nonretarded", "nonsacred", "nonsalaried", "nonsanctioned", "nonsaturated", "nonscented", "nonscheduled", "nonseasoned", "nonsecluded", "nonsegmented", "nonsegregated", "nonselected", "nonsolidified", "nonspecialized", "nonspored", "nonstandardised", "nonstandardized", "nonstratified", "nonstressed", "nonstriated", "nonstriped", "nonstructured", "nonstylised", "nonstylized", "nonsubmerged", "nonsubscripted", "nonsubsidised", "nonsubsidized", "nonsubstituted", "nonsyndicated", "nonsynthesised", "nontabulated", "nontalented", "nonthreaded", "nontinted", "nontolerated", "nontranslated", "nontunnelled", "nonunified", "nonunionised", "nonupholstered", "nonutilised", "nonutilized", "nonvalued", "nonvaried", "nonverbalized", "nonvitrified", "nonvolatilised", "nonvolatilized", "normed", "nosebleed", "notated", "notified", "nuanced", "nullified", "numerated", "oarweed", "objectified", "obliqued", "obtunded", "occupied", "octupled", "odored", "oilseed", "oinked", "oldfashioned", "onesided", "oophorectomized", "opaqued", "openhearted", "openminded", "openmouthed", "opiated", "opinionated", "oracled", "oreweed", "ossified", "outbreed", "outmoded", "outrigged", "outriggered", "outsized", "outskated", "outspeed", "outtopped", "outtrumped", "outvoiced", "outweed", "ovated", "overadorned", "overaged", "overalled", "overassured", "overbred", "overbreed", "overcomplicated", "overdamped", "overdetailed", "overdiversified", "overdyed", "overequipped", "overfatigued", "overfed", "overfeed", "overindebted", "overintensified", "overinventoried", "overmagnified", "overmodified", "overpreoccupied", "overprivileged", "overproportionated", "overqualified", "overseed", "oversexed", "oversimplified", "oversized", "oversophisticated", "overstudied", "oversulfated", "ovicelled", "ovoidshaped", "ozonated", "pacified", "packeted", "palatalized", "paled", "palsied", "paned", "panicled", "parabled", "parallelepiped", "parallelized", "parallelopiped", "parenthesised", "parodied", "parqueted", "passioned", "paunched", "pauperised", "pedigreed", "pedimented", "pedunculated", "pegged", "peglegged", "penanced", "pencilshaped", "permineralized", "personified", "petrified", "photodissociated", "photoduplicated", "photoed", "photoinduced", "photolysed", "photolyzed", "pied", "pigeoned", "pigtailed", "pigweed", "pilastered", "pillared", "pilloried", "pimpled", "pinealectomised", "pinealectomized", "pinfeathered", "pinnacled", "pinstriped", "pixellated", "pixilated", "pixillated", "plainclothed", "plantarflexed", "pled", "plumaged", "pocked", "pokeweed", "polychlorinated", "polyunsaturated", "ponytailed", "pooched", "poorspirited", "popeyed", "poppyseed", "porcelainized", "porched", "poshed", "pottered", "poxed", "preachified", "precertified", "preclassified", "preconized", "preinoculated", "premed", "prenotified", "preoccupied", "preposed", "prequalified", "preshaped", "presignified", "prespecified", "prettified", "pried", "principled", "proceed", "prophesied", "propounded", "prosed", "protonated", "proudhearted", "proxied", "pulpified", "pumpkinseed", "puppied", "purebred", "pured", "pureed", "purified", "pustuled", "putrefied", "pyjamaed", "quadruped", "qualified", "quantified", "quantised", "quantized", "quarried", "queried", "questoned", "quicktempered", "quickwitted", "quiesced", "quietened", "quizzified", "racemed", "radiosensitised", "ragweed", "raindrenched", "ramped", "rapeseed", "rarefied", "rarified", "ratified", "razoredged", "reaccelerated", "reaccompanied", "reachieved", "reacknowledged", "readdicted", "readied", "reamplified", "reannealed", "reassociated", "rebadged", "rebiopsied", "recabled", "recategorised", "receipted", "recentred", "recertified", "rechoreographed", "reclarified", "reclassified", "reconferred", "recrystalized", "rectified", "recursed", "red", "redblooded", "redefied", "redenied", "rednecked", "redshifted", "redweed", "redyed", "reed", "reembodied", "reenlighted", "refeed", "refereed", "reflexed", "refortified", "refronted", "refuged", "reglorified", "reimpregnated", "reinitialized", "rejustified", "related", "reliquefied", "remedied", "remodified", "remonetized", "remythologized", "renotified", "renullified", "renumerated", "reoccupied", "repacified", "repurified", "reputed", "requalified", "rescinded", "reseed", "reshoed", "resolidified", "resorbed", "respecified", "restudied", "retabulated", "reticulated", "retinted", "retreed", "retroacted", "reunified", "reverified", "revested", "revivified", "rewed", "ridgepoled", "riffled", "rightminded", "rigidified", "rinded", "riped", "rited", "ritualised", "riverbed", "rivered", "roached", "roadbed", "robotised", "robotized", "romanized", "rosetted", "rosined", "roughhearted", "rubied", "ruddied", "runcinated", "russeted", "sabled", "sabred", "sabretoothed", "sacheted", "sacred", "saddlebred", "sainted", "salaried", "samoyed", "sanctified", "satellited", "savvied", "sawtoothed", "scandalled", "scarified", "scarped", "sceptred", "scissored", "screed", "screwshaped", "scrupled", "sculked", "scurried", "scuttled", "seabed", "seaweed", "seed", "seedbed", "selfassured", "selforganized", "semicivilized", "semidetached", "semidisassembled", "semidomesticated", "semipetrified", "semipronated", "semirefined", "semivitrified", "sentineled", "sepaled", "sepalled", "sequinned", "sexed", "shagged", "shaggycoated", "shaggyhaired", "shaled", "shammed", "sharpangled", "sharpclawed", "sharpcornered", "sharpeared", "sharpedged", "sharpeyed", "sharpflavored", "sharplimbed", "sharpnosed", "sharpsighted", "sharptailed", "sharptongued", "sharptoothed", "sharpwitted", "sharpworded", "shed", "shellbed", "shieldshaped", "shimmied", "shinned", "shirted", "shirtsleeved", "shoed", "shortbeaked", "shortbilled", "shortbodied", "shorthaired", "shortlegged", "shortlimbed", "shortnecked", "shortnosed", "shortsighted", "shortsleeved", "shortsnouted", "shortstaffed", "shorttailed", "shorttempered", "shorttoed", "shorttongued", "shortwinded", "shortwinged", "shotted", "shred", "shrewsized", "shrined", "shrinkproofed", "sickbed", "sickleshaped", "sickleweed", "signalised", "signified", "silicified", "siliconized", "silkweed", "siltsized", "silvertongued", "simpleminded", "simplified", "singlebarreled", "singlebarrelled", "singlebed", "singlebladed", "singlebreasted", "singlecelled", "singlefooted", "singlelayered", "singleminded", "singleseeded", "singleshelled", "singlestranded", "singlevalued", "sissified", "sistered", "sixgilled", "sixmembered", "sixsided", "sixstoried", "skulled", "slickered", "slipcased", "slowpaced", "slowwitted", "slurried", "smallminded", "smoothened", "smoothtongued", "snaggletoothed", "snouted", "snowballed", "snowcapped", "snowshed", "snowshoed", "snubnosed", "so-called", "sofabed", "softhearted", "sogged", "soled", "solidified", "soliped", "sorbed", "souled", "spearshaped", "specified", "spectacled", "sped", "speeched", "speechified", "speed", "spied", "spiffied", "spindleshaped", "spiritualised", "spirted", "splayfooted", "spoonfed", "spoonfeed", "spoonshaped", "spreadeagled", "squarejawed", "squareshaped", "squareshouldered", "squaretoed", "squeegeed", "staled", "starshaped", "starspangled", "starstudded", "statechartered", "statesponsored", "statued", "steadied", "steampowered", "steed", "steelhearted", "steepled", "sterned", "stiffnecked", "stilettoed", "stimied", "stinkweed", "stirrupshaped", "stockinged", "storeyed", "storied", "stouthearted", "straitlaced", "stratified", "strawberryflavored", "streambed", "stressinduced", "stretchered", "strictured", "strongbodied", "strongboned", "strongflavored", "stronghearted", "stronglimbed", "strongminded", "strongscented", "strongwilled", "stubbled", "studied", "stultified", "stupefied", "styed", "stymied", "subclassified", "subcommissioned", "subminiaturised", "subsaturated", "subulated", "suburbanised", "suburbanized", "suburbed", "succeed", "sueded", "sugarrelated", "sulfurized", "sunbed", "superhardened", "superinfected", "supersimplified", "surefooted", "sweetscented", "swifted", "swordshaped", "syllabified", "syphilized", "tabularized", "talented", "tarpapered", "tautomerized", "teated", "teed", "teenaged", "teetotaled", "tenderhearted", "tentacled", "tenured", "termed", "ternated", "testbed", "testified", "theatricalised", "theatricalized", "themed", "thicketed", "thickskinned", "thickwalled", "thighed", "thimbled", "thimblewitted", "thonged", "thoroughbred", "thralled", "threated", "throated", "throughbred", "thyroidectomised", "thyroidectomized", "tiaraed", "ticktocked", "tidied", "tightassed", "tightfisted", "tightlipped", "timehonoured", "tindered", "tined", "tinselled", "tippytoed", "tiptoed", "titled", "toed", "tomahawked", "tonged", "toolshed", "toothplated", "toplighted", "torchlighted", "toughhearted", "traditionalized", "trajected", "tranced", "transgendered", "transliterated", "translocated", "transmogrified", "treadled", "treed", "treelined", "tressed", "trialled", "triangled", "trifoliated", "trifoliolated", "trilobed", "trucklebed", "truehearted", "trumpetshaped", "trumpetweed", "tuberculated", "tumbleweed", "tunnelshaped", "turbaned", "turreted", "turtlenecked", "tuskshaped", "tweed", "twigged", "typified", "ulcered", "ultracivilised", "ultracivilized", "ultracooled", "ultradignified", "ultradispersed", "ultrafiltered", "ultrared", "ultrasimplified", "ultrasophisticated", "unabandoned", "unabashed", "unabbreviated", "unabetted", "unabolished", "unaborted", "unabraded", "unabridged", "unabsolved", "unabsorbed", "unaccelerated", "unaccented", "unaccentuated", "unacclimatised", "unacclimatized", "unaccompanied", "unaccomplished", "unaccosted", "unaccredited", "unaccrued", "unaccumulated", "unaccustomed", "unacidulated", "unacquainted", "unacquitted", "unactivated", "unactuated", "unadapted", "unaddicted", "unadjourned", "unadjudicated", "unadjusted", "unadmonished", "unadopted", "unadored", "unadorned", "unadsorbed", "unadulterated", "unadvertised", "unaerated", "unaffiliated", "unaggregated", "unagitated", "unaimed", "unaired", "unaliased", "unalienated", "unaligned", "unallocated", "unalloyed", "unalphabetized", "unamassed", "unamortized", "unamplified", "unanaesthetised", "unanaesthetized", "unaneled", "unanesthetised", "unanesthetized", "unangered", "unannealed", "unannexed", "unannihilated", "unannotated", "unanointed", "unanticipated", "unappareled", "unappendaged", "unapportioned", "unapprenticed", "unapproached", "unappropriated", "unarbitrated", "unarched", "unarchived", "unarmored", "unarmoured", "unarticulated", "unascertained", "unashamed", "unaspirated", "unassembled", "unasserted", "unassessed", "unassociated", "unassorted", "unassuaged", "unastonished", "unastounded", "unatoned", "unattained", "unattainted", "unattenuated", "unattributed", "unauctioned", "unaudited", "unauthenticated", "unautographed", "unaverted", "unawaked", "unawakened", "unawarded", "unawed", "unbaffled", "unbaited", "unbalconied", "unbanded", "unbanished", "unbaptised", "unbaptized", "unbarreled", "unbarrelled", "unbattered", "unbeaded", "unbearded", "unbeneficed", "unbesotted", "unbetrayed", "unbetrothed", "unbiased", "unbiassed", "unbigoted", "unbilled", "unblackened", "unblanketed", "unblasphemed", "unblazoned", "unblistered", "unblockaded", "unbloodied", "unbodied", "unbonded", "unbothered", "unbounded", "unbracketed", "unbranded", "unbreaded", "unbrewed", "unbridged", "unbridled", "unbroached", "unbudgeted", "unbuffed", "unbuffered", "unburnished", "unbutchered", "unbuttered", "uncached", "uncaked", "uncalcified", "uncalibrated", "uncamouflaged", "uncamphorated", "uncanceled", "uncancelled", "uncapitalized", "uncarbonated", "uncarpeted", "uncased", "uncashed", "uncastrated", "uncatalogued", "uncatalysed", "uncatalyzed", "uncategorised", "uncatered", "uncaulked", "uncelebrated", "uncensored", "uncensured", "uncertified", "unchambered", "unchanneled", "unchannelled", "unchaperoned", "uncharacterized", "uncharted", "unchartered", "unchastened", "unchastised", "unchelated", "uncherished", "unchilled", "unchristened", "unchronicled", "uncircumcised", "uncircumscribed", "uncited", "uncivilised", "uncivilized", "unclarified", "unclassed", "unclassified", "uncleaved", "unclimbed", "unclustered", "uncluttered", "uncoagulated", "uncoded", "uncodified", "uncoerced", "uncoined", "uncollapsed", "uncollated", "uncolonised", "uncolonized", "uncolumned", "uncombined", "uncommented", "uncommercialised", "uncommercialized", "uncommissioned", "uncommitted", "uncompacted", "uncompartmentalized", "uncompartmented", "uncompensated", "uncompiled", "uncomplicated", "uncompounded", "uncomprehened", "uncomputed", "unconcealed", "unconceded", "unconcluded", "uncondensed", "unconditioned", "unconfined", "unconfirmed", "uncongested", "unconglomerated", "uncongratulated", "unconjugated", "unconquered", "unconsecrated", "unconsoled", "unconsolidated", "unconstipated", "unconstricted", "unconstructed", "unconsumed", "uncontacted", "uncontracted", "uncontradicted", "uncontrived", "unconverted", "unconveyed", "unconvicted", "uncooked", "uncooled", "uncoordinated", "uncopyrighted", "uncored", "uncorrelated", "uncorroborated", "uncosted", "uncounseled", "uncounselled", "uncounterfeited", "uncoveted", "uncrafted", "uncramped", "uncrannied", "uncrazed", "uncreamed", "uncreased", "uncreated", "uncredentialled", "uncredited", "uncrested", "uncrevassed", "uncrippled", "uncriticised", "uncriticized", "uncropped", "uncrosslinked", "uncrowded", "uncrucified", "uncrumbled", "uncrystalized", "uncrystallised", "uncrystallized", "uncubed", "uncuddled", "uncued", "unculled", "uncultivated", "uncultured", "uncupped", "uncurated", "uncurbed", "uncurried", "uncurtained", "uncushioned", "undamped", "undampened", "undappled", "undarkened", "undated", "undaubed", "undazzled", "undeadened", "undeafened", "undebated", "undebunked", "undeceased", "undecimalized", "undeciphered", "undecked", "undeclared", "undecomposed", "undeconstructed", "undedicated", "undefeated", "undeferred", "undefied", "undefined", "undeflected", "undefrauded", "undefrayed", "undegassed", "undejected", "undelegated", "undeleted", "undelimited", "undelineated", "undemented", "undemolished", "undemonstrated", "undenatured", "undenied", "undented", "undeodorized", "undepicted", "undeputized", "underaged", "underarmed", "underassessed", "underbred", "underbudgeted", "undercapitalised", "undercapitalized", "underdiagnosed", "underdocumented", "underequipped", "underexploited", "underexplored", "underfed", "underfeed", "underfurnished", "undergoverned", "undergrazed", "underinflated", "underinsured", "underinvested", "underived", "undermaintained", "undermentioned", "undermotivated", "underperceived", "underpowered", "underprivileged", "underqualified", "underrehearsed", "underresourced", "underripened", "undersaturated", "undersexed", "undersized", "underspecified", "understaffed", "understocked", "understressed", "understudied", "underutilised", "underventilated", "undescaled", "undesignated", "undetached", "undetailed", "undetained", "undeteriorated", "undeterred", "undetonated", "undevised", "undevoted", "undevoured", "undiagnosed", "undialed", "undialysed", "undialyzed", "undiapered", "undiffracted", "undigested", "undignified", "undiluted", "undiminished", "undimmed", "undipped", "undirected", "undisciplined", "undiscouraged", "undiscussed", "undisfigured", "undisguised", "undisinfected", "undismayed", "undisposed", "undisproved", "undisputed", "undisrupted", "undissembled", "undissipated", "undissociated", "undissolved", "undistilled", "undistorted", "undistracted", "undistributed", "undisturbed", "undiversified", "undiverted", "undivulged", "undoctored", "undocumented", "undomesticated", "undosed", "undramatised", "undrilled", "undrugged", "undubbed", "unduplicated", "uneclipsed", "unedged", "unedited", "unejaculated", "unejected", "unelaborated", "unelapsed", "unelected", "unelectrified", "unelevated", "unelongated", "unelucidated", "unemaciated", "unemancipated", "unemasculated", "unembalmed", "unembed", "unembellished", "unembodied", "unemboldened", "unemerged", "unenacted", "unencoded", "unencrypted", "unencumbered", "unendangered", "unendorsed", "unenergized", "unenfranchised", "unengraved", "unenhanced", "unenlarged", "unenlivened", "unenraptured", "unenriched", "unentangled", "unentitled", "unentombed", "unentranced", "unentwined", "unenumerated", "unenveloped", "unenvied", "unequaled", "unequalised", "unequalized", "unequalled", "unequipped", "unerased", "unerected", "uneroded", "unerupted", "unescorted", "unestablished", "unevaluated", "unexaggerated", "unexampled", "unexcavated", "unexceeded", "unexcelled", "unexecuted", "unexerted", "unexhausted", "unexpensed", "unexperienced", "unexpired", "unexploited", "unexplored", "unexposed", "unexpurgated", "unextinguished", "unfabricated", "unfaceted", "unfanned", "unfashioned", "unfathered", "unfathomed", "unfattened", "unfavored", "unfavoured", "unfazed", "unfeathered", "unfed", "unfeigned", "unfermented", "unfertilised", "unfertilized", "unfilleted", "unfiltered", "unfinished", "unflavored", "unflavoured", "unflawed", "unfledged", "unfleshed", "unflurried", "unflushed", "unflustered", "unfluted", "unfocussed", "unforested", "unformatted", "unformulated", "unfortified", "unfractionated", "unfractured", "unfragmented", "unfrequented", "unfretted", "unfrosted", "unfueled", "unfunded", "unfurnished", "ungarbed", "ungarmented", "ungarnished", "ungeared", "ungerminated", "ungifted", "unglazed", "ungoverned", "ungraded", "ungrasped", "ungratified", "ungroomed", "ungrounded", "ungrouped", "ungummed", "ungusseted", "unhabituated", "unhampered", "unhandicapped", "unhardened", "unharvested", "unhasped", "unhatched", "unheralded", "unhindered", "unhomogenised", "unhomogenized", "unhonored", "unhonoured", "unhooded", "unhusked", "unhyphenated", "unified", "unillustrated", "unimpacted", "unimpaired", "unimpassioned", "unimpeached", "unimpelled", "unimplemented", "unimpregnated", "unimprisoned", "unimpugned", "unincorporated", "unincubated", "unincumbered", "unindemnified", "unindexed", "unindicted", "unindorsed", "uninduced", "unindustrialised", "unindustrialized", "uninebriated", "uninfected", "uninflated", "uninflected", "uninhabited", "uninhibited", "uninitialised", "uninitialized", "uninitiated", "uninoculated", "uninseminated", "uninsulated", "uninsured", "uninterpreted", "unintimidated", "unintoxicated", "unintroverted", "uninucleated", "uninverted", "uninvested", "uninvolved", "unissued", "unjaundiced", "unjointed", "unjustified", "unkeyed", "unkindled", "unlabelled", "unlacquered", "unlamented", "unlaminated", "unlarded", "unlaureled", "unlaurelled", "unleaded", "unleavened", "unled", "unlettered", "unlicenced", "unlighted", "unlimbered", "unlimited", "unlined", "unlipped", "unliquidated", "unlithified", "unlittered", "unliveried", "unlobed", "unlocalised", "unlocalized", "unlocated", "unlogged", "unlubricated", "unmagnified", "unmailed", "unmaimed", "unmaintained", "unmalted", "unmangled", "unmanifested", "unmanipulated", "unmannered", "unmanufactured", "unmapped", "unmarred", "unmastered", "unmatriculated", "unmechanised", "unmechanized", "unmediated", "unmedicated", "unmentioned", "unmerged", "unmerited", "unmetabolised", "unmetabolized", "unmetamorphosed", "unmethylated", "unmineralized", "unmitigated", "unmoderated", "unmodernised", "unmodernized", "unmodified", "unmodulated", "unmolded", "unmolested", "unmonitored", "unmortgaged", "unmotivated", "unmotorised", "unmotorized", "unmounted", "unmutated", "unmutilated", "unmyelinated", "unnaturalised", "unnaturalized", "unnotched", "unnourished", "unobligated", "unobstructed", "unoccupied", "unoiled", "unopposed", "unoptimised", "unordained", "unorganised", "unorganized", "unoriented", "unoriginated", "unornamented", "unoxidized", "unoxygenated", "unpacified", "unpackaged", "unpaired", "unparalleled", "unparallelled", "unparasitized", "unpardoned", "unparodied", "unpartitioned", "unpasteurised", "unpasteurized", "unpatented", "unpaved", "unpedigreed", "unpenetrated", "unpenned", "unperfected", "unperjured", "unpersonalised", "unpersuaded", "unperturbed", "unperverted", "unpestered", "unphosphorylated", "unphotographed", "unpigmented", "unpiloted", "unpledged", "unploughed", "unplumbed", "unpoised", "unpolarized", "unpoliced", "unpolled", "unpopulated", "unposed", "unpowered", "unprecedented", "unpredicted", "unprejudiced", "unpremeditated", "unprescribed", "unpressurised", "unpressurized", "unpriced", "unprimed", "unprincipled", "unprivileged", "unprized", "unprocessed", "unprofaned", "unprofessed", "unprohibited", "unprompted", "unpronounced", "unproposed", "unprospected", "unproved", "unpruned", "unpublicised", "unpublicized", "unpublished", "unpuckered", "unpunctuated", "unpurified", "unqualified", "unquantified", "unquenched", "unquoted", "unranked", "unrated", "unratified", "unrebuked", "unreckoned", "unrecompensed", "unreconciled", "unreconstructed", "unrectified", "unredeemed", "unrefined", "unrefreshed", "unrefrigerated", "unregarded", "unregimented", "unregistered", "unregulated", "unrehearsed", "unrelated", "unrelieved", "unrelinquished", "unrenewed", "unrented", "unrepealed", "unreplicated", "unreprimanded", "unrequited", "unrespected", "unrestricted", "unretained", "unretarded", "unrevised", "unrevived", "unrevoked", "unrifled", "unripened", "unrivaled", "unrivalled", "unroasted", "unroofed", "unrounded", "unruffled", "unsalaried", "unsalted", "unsanctified", "unsanctioned", "unsanded", "unsaponified", "unsated", "unsatiated", "unsatisfied", "unsaturated", "unscaled", "unscarred", "unscathed", "unscented", "unscheduled", "unschooled", "unscreened", "unscripted", "unseamed", "unseared", "unseasoned", "unseeded", "unsegmented", "unsegregated", "unselected", "unserviced", "unsexed", "unshamed", "unshaped", "unsharpened", "unsheared", "unshielded", "unshifted", "unshirted", "unshoed", "unshuttered", "unsifted", "unsighted", "unsilenced", "unsimplified", "unsized", "unskewed", "unskinned", "unslaked", "unsliced", "unsloped", "unsmoothed", "unsoiled", "unsoldered", "unsolicited", "unsolved", "unsophisticated", "unsorted", "unsourced", "unsoured", "unspaced", "unspanned", "unspecialised", "unspecialized", "unspecified", "unspiced", "unstaged", "unstandardised", "unstandardized", "unstapled", "unstarched", "unstarred", "unstated", "unsteadied", "unstemmed", "unsterilised", "unsterilized", "unstickered", "unstiffened", "unstifled", "unstigmatised", "unstigmatized", "unstilted", "unstippled", "unstipulated", "unstirred", "unstocked", "unstoked", "unstoppered", "unstratified", "unstressed", "unstriped", "unstructured", "unstudied", "unstumped", "unsubdued", "unsubmitted", "unsubsidised", "unsubsidized", "unsubstantiated", "unsubstituted", "unsugared", "unsummarized", "unsupervised", "unsuprised", "unsurveyed", "unswayed", "unsweetened", "unsyllabled", "unsymmetrized", "unsynchronised", "unsynchronized", "unsyncopated", "unsyndicated", "unsynthesized", "unsystematized", "untagged", "untainted", "untalented", "untanned", "untaped", "untapered", "untargeted", "untarnished", "untattooed", "untelevised", "untempered", "untenanted", "unterminated", "untextured", "unthickened", "unthinned", "unthrashed", "unthreaded", "unthrottled", "unticketed", "untiled", "untilled", "untilted", "untimbered", "untinged", "untinned", "untinted", "untitled", "untoasted", "untoggled", "untoothed", "untopped", "untoughened", "untracked", "untrammeled", "untrammelled", "untranscribed", "untransduced", "untransferred", "untranslated", "untransmitted", "untraumatized", "untraversed", "untufted", "untuned", "untutored", "unupgraded", "unupholstered", "unutilised", "unutilized", "unuttered", "unvaccinated", "unvacuumed", "unvalidated", "unvalued", "unvandalized", "unvaned", "unvanquished", "unvapourised", "unvapourized", "unvaried", "unvariegated", "unvarnished", "unvented", "unventilated", "unverbalised", "unverbalized", "unverified", "unversed", "unvetted", "unvictimized", "unviolated", "unvitrified", "unvocalized", "unvoiced", "unwaged", "unwarped", "unwarranted", "unwaxed", "unweakened", "unweaned", "unwearied", "unweathered", "unwebbed", "unwed", "unwedded", "unweeded", "unweighted", "unwelded", "unwinterized", "unwired", "unwitnessed", "unwonted", "unwooded", "unworshipped", "unwounded", "unzoned", "uprated", "uprighted", "upsized", "upswelled", "vacuolated", "valanced", "valueoriented", "varied", "vascularised", "vascularized", "vasectomised", "vaunted", "vectorised", "vectorized", "vegged", "verdured", "verified", "vermiculated", "vernacularized", "versified", "verticillated", "vesiculated", "vied", "vilified", "virtualised", "vitrified", "vivified", "volumed", "vulcanised", "wabbled", "wafered", "waisted", "walleyed", "wared", "warmblooded", "warmhearted", "warted", "waterbased", "waterbed", "watercooled", "watersaturated", "watershed", "wavegenerated", "waxweed", "weakhearted", "weakkneed", "weakminded", "wearied", "weatherised", "weatherstriped", "webfooted", "wedgeshaped", "weed", "weeviled", "welladapted", "welladjusted", "wellbred", "wellconducted", "welldefined", "welldisposed", "welldocumented", "wellequipped", "wellestablished", "wellfavored", "wellfed", "wellgrounded", "wellintentioned", "wellmannered", "wellminded", "wellorganised", "wellrounded", "wellshaped", "wellstructured", "whinged", "whinnied", "whiplashed", "whiskered", "wholehearted", "whorled", "widebased", "wideeyed", "widemeshed", "widemouthed", "widenecked", "widespaced", "wilded", "wildered", "wildeyed", "willinghearted", "windspeed", "winterfed", "winterfeed", "winterised", "wirehaired", "wised", "witchweed", "woaded", "wombed", "wooded", "woodshed", "wooled", "woolled", "woollyhaired", "woollystemmed", "woolyhaired", "woolyminded", "wormholed", "wormshaped", "wrappered", "wretched", "wronghearted", "ycleped", "yolked", "zincified", "zinckified", "zinkified", "zombified"];

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/regularParticiplesRegex.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/config/regularParticiplesRegex.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.regularParticiplesRegex = void 0;
/**
 * A Regex that recognizes regular participles. NOTE: this often coincides with simple past forms.
 * @type {RegExp}
 */
const regularParticiplesRegex = exports.regularParticiplesRegex = /\w+ed($|[ \n\r\t.,'()"+\-;!?:/»«‹›<>])/ig;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/stopWords.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/config/stopWords.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Returns a list with stopwords for the English passive voice assessment.
 * @type {Array} The list with stopwords.
 */
var _default = exports["default"] = ["to", "which", "who", "whom", "that", "whose", "after", "although", "as", "because", "before", "even if", "even though", "if", "in order that", "inasmuch", "lest", "once", "provided", "since", "so that", "than", "though", "till", "unless", "until", "when", "whenever", "where", "whereas", "wherever", "whether", "while", "why", "by the time", "supposing", "no matter", "how", "what", "won't", "do", "does", "–", "and", "but", "or"];

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/transitionWords.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/config/transitionWords.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.singleWords = exports.multipleWords = exports["default"] = exports.allWords = void 0;
/** @module config/transitionWords */

const singleWords = exports.singleWords = ["accordingly", "additionally", "afterward", "afterwards", "albeit", "also", "although", "altogether", "another", "basically", "because", "before", "besides", "but", "certainly", "chiefly", "comparatively", "concurrently", "consequently", "contrarily", "conversely", "correspondingly", "despite", "doubtedly", "during", "e.g.", "earlier", "emphatically", "equally", "especially", "eventually", "evidently", "explicitly", "finally", "firstly", "following", "formerly", "forthwith", "fourthly", "further", "furthermore", "generally", "hence", "henceforth", "however", "i.e.", "identically", "indeed", "initially", "instead", "last", "lastly", "later", "lest", "likewise", "markedly", "meanwhile", "moreover", "nevertheless", "nonetheless", "nor", "notwithstanding", "obviously", "occasionally", "otherwise", "overall", "particularly", "presently", "previously", "rather", "regardless", "secondly", "shortly", "significantly", "similarly", "simultaneously", "since", "so", "soon", "specifically", "still", "straightaway", "subsequently", "surely", "surprisingly", "than", "then", "thereafter", "therefore", "thereupon", "thirdly", "though", "thus", "till", "undeniably", "undoubtedly", "unless", "unlike", "unquestionably", "until", "when", "whenever", "whereas", "while"];
const multipleWords = exports.multipleWords = ["above all", "after all", "after that", "all in all", "all of a sudden", "all things considered", "analogous to", "although this may be true", "analogous to", "another key point", "as a matter of fact", "as a result", "as an illustration", "as can be seen", "as has been noted", "as I have noted", "as I have said", "as I have shown", "as long as", "as much as", "as opposed to", "as shown above", "as soon as", "as well as", "at any rate", "at first", "at last", "at least", "at length", "at the present time", "at the same time", "at this instant", "at this point", "at this time", "balanced against", "being that", "by all means", "by and large", "by comparison", "by the same token", "by the time", "compared to", "be that as it may", "coupled with", "different from", "due to", "equally important", "even if", "even more", "even so", "even though", "first thing to remember", "for example", "for fear that", "for instance", "for one thing", "for that reason", "for the most part", "for the purpose of", "for the same reason", "for this purpose", "for this reason", "from time to time", "given that", "given these points", "important to realize", "in a word", "in addition", "in another case", "in any case", "in any event", "in brief", "in case", "in conclusion", "in contrast", "in detail", "in due time", "in effect", "in either case", "in essence", "in fact", "in general", "in light of", "in like fashion", "in like manner", "in order that", "in order to", "in other words", "in particular", "in reality", "in short", "in similar fashion", "in spite of", "in sum", "in summary", "in that case", "in the event that", "in the final analysis", "in the first place", "in the fourth place", "in the hope that", "in the light of", "in the long run", "in the meantime", "in the same fashion", "in the same way", "in the second place", "in the third place", "in this case", "in this situation", "in time", "in truth", "in view of", "inasmuch as", "most compelling evidence", "most important", "must be remembered", "not only", "not to mention", "note that", "now that", "of course", "on account of", "on balance", "on condition that", "on one hand", "on the condition that", "on the contrary", "on the negative side", "on the other hand", "on the positive side", "on the whole", "on this occasion", "once", "once in a while", "only if", "owing to", "point often overlooked", "prior to", "provided that", "seeing that", "so as to", "so far", "so long as", "so that", "sooner or later", "such as", "summing up", "take the case of", "that is", "that is to say", "then again", "this time", "to be sure", "to begin with", "to clarify", "to conclude", "to demonstrate", "to emphasize", "to enumerate", "to explain", "to illustrate", "to list", "to point out", "to put it another way", "to put it differently", "to repeat", "to rephrase it", "to say nothing of", "to sum up", "to summarize", "to that end", "to the end that", "to this end", "together with", "under those circumstances", "until now", "up against", "up to the present time", "vis a vis", "what's more", "while it may be true", "while this may be true", "with attention to", "with the result that", "with this in mind", "with this intention", "with this purpose in mind", "without a doubt", "without delay", "without doubt", "without reservation"];
const allWords = exports.allWords = singleWords.concat(multipleWords);
var _default = exports["default"] = allWords;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/twoPartTransitionWords.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/config/twoPartTransitionWords.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/** @module config/twoPartTransitionWords */
/**
 * Returns an array with two-part transition words to be used by the assessments.
 * @type {Array} The array filled with two-part transition words.
 */
var _default = exports["default"] = [["both", "and"], ["if", "then"], ["not only", "but also"], ["neither", "nor"], ["either", "or"], ["not", "but"], ["whether", "or"], ["no sooner", "than"]];

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/wordComplexity.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/config/wordComplexity.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
// This is a config for the Word Complexity assessment. As such, this helper is not bundled in Yoast SEO.
var _default = exports["default"] = {
  wordLength: 7,
  doesUpperCaseDecreaseComplexity: true
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/calculateFleschReadingScore.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/calculateFleschReadingScore.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = calculateScore;
var _yoastseo = __webpack_require__(/*! yoastseo */ "./node_modules/yoastseo/build/index.js");
const {
  formatNumber
} = _yoastseo.helpers;

/**
 * Returns the Flesch reading score for English.
 *
 * @param {Object} statistics The Flesch reading statistics.
 *
 * @returns {number} The Flesch reading score for English.
 */
function calculateScore(statistics) {
  const score = 206.835 - 1.015 * statistics.averageWordsPerSentence - 84.6 * (statistics.numberOfSyllables / statistics.numberOfWords);
  return formatNumber(score);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/checkIfWordIsComplex.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/checkIfWordIsComplex.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = checkIfWordIsComplex;
var _buildFormRule = _interopRequireDefault(__webpack_require__(/*! ../../../helpers/morphology/buildFormRule */ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/buildFormRule.js"));
var _createRulesFromArrays = _interopRequireDefault(__webpack_require__(/*! ../../../helpers/morphology/createRulesFromArrays */ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/createRulesFromArrays.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Checks if a word is complex.
 * This is a helper for the Word Complexity assessment. As such, this helper is not bundled in Yoast SEO.
 *
 * @param {object} config The configuration needed for assessing the word's complexity, e.g., the frequency list.
 * @param {string} word The word to check.
 * @param {object}	premiumData The object that contains data for the assessment including the frequency list.
 *
 * @returns {boolean} Whether or not a word is complex.
 */
function checkIfWordIsComplex(config, word, premiumData) {
  const lengthLimit = config.wordLength;
  const frequencyList = premiumData.frequencyList.list;

  // Whether uppercased beginning of a word decreases its complexity.
  const doesUpperCaseDecreaseComplexity = config.doesUpperCaseDecreaseComplexity;

  // The word is not complex if it's less than or the same as the length limit, i.e. 7 characters for English.
  if (word.length <= lengthLimit) {
    return false;
  }

  // The word is not complex if it starts with a capital and thus is assumed to be a named entity.
  if (doesUpperCaseDecreaseComplexity && word[0].toLowerCase() !== word[0]) {
    return false;
  }

  // The word is not complex if it's in the frequency list.
  if (frequencyList.includes(word)) {
    return false;
  }

  // The word is not complex if its singular form is in the frequency list.
  if (premiumData) {
    const singular = (0, _buildFormRule.default)(word, (0, _createRulesFromArrays.default)(premiumData.nouns.regexNoun.singularize));
    return !frequencyList.includes(singular);
  }
  return true;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/getClauses.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/getClauses.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getEnglishClauses;
var _yoastseo = __webpack_require__(/*! yoastseo */ "./node_modules/yoastseo/build/index.js");
var _Clause = _interopRequireDefault(__webpack_require__(/*! ../values/Clause */ "./node_modules/yoastseo/build/languageProcessing/languages/en/values/Clause.js"));
var _passiveVoiceAuxiliaries = _interopRequireDefault(__webpack_require__(/*! ../config/internal/passiveVoiceAuxiliaries.js */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/internal/passiveVoiceAuxiliaries.js"));
var _stopWords = _interopRequireDefault(__webpack_require__(/*! ../config/stopWords.js */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/stopWords.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _stripSpaces = _interopRequireDefault(__webpack_require__(/*! ../../../helpers/sanitize/stripSpaces */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripSpaces.js"));
var _indices = __webpack_require__(/*! ../../../helpers/word/indices */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/indices.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const {
  createRegexFromArray,
  getClauses
} = _yoastseo.languageProcessing;
const options = {
  Clause: _Clause.default,
  stopwords: _stopWords.default,
  auxiliaries: _passiveVoiceAuxiliaries.default,
  ingExclusions: ["king", "cling", "ring", "being", "thing", "something", "anything"],
  regexes: {
    auxiliaryRegex: createRegexFromArray(_passiveVoiceAuxiliaries.default),
    stopCharacterRegex: /([:,]|('ll)|('ve))(?=[ \n\r\t'"+\-»«‹›<>])/ig,
    verbEndingInIngRegex: /\w+ing(?=$|[ \n\r\t.,'()"+\-;!?:/»«‹›<>])/ig
  },
  otherStopWordIndices: []
};

/**
 * Gets active verbs (ending in ing) to determine sentence breakers in English.
 *
 * @param {string} sentence The sentence to get the active verbs from.
 *
 * @returns {Array} The array with valid matches.
 */
const getVerbsEndingInIngIndices = function (sentence) {
  // Matches the sentences with words ending in ing.
  let matches = sentence.match(options.regexes.verbEndingInIngRegex) || [];
  // Filters out words ending in -ing that aren't verbs.
  matches = matches.filter(match => !(0, _lodash.includes)(options.ingExclusions, (0, _stripSpaces.default)(match)));
  return (0, _indices.getIndicesByWordList)(matches, sentence);
};

/**
 * Gets the clauses from a sentence by determining sentence breakers.
 *
 * @param {string} sentence The sentence to split up in clauses.
 *
 * @returns {Array} The array with all clauses that have an auxiliary.
 */
function getEnglishClauses(sentence) {
  options.otherStopWordIndices = getVerbsEndingInIngIndices(sentence);
  return getClauses(sentence, options);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/getStemmer.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/getStemmer.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getStemmer;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _yoastseo = __webpack_require__(/*! yoastseo */ "./node_modules/yoastseo/build/index.js");
var _determineStem = _interopRequireDefault(__webpack_require__(/*! ./internal/determineStem */ "./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/internal/determineStem.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const {
  baseStemmer
} = _yoastseo.languageProcessing;
/**
 * Returns the stemmer for a researcher.
 *
 * @param {Researcher} researcher The researcher.
 *
 * @returns {Function} The stemmer.
 */
function getStemmer(researcher) {
  const morphologyData = (0, _lodash.get)(researcher.getData("morphology"), "en", false);
  if (morphologyData) {
    return word => (0, _determineStem.default)(word, morphologyData);
  }
  return baseStemmer;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/internal/determineStem.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/internal/determineStem.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
exports.determineIrregularStem = determineIrregularStem;
exports.determineIrregularVerbStem = determineIrregularVerbStem;
exports.determineRegularStem = determineRegularStem;
exports.determineStem = determineStem;
exports.findShortestAndAlphabeticallyFirst = findShortestAndAlphabeticallyFirst;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _yoastseo = __webpack_require__(/*! yoastseo */ "./node_modules/yoastseo/build/index.js");
var _getAdjectiveStem = _interopRequireDefault(__webpack_require__(/*! ./getAdjectiveStem */ "./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/internal/getAdjectiveStem.js"));
var _getVerbStem = __webpack_require__(/*! ./getVerbStem.js */ "./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/internal/getVerbStem.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const {
  buildFormRule,
  createRulesFromArrays
} = _yoastseo.languageProcessing;
/**
 * Gets the shortest of the alphabetically ordered strings from an array.
 *
 * @param {string[]} array  The array of strings.
 *
 * @returns {string|undefined}  The shortest of the alphabetically ordered strings from the input array;
 *                              undefined if the input array is empty.
 */
function findShortestAndAlphabeticallyFirst(array) {
  const strings = (0, _lodash.flatten)(array);
  let result = strings.pop();
  strings.forEach(str => {
    const lengthDifference = str.length - result.length;
    if (lengthDifference === 0) {
      if (str.localeCompare(result) < 0) {
        result = str;
      }
    } else if (lengthDifference < 0) {
      result = str;
    }
  });
  return result;
}

/**
 * Checks if the input word occurs in the list of exceptions and if so returns the first form of the paradigm, which is
 * always the base.
 *
 * @param {string} word                 The word for which to determine its base.
 * @param {Array}  irregulars           An array of irregular nouns and adjectives.
 *
 * @returns {string|null} The base form of the irregular word; null if no irregular stem was found.
 */
function determineIrregularStem(word, irregulars) {
  for (let i = 0; i < irregulars.length; i++) {
    const paradigm = irregulars[i];
    for (let j = 0; j < paradigm.length; j++) {
      if (paradigm[j] === word) {
        return paradigm[0];
      }
    }
  }
  return null;
}

/**
 * Checks if the input word occurs in the list of exception verbs and if so returns the first form
 * of the paradigm, which is always the base. Contrary to nouns and adjectives, irregular verbs can have different prefixes
 * which are not included in the list of exceptions and have to be processed separately.
 *
 * @param {string}    word            The word for which to determine its base.
 * @param {Object}    verbMorphology  Regexes and irregulars for verb morphology, False if verb rules should not be applied.
 *
 * @returns {string|null} The base form of the irregular word; null if no irregular stem was found.
 */
function determineIrregularVerbStem(word, verbMorphology) {
  const paradigmIfIrregularVerb = (0, _getVerbStem.checkIrregulars)(word, verbMorphology.irregularVerbs, verbMorphology.regexVerb.verbPrefixes);
  if (!(0, _lodash.isUndefined)(paradigmIfIrregularVerb)) {
    return paradigmIfIrregularVerb[0];
  }
  return null;
}

/**
 * Gets possible stems as a regular noun, adjective and verb.
 *
 * @param {string} word              The word for which to determine its base.
 * @param {Object} morphologyData    The morphology data for the language.
 *
 * @returns {string} The shortest and the alphabetically-first of possible noun-like, verb-like and adjective-like bases.
 */
function determineRegularStem(word, morphologyData) {
  // Try to singularize as a noun.
  const regexVerb = morphologyData.verbs.regexVerb;
  const baseIfPluralNoun = buildFormRule(word, createRulesFromArrays(morphologyData.nouns.regexNoun.singularize));
  if (!(0, _lodash.isUndefined)(baseIfPluralNoun)) {
    // Bring ing-nouns to base forms ("blessings" -> "bless").
    if ((0, _getVerbStem.endsWithIng)(baseIfPluralNoun)) {
      return buildFormRule(baseIfPluralNoun, createRulesFromArrays(regexVerb.ingFormToInfinitive));
    }
    return baseIfPluralNoun;
  }

  // Check if the word ends with "ic", "ical" or "ically". Return the "ical" form for consistency.
  const regexAdjective = morphologyData.adjectives.regexAdjective;
  const baseIfIcally = buildFormRule(word, createRulesFromArrays(regexAdjective.icallyToBase));
  if (!(0, _lodash.isUndefined)(baseIfIcally)) {
    return baseIfIcally;
  }

  // No more quick guesses, we have to determine a verbal infinitive and an adjectival base.
  const possibleRegularBases = [];

  // Verbal infinitive.
  const baseIfVerb = (0, _getVerbStem.getInfinitive)(word, regexVerb).infinitive;
  possibleRegularBases.push(baseIfVerb);

  // Adjectival base.
  const stopAdjectives = morphologyData.adjectives.stopAdjectives;
  const baseIfAdjective = (0, _getAdjectiveStem.default)(word, regexAdjective, stopAdjectives).base;
  possibleRegularBases.push(baseIfAdjective);
  return findShortestAndAlphabeticallyFirst(possibleRegularBases);
}

/**
 * Returns the stem of the input word using the morphologyData (language-specific).
 *
 * @param   {string} word           The word to get the stem for.
 * @param   {Object} morphologyData The available morphology data per language (false if unavailable).
 *
 * @returns {string} Stemmed (or base) form of the word.
 */
function determineStem(word, morphologyData) {
  const nounMorphology = morphologyData.nouns;
  const baseIfPossessive = buildFormRule(word, createRulesFromArrays(nounMorphology.regexNoun.possessiveToBase));
  let stem, irregular;

  // Determine if this is an irregular noun, adjective or verb.
  if ((0, _lodash.isUndefined)(baseIfPossessive)) {
    stem = word;
    // Word can be a noun, adjective or verb.
    irregular = determineIrregularStem(word, nounMorphology.irregularNouns) || determineIrregularStem(word, morphologyData.adjectives.irregularAdjectives) || determineIrregularVerbStem(word, morphologyData.verbs);
  } else {
    stem = baseIfPossessive;
    // The word is a possessive, it can only be a noun or an ing-noun;
    irregular = determineIrregularStem(baseIfPossessive, nounMorphology.irregularNouns);
  }
  if (irregular) {
    // Found the stem of an irregular word! Return it.
    return irregular;
  }

  // Treat the word as a regular noun, adjective or verb.
  return determineRegularStem(stem, morphologyData);
}
var _default = exports["default"] = determineStem;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/internal/getAdjectiveStem.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/internal/getAdjectiveStem.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _yoastseo = __webpack_require__(/*! yoastseo */ "./node_modules/yoastseo/build/index.js");
// "use strict";

const {
  buildFormRule,
  createRulesFromArrays
} = _yoastseo.languageProcessing;

/**
 * Constructs a function that checks if the input word can be a specific adjectival form.
 *
 * @param {string}      endsWith            How the form ends.
 * @param {int}         minimumWordLength   How long the word should be to classify for this form.
 * @param {string[]}    exceptions          The list of words with that ending (endsWith) which are not this form.
 *
 * @returns {Function} A function that checks if the input word can be a specific adjectival form.
 */
const constructCanBeFunction = function (endsWith, minimumWordLength, exceptions) {
  return word => {
    const wordLength = word.length;
    if (wordLength < minimumWordLength) {
      return false;
    }
    const doesEndWith = word.substring(wordLength - endsWith.length, wordLength) === endsWith;
    return doesEndWith && !exceptions.includes(word);
  };
};

/**
 * Forms the base form from an input word.
 *
 * @param {string}   word                                  The word to build the base form for.
 * @param {Object}   regexAdjective                        The lists of regexes to apply to stem adjectives.
 * @param {Array}    regexAdjective.comparativeToBaseRegex The Array of regex-based rules to bring comparatives to base.
 * @param {Array}    regexAdjective.superlativeToBaseRegex The Array of regex-based rules to bring superlatives to base.
 * @param {Array}    regexAdjective.adverbToBaseRegex      The Array of regex-based rules to bring adverbs to base.
 * @param {Object}   stopAdjectives                        The lists of words that are not adverbs.
 * @param {string[]} stopAdjectives.erExceptions           The list of words that end with -er and are not comparatives.
 * @param {string[]} stopAdjectives.estExceptions          The list of words that end with -est and are not superlatives.
 * @param {string[]} stopAdjectives.lyExceptions           The list of words that end with -ly and are not adverbs.
 *
 * @returns {Object} The base form of the input word.
 */
function _default(word, regexAdjective, stopAdjectives) {
  /*
   * Check comparatives: Consider only words of four letters or more (otherwise, words like "per" are being treated
   * as comparatives).
   */
  const canBeComparative = constructCanBeFunction("er", 4, stopAdjectives.erExceptions);
  if (canBeComparative(word)) {
    const comparativeToBaseRegex = createRulesFromArrays(regexAdjective.comparativeToBase);
    return {
      base: buildFormRule(word, comparativeToBaseRegex) || word,
      guessedForm: "er"
    };
  }

  /*
   * Check superlatives: Consider only words of five letters or more (otherwise, words like "test" are being treated
   * as superlatives).
   */
  const canBeSuperlative = constructCanBeFunction("est", 5, stopAdjectives.estExceptions);
  if (canBeSuperlative(word)) {
    const superlativeToBaseRegex = createRulesFromArrays(regexAdjective.superlativeToBase);
    return {
      base: buildFormRule(word, superlativeToBaseRegex) || word,
      guessedForm: "est"
    };
  }

  /*
   * Check ly-adverbs: Consider only words of five letters or more (otherwise, words like "lily" are being treated
   * as ly-adverbs).
   */
  const canBeLyAdverb = constructCanBeFunction("ly", 5, stopAdjectives.lyExceptions);
  if (canBeLyAdverb(word)) {
    const adverbToBaseRegex = createRulesFromArrays(regexAdjective.adverbToBase);
    return {
      base: buildFormRule(word, adverbToBaseRegex),
      guessedForm: "ly"
    };
  }
  return {
    base: word,
    guessedForm: "base"
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/internal/getParticiples.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/internal/getParticiples.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getParticiples;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _yoastseo = __webpack_require__(/*! yoastseo */ "./node_modules/yoastseo/build/index.js");
var _passiveVoiceIrregulars = _interopRequireDefault(__webpack_require__(/*! ../../config/internal/passiveVoiceIrregulars */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/internal/passiveVoiceIrregulars.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const {
  matchRegularParticiples,
  getWords
} = _yoastseo.languageProcessing;
/**
 * Creates participle array for the participles found in a clause.
 *
 * @param {string} clauseText The clause to find participles in
 *
 * @returns {Array} The list with participles.
 */
function getParticiples(clauseText) {
  const words = getWords(clauseText);
  const foundParticiples = [];
  (0, _lodash.forEach)(words, function (word) {
    const regex = [/\w+ed($|[ \n\r\t.,'()"+\-;!?:/»«‹›<>])/ig];
    if (matchRegularParticiples(word, regex).length !== 0 || (0, _lodash.includes)(_passiveVoiceIrregulars.default, word)) {
      foundParticiples.push(word);
    }
  });
  return foundParticiples;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/internal/getVerbStem.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/internal/getVerbStem.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.normalizePrefixed = exports.getInfinitive = exports.endsWithIng = exports.checkIrregulars = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _yoastseo = __webpack_require__(/*! yoastseo */ "./node_modules/yoastseo/build/index.js");
// "use strict";

const {
  buildFormRule,
  createRulesFromArrays
} = _yoastseo.languageProcessing;
const vowelRegex = /([aeiouy])/g;

/**
 * Checks if the input word has one of the standard verb prefixes and if so returns a prefix and a de-prefixed verb to be
 * further used to compare with the list of irregular verbs.
 *
 * @param {string} word             The word for which to determine if it has one of the standard verb prefixes.
 * @param {Object} verbPrefixes     The collection of verb prefixes to be used for normalization
 *
 * @returns {Array} Array of word forms from the exception list.
 */
const normalizePrefixed = function (word, verbPrefixes) {
  for (const property in verbPrefixes) {
    if (verbPrefixes.hasOwnProperty) {
      verbPrefixes[property] = new RegExp(verbPrefixes[property], "i");
    }
  }
  if (verbPrefixes.sevenLetterHyphenPrefixes.test(word) === true) {
    return {
      normalizedWord: word.replace(verbPrefixes.sevenLetterHyphenPrefixes, ""),
      prefix: word.substring(0, 8)
    };
  }
  if (verbPrefixes.sevenLetterPrefixes.test(word) === true) {
    return {
      normalizedWord: word.replace(verbPrefixes.sevenLetterPrefixes, ""),
      prefix: word.substring(0, 7)
    };
  }
  if (verbPrefixes.fiveLetterHyphenPrefixes.test(word) === true) {
    return {
      normalizedWord: word.replace(verbPrefixes.fiveLetterHyphenPrefixes, ""),
      prefix: word.substring(0, 6)
    };
  }
  if (verbPrefixes.fiveLetterPrefixes.test(word) === true) {
    return {
      normalizedWord: word.replace(verbPrefixes.fiveLetterPrefixes, ""),
      prefix: word.substring(0, 5)
    };
  }
  if (verbPrefixes.fourLetterHyphenPrefixes.test(word) === true) {
    return {
      normalizedWord: word.replace(verbPrefixes.fourLetterHyphenPrefixes, ""),
      prefix: word.substring(0, 5)
    };
  }
  if (verbPrefixes.fourLetterPrefixes.test(word) === true) {
    return {
      normalizedWord: word.replace(verbPrefixes.fourLetterPrefixes, ""),
      prefix: word.substring(0, 4)
    };
  }
  if (verbPrefixes.threeLetterHyphenPrefixes.test(word) === true) {
    return {
      normalizedWord: word.replace(verbPrefixes.threeLetterHyphenPrefixes, ""),
      prefix: word.substring(0, 4)
    };
  }
  if (verbPrefixes.threeLetterPrefixes.test(word) === true) {
    return {
      normalizedWord: word.replace(verbPrefixes.threeLetterPrefixes, ""),
      prefix: word.substring(0, 3)
    };
  }
  if (verbPrefixes.twoLetterHyphenPrefixes.test(word) === true) {
    return {
      normalizedWord: word.replace(verbPrefixes.twoLetterHyphenPrefixes, ""),
      prefix: word.substring(0, 3)
    };
  }
  if (verbPrefixes.twoLetterPrefixes.test(word) === true) {
    return {
      normalizedWord: word.replace(verbPrefixes.twoLetterPrefixes, ""),
      prefix: word.substring(0, 2)
    };
  }
  if (verbPrefixes.oneLetterPrefixes.test(word) === true) {
    return {
      normalizedWord: word.replace(verbPrefixes.oneLetterPrefixes, ""),
      prefix: word.substring(0, 1)
    };
  }
};

/**
 * Checks if the input word occurs in the list of exception verbs and if so returns all its irregular forms.
 * If not checks if it is an irregular verb with one of the standard verb prefixes, if so returns all irregular prefixed forms.
 *
 * @param {string} word             The word for which to determine its irregular forms.
 * @param {Array} irregularVerbs    The array of irregular verbs available for this language.
 * @param {Object} verbPrefixes     The collection of verb prefixes to be used for normalization of irregular verbs.
 *
 * @returns {Array} Array of word forms from the exception list.
 */
exports.normalizePrefixed = normalizePrefixed;
const checkIrregulars = function (word, irregularVerbs, verbPrefixes) {
  let irregulars;
  irregularVerbs.forEach(function (paradigm) {
    paradigm.forEach(function (wordInParadigm) {
      if (wordInParadigm === word) {
        irregulars = paradigm;
      }
    });
  });
  if ((0, _lodash.isUndefined)(irregulars)) {
    const normalizedIrregular = normalizePrefixed(word, verbPrefixes);
    if (!(0, _lodash.isUndefined)(normalizedIrregular)) {
      irregularVerbs.forEach(function (paradigm) {
        paradigm.forEach(function (wordInParadigm) {
          if (wordInParadigm === normalizedIrregular.normalizedWord) {
            irregulars = paradigm.map(function (verb) {
              return normalizedIrregular.prefix.concat(verb);
            });
          }
        });
      });
    }
  }
  return irregulars;
};

/**
 * Checks if the input word ends with "s".
 *
 * @param {string} word The word to check.
 *
 * @returns {boolean} True if the word ends with "s".
 */
exports.checkIrregulars = checkIrregulars;
const endsWithS = function (word) {
  const wordLength = word.length;
  // Consider only words of four letters or more to be s-forms (otherwise, words like "its" are being treated as verb forms).
  if (wordLength > 3) {
    return word[word.length - 1] === "s";
  }
  return false;
};

/**
 * Checks if the input word ends with "ing".
 *
 * @param {string} word The word to check.
 *
 * @returns {boolean} True if the word ends with "ing".
 */
const endsWithIng = function (word) {
  const vowelCount = (word.match(vowelRegex) || []).length;

  // Consider only words that have at least one more vowel besides "i" in "ing" (otherwise, words like "ping" are being treated as verb forms).
  if (vowelCount > 1 && word.length > 4) {
    return word.substring(word.length - 3, word.length) === "ing";
  }
  return false;
};

/**
 * Checks if the input word ends with "ed".
 *
 * @param {string} word The word to check.
 *
 * @returns {boolean} True if the word ends with "ed".
 */
exports.endsWithIng = endsWithIng;
const endsWithEd = function (word) {
  const vowelCount = (word.match(vowelRegex) || []).length;

  // Consider only words that have at least one more vowel besides "e" in "ed" (otherwise, words like "red" are being treated as verb forms).
  if (vowelCount > 1 || vowelCount === 1 && word.substring(word.length - 3, word.length - 2) !== "e") {
    return word.substring(word.length - 2, word.length) === "ed";
  }
  return false;
};

/**
 * Forms the infinitive from an input word.
 *
 * @param {string} word                               The word to build the infinitive for.
 * @param {Object} regexVerb                          The list of regex rules used to bring verb forms to infinitive.
 * @param {Array}  regexVerb.sFormToInfinitiveRegex   The array of regex-based rules used to bring -s forms to infinitive.
 * @param {Array}  regexVerb.ingFormToInfinitiveRegex The array of regex-based rules used to bring -ing forms to infinitive.
 * @param {Array}  regexVerb.edFormToInfinitiveRegex  The array of regex-based rules used to bring -ed forms to infinitive.
 *
 * @returns {Object} The infinitive of the input word.
 */
const getInfinitive = function (word, regexVerb) {
  const sFormToInfinitiveRegex = createRulesFromArrays(regexVerb.sFormToInfinitive);
  const ingFormToInfinitiveRegex = createRulesFromArrays(regexVerb.ingFormToInfinitive);
  const edFormToInfinitiveRegex = createRulesFromArrays(regexVerb.edFormToInfinitive);
  if (endsWithS(word)) {
    return {
      infinitive: buildFormRule(word, sFormToInfinitiveRegex),
      guessedForm: "s"
    };
  }
  if (endsWithIng(word)) {
    return {
      infinitive: buildFormRule(word, ingFormToInfinitiveRegex),
      guessedForm: "ing"
    };
  }
  if (endsWithEd(word)) {
    return {
      infinitive: buildFormRule(word, edFormToInfinitiveRegex) || word,
      guessedForm: "ed"
    };
  }
  return {
    infinitive: word,
    guessedForm: "inf"
  };
};
exports.getInfinitive = getInfinitive;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/values/Clause.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/values/Clause.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _functionWords = __webpack_require__(/*! ../config/functionWords */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/functionWords.js");
var _passiveVoiceNonVerbEndingEd = _interopRequireDefault(__webpack_require__(/*! ../config/internal/passiveVoiceNonVerbEndingEd */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/internal/passiveVoiceNonVerbEndingEd.js"));
var _getParticiples = _interopRequireDefault(__webpack_require__(/*! ../helpers/internal/getParticiples */ "./node_modules/yoastseo/build/languageProcessing/languages/en/helpers/internal/getParticiples.js"));
var _yoastseo = __webpack_require__(/*! yoastseo */ "./node_modules/yoastseo/build/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const {
  precedenceException,
  directPrecedenceException,
  values
} = _yoastseo.languageProcessing;
const Clause = values.Clause;

/**
 * Creates a Clause object for the English language.
 */
class EnglishClause extends Clause {
  /**
   * Constructor.
   *
   * @param {string} clauseText   The text of the clause.
   * @param {Array} auxiliaries   The auxiliaries.
   *
   * @constructor
   */
  constructor(clauseText, auxiliaries) {
    super(clauseText, auxiliaries);
    this._participles = (0, _getParticiples.default)(this.getClauseText());
    this.checkParticiples();
  }

  /**
   * Checks if any exceptions are applicable to this participle that would result in the clause not being passive.
   * If no exceptions are found, the clause is passive.
   *
   * @returns {boolean} Returns true if no exception is found.
   */
  checkParticiples() {
    const clause = this.getClauseText();
    const passiveParticiples = this.getParticiples().filter(participle => !(0, _lodash.includes)(_passiveVoiceNonVerbEndingEd.default, participle) && !this.hasRidException(participle) && !directPrecedenceException(clause, participle, _functionWords.cannotDirectlyPrecedePassiveParticiple) && !precedenceException(clause, participle, _functionWords.cannotBeBetweenPassiveAuxiliaryAndParticiple));
    this.setPassive(passiveParticiples.length > 0);
  }

  /**
   * Checks whether the participle is 'rid' in combination with 'get', 'gets', 'getting', 'got' or 'gotten'.
   * If this is true, the participle is not passive.
   *
   * @param {string} participle   The participle
   *
   * @returns {boolean} Returns true if 'rid' is found in combination with a form of 'get'
   * otherwise returns false.
   */
  hasRidException(participle) {
    if (participle === "rid") {
      const irregularExclusionArray = ["get", "gets", "getting", "got", "gotten"];
      return !(0, _lodash.isEmpty)((0, _lodash.intersection)(irregularExclusionArray, this.getAuxiliaries()));
    }
    return false;
  }
}
var _default = exports["default"] = EnglishClause;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/es/config/wordComplexity.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/es/config/wordComplexity.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
// This is a config for the Word Complexity assessment. As such, this helper is not bundled in Yoast SEO.
var _default = exports["default"] = {
  wordLength: 7
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/es/helpers/checkIfWordIsComplex.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/es/helpers/checkIfWordIsComplex.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = checkIfWordIsComplex;
const vowels = "aeiuoyáéíóúñ";
const consonants = "bcdfghjklmnpqrstvwxzñ";
const vowelsSuffix = "[" + vowels + "](s)$";
const vowelsSuffixRegex = new RegExp(vowelsSuffix);
const consonantSuffix = "[" + consonants + "](es)$";
const consonantSuffixRegex = new RegExp(consonantSuffix);
const suffixes = "(s|es)$";
const suffixesRegex = new RegExp(suffixes);

/**
 * Checks if a word is complex.
 * This is a helper for the Word Complexity assessment. As such, this helper is not bundled in Yoast SEO.
 *
 * @param {object} config The configuration needed for assessing the word's complexity, e.g., the frequency list.
 * @param {string} word The word to check.
 * @param {object}	premiumData The object that contains data for the assessment including the frequency list.
 *
 * @returns {boolean} Whether or not a word is complex.
 */
function checkIfWordIsComplex(config, word, premiumData) {
  const lengthLimit = config.wordLength;
  const frequencyList = premiumData.frequencyList.list;

  // The Spanish word is not complex if its length is 7 characters or fewer.
  if (word.length <= lengthLimit) {
    return false;
  }

  // The Spanish word starts with a capital and thus is assumed to be a named entity.
  if (word[0].toLowerCase() !== word[0]) {
    return false;
  }

  // The word is not complex if it's in the frequency list.
  if (frequencyList.includes(word)) {
    return false;
  }
  /*
  * If a word is longer than 7 characters and has a plural ending in -es or -s, we remove the ending
  * and check if the singular form can be found in the frequency list.
  * The word is not complex if the singular form is in the list.
  */
  // It's important to check consonant suffixes before vowel suffixes so order should not be altered.
  if (consonantSuffixRegex.test(word)) {
    word = word.replace(suffixesRegex, "");
    return !frequencyList.includes(word);
  } else if (vowelsSuffixRegex.test(word)) {
    word = word.replace(suffixesRegex, "");
    return !frequencyList.includes(word);
  }
  return true;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/fr/config/wordComplexity.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/fr/config/wordComplexity.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
// This is a config for the Word Complexity assessment. As such, this helper is not bundled in Yoast SEO.
var _default = exports["default"] = {
  wordLength: 9
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/fr/helpers/checkIfWordIsComplex.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/fr/helpers/checkIfWordIsComplex.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = checkIfWordIsComplex;
var _quotes = __webpack_require__(/*! ../../../helpers/sanitize/quotes */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/quotes.js");
const contractionPrefixes = "^(c'|d'|l'|s')";
const contractionRegex = new RegExp(contractionPrefixes);

/**
 * Checks if a word is complex.
 * This is a helper for the Word Complexity assessment. As such, this helper is not bundled in Yoast SEO.
 *
 * @param {object} config The configuration needed for assessing the word's complexity, e.g., the frequency list.
 * @param {string} word The word to check.
 * @param {object}	premiumData The object that contains data for the assessment including the frequency list.
 *
 * @returns {boolean} Whether or not a word is complex.
 */
function checkIfWordIsComplex(config, word, premiumData) {
  const lengthLimit = config.wordLength;
  const frequencyList = premiumData.frequencyList.list;

  // Normalize single quotes before checking for contractions.
  word = (0, _quotes.normalizeSingle)(word);

  /*
   * We want to remove the definite article l', preposition d' from a word,
   * since an article or preposition doesn't add any complexity to the word.
   */
  if (contractionRegex.test(word)) {
    word = word.replace(contractionRegex, "");
  }

  // The word is not complex if it's less than or the same as the length limit, i.e. 9 characters for French.
  if (word.length <= lengthLimit) {
    return false;
  }

  // The word is not complex if it's in the frequency list.
  if (frequencyList.includes(word)) {
    return false;
  }

  /*
   * In French where capital letter beginning decreases the complexity of a word,
   * word longer than 9 characters is not complex if it starts with capital letter.
   */
  if (word[0].toLowerCase() === word[0]) {
    const standardSPluralSuffixesRegex = new RegExp(premiumData.suffixGroupsComplexity.standardSuffixesWithSplural);
    const standardXPluralSuffixesRegex = new RegExp(premiumData.suffixGroupsComplexity.standardSuffixesWithXplural);
    const irregularPluralSingularSuffixes = premiumData.suffixGroupsComplexity.irregularPluralSingularSuffixes;
    const irregularPluralSuffixRegex = new RegExp(irregularPluralSingularSuffixes[0]);

    /*
     * If a word is longer than 9 characters and doesn't start with capital letter,
     * we check further whether it is a plural that ends on the -s or -x plural suffix. If it is, we remove the plural suffix
     * and check if the singular word can be found in the frequency list.
     * if it is a plural that does not end on -s or -x but on -aux, we replace the plural -aux suffix with the singular suffix -al.
     * The word is not complex if the singular form is in the list.
     */
    if (standardSPluralSuffixesRegex.test(word) || standardXPluralSuffixesRegex.test(word)) {
      word = word.substring(0, word.length - 1);
    } else if (irregularPluralSuffixRegex.test(word)) {
      word = word.replace(irregularPluralSuffixRegex, irregularPluralSingularSuffixes[1]);
    }
    return !frequencyList.includes(word);
  }
  return false;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/ja/config/metaDescriptionLength.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/ja/config/metaDescriptionLength.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = exports["default"] = {
  recommendedMaximumLength: 60,
  maximumLength: 80
};

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/altTagCount.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/altTagCount.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = altTagCount;
var _getAltAttribute = _interopRequireDefault(__webpack_require__(/*! ../helpers/image/getAltAttribute */ "./node_modules/yoastseo/build/languageProcessing/helpers/image/getAltAttribute.js"));
var _findKeywordFormsInString = __webpack_require__(/*! ../helpers/match/findKeywordFormsInString */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/findKeywordFormsInString.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _getImagesInTree = _interopRequireDefault(__webpack_require__(/*! ../helpers/image/getImagesInTree */ "./node_modules/yoastseo/build/languageProcessing/helpers/image/getImagesInTree.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module researches/imageAltTags */

/**
 * Matches the alt-tags in the images found in the text.
 * Returns an object with the totals and different alt-tags.
 *
 * @param {Array}       imageNodes        		Array with all the image nodes in the text
 * @param {Object}      topicForms          	The object with the keyphrase and the synonyms forms from the paper.
 * @param {string}      locale              	The locale used for transliteration.
 * @param {function}    matchWordCustomHelper 	A language-specific helper function to match word in text.
 *
 * @returns {object} altProperties Object with all alt-tags that were found.
 */
const matchAltProperties = function (imageNodes, topicForms, locale, matchWordCustomHelper) {
  const altProperties = {
    noAlt: 0,
    withAlt: 0,
    withAltKeyword: 0,
    withAltNonKeyword: 0
  };
  imageNodes.forEach(imageNode => {
    const alttag = (0, _getAltAttribute.default)(imageNode);

    // If no alt-tag is set
    if (alttag === "") {
      altProperties.noAlt++;
      return;
    }

    // If no keyword is set, but the alt-tag is
    if ((0, _lodash.isEmpty)(topicForms.keyphraseForms)) {
      altProperties.withAlt++;
      return;
    }

    // If the keyword is matched in the alt tag
    const keywordMatchedInAltTag = (0, _findKeywordFormsInString.findTopicFormsInString)(topicForms, alttag, true, locale, matchWordCustomHelper);
    if (keywordMatchedInAltTag.percentWordMatches >= 50) {
      altProperties.withAltKeyword++;
      return;
    }
    altProperties.withAltNonKeyword++;
  });
  return altProperties;
};

/**
 * Checks the text for images, checks the type of each image and alt attributes for containing keywords
 *
 * @param {Paper}       paper       The paper to check for images.
 * @param {Researcher}  researcher  The researcher to use for analysis.
 *
 * @returns {object} Object containing all types of found images
 */
function altTagCount(paper, researcher) {
  const images = (0, _getImagesInTree.default)(paper);
  const topicForms = researcher.getResearch("morphology");
  const matchWordCustomHelper = researcher.getHelper("matchWordCustomHelper");
  return matchAltProperties(images, topicForms, paper.getLocale(), matchWordCustomHelper);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/countSentencesFromText.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/countSentencesFromText.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _getSentences = _interopRequireDefault(__webpack_require__(/*! ../helpers/sentence/getSentences */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentences.js"));
var _sentencesLength = _interopRequireDefault(__webpack_require__(/*! ../helpers/sentence/sentencesLength.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/sentencesLength.js"));
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ../helpers/html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
var _helpers = __webpack_require__(/*! ../helpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Count sentences in the text.
 * @param {Paper} paper The Paper object to get text from.
 * @param {Researcher} 	researcher 	The researcher to use for analysis.
 * @returns {Array} The sentences from the text.
 */
function _default(paper, researcher) {
  const memoizedTokenizer = researcher.getHelper("memoizedTokenizer");
  let text = paper.getText();
  text = (0, _htmlParser.default)(text);
  text = (0, _helpers.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);
  const sentences = (0, _getSentences.default)(text, memoizedTokenizer);
  return (0, _sentencesLength.default)(sentences, researcher);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/findKeyphraseInSEOTitle.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/findKeyphraseInSEOTitle.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _matchTextWithWord = _interopRequireDefault(__webpack_require__(/*! ../helpers/match/matchTextWithWord.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/matchTextWithWord.js"));
var _findKeywordFormsInString = __webpack_require__(/*! ../helpers/match/findKeywordFormsInString.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/findKeywordFormsInString.js");
var _stemPrefixedFunctionWords = __webpack_require__(/*! ../helpers/morphology/stemPrefixedFunctionWords.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/stemPrefixedFunctionWords.js");
var _processExactMatchRequest = _interopRequireDefault(__webpack_require__(/*! ../helpers/match/processExactMatchRequest */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/processExactMatchRequest.js"));
var _getWords = _interopRequireDefault(__webpack_require__(/*! ../helpers/word/getWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
var _wordBoundariesWithoutPunctuation = __webpack_require__(/*! ../../config/wordBoundariesWithoutPunctuation */ "./node_modules/yoastseo/build/config/wordBoundariesWithoutPunctuation.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
let functionWords = [];

/**
 * Strips all function words from the start of the given string.
 *
 * @param {string} str The string from which to strip the function words.
 *
 * @returns {boolean} Whether the string consists of function words only.
 */
const stripFunctionWordsFromStart = function (str) {
  str = str.toLocaleLowerCase();

  /*
  	 * We use a word boundary regex that includes whitespaces, en-dashes, and hyphens for all languages.
  	 * This means that when we filter out function words from the beginning of the title, we also filter out words
  	 * separated by hyphens (e.g. 'three-piece'), as well as function words attached to a content word with a hyphen
  	 * (e.g. 'after' in 'after-school).
  	 * In Indonesian we normally don't want to treat hyphens as word boundaries, but in this case it makes sense because
  	 * an Indonesian title can also contain function words seperated by hyphens at the beginning of the title (e.g. 'dua'
  	 * and 'lima' in 'dua-lima ribuan').
  	 * As a downside, single function words containing hyphens (e.g. 'vis-à-vis') won't be filtered out, but we are solving this
  	 * by adding each word from such function words as separate entries in the function words lists.
   	 */
  let titleWords = (0, _getWords.default)(str.toLocaleLowerCase(), _wordBoundariesWithoutPunctuation.WORD_BOUNDARY_WITH_HYPHEN);

  // Strip all function words from the start of the string.
  titleWords = (0, _lodash.filter)(titleWords, function (word) {
    return !(0, _lodash.includes)(functionWords, word.trim().toLocaleLowerCase());
  });
  return (0, _lodash.isEmpty)(titleWords);
};

/**
 * Checks the position of the keyphrase in the SEO title.
 *
 * @param {string} title 		The SEO title of the paper.
 * @param {number} position 	The position of the keyphrase in the SEO title.
 *
 * @returns {number} Potentially adjusted position of the keyphrase in the SEO title.
 */
const adjustPosition = function (title, position) {
  // Don't do anything if position is already 0.
  if (position === 0) {
    return position;
  }

  // Don't do anything if no function words exist for this language.
  if (functionWords.length === 0) {
    return position;
  }

  // Strip all function words from the beginning of the SEO title.
  const titleBeforeKeyword = title.substring(0, position);
  if (stripFunctionWordsFromStart(titleBeforeKeyword)) {
    /*
     * Return position 0 if there are no words left in the SEO title before the keyword after filtering
     * the function words (such that "keyword" in "the keyword" is still counted as position 0).
    	 */
    return 0;
  }
  return position;
};

/**
 * Creates a cartesian product of the given arrays.
 * This function is taken from: https://stackoverflow.com/questions/12303989/cartesian-product-of-multiple-arrays-in-javascript
 *
 * @param {array} arrays The arrays to create the cartesian product of.
 *
 * @returns {array} The cartesian product of the given arrays.
 */
function cartesian(...arrays) {
  return arrays.reduce((a, b) => a.flatMap(d => b.map(e => [d, e].flat())));
}

/**
 * Finds the exact match of the keyphrase in the SEO title for languages that have prefixed function words.
 *
 * @param {object} matchesObject The object that contains an array of matched words of the keyphrase in SEO title and the position of the match.
 * @param {string} keyphrase The keyphrase to find in the SEO title.
 * @param {object} result The result object to store the results in.
 * @param {RegExp} prefixedFunctionWordsRegex The function to stem the prefixed function words.
 * @param {string} title The SEO title of the paper.
 * @param {string} locale The locale of the paper.
 *
 * @returns {object} The new result object containing the results of the analysis.
 */
function findExactMatch(matchesObject, keyphrase, result, prefixedFunctionWordsRegex, title, locale) {
  let matchedPrefixedFunctionWords = [];
  /*
  For each matched word of the keyphrase, get the prefixed function word.
  For example, for the matches array [ "القطط" ,"والوسيمة" ], the `matchedPrefixedFunctionWords` array will be [ "ال", "وال" ].
   */
  matchesObject.matches.forEach(match => {
    const {
      prefix: prefixedFunctionWord
    } = (0, _stemPrefixedFunctionWords.stemPrefixedFunctionWords)(match, prefixedFunctionWordsRegex);
    matchedPrefixedFunctionWords.push(prefixedFunctionWord);
  });

  // Split the keyphrase into words. For example, the keyphrase "قطط وسيمة" will be split into [ قطط", "وسيمة" ].
  const splitKeyphrase = keyphrase.split(" ");
  let keyphraseVariations = [];

  // Add an empty string to the array to account for the case where the word is not prefixed, remove duplicates.
  matchedPrefixedFunctionWords = (0, _lodash.uniq)(matchedPrefixedFunctionWords.concat([""]));
  /*
   Create an array of arrays, where each array contains each word of the keyphrase with function word prefixes attached.
   For example, when the split keyphrase is [ "قطط", "وسيمة" ] and the matchedPrefixedFunctionWords is [ "ال", "وال", "" ],
   the array would be: [ [ "والقطط","القطط", "قطط" ], [ "والوسيمة" ,"الوسيمة", "وسيمة" ] ].
   */
  const arrays = [];
  splitKeyphrase.forEach(word => {
    arrays.push(matchedPrefixedFunctionWords.map(prefixedFunctionWord => prefixedFunctionWord + word));
  });
  /*
  Create the cartesian product of the created arrays: to create all possible combinations of the previously created arrays.
  For example, the cartesian product of [ [ "والقطط","القطط", "قطط" ], [ "والوسيمة" ,"الوسيمة", "وسيمة" ] ] will be:
  ...[ [ "والقطط", "والوسيمة" ], [ "والقطط", "الوسيمة" ], [ "والقطط", "وسيمة" ], [ "القطط", "والوسيمة" ]]
   */
  keyphraseVariations = cartesian(...arrays);
  // Turn the keyphrase combination array into strings. For example, [ "والقطط", "والوسيمة" ] will be turned into "والقطط والوسيمة".
  keyphraseVariations = keyphraseVariations.map(variation => Array.isArray(variation) ? variation.join(" ") : variation);
  keyphraseVariations.forEach(variation => {
    // Check if the exact match of the keyphrase combination is found in the SEO title.
    const foundMatch = (0, _matchTextWithWord.default)(title, variation, locale, false);
    if (foundMatch.count > 0) {
      result.exactMatchFound = true;
      // Adjust the position of the matched keyphrase if it's preceded by non-prefixed function words.
      result.position = adjustPosition(title, foundMatch.position);
    }
  });
  /*
  This check if to account for the case where an exact match of the keyphrase is not found in the SEO title,
  but it's found in the position is 0.
   */
  if (matchesObject.position === 0) {
    result.position = 0;
  }
  return result;
}

/**
 * An object containing the results of the keyphrase in SEO title research.
 *
 * @typedef {Object} 	KeyphraseInSEOTitleResult
 * @property {boolean}	exactMatchFound	Whether the exact match of the keyphrase was found in the SEO title.
 * @property {boolean}	allWordsFound	Whether all content words from the keyphrase were found in the SEO title.
 * @property {number}	position The position of the keyphrase in the SEO title.
 * @property {boolean}	exactMatchKeyphrase Whether the exact match was requested.
 */

/**
 * Checks if all content words from the keyphrase are found in the SEO title.
 *
 * @param {Paper} paper The Paper object that contains analysis data.
 * @param {Researcher} researcher The language researcher.
 * @param {string} keyword The keyword to find in the SEO title.
 * @param {object} result The result object to store the results in.
 * @param {RegExp} prefixedFunctionWordsRegex The researcher to use for analysis.
 * @returns {object} The new result object containing the results of the analysis.
 */
function checkIfAllWordsAreFound(paper, researcher, keyword, result, prefixedFunctionWordsRegex) {
  const title = paper.getTitle();
  const locale = paper.getLocale();
  const topicForms = researcher.getResearch("morphology");

  // Use only keyphrase (not the synonyms) to match topic words in the SEO title.
  const useSynonyms = false;
  const separateWordsMatched = (0, _findKeywordFormsInString.findTopicFormsInString)(topicForms, title, useSynonyms, locale, false);
  if (separateWordsMatched.percentWordMatches === 100) {
    /*
    If all words are found and the position of the found words is 0, we further check if the exact match is found
    for languages with a helper to stem prefixed function words, e.g. definite article.
    Our support for this type of language is currently only for Arabic and Hebrew.
    For example, in Arabic, the word "المنزل" (the house) is written as "ال" (the) + "منزل" (house).
    And in Hebrew, the word "הבית" (the house) is written as "ה" (the) + "בית" (house).
    In the above case, when the keyphrase is "منزل", and the SEO title starts with "المنزل" in Arabic,
    or when the keyphrase is "בית" and the SEO title is "הבית", we want to consider this as an exact match
    and the position is 0 if it's found in the beginning of the SEO title.
    This treatment is to align with the way we match the keyphrase in SEO title for other languages.
    For example, in English, the keyphrase "house" is considered to be found in the SEO title "the house" at position 0.
     */
    if (prefixedFunctionWordsRegex) {
      const {
        exactMatchFound,
        position
      } = findExactMatch(separateWordsMatched, keyword, result, prefixedFunctionWordsRegex, title, locale);
      result = {
        ...result,
        exactMatchFound: exactMatchFound,
        position: position
      };
    }
    result.allWordsFound = true;
  }
  return result;
}

/**
 * Counts the occurrences of the keyword in the SEO title. Returns the result that contains information on
 * (1) whether the exact match of the keyphrase was used in the SEO title,
 * (2) whether all (content) words from the keyphrase were found in the SEO title,
 * (3) at which position the exact match was found in the SEO title.
 *
 * @param {Object} paper 			The paper containing SEO title and keyword.
 * @param {Researcher} researcher 	The researcher to use for analysis.
 *
 * @returns {KeyphraseInSEOTitleResult} An object containing the information on whether the keyphrase was matched in the SEO title and how.
 */
const findKeyphraseInSEOTitle = function (paper, researcher) {
  functionWords = researcher.getConfig("functionWords");
  let keyword = (0, _lodash.escapeRegExp)(paper.getKeyword());
  const title = paper.getTitle();
  const locale = paper.getLocale();
  let result = {
    exactMatchFound: false,
    allWordsFound: false,
    position: -1,
    exactMatchKeyphrase: false
  };

  // Check if the keyphrase is enclosed in double quotation marks to ensure that only exact matches are processed.
  const exactMatchRequest = (0, _processExactMatchRequest.default)(keyword);
  if (exactMatchRequest.exactMatchRequested) {
    keyword = exactMatchRequest.keyphrase;
    result.exactMatchKeyphrase = true;
  }

  // Check if the exact match of the keyphrase is found in the SEO title.
  const prefixedFunctionWordsRegex = researcher.getConfig("prefixedFunctionWordsRegex");
  const keywordMatched = (0, _matchTextWithWord.default)(title, keyword, locale, false);
  if (keywordMatched.count > 0 && !prefixedFunctionWordsRegex) {
    result.exactMatchFound = true;
    result.allWordsFound = true;
    result.position = adjustPosition(title, keywordMatched.position);
    return result;
  }
  result = checkIfAllWordsAreFound(paper, researcher, keyword, result, prefixedFunctionWordsRegex);
  return result;
};
var _default = exports["default"] = findKeyphraseInSEOTitle;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/findKeywordInFirstParagraph.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/findKeywordInFirstParagraph.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _findKeywordFormsInString = __webpack_require__(/*! ../helpers/match/findKeywordFormsInString.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/findKeywordFormsInString.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/** @module analyses/findKeywordInFirstParagraph */

/**
 * Checks if the introductory paragraph contains keyphrase or synonyms.
 * First splits the first paragraph by sentences. Finds the first paragraph which contains sentences e.g., not an image).
 * (1) Tries to find all (content) words from the keyphrase or a synonym phrase within one sentence.
 * If found all words within one sentence, returns an object with foundInOneSentence = true and keyphraseOrSynonym = "keyphrase"
 * or "synonym".
 * If it did not find all words within one sentence, goes ahead with matching the keyphrase with the entire first paragraph.
 * (2) Tries to find all (content) words from the keyphrase or a synonym phrase within the paragraph.
 * If found all words within the paragraph, returns an object with foundInOneSentence = false, foundInParagraph = true,
 * and keyphraseOrSynonym = "keyphrase" or "synonym".
 * If found not all words within the paragraph of nothing at all, returns an object with foundInOneSentence = false,
 * foundInParagraph = false, and keyphraseOrSynonym = "".
 *
 * @param {Paper} paper The text to check for paragraphs.
 * @param {Researcher} researcher The researcher to use for analysis.
 *
 * @returns {Object} Whether the keyphrase words were found in one sentence, whether the keyphrase words were found in
 * the paragraph, whether a keyphrase or a synonym phrase was matched.
 */
function _default(paper, researcher) {
  const firstParagraph = researcher.getResearch("getParagraphs")[0];
  const topicForms = researcher.getResearch("morphology");
  const matchWordCustomHelper = researcher.getHelper("matchWordCustomHelper");
  const locale = paper.getLocale();
  const result = {
    foundInOneSentence: false,
    foundInParagraph: false,
    keyphraseOrSynonym: ""
  };
  if ((0, _lodash.isEmpty)(firstParagraph)) {
    return result;
  }
  const sentences = firstParagraph.sentences.map(sentence => sentence.text);
  // Use both keyphrase and synonyms to match topic words in the first paragraph.
  const useSynonyms = true;
  if (!(0, _lodash.isEmpty)(sentences)) {
    const firstResultSentence = sentences.map(sentence => (0, _findKeywordFormsInString.findTopicFormsInString)(topicForms, sentence, useSynonyms, locale, matchWordCustomHelper)).find(resultSentence => resultSentence.percentWordMatches === 100);
    if (firstResultSentence) {
      result.foundInOneSentence = true;
      result.foundInParagraph = true;
      result.keyphraseOrSynonym = firstResultSentence.keyphraseOrSynonym;
      return result;
    }
    const resultParagraph = (0, _findKeywordFormsInString.findTopicFormsInString)(topicForms, firstParagraph.innerText(), useSynonyms, locale, matchWordCustomHelper);
    if (resultParagraph.percentWordMatches === 100) {
      result.foundInParagraph = true;
      result.keyphraseOrSynonym = resultParagraph.keyphraseOrSynonym;
      return result;
    }
  }
  return result;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/findTransitionWords.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/findTransitionWords.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _createRegexFromDoubleArray = _interopRequireDefault(__webpack_require__(/*! ../helpers/regex/createRegexFromDoubleArray.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/regex/createRegexFromDoubleArray.js"));
var _getSentences = _interopRequireDefault(__webpack_require__(/*! ../helpers/sentence/getSentences.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentences.js"));
var _quotes = __webpack_require__(/*! ../helpers/sanitize/quotes.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/quotes.js");
var _matchWordInSentence = __webpack_require__(/*! ../helpers/word/matchWordInSentence.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/matchWordInSentence.js");
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ../helpers/html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _helpers = __webpack_require__(/*! ../helpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
let regexFromDoubleArray = null;
let regexFromDoubleArrayCacheKey = "";

/**
 * Memoizes the createRegexFromDoubleArray with the twoPartTransitionWords.
 *
 * @param {Array} twoPartTransitionWords The array containing two-part transition words.
 *
 * @returns {RegExp} The RegExp to match text with a double array.
 */
function getRegexFromDoubleArray(twoPartTransitionWords) {
  const cacheKey = (0, _lodash.flattenDeep)(twoPartTransitionWords).join("");
  if (regexFromDoubleArrayCacheKey !== cacheKey || regexFromDoubleArray === null) {
    regexFromDoubleArrayCacheKey = cacheKey;
    regexFromDoubleArray = (0, _createRegexFromDoubleArray.default)(twoPartTransitionWords);
  }
  return regexFromDoubleArray;
}

/**
 * Matches the sentence against two part transition words.
 *
 * @param {string} sentence The sentence to match against.
 * @param {Array} twoPartTransitionWords The array containing two-part transition words.
 * @returns {Array} The found transitional words.
 */
const matchTwoPartTransitionWords = function (sentence, twoPartTransitionWords) {
  sentence = (0, _quotes.normalizeSingle)(sentence);
  const twoPartTransitionWordsRegex = getRegexFromDoubleArray(twoPartTransitionWords);
  return sentence.match(twoPartTransitionWordsRegex);
};

/**
 * Matches the sentence against transition words.
 *
 * @param {string} sentence The sentence to match against.
 * @param {Array} transitionWords The array containing transition words.
 * @returns {Array} The found transitional words.
 */
const matchTransitionWords = function (sentence, transitionWords) {
  sentence = (0, _quotes.normalizeSingle)(sentence);
  return transitionWords.filter(word => (0, _matchWordInSentence.isWordInSentence)(word, sentence));
};

/**
 * Checks the passed sentences to see if they contain transition words.
 *
 * @param {Array} sentences The sentences to match against.
 * @param {Array} transitionWords The array containing transition words.
 * @param {Array} twoPartTransitionWords The array containing two part transition words.
 * @param {function} matchTransitionWordsHelper The language-specific helper function to match transition words in a sentence.
 *
 * @returns {Array} Array of sentence objects containing the complete sentence and the transition words.
 */
const checkSentencesForTransitionWords = function (sentences, transitionWords, twoPartTransitionWords, matchTransitionWordsHelper) {
  const results = [];
  sentences.forEach(sentence => {
    if (twoPartTransitionWords) {
      const twoPartMatches = matchTwoPartTransitionWords(sentence, twoPartTransitionWords);
      if (twoPartMatches !== null) {
        results.push({
          sentence: sentence,
          transitionWords: twoPartMatches
        });
        return;
      }
    }
    const transitionWordMatches = matchTransitionWordsHelper ? matchTransitionWordsHelper(sentence, transitionWords) : matchTransitionWords(sentence, transitionWords);
    if (transitionWordMatches.length !== 0) {
      results.push({
        sentence: sentence,
        transitionWords: transitionWordMatches
      });
    }
  });
  return results;
};

/**
 * Checks how many sentences from a text contain at least one transition word or two-part transition word
 * that are defined in the transition words config and two part transition words config.
 *
 * @param {Paper} paper The Paper object to get text from.
 * @param {Researcher} researcher The researcher.
 *
 * @returns {object} An object with the total number of sentences in the text
 *                   and the total number of sentences containing one or more transition words.
 */
function _default(paper, researcher) {
  const matchTransitionWordsHelper = researcher.getHelper("matchTransitionWordsHelper");
  const transitionWords = researcher.getConfig("transitionWords");
  const twoPartTransitionWords = researcher.getConfig("twoPartTransitionWords");
  const memoizedTokenizer = researcher.getHelper("memoizedTokenizer");
  let text = paper.getText();
  text = (0, _htmlParser.default)(text);
  text = (0, _helpers.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);
  const sentences = (0, _getSentences.default)(text, memoizedTokenizer);
  const sentenceResults = checkSentencesForTransitionWords(sentences, transitionWords, twoPartTransitionWords, matchTransitionWordsHelper);
  return {
    totalSentences: sentences.length,
    sentenceResults: sentenceResults,
    transitionWordSentences: sentenceResults.length
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/functionWordsInKeyphrase.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/functionWordsInKeyphrase.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _getWords = _interopRequireDefault(__webpack_require__(/*! ../helpers/word/getWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
var _processExactMatchRequest = _interopRequireDefault(__webpack_require__(/*! ../helpers/match/processExactMatchRequest */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/processExactMatchRequest.js"));
var _wordBoundariesWithoutPunctuation = __webpack_require__(/*! ../../config/wordBoundariesWithoutPunctuation */ "./node_modules/yoastseo/build/config/wordBoundariesWithoutPunctuation.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Checks if the keyphrase contains of function words only.
 *
 * @param {object} paper The paper containing the keyword.
 * @param {Researcher} researcher The researcher.
 *
 * @returns {boolean} Whether the keyphrase contains of content words only.
 */
function _default(paper, researcher) {
  const functionWords = researcher.getConfig("functionWords");

  // A helper to get words from the keyphrase for languages that don't use the default way.
  const getWordsCustomHelper = researcher.getHelper("getWordsCustomHelper");
  const keyphrase = paper.getKeyword();

  // Return false if there are double quotes around the keyphrase.
  if ((0, _processExactMatchRequest.default)(keyphrase).exactMatchRequested) {
    return false;
  }

  /*
      * We use a word boundary regex that includes whitespaces, en-dashes, and hyphens for all languages.
      * This means that we also consider keyphrases that consist of function words separated by hyphens (e.g. 'two-year-old')
      * as containing only function words. Since many hyphenated phrases can also be written without hyphens, this way the
      * behavior for hyphenated phrases matches the behavior for unhyphenated phrases.
      * In Indonesian we normally don't want to treat hyphens as word boundaries, but in this case it makes sense because
      * in Indonesian you can also have function words seperated by hyphens (e.g. 'dua-lima').
      * As a downside, single function words containing hyphens (e.g. 'vis-à-vis') won't be automatically matched, but we
      * are solving this by adding each word from such function words as separate entries in the function words lists.
      */
  let keyphraseWords = getWordsCustomHelper ? getWordsCustomHelper(keyphrase) : (0, _getWords.default)(keyphrase, _wordBoundariesWithoutPunctuation.WORD_BOUNDARY_WITH_HYPHEN);
  keyphraseWords = (0, _lodash.filter)(keyphraseWords, function (word) {
    return !(0, _lodash.includes)(functionWords, word.trim().toLocaleLowerCase());
  });
  return (0, _lodash.isEmpty)(keyphraseWords);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/getAnchorsWithKeyphrase.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/getAnchorsWithKeyphrase.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _filterWordsFromArray = _interopRequireDefault(__webpack_require__(/*! ../helpers/word/filterWordsFromArray */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/filterWordsFromArray.js"));
var _findKeywordFormsInString = __webpack_require__(/*! ../helpers/match/findKeywordFormsInString */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/findKeywordFormsInString.js");
var _getWords = _interopRequireDefault(__webpack_require__(/*! ../helpers/word/getWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
var _matchTextWithArray = _interopRequireDefault(__webpack_require__(/*! ../helpers/match/matchTextWithArray */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/matchTextWithArray.js"));
var _parseSynonyms = _interopRequireDefault(__webpack_require__(/*! ../helpers/sanitize/parseSynonyms */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/parseSynonyms.js"));
var _processExactMatchRequest = _interopRequireDefault(__webpack_require__(/*! ../helpers/match/processExactMatchRequest */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/processExactMatchRequest.js"));
var _url = _interopRequireDefault(__webpack_require__(/*! ../helpers/url/url.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/url/url.js"));
var _wordBoundariesWithoutPunctuation = __webpack_require__(/*! ../../config/wordBoundariesWithoutPunctuation */ "./node_modules/yoastseo/build/config/wordBoundariesWithoutPunctuation.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
let functionWords = [];

/**
 * Checks whether the anchor's link is a relative fragment or the same as the site url/domain.
 * Relative fragment links always point to the page itself.
 *
 * @param {String} anchorLink       The link anchor.
 * @param {String} siteUrlOrDomain  The site URL or domain of the paper.
 *
 * @returns {boolean} Whether the anchor's link is a relative fragment or the same as the site url/domain.
 */
function isLinkingToSelf(anchorLink, siteUrlOrDomain) {
  return Boolean(_url.default.areEqual(anchorLink, siteUrlOrDomain) || _url.default.isRelativeFragmentURL(anchorLink));
}

/**
 * Gets the anchors whose url is not linking at the current site url/domain.
 *
 * @param {Array}   anchors         An array with all anchors from the paper.
 * @param {String}  siteUrlOrDomain The site URL or domain of the paper.
 *
 * @returns {Array} The array of all anchors whose url is not linking at the current site url/domain.
 */
function getAnchorsLinkingToSelf(anchors, siteUrlOrDomain) {
  const anchorsLinkingToSelf = anchors.map(function (anchor) {
    const anchorLink = anchor.attributes.href;
    // Return false if there is no href attribute.
    return anchorLink ? isLinkingToSelf(anchorLink, siteUrlOrDomain) : false;
  });
  return anchors.filter((anchor, index) => !anchorsLinkingToSelf[index]);
}

/**
 * Gets the anchors with text that contains all content words of the topic (i.e. keyphrase or synonyms).
 *
 * @param {Array}       anchors         An array with all anchors from the paper
 * @param {Object}      topicForms      The object with topicForms. It contains all forms of the keyphrase and synonyms.
 * @param {String}      locale          The locale of the paper.
 * @param {Function}    matchWordCustomHelper The helper function to match word in text.
 *
 * @returns {String[]} The array of all anchors with text that contains all content words of the keyphrase or synonyms.
 */
function getAnchorsContainingTopic(anchors, topicForms, locale, matchWordCustomHelper) {
  const anchorsContainingTopic = anchors.map(function (anchor) {
    // Only retrieve the anchor's text. This is because we only use the anchor text for the following check.
    const anchorText = anchor.innerText();
    return (0, _findKeywordFormsInString.findTopicFormsInString)(topicForms, anchorText, true, locale, matchWordCustomHelper).percentWordMatches === 100;
  });
  return anchors.filter((anchor, index) => anchorsContainingTopic[index]);
}

/**
 * Gets the anchors with text that has the same content words as the keyphrase or synonyms.
 *
 * @param {Array}       anchors             		An array with all anchors from the paper.
 * @param {Object}      topicForms          		The object with topicForms. It contains all forms of the keyphrase and synonyms.
 * @param {string}      locale              		The locale of the paper.
 * @param {Object}      customHelpers       		An object containing custom helpers.
 * @param {Object[]}    exactMatchRequest   		An array of objects containing the keyphrase and information on whether
 * 													the exact match has been requested.
 * @param {boolean}	 	areHyphensWordBoundaries	Whether hyphens should be treated as word boundaries.
 *
 * @returns {Array} The array of all anchors with text that has the same content words as the keyphrase/synonyms.
 */
function getAnchorsWithSameTextAsTopic(anchors, topicForms, locale, customHelpers, exactMatchRequest, areHyphensWordBoundaries) {
  const matchWordCustomHelper = customHelpers.matchWordCustomHelper;
  const getWordsCustomHelper = customHelpers.getWordsCustomHelper;

  // Prepare keyphrase and synonym forms for comparison with anchors.
  const keyphraseAndSynonymsWords = [(0, _lodash.flatten)(topicForms.keyphraseForms)];
  const synonymsForms = topicForms.synonymsForms;
  synonymsForms.forEach(form => keyphraseAndSynonymsWords.push((0, _lodash.flatten)(form)));

  // The variable that will save all the anchors with text that has the same content words as the keyphrase/synonyms.
  const anchorsContainedInTopic = [];
  anchors.forEach(function (currentAnchor) {
    const currentAnchorText = currentAnchor.innerText();

    /*
          * For keyphrase matching, we want to split words on hyphens and en-dashes, except for languages where hyphens shouldn't
          * be treated as word boundaries. Currently, the latter only applies to Indonesian, where hyphens are used to create plural forms of nouns,
          * such as "buku-buku" being a plural form of "buku". We want to treat forms like "buku-buku" as one word, so we shouldn't
          * split words on hyphens in Indonesian.
          * For languages where hyphens are treated as word boundaries we pass a custom word boundary regex string to the getWords helper
          * that includes whitespaces, hyphens (u002d), and en-dashes (u2013). Otherwise, we pass a word boundary regex that only includes
          * whitespaces and en-dashes.
          */
    let anchorWords;
    if (getWordsCustomHelper) {
      anchorWords = (0, _lodash.uniq)(getWordsCustomHelper(currentAnchorText));
    } else if (areHyphensWordBoundaries) {
      anchorWords = (0, _lodash.uniq)((0, _getWords.default)(currentAnchorText, _wordBoundariesWithoutPunctuation.WORD_BOUNDARY_WITH_HYPHEN));
    } else {
      anchorWords = (0, _lodash.uniq)((0, _getWords.default)(currentAnchorText, _wordBoundariesWithoutPunctuation.WORD_BOUNDARY_WITHOUT_HYPHEN));
    }

    /*
     * Filter function words out of the anchor text.
     * If the anchor text contains only function words, we keep them.
     */
    const filteredAnchorWords = (0, _filterWordsFromArray.default)(anchorWords, functionWords);
    if (filteredAnchorWords.length > 0) {
      anchorWords = filteredAnchorWords;
    }
    exactMatchRequest.forEach(request => {
      /*
       * Check a) if the exact match is requested for the keyphrase, and
       * b) if every content word in the anchor text is included in the keyphrase or synonym.
       */
      if (request.exactMatchRequested && anchorWords.every(anchorWord => request.keyphrase.includes(anchorWord))) {
        anchorsContainedInTopic.push(true);
      }
    });

    // Check if every word in the anchor text is also present in the keyphrase/synonym.
    for (let i = 0; i < keyphraseAndSynonymsWords.length; i++) {
      const topicForm = keyphraseAndSynonymsWords[i];
      if (anchorWords.every(anchorWord => (0, _matchTextWithArray.default)(anchorWord, topicForm, locale, matchWordCustomHelper).count > 0)) {
        anchorsContainedInTopic.push(true);
        break;
      }
    }
  });
  return anchors.filter((anchor, index) => anchorsContainedInTopic[index]);
}

/**
 * Checks whether the content words of the anchor text are the same as the content words of the keyphrase or synonym.
 * Also includes different word forms if the morphology is available.
 *
 * @param {Paper}       paper       The paper to research.
 * @param {Researcher}  researcher  The researcher to use.
 *
 * @returns {Object} The amount of anchor texts whose content words are the same as the keyphrase or synonyms' content words.
 */
function _default(paper, researcher) {
  functionWords = researcher.getConfig("functionWords");
  const areHyphensWordBoundaries = researcher.getConfig("areHyphensWordBoundaries");
  const result = {
    anchorsWithKeyphrase: [],
    anchorsWithKeyphraseCount: 0
  };
  // STEP 1.
  // If the paper's text is empty, return empty result.
  if (paper.getText() === "") {
    return result;
  }

  // STEP 2.
  const keyphrase = paper.getKeyword();
  /*
   * If no keyphrase is set, return empty result.
   * This is a conscious decision where we won't assess the paper if the keyphrase is not set.
   * This includes a case where only the synonym is set but not the keyphrase.
   */
  if (keyphrase === "") {
    return result;
  }
  /*
   * When the keyphrase is set, also retrieve the synonyms and save them in "topics" array.
   * Eventually, the term topics here refers to either keyphrase or synonyms.
   */
  const originalTopics = (0, _parseSynonyms.default)(paper.getSynonyms());
  originalTopics.push(keyphrase);

  // Retrieve the anchors.
  let anchors = paper.getTree().findAll(treeNode => treeNode.name === "a");
  /*
   * We get the site's URL (e.g., https://yoast.com) or domain (e.g., yoast.com) from the paper.
   * In case of WordPress, the variable is a URL. In case of Shopify, it is a domain.
   */
  const siteUrlOrDomain = paper.getPermalink();

  // STEP 3.
  // Get the anchors with urls that are not linking to the current site url/domain.
  anchors = getAnchorsLinkingToSelf(anchors, siteUrlOrDomain);
  // If all anchor urls are linking to the current site url/domain, return empty result.
  if (anchors.length === 0) {
    return result;
  }
  const locale = paper.getLocale();
  const topicForms = researcher.getResearch("morphology");
  const customHelpers = {
    matchWordCustomHelper: researcher.getHelper("matchWordCustomHelper"),
    getWordsCustomHelper: researcher.getHelper("getWordsCustomHelper")
  };

  // STEP 4.
  // Get the anchors with text that contains the keyphrase/synonyms' content words.
  anchors = getAnchorsContainingTopic(anchors, topicForms, locale, customHelpers.matchWordCustomHelper);
  // If all anchor texts do not contain the keyphrase/synonyms' content words, return empty result.
  if (anchors.length === 0) {
    return result;
  }

  // STEP 5.
  // Check if exact match is requested for every topic (keyphrase or synonym).
  const isExactMatchRequested = originalTopics.map(originalTopic => (0, _processExactMatchRequest.default)(originalTopic));
  // Get the anchors with text that has the same content words as the keyphrase/synonyms.
  anchors = getAnchorsWithSameTextAsTopic(anchors, topicForms, locale, customHelpers, isExactMatchRequested, areHyphensWordBoundaries);
  return {
    anchorsWithKeyphrase: anchors,
    anchorsWithKeyphraseCount: anchors.length
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/getFleschReadingScore.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/getFleschReadingScore.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DIFFICULTY = void 0;
exports["default"] = _default;
var _stripNumbers = _interopRequireDefault(__webpack_require__(/*! ../helpers/sanitize/stripNumbers.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripNumbers.js"));
var _countSentences = _interopRequireDefault(__webpack_require__(/*! ../helpers/sentence/countSentences.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/countSentences.js"));
var _countWords = _interopRequireDefault(__webpack_require__(/*! ../helpers/word/countWords.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/countWords.js"));
var _countSyllables = _interopRequireDefault(__webpack_require__(/*! ../helpers/syllables/countSyllables.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/syllables/countSyllables.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module analyses/calculateFleschReading */

/**
 * Calculates an average from a total and an amount
 *
 * @param {number} total The total.
 * @param {number} amount The amount.
 * @returns {number} The average from the total and the amount.
 */
const getAverage = function (total, amount) {
  return total / amount;
};

/**
 * The Flesch reading ease difficulty.
 * @readonly
 * @enum {number}
 */
const DIFFICULTY = exports.DIFFICULTY = {
  NO_DATA: -1,
  VERY_EASY: 0,
  EASY: 1,
  FAIRLY_EASY: 2,
  OKAY: 3,
  FAIRLY_DIFFICULT: 4,
  DIFFICULT: 5,
  VERY_DIFFICULT: 6
};

/**
 * Returns the Flesch reading ease difficulty based on the boundaries
 * defined in the score configuration.
 *
 * @param {number} score The Flesch reading ease score.
 * @param {Object} scoreConfiguration The score configuration.
 *
 * @returns {DIFFICULTY} The Flesch reading ease difficulty.
 */
function getDifficulty(score, scoreConfiguration) {
  if (score >= scoreConfiguration.borders.veryEasy) {
    return DIFFICULTY.VERY_EASY;
  } else if ((0, _lodash.inRange)(score, scoreConfiguration.borders.easy, scoreConfiguration.borders.veryEasy)) {
    return DIFFICULTY.EASY;
  } else if ((0, _lodash.inRange)(score, scoreConfiguration.borders.fairlyEasy, scoreConfiguration.borders.easy)) {
    return DIFFICULTY.FAIRLY_EASY;
  } else if ((0, _lodash.inRange)(score, scoreConfiguration.borders.okay, scoreConfiguration.borders.fairlyEasy)) {
    return DIFFICULTY.OKAY;
  } else if ((0, _lodash.inRange)(score, scoreConfiguration.borders.fairlyDifficult, scoreConfiguration.borders.okay)) {
    return DIFFICULTY.FAIRLY_DIFFICULT;
  } else if ((0, _lodash.inRange)(score, scoreConfiguration.borders.difficult, scoreConfiguration.borders.fairlyDifficult)) {
    return DIFFICULTY.DIFFICULT;
  }
  return DIFFICULTY.VERY_DIFFICULT;
}

/**
 * Retrieves the scoring configuration defining the boundaries to use to
 * determine the Flesch reading ease difficulty.
 *
 * @param {Researcher} researcher The researcher.
 *
 * @returns {Object} The language specific scoring configuration, or the default configuration if not available.
 */
function getConfiguration(researcher) {
  const languageSpecificConfig = researcher.getConfig("fleschReadingEaseScores");
  const defaultConfig = {
    borders: {
      veryEasy: 90,
      easy: 80,
      fairlyEasy: 70,
      okay: 60,
      fairlyDifficult: 50,
      difficult: 30,
      veryDifficult: 0
    },
    scores: {
      veryEasy: 9,
      easy: 9,
      fairlyEasy: 9,
      okay: 9,
      fairlyDifficult: 6,
      difficult: 3,
      veryDifficult: 3
    }
  };
  return languageSpecificConfig ? languageSpecificConfig : defaultConfig;
}

/**
 * This calculates the Flesch reading score for a given text.
 *
 * @param {Paper}       paper           The paper containing the text.
 * @param {Researcher}  researcher      The researcher.
 *
 * @returns {{ score: number, difficulty: DIFFICULTY }} The Flesch reading score.
 */
function _default(paper, researcher) {
  const syllables = researcher.getConfig("syllables");
  const memoizedTokenizer = researcher.getHelper("memoizedTokenizer");
  const languageSpecificConfiguration = getConfiguration(researcher);
  let text = paper.getText();
  if (text === "") {
    // A score of -1 signals to the code down the line that no valid FRE was calculated.
    return {
      score: -1,
      difficulty: DIFFICULTY.NO_DATA
    };
  }
  text = (0, _stripNumbers.default)(text);
  const numberOfSentences = (0, _countSentences.default)(text, memoizedTokenizer);
  const numberOfWords = (0, _countWords.default)(text);

  // Do not show the Flesch reading ease when there is not enough data for the FRE to make sense. Also used to prevent division by zero errors.
  // A score of -1 signals to the code down the line that no valid FRE was calculated.
  if (numberOfSentences < 1 || numberOfWords <= 10) {
    return {
      score: -1,
      difficulty: DIFFICULTY.NO_DATA
    };
  }
  const numberOfSyllables = (0, _countSyllables.default)(text, syllables);
  const averageWordsPerSentence = getAverage(numberOfWords, numberOfSentences);
  const syllablesPer100Words = numberOfSyllables * (100 / numberOfWords);
  const statistics = {
    numberOfSentences,
    numberOfWords,
    numberOfSyllables,
    averageWordsPerSentence,
    syllablesPer100Words
  };
  const getScore = researcher.getHelper("fleschReadingScore");
  const score = (0, _lodash.clamp)(getScore(statistics), 0, 100);
  const difficulty = getDifficulty(score, languageSpecificConfiguration);
  return {
    score,
    difficulty
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/getKeywordDensity.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/getKeywordDensity.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getKeyphraseDensity;
exports.getKeywordDensity = getKeywordDensity;
var _getAllWordsFromTree = _interopRequireDefault(__webpack_require__(/*! ../helpers/word/getAllWordsFromTree */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getAllWordsFromTree.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Calculates the keyphrase density.
 *
 * @param {Paper} paper The paper containing keyphrase and text.
 * @param {Researcher} researcher The researcher.
 *
 * @returns {number} The keyphrase density.
 */
function getKeyphraseDensity(paper, researcher) {
  const getWordsCustomHelper = researcher.getHelper("getWordsCustomHelper");
  let wordCount = 0;

  // If there is a custom getWords helper, use its output for countWords.
  if (getWordsCustomHelper) {
    wordCount = getWordsCustomHelper(paper.getText()).length;
  } else {
    wordCount = (0, _getAllWordsFromTree.default)(paper).length;
  }
  if (wordCount === 0) {
    return 0;
  }
  const keyphraseCount = researcher.getResearch("getKeyphraseCount");
  return keyphraseCount.count / wordCount * 100;
}

/**
 * Calculates the keyphrase density.
 *
 * @deprecated Use getKeyphraseDensity instead.
 *
 * @param {Paper} paper The paper containing keyphrase and text.
 * @param {Researcher} researcher The researcher.
 *
 * @returns {number} The keyphrase density.
 */
function getKeywordDensity(paper, researcher) {
  console.warn("This function is deprecated, use getKeyphraseDensity instead.");
  return getKeyphraseDensity(paper, researcher);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/getLinkStatistics.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/getLinkStatistics.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _checkNofollow = _interopRequireDefault(__webpack_require__(/*! ../helpers/link/checkNofollow.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/link/checkNofollow.js"));
var _getAnchorsFromText = _interopRequireDefault(__webpack_require__(/*! ../helpers/link/getAnchorsFromText.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/link/getAnchorsFromText.js"));
var _getLinkType = _interopRequireDefault(__webpack_require__(/*! ../helpers/link/getLinkType.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/link/getLinkType.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Counts the links found in the text.
 *
 * @param {Paper} paper The paper object containing text, keyword and url.
 *
 * @returns {object} The object containing all linktypes.
 * total: the total number of links found.
 * internalTotal: the total number of links that are internal.
 * internalDofollow: the internal links without a nofollow attribute.
 * internalNofollow: the internal links with a nofollow attribute.
 * externalTotal: the total number of links that are external.
 * externalDofollow: the external links without a nofollow attribute.
 * externalNofollow: the internal links with a dofollow attribute.
 * otherTotal: all links that are not HTTP or HTTPS.
 * otherDofollow: other links without a nofollow attribute.
 * otherNofollow: other links with a nofollow attribute.
 */
function _default(paper) {
  const anchors = (0, _getAnchorsFromText.default)(paper.getText());
  /*
   * We get the site's URL (e.g., https://yoast.com) or domain (e.g., yoast.com) from the paper.
   * In case of WordPress, the variable is a URL. In case of Shopify, it is a domain.
   */
  const siteUrlOrDomain = paper.getPermalink();
  const linkCount = {
    total: anchors.length,
    internalTotal: 0,
    internalDofollow: 0,
    internalNofollow: 0,
    externalTotal: 0,
    externalDofollow: 0,
    externalNofollow: 0,
    otherTotal: 0,
    otherDofollow: 0,
    otherNofollow: 0
  };
  for (let i = 0; i < anchors.length; i++) {
    const currentAnchor = anchors[i];
    const linkType = (0, _getLinkType.default)(currentAnchor, siteUrlOrDomain);
    const linkFollow = (0, _checkNofollow.default)(currentAnchor);
    linkCount[linkType + "Total"]++;
    linkCount[linkType + linkFollow]++;
  }
  return linkCount;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/getLinks.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/getLinks.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _getAnchorsFromText = _interopRequireDefault(__webpack_require__(/*! ../helpers/link/getAnchorsFromText.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/link/getAnchorsFromText.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _url = _interopRequireDefault(__webpack_require__(/*! ../helpers/url/url.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/url/url.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module analyses/getLinkStatistics */

/**
 * Checks a text for anchors and returns the number found.
 *
 * @param {Object} paper The paper to get the text from.
 * @returns {Array} An array with the anchors
 */
function _default(paper) {
  const anchors = (0, _getAnchorsFromText.default)(paper.getText());
  return (0, _lodash.map)(anchors, _url.default.getFromAnchorTag);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/getLongCenterAlignedTexts.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/getLongCenterAlignedTexts.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ../helpers/html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
var _matchStringWithRegex = _interopRequireDefault(__webpack_require__(/*! ../helpers/regex/matchStringWithRegex */ "./node_modules/yoastseo/build/languageProcessing/helpers/regex/matchStringWithRegex.js"));
var _sanitizeString = _interopRequireDefault(__webpack_require__(/*! ../helpers/sanitize/sanitizeString */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/sanitizeString.js"));
var _filterShortcodesFromTree = __webpack_require__(/*! ../helpers/sanitize/filterShortcodesFromTree.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/filterShortcodesFromTree.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const centerAlignRegex = /class=["'].*?has-text-align-center.*?["']/i;
const paragraphsRegex = /<p(?:[^>]+)?>(.*?)<\/p>/ig;
const headingsRegex = /<h([1-6])(?:[^>]+)?>(.*?)<\/h\1>/ig;

/**
 * Filters out all elements that are center-aligned and longer than 50 characters (after stripping HTML tags).
 *
 * @param {string[]}    elements    An array containing all cases of a specific element that were found in a text.
 * @param {string}      elementType The type of the elements.
 *
 * @returns {Object[]}	An array containing all elements of a specific type that are center-aligned and longer than 50 characters.
 */
function getLongCenterAlignedElements(elements, elementType) {
  /**
   * Before counting the characters of a text, we sanitize the text first by removing HTML tags.
   * In the filtered array, we save the un-sanitized text.
   * This text will be used for highlighting feature where we will match this with the html of a post.
   */
  const longCenterAlignedTexts = elements.filter(element => centerAlignRegex.test(element) && (0, _sanitizeString.default)(element).length > 50);

  /*
   * Also specify the type of the element.
   * This information will be used when applying the highlighting to the text in the editor.
   */
  return longCenterAlignedTexts.map(text => {
    return {
      text,
      elementType
    };
  });
}

/**
 * Finds all paragraphs and headings that are center-aligned and longer than 50 characters (after stripping html tags).
 *
 * Returns an array with one object per paragraph/heading.
 * For example: [ {text: "abc", elementType: "heading"}, {text: "123", elementType: "paragraph"} ].
 *
 * @param {Paper}   paper   The paper to analyze.
 *
 * @returns {Object[]}	An array of objects for each too long center-aligned paragraph/heading.
 */
function _default(paper) {
  let text = paper.getText();
  text = (0, _htmlParser.default)(text);
  text = (0, _filterShortcodesFromTree.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);

  // Get all paragraphs from the text. We only retrieve the paragraphs with <p> tags.
  const allParagraphs = (0, _matchStringWithRegex.default)(text, paragraphsRegex);
  // Get all the headings from the text. Here we retrieve the headings from level 1-6.
  const allHeadings = (0, _matchStringWithRegex.default)(text, headingsRegex);
  const longParagraphsWithCenterAlignedText = getLongCenterAlignedElements(allParagraphs, "paragraph");
  const longHeadingsWithCenterAlignedText = getLongCenterAlignedElements(allHeadings, "heading");
  return (0, _lodash.flatten)(longParagraphsWithCenterAlignedText.concat(longHeadingsWithCenterAlignedText));
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/getParagraphLength.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/getParagraphLength.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _imageInText = __webpack_require__(/*! ../helpers/image/imageInText */ "./node_modules/yoastseo/build/languageProcessing/helpers/image/imageInText.js");
var _sanitizeLineBreakTag = _interopRequireDefault(__webpack_require__(/*! ../helpers/sanitize/sanitizeLineBreakTag */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/sanitizeLineBreakTag.js"));
var _countWords = _interopRequireDefault(__webpack_require__(/*! ../helpers/word/countWords.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/countWords.js"));
var _matchParagraphs = _interopRequireDefault(__webpack_require__(/*! ../helpers/html/matchParagraphs.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/matchParagraphs.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ../helpers/html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
var _helpers = __webpack_require__(/*! ../helpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Gets all paragraphs and their word counts or character counts from the text.
 *
 * @param {Paper} 		paper 		The paper object to get the text from.
 * @param {Researcher} 	researcher 	The researcher to use for analysis.
 *
 * @returns {Array} The array containing an object with the paragraph word or character count and paragraph text.
 */
function _default(paper, researcher) {
  let text = paper.getText();
  text = (0, _htmlParser.default)(text);
  text = (0, _helpers.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);

  // Remove images from text before retrieving the paragraphs.
  // This step is done here so that applying highlight in captions is possible for ParagraphTooLongAssessment.
  text = text.replace(_imageInText.imageRegex, "");

  // Replace line break tags containing attribute(s) with paragraph tag.
  text = (0, _sanitizeLineBreakTag.default)(text);
  const paragraphs = (0, _matchParagraphs.default)(text);
  const paragraphsLength = [];

  // An optional custom helper to count length to use instead of countWords.
  const customCountLength = researcher.getHelper("customCountLength");
  paragraphs.map(function (paragraph) {
    paragraphsLength.push({
      countLength: customCountLength ? customCountLength(paragraph) : (0, _countWords.default)(paragraph),
      text: paragraph
    });
  });
  return (0, _lodash.filter)(paragraphsLength, function (paragraphLength) {
    return paragraphLength.countLength > 0;
  });
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/getParagraphs.js":
/*!************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/getParagraphs.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Returns all paragraphs in a given Paper.
 * Remove paragraphs that do not contain sentences or only consist of links.
 *
 * @param {Paper} paper The current paper.
 * @returns {Paragraph[]} All paragraphs in the paper.
 */
function _default(paper) {
  let paragraphs = paper.getTree().findAll(node => node.name === "p");

  // Remove empty paragraphs without sentences and paragraphs only consisting of links.
  paragraphs = (0, _lodash.reject)(paragraphs, paragraph => paragraph.sentences.length === 0);
  paragraphs = (0, _lodash.reject)(paragraphs, paragraph => paragraph.childNodes.every(node => node.name === "a"));
  return paragraphs;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/getPassiveVoiceResult.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/getPassiveVoiceResult.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getPassiveVoice;
exports.getPeriphrasticPassives = exports.getMorphologicalPassives = void 0;
var _getSentences = _interopRequireDefault(__webpack_require__(/*! ../helpers/sentence/getSentences.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentences.js"));
var _stripHTMLTags = __webpack_require__(/*! ../helpers/sanitize/stripHTMLTags.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripHTMLTags.js");
var _Sentence = _interopRequireDefault(__webpack_require__(/*! ../../languageProcessing/values/Sentence.js */ "./node_modules/yoastseo/build/languageProcessing/values/Sentence.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ../helpers/html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
var _helpers = __webpack_require__(/*! ../helpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Looks for morphological passive voice.
 * Supported morphological languages: "ru", "sv", "id", "ar", "he", "tr", "fa".
 * Farsi is implemented as morphological because the periphrastic passives are used as compound verbs (among other compound passives).
 * @param {Paper}      paper      The paper object.
 * @param {Researcher} researcher The researcher.
 *
 * @returns {Object} The found passive sentences.
 */
const getMorphologicalPassives = function (paper, researcher) {
  const isPassiveSentence = researcher.getHelper("isPassiveSentence");
  let text = paper.getText();
  text = (0, _htmlParser.default)(text);
  text = (0, _helpers.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);
  const memoizedTokenizer = researcher.getHelper("memoizedTokenizer");
  const sentences = (0, _getSentences.default)(text, memoizedTokenizer).map(function (sentence) {
    return new _Sentence.default(sentence);
  });
  const totalNumberSentences = sentences.length;
  const passiveSentences = [];
  (0, _lodash.forEach)(sentences, function (sentence) {
    const strippedSentence = (0, _stripHTMLTags.stripFullTags)(sentence.getSentenceText()).toLocaleLowerCase();
    sentence.setPassive(isPassiveSentence(strippedSentence));
    if (sentence.isPassive() === true) {
      passiveSentences.push(sentence.getSentenceText());
    }
  });
  return {
    total: totalNumberSentences,
    passives: passiveSentences
  };
};

/**
 * Looks for periphrastic passive voice.
 * Supported periphrastic languages: "en", "de", "nl", "fr", "es", "it", "pt", "pl", "sk".
 *
 * @param {Paper}      paper      The paper object.
 * @param {Researcher} researcher The researcher.
 *
 * @returns {Object} The found passive sentences.
 */
exports.getMorphologicalPassives = getMorphologicalPassives;
const getPeriphrasticPassives = function (paper, researcher) {
  const getClauses = researcher.getHelper("getClauses");
  let text = paper.getText();
  text = (0, _htmlParser.default)(text);
  text = (0, _helpers.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);
  const memoizedTokenizer = researcher.getHelper("memoizedTokenizer");
  const sentences = (0, _getSentences.default)(text, memoizedTokenizer).map(function (sentence) {
    return new _Sentence.default(sentence);
  });
  const totalNumberSentences = sentences.length;
  const passiveSentences = [];
  (0, _lodash.forEach)(sentences, function (sentence) {
    const strippedSentence = (0, _stripHTMLTags.stripFullTags)(sentence.getSentenceText()).toLocaleLowerCase();

    // The functionality based on sentencePart objects should be rewritten using array indices of stopwords and auxiliaries.

    // Divide a sentence into clauses and return an array of clause objects that have been checked for passiveness.
    const clauses = getClauses(strippedSentence);
    sentence.setClauses(clauses);

    // Check sentence passiveness based on its clause passiveness.
    if (sentence.isPassive()) {
      passiveSentences.push(sentence.getSentenceText());
    }
  });
  return {
    total: totalNumberSentences,
    passives: passiveSentences
  };
};

/**
 * Looks for both morphological and periphrastic passive voice
 * Supported languages with both morphological and periphrastic passives: "hu", "nb".
 * Due to technical difficulties "nb" is only implemented as periphrastic at the moment. Languages that have not been implemented yet: "da".
 *
 * @param {Paper}      paper      The paper object.
 * @param {Researcher} researcher The researcher.
 *
 * @returns {Object} The found passive sentences.
 */
exports.getPeriphrasticPassives = getPeriphrasticPassives;
const getMorphologicalAndPeriphrasticPassive = function (paper, researcher) {
  const morphologicalPassives = getMorphologicalPassives(paper, researcher);
  const periphrasticPassives = getPeriphrasticPassives(paper, researcher).passives;
  return {
    total: morphologicalPassives.total,
    passives: periphrasticPassives.concat(morphologicalPassives.passives)
  };
};

/**
 * Looks for passive voice.
 *
 * @param {Paper}      paper      The paper object.
 * @param {Researcher} researcher The researcher.
 *
 * @returns {Object} The found passive sentences.
 */
function getPassiveVoice(paper, researcher) {
  const passiveType = researcher.getConfig("passiveConstructionType");
  if (passiveType === "periphrastic") {
    return getPeriphrasticPassives(paper, researcher);
  }
  if (passiveType === "morphological") {
    return getMorphologicalPassives(paper, researcher);
  }
  return getMorphologicalAndPeriphrasticPassive(paper, researcher);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/getProminentWordsForInsights.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/getProminentWordsForInsights.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _determineProminentWords = __webpack_require__(/*! ../helpers/prominentWords/determineProminentWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/prominentWords/determineProminentWords.js");
var _removeURLs = _interopRequireDefault(__webpack_require__(/*! ../helpers/sanitize/removeURLs.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removeURLs.js"));
var _removeEmailAddresses = _interopRequireDefault(__webpack_require__(/*! ../helpers/sanitize/removeEmailAddresses */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removeEmailAddresses.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Retrieves the prominent words from the given paper.
 *
 * @param {Paper} paper             The paper to determine the prominent words of.
 * @param {Researcher} researcher   The researcher to use for analysis.
 *
 * @returns {WordCombination[]} Prominent words for this paper, filtered and sorted.
 */
function getProminentWordsForInsights(paper, researcher) {
  const functionWords = researcher.getConfig("functionWords");
  // An optional custom helper to return custom function to return the stem of a word.
  const customStemmer = researcher.getHelper("customGetStemmer");
  const stemmer = customStemmer ? customStemmer(researcher) : researcher.getHelper("getStemmer")(researcher);
  // An optional custom helper to get words from the text.
  const getWordsCustomHelper = researcher.getHelper("getWordsCustomHelper");
  let text = paper.getText();
  // We don't want to include URLs or email addresses in prominent words.
  text = (0, _removeURLs.default)(text);
  text = (0, _removeEmailAddresses.default)(text);

  // If the language has a custom helper to get words from the text, we don't retrieve the abbreviation.
  const abbreviations = getWordsCustomHelper ? [] : (0, _determineProminentWords.retrieveAbbreviations)(text);
  const prominentWordsFromText = (0, _determineProminentWords.getProminentWords)(text, abbreviations, stemmer, functionWords, getWordsCustomHelper);
  const collapsedWords = (0, _determineProminentWords.collapseProminentWordsOnStem)(prominentWordsFromText);
  (0, _determineProminentWords.sortProminentWords)(collapsedWords);

  /*
   * Collapse the list of prominent words on stems, sort it, filter out all words that occur less than
   * 5 times in the text. Return the 20 top items from this list.
   */
  return (0, _lodash.take)((0, _determineProminentWords.filterProminentWords)(collapsedWords, 5), 20);
}
var _default = exports["default"] = getProminentWordsForInsights;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/getProminentWordsForInternalLinking.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/getProminentWordsForInternalLinking.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _countWords = _interopRequireDefault(__webpack_require__(/*! ../helpers/word/countWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/countWords.js"));
var _determineProminentWords = __webpack_require__(/*! ../helpers/prominentWords/determineProminentWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/prominentWords/determineProminentWords.js");
var _getSubheadings = __webpack_require__(/*! ../helpers/html/getSubheadings */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/getSubheadings.js");
var _baseStemmer = _interopRequireDefault(__webpack_require__(/*! ../helpers/morphology/baseStemmer */ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/baseStemmer.js"));
var _removeURLs = _interopRequireDefault(__webpack_require__(/*! ../helpers/sanitize/removeURLs.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removeURLs.js"));
var _removeEmailAddresses = _interopRequireDefault(__webpack_require__(/*! ../helpers/sanitize/removeEmailAddresses */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removeEmailAddresses.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Removes URLs and email addresses from the text.
 *
 * @param {string}	text	The text to sanitize.
 *
 * @returns {string} The text without URLs and email addresses.
 */
const sanitizeText = function (text) {
  text = (0, _removeURLs.default)(text);
  return (0, _removeEmailAddresses.default)(text);
};

/**
 * Retrieves the prominent words from the given paper.
 *
 * @param {Paper}       paper       The paper to determine the prominent words of.
 * @param {Researcher}  researcher  The researcher to use for analysis.
 *
 * @returns {Object}          result                    A compound result object.
 * @returns {ProminentWord[]} result.prominentWords     Prominent words for this paper, filtered and sorted.
 * @returns {boolean}         result.hasMetaDescription Whether the metadescription is available in the input paper.
 * @returns {boolean}         result.hasTitle           Whether the title is available in the input paper.
 */
function getProminentWordsForInternalLinking(paper, researcher) {
  const functionWords = researcher.getConfig("functionWords");
  // An optional custom helper to return custom function to return the stem of a word.
  const customStemmer = researcher.getHelper("customGetStemmer");
  const stemmer = customStemmer ? customStemmer(researcher) : researcher.getHelper("getStemmer")(researcher);
  // An optional custom helper to get words from the text.
  const getWordsCustomHelper = researcher.getHelper("getWordsCustomHelper");
  // An optional custom helper to count length to use instead of countWords.
  const customCountLength = researcher.getHelper("customCountLength");
  const text = sanitizeText(paper.getText());
  const metadescription = sanitizeText(paper.getDescription());
  const title = sanitizeText(paper.getTitle());
  const result = {};
  result.hasMetaDescription = metadescription !== "";
  result.hasTitle = title !== "";
  result.prominentWords = [];

  /**
   * We only want to return suggestions (and spend time calculating prominent words) if the text is at least 100 words.
   * And when a customCountLength is available, we only want to return the suggestions if the text has at least 200 characters.
  	 */
  if (customCountLength) {
    if (customCountLength(text) < 200) {
      return result;
    }
  } else if ((0, _countWords.default)(text) < 100) {
    return result;
  }
  const subheadings = (0, _getSubheadings.getSubheadingsTopLevel)(text).map(subheading => subheading[2]);
  const attributes = [paper.getKeyword(), paper.getSynonyms(), title, metadescription, subheadings.join(" ")];

  // If the language has a custom helper to get words from the text, we don't retrieve the abbreviation.
  const abbreviations = getWordsCustomHelper ? [] : (0, _determineProminentWords.retrieveAbbreviations)(text.concat(attributes.join(" ")));
  const removedSubheadingText = (0, _getSubheadings.removeSubheadingsTopLevel)(text);
  const prominentWordsFromText = (0, _determineProminentWords.getProminentWords)(removedSubheadingText, abbreviations, stemmer, functionWords, getWordsCustomHelper);
  const prominentWordsFromPaperAttributes = (0, _determineProminentWords.getProminentWordsFromPaperAttributes)(attributes, abbreviations, stemmer, functionWords, getWordsCustomHelper);

  /*
   * If a word is used in any of the attributes, its weight is automatically high.
   * To make sure the word survives weight filters and gets saved in the database, make the number of occurrences times-3.
   */
  prominentWordsFromPaperAttributes.forEach(relevantWord => relevantWord.setOccurrences(relevantWord.getOccurrences() * 3));
  const collapsedWords = (0, _determineProminentWords.collapseProminentWordsOnStem)(prominentWordsFromPaperAttributes.concat(prominentWordsFromText));
  (0, _determineProminentWords.sortProminentWords)(collapsedWords);

  /*
   * If morphology data are available for a language, the minimum number of occurrences to consider a word to be prominent is 4.
   * This minimum number was chosen in order to avoid premature suggestions of words from the paper attributes.
   * These get a times-3 boost and would therefore be prominent with just 1 occurrence.
   *
   * If morphology data are not available, and therefore word forms are not recognized, the minimum threshold is lowered to 2.
   */
  let minimumNumberOfOccurrences = 4;
  if (stemmer === _baseStemmer.default) {
    minimumNumberOfOccurrences = 2;
  }

  /*
   * Return the 100 top items from the collapsed and sorted list. The number is picked deliberately to prevent larger
   * articles from getting too long of lists.
   */
  result.prominentWords = (0, _lodash.take)((0, _determineProminentWords.filterProminentWords)(collapsedWords, minimumNumberOfOccurrences), 100);
  return result;
}
var _default = exports["default"] = getProminentWordsForInternalLinking;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/getSentenceBeginnings.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/getSentenceBeginnings.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _getWords = _interopRequireDefault(__webpack_require__(/*! ../helpers/word/getWords.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
var _getSentences = _interopRequireDefault(__webpack_require__(/*! ../helpers/sentence/getSentences */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentences.js"));
var _stripSpaces = _interopRequireDefault(__webpack_require__(/*! ../helpers/sanitize/stripSpaces.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripSpaces.js"));
var _stripHTMLTags = __webpack_require__(/*! ../helpers/sanitize/stripHTMLTags.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripHTMLTags.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ../helpers/html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
var _helpers = __webpack_require__(/*! ../helpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Compares the first word of each sentence with the first word of the following sentence.
 *
 * @param {string} currentSentenceBeginning The first word of the current sentence.
 * @param {string} nextSentenceBeginning The first word of the next sentence.
 * @returns {boolean} Returns true if sentence beginnings match.
 */
const startsWithSameWord = function (currentSentenceBeginning, nextSentenceBeginning) {
  return !(0, _lodash.isEmpty)(currentSentenceBeginning) && currentSentenceBeginning === nextSentenceBeginning;
};

/**
 * Counts the number of similar sentence beginnings.
 *
 * @param {Array} sentenceBeginnings The array containing the first word of each sentence.
 * @param {Array} sentences The array containing all sentences.
 * @returns {Array} The array containing the objects containing the first words and the corresponding counts.
 */
const compareFirstWords = function (sentenceBeginnings, sentences) {
  const consecutiveFirstWords = [];
  let foundSentences = [];
  let sameBeginnings = 1;
  (0, _lodash.forEach)(sentenceBeginnings, function (beginning, i) {
    const currentSentenceBeginning = beginning;
    const nextSentenceBeginning = sentenceBeginnings[i + 1];
    foundSentences.push(sentences[i]);
    if (startsWithSameWord(currentSentenceBeginning, nextSentenceBeginning)) {
      sameBeginnings++;
    } else {
      consecutiveFirstWords.push({
        word: currentSentenceBeginning,
        count: sameBeginnings,
        sentences: foundSentences
      });
      sameBeginnings = 1;
      foundSentences = [];
    }
  });
  return consecutiveFirstWords;
};

/**
 * Retrieves the first word from the sentence. If the first or second word is on an exception list of words that should not be considered as sentence
 * beginnings, the following word is also retrieved.
 *
 * @param {string}  sentence                The sentence to retrieve the first word from.
 * @param {Array}   firstWordExceptions     First word exceptions to match against.
 * @param {Array}   secondWordExceptions    Second word exceptions to match against.
 * @param {function}	getWordsCustomHelper   The language-specific helper function to retrieve words from text.
 *
 * @returns {string} The first word of the sentence.
 */
function getSentenceBeginning(sentence, firstWordExceptions, secondWordExceptions, getWordsCustomHelper) {
  const stripped = (0, _stripHTMLTags.stripFullTags)((0, _stripSpaces.default)(sentence));
  const words = getWordsCustomHelper ? getWordsCustomHelper(stripped) : (0, _getWords.default)(stripped);
  if (words.length === 0) {
    return "";
  }
  let firstWord = words[0].toLocaleLowerCase();
  if (firstWordExceptions.indexOf(firstWord) > -1 && words.length > 1) {
    firstWord = firstWord + " " + words[1];
    if (secondWordExceptions) {
      if (secondWordExceptions.includes(words[1])) {
        firstWord = firstWord + " " + words[2];
      }
    }
  }
  return firstWord;
}

/**
 * Gets the first word of each sentence from the text, and returns an object containing the first word of each sentence and the corresponding counts.
 *
 * @param {Paper}       paper       The Paper object to get the text from.
 * @param {Researcher}  researcher  The researcher this research is a part of.
 *
 * @returns {Object} The object containing the first word of each sentence and the corresponding counts.
 */
function _default(paper, researcher) {
  const firstWordExceptions = researcher.getConfig("firstWordExceptions");
  const secondWordExceptions = researcher.getConfig("secondWordExceptions");
  const getWordsCustomHelper = researcher.getHelper("getWordsCustomHelper");
  const memoizedTokenizer = researcher.getHelper("memoizedTokenizer");
  let text = paper.getText();
  text = (0, _htmlParser.default)(text);
  text = (0, _helpers.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);

  // Remove any HTML whitespace padding and replace it with a single whitespace.
  text = text.replace(/[\s\n]+/g, " ");

  // Exclude text inside tables.
  text = text.replace(/<figure class='wp-block-table'>.*<\/figure>/sg, "");

  // Exclude text inside list items.
  text = text.replace(/<li(?:[^>]+)?>(.*?)<\/li>/ig, "");
  let sentences = (0, _getSentences.default)(text, memoizedTokenizer);
  let sentenceBeginnings = sentences.map(function (sentence) {
    return getSentenceBeginning(sentence, firstWordExceptions, secondWordExceptions, getWordsCustomHelper);
  });
  sentences = sentences.filter(function (sentence) {
    const stripped = (0, _stripSpaces.default)(sentence);
    const words = getWordsCustomHelper ? getWordsCustomHelper(stripped) : (0, _getWords.default)(stripped);
    return words.length > 0;
  });
  sentenceBeginnings = (0, _lodash.filter)(sentenceBeginnings);
  return compareFirstWords(sentenceBeginnings, sentences);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/getSubheadingTextLengths.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/getSubheadingTextLengths.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _getSubheadingTexts = _interopRequireDefault(__webpack_require__(/*! ../helpers/html/getSubheadingTexts */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/getSubheadingTexts.js"));
var _countWords = _interopRequireDefault(__webpack_require__(/*! ../helpers/word/countWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/countWords.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ../helpers/html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
var _helpers = __webpack_require__(/*! ../helpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Gets the subheadings from the text and returns the length of these subheading in an array.
 *
 * @param {Paper}       paper       The Paper object to get the text from.
 * @param {Researcher}  researcher  The researcher to use for analysis.
 *
 * @returns {Object} The object containing the array of found subheadings and the length of the text before the first subheading.
 */
function _default(paper, researcher) {
  let text = paper.getText();
  text = (0, _htmlParser.default)(text);
  text = (0, _helpers.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);
  const matches = (0, _getSubheadingTexts.default)(text);

  // An optional custom helper to count length to use instead of countWords.
  const customCountLength = researcher.getHelper("customCountLength");
  const foundSubheadings = [];
  (0, _lodash.forEach)(matches, function (match) {
    foundSubheadings.push({
      subheading: match.subheading,
      text: match.text,
      countLength: customCountLength ? customCountLength(match.text) : (0, _countWords.default)(match.text),
      index: match.index
    });
  });
  let textBeforeFirstSubheadingLength = 0;
  let textBeforeFirstSubheading = "";
  if (foundSubheadings.length > 0) {
    // Find first subheading.
    const firstSubheading = foundSubheadings[0];
    // Retrieve text preceding first subheading.
    textBeforeFirstSubheading = text.slice(0, firstSubheading.index);
    textBeforeFirstSubheadingLength = customCountLength ? customCountLength(textBeforeFirstSubheading) : (0, _countWords.default)(textBeforeFirstSubheading);
  }

  // Check if there is a text before the first subheading.
  if (textBeforeFirstSubheadingLength > 0 && textBeforeFirstSubheading !== "") {
    // Also add the text before the first subheading to the array.
    foundSubheadings.unshift({
      // Assign an empty string for the subheading for text that comes before the first subheading.
      subheading: "",
      text: textBeforeFirstSubheading,
      countLength: textBeforeFirstSubheadingLength
    });
  }
  return foundSubheadings;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/getWordForms.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/getWordForms.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _quotes = __webpack_require__(/*! ../helpers/sanitize/quotes */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/quotes.js");
var _buildTopicStems = __webpack_require__(/*! ../helpers/morphology/buildTopicStems */ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/buildTopicStems.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _getAllWordsFromPaper = _interopRequireDefault(__webpack_require__(/*! ../helpers/morphology/getAllWordsFromPaper */ "./node_modules/yoastseo/build/languageProcessing/helpers/morphology/getAllWordsFromPaper.js"));
var _parseSynonyms = _interopRequireDefault(__webpack_require__(/*! ../helpers/sanitize/parseSynonyms */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/parseSynonyms.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * A stem with accompanying forms.
 *
 * @param {string}      stem    The word stem.
 * @param {string[]}    forms   The word forms for the stem.
 *
 * @constructor
 */
function StemWithForms(stem, forms) {
  this.stem = stem;
  this.forms = forms;
}

/**
 * A result for all topic forms.
 *
 * @param {Array[]} keyphraseForms  All keyphrase forms.
 * @param {Array[]} synonymsForms   All synonym forms.
 * @constructor
 */
function Result(keyphraseForms = [], synonymsForms = []) {
  this.keyphraseForms = keyphraseForms;
  this.synonymsForms = synonymsForms;
}

/**
 * Takes a stem-original pair and returns the accompanying forms for the stem that were found in the paper. Additionally
 * adds a sanitized version of the original word and (for specific languages) creates basic word forms.
 *
 * @param {StemOriginalPair}    stemOriginalPair            The stem-original pair for which to get forms.
 * @param {StemWithForms[]}     paperWordsGroupedByStems    All word forms in the paper grouped by stem.
 * @param {Function|null}       createBasicWordForms        A function to create basic word forms (if available).
 *
 * @returns {string[]} All forms found in the paper for the given stem, plus a sanitized version of the original word.
 */
function replaceStemWithForms(stemOriginalPair, paperWordsGroupedByStems, createBasicWordForms) {
  const matchingStemFormPair = paperWordsGroupedByStems.find(element => element.stem === stemOriginalPair.stem);
  const originalSanitized = (0, _quotes.normalizeSingle)((0, _lodash.escapeRegExp)(stemOriginalPair.original));
  const forms = matchingStemFormPair ? [originalSanitized, ...matchingStemFormPair.forms] : [originalSanitized];

  // Add extra forms for languages for which we have basic word form support.
  if (createBasicWordForms) {
    forms.push(...createBasicWordForms(stemOriginalPair.original));
  }

  /*
   * Return original and found or created forms.
   * Only return original if no matching forms were found in the text and no forms could be created.
   */
  return [...new Set(forms)];
}

/**
 * Extracts the stems from all keyphrase and synonym stems.
 *
 * @param {TopicPhrase}   keyphrase  A topic phrase.
 * @param {TopicPhrase[]} synonyms   An array of topic phrases.
 *
 * @returns {string[]} All word stems of they keyphrase and synonyms.
 */
function extractStems(keyphrase, synonyms) {
  const keyphraseStemsOnly = keyphrase.stemOriginalPairs.length === 0 ? [] : keyphrase.getStems();
  const synonymsStemsOnly = synonyms.length === 0 ? [] : synonyms.map(topicPhrase => topicPhrase.getStems());
  return [...keyphraseStemsOnly, ...(0, _lodash.flattenDeep)(synonymsStemsOnly)];
}

/**
 * Constructs the result with forms for a topic phrase (i.e., a keyphrase or a synonym).
 *
 * @param {TopicPhrase}     topicPhrase              The topic phrase for which to construct the result.
 * @param {StemWithForms[]} paperWordsGroupedByStems All word forms in the paper grouped by stem.
 * @param {Function|null}   createBasicWordForms     A function to create basic word forms (if available).
 *
 * @returns {Array.<string[]>} The word forms for a given topic phrase, grouped by original topic phrase word.
 */
function constructTopicPhraseResult(topicPhrase, paperWordsGroupedByStems, createBasicWordForms) {
  // Empty result for an empty topic phrase.
  if (topicPhrase.stemOriginalPairs.length === 0) {
    return [];
  }
  if (topicPhrase.exactMatch) {
    return [[topicPhrase.stemOriginalPairs[0].stem]];
  }
  return topicPhrase.stemOriginalPairs.map(function (stemOriginalPair) {
    return replaceStemWithForms(stemOriginalPair, paperWordsGroupedByStems, createBasicWordForms);
  });
}

/**
 * Gets all matching word forms for the keyphrase and synonyms. Stems are either collected from
 * the paper or, for specific languages, directly created.
 *
 * @param {string}          keyphrase               	The keyphrase.
 * @param {string[]}        synonyms                	The synonyms.
 * @param {string[]}        allWordsFromPaper       	All words found in the paper.
 * @param {string[]}        functionWords           	The function words for a given language (if available).
 * @param {Function|null}   stemmer                 	A stemmer (if available).
 * @param {Function|null}   createBasicWordForms    	A function to create basic word forms (if available).
 * @param {boolean}   		areHyphensWordBoundaries	Whether hyphens should be treated as word boundaries.

 * @returns {Object} Object with an array of keyphrase forms and an array of arrays of synonyms forms, based on the forms
 * found in the text or created forms.
 */
function getWordForms(keyphrase, synonyms, allWordsFromPaper, functionWords, stemmer, createBasicWordForms, areHyphensWordBoundaries) {
  const topicPhrases = (0, _buildTopicStems.collectStems)(keyphrase, synonyms, stemmer, functionWords, areHyphensWordBoundaries);
  const keyphraseStemmed = topicPhrases.keyphraseStems;
  const synonymsStemmed = topicPhrases.synonymsStems;

  // Return an empty result when no keyphrase and synonyms have been set.
  if (keyphraseStemmed.stemOriginalPairs.length === 0 && synonymsStemmed.length === 0) {
    return new Result();
  }

  // Return exact match if all topic phrases contain exact match. Forms don't need to be built in that case.
  const allTopicPhrases = [keyphraseStemmed, ...synonymsStemmed];
  if (allTopicPhrases.every(topicPhrase => topicPhrase.exactMatch === true)) {
    return new Result([[keyphraseStemmed.stemOriginalPairs[0].stem]], synonymsStemmed.map(synonym => [[synonym.stemOriginalPairs[0].stem]]));
  }

  // Get all stems from the keyphrase and synonyms.
  const topicStemsFlat = [...new Set(extractStems(keyphraseStemmed, synonymsStemmed))];

  /*
   * Get all words from the paper text, title, meta description and slug.
   * Filter duplicates and function words.
   */
  const paperWords = [...new Set(allWordsFromPaper.filter(word => !functionWords.includes(word)))];

  // Add stems to words from the paper, filter out all forms that aren't in the keyphrase or synonyms and order alphabetically.
  const paperWordsWithStems = paperWords.map(word => new _buildTopicStems.StemOriginalPair(stemmer(word), word)).filter(stemOriginalPair => topicStemsFlat.includes(stemOriginalPair.stem)).sort((a, b) => a.stem.localeCompare(b.stem));

  // Group word-stem pairs from the paper by stems.
  const paperWordsGroupedByStems = paperWordsWithStems.reduce(function (accumulator, stemOriginalPair) {
    const lastItem = accumulator[accumulator.length - 1];
    if (accumulator.length === 0 || lastItem.stem !== stemOriginalPair.stem) {
      accumulator.push(new StemWithForms(stemOriginalPair.stem, [stemOriginalPair.original]));
    } else {
      lastItem.forms.push(stemOriginalPair.original);
    }
    return accumulator;
  }, []);
  return new Result(constructTopicPhraseResult(keyphraseStemmed, paperWordsGroupedByStems, createBasicWordForms), synonymsStemmed.map(synonym => constructTopicPhraseResult(synonym, paperWordsGroupedByStems, createBasicWordForms)));
}

/**
 * Gets all matching word forms for the keyphrase and synonyms.
 *
 * @param {Paper}       paper       	The paper.
 * @param {Researcher}  researcher  	The researcher.
 *
 * @returns {Object} Object with an array of keyphrase forms and an array of arrays of synonyms forms, based on the forms
 * found in the text or created forms.
 */
function _default(paper, researcher) {
  const functionWords = researcher.getConfig("functionWords");
  const stemmer = researcher.getHelper("getStemmer")(researcher);
  const createBasicWordForms = researcher.getHelper("createBasicWordForms");
  const language = researcher.getConfig("language");
  /*
   * Whether we want to split words on hyphens depends on the language.
   * In all languages apart from Indonesian, we consider hyphens as word boundaries. But in Indonesian, hyphens are used
   * to form plural forms of nouns, e.g. 'buku' is the singular form for 'book' and 'buku-buku' is the plural form.
   * This is why we don't split words on hyphens in Indonesian and we consider 'buku-buku' as one word rather than two.
   */
  const areHyphensWordBoundaries = researcher.getConfig("areHyphensWordBoundaries");
  const allWordsFromPaper = (0, _getAllWordsFromPaper.default)(paper, areHyphensWordBoundaries).map(word => word.toLocaleLowerCase(language));
  const keyphrase = paper.getKeyword().toLocaleLowerCase(language).trim();
  const synonyms = (0, _parseSynonyms.default)(paper.getSynonyms().toLocaleLowerCase(language).trim());
  return getWordForms(keyphrase, synonyms, allWordsFromPaper, functionWords, stemmer, createBasicWordForms, areHyphensWordBoundaries);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/h1s.js":
/*!**************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/h1s.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Gets all H1s in a text, including their content and their position information.
 *
 * @param {Paper} paper The paper for which to get the H1s.
 *
 * @returns {Array} An array with all H1s, their content and position.
 */
function _default(paper) {
  const tree = paper.getTree();
  const h1Matches = tree.findAll(node => node.name === "h1");
  return h1Matches.map(h1Match => ({
    tag: "h1",
    content: h1Match.findAll(node => node.name === "#text").map(textNode => textNode.value).join(""),
    position: {
      startOffset: h1Match.sourceCodeLocation.startTag.endOffset,
      endOffset: h1Match.sourceCodeLocation.endTag.startOffset,
      clientId: h1Match.clientId || ""
    }
  })).filter(h1 => !!h1.content);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/imageCount.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/imageCount.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = imageCount;
var _getImagesInTree = _interopRequireDefault(__webpack_require__(/*! ../helpers/image/getImagesInTree */ "./node_modules/yoastseo/build/languageProcessing/helpers/image/getImagesInTree.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module researches/imageInText */

/**
 * Checks the amount of images in the text.
 *
 * @param {Paper} paper The paper to check for images.
 *
 * @returns {number} The amount of found images.
 */
function imageCount(paper) {
  const images = (0, _getImagesInTree.default)(paper);
  return images.length;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "getLongCenterAlignedTexts", ({
  enumerable: true,
  get: function () {
    return _getLongCenterAlignedTexts.default;
  }
}));
Object.defineProperty(exports, "keyphraseDistribution", ({
  enumerable: true,
  get: function () {
    return _keyphraseDistribution.default;
  }
}));
Object.defineProperty(exports, "wordComplexity", ({
  enumerable: true,
  get: function () {
    return _wordComplexity.default;
  }
}));
var _getLongCenterAlignedTexts = _interopRequireDefault(__webpack_require__(/*! ./getLongCenterAlignedTexts */ "./node_modules/yoastseo/build/languageProcessing/researches/getLongCenterAlignedTexts.js"));
var _wordComplexity = _interopRequireDefault(__webpack_require__(/*! ./wordComplexity */ "./node_modules/yoastseo/build/languageProcessing/researches/wordComplexity.js"));
var _keyphraseDistribution = _interopRequireDefault(__webpack_require__(/*! ./keyphraseDistribution */ "./node_modules/yoastseo/build/languageProcessing/researches/keyphraseDistribution.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/keyphraseDistribution.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/keyphraseDistribution.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.maximizeSentenceScores = exports.keyphraseDistributionResearcher = exports.getDistraction = exports["default"] = exports.computeScoresPerSentenceShortTopic = exports.computeScoresPerSentenceLongTopic = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _findKeywordFormsInString = __webpack_require__(/*! ../helpers/match/findKeywordFormsInString */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/findKeywordFormsInString.js");
var _markWordsInSentences = __webpack_require__(/*! ../helpers/word/markWordsInSentences */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/markWordsInSentences.js");
var _getSentences = _interopRequireDefault(__webpack_require__(/*! ../helpers/sentence/getSentences */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentences.js"));
var _parseSynonyms = _interopRequireDefault(__webpack_require__(/*! ../helpers/sanitize/parseSynonyms */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/parseSynonyms.js"));
var _mergeListItems = __webpack_require__(/*! ../helpers/sanitize/mergeListItems */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/mergeListItems.js");
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ../helpers/html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
var _filterShortcodesFromTree = __webpack_require__(/*! ../helpers/sanitize/filterShortcodesFromTree */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/filterShortcodesFromTree.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Checks whether at least half of the content words from the topic are found within the sentence.
 * Assigns a score to every sentence following the following schema:
 * 9 if at least half of the content words from the topic are in the sentence,
 * 3 otherwise.
 *
 * @param {Array}  topic     The word forms of all content words in a keyphrase or a synonym.
 * @param {Array}  sentences An array of all sentences in the text.
 * @param {string} locale    The locale of the paper to analyse.
 * @param {function}    matchWordCustomHelper 	The language-specific helper function to match word in text.
 *
 * @returns {Array} The scores per sentence.
 */
const computeScoresPerSentenceLongTopic = function (topic, sentences, locale, matchWordCustomHelper) {
  const sentenceScores = Array(sentences.length);
  for (let i = 0; i < sentences.length; i++) {
    const foundInCurrentSentence = (0, _findKeywordFormsInString.findWordFormsInString)(topic, sentences[i], locale, matchWordCustomHelper);
    if (foundInCurrentSentence.percentWordMatches >= 50) {
      sentenceScores[i] = 9;
    } else {
      sentenceScores[i] = 3;
    }
  }
  return sentenceScores;
};

/**
 * Checks whether all content words from the topic are found within one sentence.
 * Assigns a score to every sentence following the following schema:
 * 9 if all content words from the topic are in the sentence,
 * 3 if not all content words from the topic were found in the sentence.
 *
 * @param {Array}  topic     The word forms of all content words in a keyphrase or a synonym.
 * @param {Array}  sentences An array of all sentences in the text.
 * @param {string} locale    The locale of the paper to analyse.
 * @param {function}    matchWordCustomHelper 	The language-specific helper function to match word in text.
 *
 * @returns {Array} The scores per sentence.
 */
exports.computeScoresPerSentenceLongTopic = computeScoresPerSentenceLongTopic;
const computeScoresPerSentenceShortTopic = function (topic, sentences, locale, matchWordCustomHelper) {
  const sentenceScores = Array(sentences.length);
  for (let i = 0; i < sentences.length; i++) {
    const currentSentence = sentences[i];
    const foundInCurrentSentence = (0, _findKeywordFormsInString.findWordFormsInString)(topic, currentSentence, locale, matchWordCustomHelper);
    if (foundInCurrentSentence.percentWordMatches === 100) {
      sentenceScores[i] = 9;
    } else {
      sentenceScores[i] = 3;
    }
  }
  return sentenceScores;
};

/**
 * Maximizes scores: Give every sentence a maximal score that it got from analysis of all topics
 *
 * @param {Array} sentenceScores The scores for every sentence, as assessed per keyphrase and every synonym.
 *
 * @returns {Array} Maximal scores of topic relevance per sentence.
 */
exports.computeScoresPerSentenceShortTopic = computeScoresPerSentenceShortTopic;
const maximizeSentenceScores = function (sentenceScores) {
  const sentenceScoresTransposed = sentenceScores[0].map(function (col, i) {
    return sentenceScores.map(function (row) {
      return row[i];
    });
  });
  return sentenceScoresTransposed.map(function (scoresForOneSentence) {
    return (0, _lodash.max)(scoresForOneSentence);
  });
};

/**
 * Computes the maximally long piece of text that does not include the topic.
 *
 * @param {Array} sentenceScores The array of scores per sentence.
 *
 * @returns {number} The maximum number of sentences that do not include the topic.
 */
exports.maximizeSentenceScores = maximizeSentenceScores;
const getDistraction = function (sentenceScores) {
  const numberOfSentences = sentenceScores.length;
  const allTopicSentencesIndices = [];
  for (let i = 0; i < numberOfSentences; i++) {
    if (sentenceScores[i] > 3) {
      allTopicSentencesIndices.push(i);
    }
  }
  const numberOfTopicSentences = allTopicSentencesIndices.length;
  if (numberOfTopicSentences === 0) {
    return numberOfSentences;
  }

  /**
   * Add fake topic sentences at the very beginning and at the very end
   * to account for cases when the text starts or ends with a train of distraction.
   */
  allTopicSentencesIndices.unshift(-1);
  allTopicSentencesIndices.push(numberOfSentences);
  const distances = [];
  for (let i = 1; i < numberOfTopicSentences + 2; i++) {
    distances.push(allTopicSentencesIndices[i] - allTopicSentencesIndices[i - 1] - 1);
  }
  return (0, _lodash.max)(distances);
};

/**
 * Computes the per-sentence scores depending on the length of the topic phrase and maximizes them over all topic phrases.
 *
 * @param {Array}       sentences              The sentences to get scores for.
 * @param {Array}       topicFormsInOneArray   The topic phrases forms to search for in the sentences.
 * @param {string}      locale                 The locale to work in.
 * @param {Array}       functionWords           The function words list.
 * @param {function}    matchWordCustomHelper 	The language-specific helper function to match word in text.
 * @param {int}         topicLengthCriteria     The topic length criteria. The default value is 4, where a topic is considered short
 *                                              if it's less than 4 word long, and otherwise long.
 * @param {Array}       originalTopic           The array of the original form of the topic with function words filtered out.
 * @param {function}    wordsCharacterCount     The helper to calculate the characters length of all the words in the array.
 *
 * @returns {Object} An array with maximized score per sentence and an array with all sentences that do not contain the topic.
 */
exports.getDistraction = getDistraction;
const getSentenceScores = function (sentences, topicFormsInOneArray, locale, functionWords, matchWordCustomHelper, topicLengthCriteria = 4, originalTopic, wordsCharacterCount) {
  // Compute per-sentence scores of topic-relatedness.
  const topicNumber = topicFormsInOneArray.length;
  const sentenceScores = Array(topicNumber);

  // For languages with function words apply either full match or partial match depending on topic length
  if (functionWords.length > 0) {
    for (let i = 0; i < topicNumber; i++) {
      const topic = topicFormsInOneArray[i];
      /*
       * If the helper to calculate the characters length of all the words in the array is available,
       * we use this helper to calculate the characters length of the original topic form.
       * We then use the result and compare it with the topicLengthCriteria.
       */
      const topicLength = wordsCharacterCount ? wordsCharacterCount(originalTopic[i]) : topic.length;
      if (topicLength < topicLengthCriteria) {
        sentenceScores[i] = computeScoresPerSentenceShortTopic(topic, sentences, locale, matchWordCustomHelper);
      } else {
        sentenceScores[i] = computeScoresPerSentenceLongTopic(topic, sentences, locale, matchWordCustomHelper);
      }
    }
  } else {
    // For languages without function words apply the full match always
    for (let i = 0; i < topicNumber; i++) {
      const topic = topicFormsInOneArray[i];
      sentenceScores[i] = computeScoresPerSentenceShortTopic(topic, sentences, locale, matchWordCustomHelper);
    }
  }

  // Maximize scores: Give every sentence a maximal score that it got from analysis of all topics
  const maximizedSentenceScores = maximizeSentenceScores(sentenceScores);

  // Zip an array combining each sentence with the associated maximized score.
  const sentencesWithMaximizedScores = (0, _lodash.zipWith)(sentences, maximizedSentenceScores, (sentence, score) => {
    return {
      sentence,
      score
    };
  });

  // Filter sentences that contain topic words for future highlights.
  const sentencesWithTopic = sentencesWithMaximizedScores.filter(sentenceObject => sentenceObject.score > 3);
  return {
    maximizedSentenceScores: maximizedSentenceScores,
    sentencesWithTopic: sentencesWithTopic.map(sentenceObject => sentenceObject.sentence)
  };
};

/**
 * Determines which portions of the text did not receive a lot of content words from keyphrase and synonyms.
 *
 * @param {Paper}       paper               The paper to check the keyphrase distribution for.
 * @param {Researcher}  researcher          The researcher to use for analysis.
 *
 * @returns {Object} The scores of topic relevance per portion of text and an array of all word forms to highlight.
 */
const keyphraseDistributionResearcher = function (paper, researcher) {
  const functionWords = researcher.getConfig("functionWords");
  const matchWordCustomHelper = researcher.getHelper("matchWordCustomHelper");
  const getContentWordsHelper = researcher.getHelper("getContentWords");
  const wordsCharacterCount = researcher.getResearch("wordsCharacterCount");
  const memoizedTokenizer = researcher.getHelper("memoizedTokenizer");

  // Custom topic length criteria for languages that don't use the default value to determine whether a topic is long or short.
  const topicLengthCriteria = researcher.getConfig("topicLength").lengthCriteria;
  let text = paper.getText();
  text = (0, _htmlParser.default)(text);
  text = (0, _filterShortcodesFromTree.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);
  text = (0, _mergeListItems.mergeListItems)(text);
  const sentences = (0, _getSentences.default)(text, memoizedTokenizer);
  const topicForms = researcher.getResearch("morphology");
  const originalTopic = [];
  if (getContentWordsHelper) {
    originalTopic.push(getContentWordsHelper(paper.getKeyword()));
    (0, _parseSynonyms.default)(paper.getSynonyms()).forEach(synonym => originalTopic.push(getContentWordsHelper(synonym)));
  }
  const locale = paper.getLocale();
  const topicFormsInOneArray = [topicForms.keyphraseForms];
  topicForms.synonymsForms.forEach(function (synonym) {
    topicFormsInOneArray.push(synonym);
  });
  const allTopicWords = (0, _lodash.uniq)((0, _lodash.flattenDeep)(topicFormsInOneArray)).sort((a, b) => b.length - a.length);

  // Get per-sentence scores and sentences that have topic.
  const sentenceScores = getSentenceScores(sentences, topicFormsInOneArray, locale, functionWords, matchWordCustomHelper, topicLengthCriteria, originalTopic, wordsCharacterCount);
  const maximizedSentenceScores = sentenceScores.maximizedSentenceScores;
  const maxLengthDistraction = getDistraction(maximizedSentenceScores);
  return {
    sentencesToHighlight: (0, _markWordsInSentences.markWordsInSentences)(allTopicWords, sentenceScores.sentencesWithTopic, locale, matchWordCustomHelper),
    keyphraseDistributionScore: maxLengthDistraction / sentences.length * 100
  };
};
exports.keyphraseDistributionResearcher = keyphraseDistributionResearcher;
var _default = exports["default"] = keyphraseDistributionResearcher;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/keyphraseLength.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/keyphraseLength.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Determines the length in words of the keyphrase.
 *
 * @param {Paper} paper 			The paper to research
 * @param {Researcher} researcher 	The researcher to use for analysis
 *
 * @returns {Object} The length of the keyphrase and the function words list.
 */
function _default(paper, researcher) {
  const topicForms = researcher.getResearch("morphology");
  const functionWords = researcher.getConfig("functionWords");
  return {
    keyphraseLength: topicForms.keyphraseForms.length,
    functionWords: functionWords
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/keywordCount.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/keywordCount.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.countKeyphraseInText = countKeyphraseInText;
exports["default"] = getKeyphraseCount;
exports.keywordCount = keywordCount;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _getSentencesFromTree = _interopRequireDefault(__webpack_require__(/*! ../helpers/sentence/getSentencesFromTree */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentencesFromTree.js"));
var _quotes = __webpack_require__(/*! ../helpers/sanitize/quotes */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/quotes.js");
var _getMarkingsInSentence = _interopRequireDefault(__webpack_require__(/*! ../helpers/highlighting/getMarkingsInSentence */ "./node_modules/yoastseo/build/languageProcessing/helpers/highlighting/getMarkingsInSentence.js"));
var _matchWordFormsWithSentence = _interopRequireDefault(__webpack_require__(/*! ../helpers/match/matchWordFormsWithSentence */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/matchWordFormsWithSentence.js"));
var _isDoubleQuoted = _interopRequireDefault(__webpack_require__(/*! ../helpers/match/isDoubleQuoted */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/isDoubleQuoted.js"));
var _markWordsInSentences = __webpack_require__(/*! ../helpers/word/markWordsInSentences */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/markWordsInSentences.js");
var _getSentences = _interopRequireDefault(__webpack_require__(/*! ../helpers/sentence/getSentences */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentences.js"));
var _helpers = __webpack_require__(/*! ../helpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Counts the occurrences of the keyphrase in the text and creates the Mark objects for the matches.
 *
 * @param {(Sentence|string)[]}	sentences			The sentences to check.
 * @param {Array}		keyphraseForms				The keyphrase forms.
 * @param {string}		locale						The locale used in the analysis.
 * @param {function}	matchWordCustomHelper		A custom helper to match words with a text.
 * @param {boolean}		isExactMatchRequested		Whether the exact matching is requested.
 * @param {function}	customSplitIntoTokensHelper	A custom helper to split sentences into tokens.
 *
 * @returns {{markings: Mark[], count: number}} The number of keyphrase occurrences in the text and the Mark objects of the matches.
 */
function countKeyphraseInText(sentences, keyphraseForms, locale, matchWordCustomHelper, isExactMatchRequested, customSplitIntoTokensHelper) {
  const result = {
    count: 0,
    markings: []
  };
  sentences.forEach(sentence => {
    const matchesInSentence = keyphraseForms.map(wordForms => (0, _matchWordFormsWithSentence.default)(sentence, wordForms, locale, matchWordCustomHelper, isExactMatchRequested, customSplitIntoTokensHelper));

    // A sentence has at least one full-match of the keyphrase if each word occurs at least once.
    const isEachWordFound = matchesInSentence.every(wordForms => wordForms.count > 0);
    if (isEachWordFound) {
      /*
       * Retrieve all the occurrences' count of each word of the keyphrase and save it in an array.
       * matches: [ [ { matches: ["red"], count: 1 } ], [ { matches: ["pandas"], count: 2 } ] ]
       * counts: [ 1, 2 ]
       */
      const counts = matchesInSentence.map(match => match.count);
      /*
       * The number of the full-match count is the lowest count of the occurrences.
       * counts: [ 1, 2 ]
       * totalMatchCount: 1
       *
       * From the example above, the full-match is 1, because one of the "pandas" occurrences is not accompanied by "red"
       * to be counted as a full-match.
       */
      const totalMatchCount = Math.min(...counts);
      const foundWords = (0, _lodash.flattenDeep)(matchesInSentence.map(match => match.matches));
      let markings = [];
      if (matchWordCustomHelper) {
        // Currently, this check is only applicable for Japanese.
        markings = (0, _markWordsInSentences.markWordsInASentence)(sentence, foundWords, matchWordCustomHelper);
      } else {
        markings = (0, _getMarkingsInSentence.default)(sentence, foundWords);
      }
      result.count += totalMatchCount;
      result.markings.push(markings);
    }
  });
  return result;
}

/**
 * Calculates the keyphrase count, takes morphology into account.
 *
 * @param {Paper}       paper       The paper containing keyphrase and text.
 * @param {Researcher}  researcher  The researcher.
 *
 * @returns {{count: number, markings: Mark[], keyphraseLength: number}} An object containing the keyphrase count, markings and the kephrase length.
 */
function getKeyphraseCount(paper, researcher) {
  const result = {
    count: 0,
    markings: [],
    keyphraseLength: 0
  };
  const topicForms = researcher.getResearch("morphology");
  let keyphraseForms = topicForms.keyphraseForms;
  const keyphraseLength = keyphraseForms.length;

  /*
   * Normalize single quotes so that word form with different type of single quotes can still be matched.
   * For example, "key‛word" should match "key'word".
   */
  keyphraseForms = keyphraseForms.map(word => word.map(form => (0, _quotes.normalizeSingle)(form)));
  if (keyphraseLength === 0) {
    return result;
  }
  const matchWordCustomHelper = researcher.getHelper("matchWordCustomHelper");
  const customSentenceTokenizer = researcher.getHelper("memoizedTokenizer");
  const customSplitIntoTokensHelper = researcher.getHelper("splitIntoTokensCustom");
  const locale = paper.getLocale();
  const text = matchWordCustomHelper ? (0, _helpers.filterShortcodesFromHTML)(paper.getText(), paper._attributes && paper._attributes.shortcodes) : paper.getText();

  // When the custom helper is available, we're using the sentences retrieved from the text for the analysis.
  const sentences = matchWordCustomHelper ? (0, _getSentences.default)(text, customSentenceTokenizer) : (0, _getSentencesFromTree.default)(paper);
  // Exact matching is requested when the keyphrase is enclosed in double quotes.
  const isExactMatchRequested = (0, _isDoubleQuoted.default)(paper.getKeyword());

  /*
  * Count the amount of keyphrase occurrences in the sentences.
  * An occurrence is counted when all words of the keyphrase are contained within the sentence. Each sentence can contain multiple keyphrases.
  * (e.g. "The apple potato is an apple and a potato." has two occurrences of the keyphrase "apple potato").
  */
  const keyphraseFound = countKeyphraseInText(sentences, keyphraseForms, locale, matchWordCustomHelper, isExactMatchRequested, customSplitIntoTokensHelper);
  result.count = keyphraseFound.count;
  result.markings = (0, _lodash.flatten)(keyphraseFound.markings);
  result.keyphraseLength = keyphraseLength;
  return result;
}

/**
 * Calculates the keyphrase count, takes morphology into account.
 *
 * @deprecated Use getKeyphraseCount instead.
 *
 * @param {Paper}       paper       The paper containing keyphrase and text.
 * @param {Researcher}  researcher  The researcher.
 *
 * @returns {Object} An array of all the matches, markings and the keyphrase count.
 */
function keywordCount(paper, researcher) {
  console.warn("This function is deprecated, use getKeyphraseCount instead.");
  return getKeyphraseCount(paper, researcher);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/keywordCountInUrl.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/keywordCountInUrl.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
exports.keywordCountInSlug = keywordCountInSlug;
exports.keywordCountInUrl = keywordCountInUrl;
var _parseSlug = _interopRequireDefault(__webpack_require__(/*! ../helpers/url/parseSlug */ "./node_modules/yoastseo/build/languageProcessing/helpers/url/parseSlug.js"));
var _findKeywordFormsInString = __webpack_require__(/*! ../helpers/match/findKeywordFormsInString.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/findKeywordFormsInString.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/** @module researches/keywordCountInSlug */

/**
 * Matches the keyword in the slug. Replaces all dashes and underscores with whitespaces and uses whitespace as word boundary.
 *
 * @param {Paper} paper the Paper object to use in this count.
 * @param {Researcher} researcher The Researcher object containing all available researches.
 *
 * @returns {{keyphraseLength: int, percentWordMatches: int}} The length of the keyphrase and the percentage of keyphrase forms that has been found.
 */
function keywordCountInSlug(paper, researcher) {
  /*
   * We want to override the `areHyphensWordBoundaries` config value from the researcher so that it is `true` for all
   * languages. This is because slugs usually use hyphens (or underscores) as word boundaries. So if only the slug is
   * split on hyphens and not the keyphrase forms, some keyphrase forms won't be found in the slug.
   */
  const languageResearcher = (0, _lodash.cloneDeep)(researcher);
  languageResearcher.addConfig("areHyphensWordBoundaries", true);
  const topicForms = languageResearcher.getResearch("morphology");
  const parsedSlug = (0, _parseSlug.default)(paper.getSlug());
  const locale = paper.getLocale();
  const keyphraseInSlug = (0, _findKeywordFormsInString.findTopicFormsInString)(topicForms, parsedSlug, false, locale, false);
  return {
    keyphraseLength: topicForms.keyphraseForms.length,
    percentWordMatches: keyphraseInSlug.percentWordMatches
  };
}

/**
 * Matches the keyword in the slug.
 * keywordCountInUrl was the previous name for keywordCountInSlug (hence the name of this file).
 * We keep (and expose) this research for backwards compatibility.
 *
 * @deprecated Since version 18.7. Use keywordCountInSlug instead.
 *
 * @param {Paper} paper the Paper object to use in this count.
 * @param {Researcher} researcher The Researcher object containing all available researches.
 *
 * @returns {{keyphraseLength: int, percentWordMatches: int}} The length of the keyphrase and the percentage of keyphrase forms that has been found.
 */
function keywordCountInUrl(paper, researcher) {
  console.warn("This function is deprecated, use keywordCountInSlug instead.");
  return keywordCountInSlug(paper, researcher);
}
var _default = exports["default"] = keywordCountInSlug;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/matchKeywordInSubheadings.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/matchKeywordInSubheadings.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = matchKeywordInSubheadings;
var _getSubheadings = __webpack_require__(/*! ../helpers/html/getSubheadings */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/getSubheadings.js");
var _stripNonTextTags = _interopRequireDefault(__webpack_require__(/*! ../helpers/sanitize/stripNonTextTags */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripNonTextTags.js"));
var _findKeywordFormsInString = __webpack_require__(/*! ../helpers/match/findKeywordFormsInString */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/findKeywordFormsInString.js");
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ../helpers/html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
var _helpers = __webpack_require__(/*! ../helpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Computes the amount of subheadings reflecting the topic.
 *
 * @param {Object}      topicForms      The main key phrase and its synonyms to check.
 * @param {string[]}    subheadings     The subheadings to check.
 * @param {boolean}     useSynonyms     Whether to match synonyms or only main keyphrase.
 * @param {string}      locale          The current locale.
 * @param {Array}       functionWords	The function words list.
 * @param {function}    matchWordCustomHelper   The language-specific helper function to match word in text.
 *
 * @returns {number} The amount of subheadings reflecting the topic.
 */
const numberOfSubheadingsReflectingTopic = function (topicForms, subheadings, useSynonyms, locale, functionWords, matchWordCustomHelper) {
  return subheadings.filter(subheading => {
    const matchedTopicForms = (0, _findKeywordFormsInString.findTopicFormsInString)(topicForms, subheading, useSynonyms, locale, matchWordCustomHelper);
    if (functionWords.length === 0) {
      return matchedTopicForms.percentWordMatches === 100;
    }
    return matchedTopicForms.percentWordMatches > 50;
  }).length;
};

/**
 * Checks if there are any h2 or h3 subheadings in the text and if they have the keyphrase or synonyms in them.
 *
 * @param {Object}     paper      The paper object containing the text and keyword.
 * @param {Researcher} researcher The researcher object.
 *
 * @returns {Object} The result object.
 */
function matchKeywordInSubheadings(paper, researcher) {
  const functionWords = researcher.getConfig("functionWords");

  // A custom helper to match word in text.
  const matchWordCustomHelper = researcher.getHelper("matchWordCustomHelper");
  let text = paper.getText();
  text = (0, _htmlParser.default)(text);
  text = (0, _helpers.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);
  text = (0, _stripNonTextTags.default)(text);
  const topicForms = researcher.getResearch("morphology");
  const locale = paper.getLocale();
  const result = {
    count: 0,
    matches: 0,
    percentReflectingTopic: 0
  };
  const useSynonyms = true;
  const subheadings = (0, _getSubheadings.getSubheadingContentsTopLevel)(text);
  if (subheadings.length !== 0) {
    result.count = subheadings.length;
    result.matches = numberOfSubheadingsReflectingTopic(topicForms, subheadings, useSynonyms, locale, functionWords, matchWordCustomHelper);
    result.percentReflectingTopic = result.matches / result.count * 100;
  }
  return result;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/metaDescriptionKeyword.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/metaDescriptionKeyword.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _matchTextWithArray = _interopRequireDefault(__webpack_require__(/*! ../helpers/match/matchTextWithArray */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/matchTextWithArray.js"));
var _getSentences = _interopRequireDefault(__webpack_require__(/*! ../helpers/sentence/getSentences */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentences.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Replaces found keyword forms in the given description.
 *
 * @param {string}      description         The description to remove the matched keyword forms from.
 * @param {Object[]}    matchedKeywordForms The matched keyword forms to remove from the description.
 * @param {Number}      maxToRemove         The maximum amount of matches of each individual keyword to remove.
 *
 * @returns {string} The description with the keywords removed.
 */
const replaceFoundKeywordForms = function (description, matchedKeywordForms, maxToRemove) {
  // Replace matches so we do not match them for synonyms.
  matchedKeywordForms.forEach(keywordForm => keywordForm.matches.slice(0, maxToRemove).forEach(match => {
    description = description.replace(match, "");
  }));
  return description;
};

/**
 * Counts the number of full keyphrase matches in the given sentence. Takes synonyms into account.
 * A full keyphrase is when all keywords in the keyphrase match.
 *
 * @param {string}      sentence        The sentence that needs to be analyzed.
 * @param {Object}      topicForms      The keyphrase (and its optional synonyms') word forms.
 * @param {string}      locale          The current locale.
 * @param {function}    matchWordCustomHelper   The language-specific helper function to match word in text.
 *
 * @returns {Number} The number of matched keyphrases in the sentence.
 */
const matchPerSentence = function (sentence, topicForms, locale, matchWordCustomHelper) {
  // Focus keyphrase matches.
  const matchesKeyphrase = topicForms.keyphraseForms.map(keywordForms => (0, _matchTextWithArray.default)(sentence, keywordForms, locale, matchWordCustomHelper));
  // Count the number of matches that contain every word in the entire keyphrase.
  const fullKeyphraseMatches = Math.min(...matchesKeyphrase.map(match => match.count));

  // Replace all full keyphrase matches so we do not match them for synonyms.
  sentence = replaceFoundKeywordForms(sentence, matchesKeyphrase, fullKeyphraseMatches);

  // Keyphrase synonyms matches.
  const fullSynonymsMatches = topicForms.synonymsForms.map(synonymForms => {
    // Synonym keyphrase matches.
    const matches = synonymForms.map(keywordForms => (0, _matchTextWithArray.default)(sentence, keywordForms, locale, matchWordCustomHelper));
    // Count the number of matches that contain every word in the entire synonym keyphrase.
    const fullSynonymMatches = Math.min(...matches.map(match => match.count));
    // Replace all full matches so we do not match them for other synonyms.
    sentence = replaceFoundKeywordForms(sentence, matchesKeyphrase, fullSynonymMatches);
    return fullSynonymMatches;
  });
  return [fullKeyphraseMatches, ...fullSynonymsMatches].reduce((sum, count) => sum + count, 0);
};

/**
 * Counts the number of full keyphrase matches in the description.
 *
 * @param {Paper}       paper       The paper object containing the description.
 * @param {Researcher}  researcher  The researcher object to gather researchers from.
 *
 * @returns {Number} The number of keyphrase matches for the entire description.
 */
function _default(paper, researcher) {
  const description = paper.getDescription();
  const locale = paper.getLocale();
  const topicForms = researcher.getResearch("morphology");
  const matchWordCustomHelper = researcher.getHelper("matchWordCustomHelper");
  const memoizedTokenizer = researcher.getHelper("memoizedTokenizer");
  const sentences = (0, _getSentences.default)(description, memoizedTokenizer);
  const sentenceMatches = sentences.map(sentence => matchPerSentence(sentence, topicForms, locale, matchWordCustomHelper));
  return sentenceMatches.reduce((sum, count) => sum + count, 0);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/metaDescriptionLength.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/metaDescriptionLength.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = metaDescriptionLength;
var _countMetaDescriptionLength = _interopRequireDefault(__webpack_require__(/*! ../helpers/word/countMetaDescriptionLength */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/countMetaDescriptionLength.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Count the meta description length.
 *
 * @param {Paper} paper The paper to check for images.
 *
 * @returns {number|*}  The meta description length.
 */
function metaDescriptionLength(paper) {
  return (0, _countMetaDescriptionLength.default)(paper.getDate(), paper.getDescription());
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/pageTitleWidth.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/pageTitleWidth.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Check the width of the title in pixels
 * @param {Paper} paper The paper object containing the title width in pixels.
 * @returns {number} The width of the title in pixels
 */
function _default(paper) {
  if (paper.hasTitle()) {
    return paper.getTitleWidth();
  }
  return 0;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/readingTime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/readingTime.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _getLanguage = _interopRequireDefault(__webpack_require__(/*! ../../languageProcessing/helpers/language/getLanguage */ "./node_modules/yoastseo/build/languageProcessing/helpers/language/getLanguage.js"));
var _wordCountInText = _interopRequireDefault(__webpack_require__(/*! ./wordCountInText.js */ "./node_modules/yoastseo/build/languageProcessing/researches/wordCountInText.js"));
var _imageCount = _interopRequireDefault(__webpack_require__(/*! ./imageCount.js */ "./node_modules/yoastseo/build/languageProcessing/researches/imageCount.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Calculates the expected reading time of a text.
 *
 * @param {Paper} paper The paper to calculate the reading time for.
 * @param {Researcher} researcher The researcher.
 *
 * @returns {number} The expected reading time in minutes for a given language.
 */
function _default(paper, researcher) {
  const language = (0, _getLanguage.default)(paper.getLocale());

  // A helper to get words from the text for languages that don't use the default approach.
  const customGetWords = researcher.getHelper("getWordsCustomHelper");
  const countCharactersFromArray = researcher.getHelper("wordsCharacterCount");

  /*
   * These numbers (both in `wordsPerMinute` and `charactersPerMinute`) are based on research into average reading times:
   * Susanne Trauzettel-Klosinski, Klaus Dietz, the IReST Study Group;
   * Standardized Assessment of Reading Performance: The New International Reading Speed Texts IReST.
   * Invest. Ophthalmol. Vis. Sci. 2012;53(9):5452-5461
   */
  const wordsPerMinute = {
    ar: 138,
    cn: 158,
    de: 179,
    en: 228,
    es: 218,
    fi: 161,
    fr: 195,
    he: 187,
    it: 188,
    nl: 202,
    pl: 166,
    pt: 181,
    ru: 184,
    sl: 180,
    sv: 199,
    tr: 166
  };
  const charactersPerMinute = {
    ja: 357
  };
  const wordsPerMinuteScore = wordsPerMinute[language];
  const charactersPerMinuteScore = charactersPerMinute[language];

  // The default approach of calculating the text length is by counting the words in the text.
  let textLength = (0, _wordCountInText.default)(paper).count;
  let minutesToReadText;
  if (charactersPerMinuteScore) {
    /*
     * If a language has a characters per minute score, we assume that the language also uses a character count helper
     * for retrieving the text length and a custom helper to get words from the text.
     */
    textLength = countCharactersFromArray(customGetWords(paper.getText()));
    minutesToReadText = textLength / charactersPerMinuteScore;
  } else if (wordsPerMinuteScore) {
    minutesToReadText = textLength / wordsPerMinuteScore;
  } else {
    // If the language is not on both lists, assign the average of all language-dependent reading times as the score.
    const sumWordsPerMinute = Object.values(wordsPerMinute).reduce((a, b) => a + b);
    const sumNumberOfLanguages = Object.keys(wordsPerMinute).length;
    minutesToReadText = textLength / (sumWordsPerMinute / sumNumberOfLanguages);
  }
  const minutesPerImage = 0.2;
  const numberOfImages = (0, _imageCount.default)(paper);

  /*
   * This formula is based on the average number of words a person is expected to read per minute,
   * plus extra time for each image in the text. It returns the expected reading time in whole minutes,
   * rounded up to the nearest minute.
   */
  return Math.ceil(minutesToReadText + numberOfImages * minutesPerImage);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/sentences.js":
/*!********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/sentences.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _getSentences = _interopRequireDefault(__webpack_require__(/*! ../helpers/sentence/getSentences */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentences.js"));
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ../helpers/html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
var _helpers = __webpack_require__(/*! ../helpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Returns the sentences from a paper.
 *
 * @param {Paper}   paper       The paper to analyze.
 * @param {object}  researcher  The researcher.
 *
 * @returns {Array} Sentences found in the paper.
 */
function _default(paper, researcher) {
  const memoizedTokenizer = researcher.getHelper("memoizedTokenizer");
  let text = paper.getText();
  text = (0, _htmlParser.default)(text);
  text = (0, _helpers.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);
  return (0, _getSentences.default)(text, memoizedTokenizer);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/videoCount.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/videoCount.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = countVideoInText;
/**
 * Checks the amount of videos in the text.
 *
 * @param {Paper} paper The paper to check for videos.
 *
 * @returns {number} The amount of found videos.
 */
function countVideoInText(paper) {
  const videoTag = new RegExp("(<video).*?(</video>)", "igs");

  // Match videos occurrences in the text and save the matches in an array.
  let videoMatches = paper.getText().match(videoTag);

  // If no matches found, assign an empty array.
  if (videoMatches === null) {
    videoMatches = [];
  }
  return videoMatches.length;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/wordComplexity.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/wordComplexity.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = wordComplexity;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _getSentences = _interopRequireDefault(__webpack_require__(/*! ../helpers/sentence/getSentences */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentences.js"));
var _getWords = _interopRequireDefault(__webpack_require__(/*! ../helpers/word/getWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ../helpers/html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
var _filterShortcodesFromTree = __webpack_require__(/*! ../helpers/sanitize/filterShortcodesFromTree */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/filterShortcodesFromTree.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * An object containing the results of the complex words research for a single sentence.
 *
 * The structure of the data is:
 * @example
 * {
 * complexWords: ["word1", "word2", "word3" ],
 * sentence: "the sentence"
 * }
 *
 * @typedef {Object} 	ComplexWordsResult
 * @property {string[]}	complexWords	The complex words in the sentence.
 * @property {string}	sentence		The sentence.
 */

/**
 * Retrieves all complex words in a sentence.
 *
 * @param {string} 		currentSentence	The current sentence.
 * @param {Researcher} 	researcher		The researcher object.
 *
 * @returns {ComplexWordsResult} An object containing all complex words in a given sentence.
 */
const getComplexWords = function (currentSentence, researcher) {
  const language = researcher.getConfig("language");
  const checkIfWordIsComplex = researcher.getHelper("checkIfWordIsComplex");
  const functionWords = researcher.getConfig("functionWords");
  const wordComplexityConfig = researcher.getConfig("wordComplexity");
  const checkIfWordIsFunction = researcher.getHelper("checkIfWordIsFunction");
  const premiumData = (0, _lodash.get)(researcher.getData("morphology"), language, false);
  const allWords = (0, _getWords.default)(currentSentence);
  // Filters out function words because function words are not complex.
  // Words are converted to lowercase before processing to avoid excluding function words that start with a capital letter.
  const words = allWords.filter(word => !(checkIfWordIsFunction ? checkIfWordIsFunction(word) : functionWords.includes(word)));
  const result = {
    complexWords: [],
    sentence: currentSentence
  };
  if (!premiumData) {
    return result;
  }
  words.forEach(word => {
    if (checkIfWordIsComplex(wordComplexityConfig, word, premiumData)) {
      result.complexWords.push(word);
    }
  });
  return result;
};

/**
 * Calculates the percentage of the complex words compared to the total words in the text.
 *
 * @param {ComplexWordsResult[]}	complexWordsResults	The array of complex words results.
 * @param {string[]} 				words    			The array of words retrieved from the text.
 *
 * @returns {number} The percentage of the complex words compared to the total words in the text.
 */
const calculateComplexWordsPercentage = function (complexWordsResults, words) {
  const totalComplexWords = (0, _lodash.flatMap)(complexWordsResults, result => result.complexWords);
  const percentage = totalComplexWords.length / words.length * 100;

  // If the number is a decimal, round it to two numbers after the period, e.g. 5.12345 -> 5.12.
  // This approach is inspired from this thread: https://stackoverflow.com/questions/11832914/how-to-round-to-at-most-2-decimal-places-if-necessary.
  return +percentage.toFixed(2);
};

/**
 * Gets the complex words from the sentences and calculates the percentage of complex words compared to the total words in the text.
 * This is a research for the Word Complexity assessment. As such, this research is not part of the AbstractResearcher, and not bundled in Yoast SEO.
 *
 * @param {Paper}       paper       The Paper object to get the text from.
 * @param {Researcher}  researcher  The researcher object.
 *
 * @returns {{complexWords: ComplexWordsResult[], percentage: number}}
 * The complex words found and their percentage compared to the total words in the text.
 */
function wordComplexity(paper, researcher) {
  const memoizedTokenizer = researcher.getHelper("memoizedTokenizer");
  let text = paper.getText();
  text = (0, _htmlParser.default)(text);
  text = (0, _filterShortcodesFromTree.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);
  const sentences = (0, _getSentences.default)(text, memoizedTokenizer);

  // Find the complex words in each sentence.
  let results = sentences.map(sentence => getComplexWords(sentence, researcher));

  // Remove sentences without complex words.
  results = results.filter(result => result.complexWords.length !== 0);

  // Calculate the percentage of complex words in the text as a whole.
  const words = (0, _getWords.default)(text);
  const percentage = calculateComplexWordsPercentage(results, words);
  return {
    complexWords: results,
    percentage: percentage
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/researches/wordCountInText.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/researches/wordCountInText.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _countWords = _interopRequireDefault(__webpack_require__(/*! ../helpers/word/countWords.js */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/countWords.js"));
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ../helpers/html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
var _helpers = __webpack_require__(/*! ../helpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * A result of the word count calculation.
 *
 * @typedef WordCountResult
 * @param {number} count The number of words found in the text.
 * @param {"word"} unit The unit used in the text length calculations, always "word".
 */

/**
 * Count the words in the text.
 *
 * @param {Paper} paper The Paper object.
 *
 * @returns {WordCountResult} The number of words found in the text, plus "word" as the unit used in calculating the text length.
 */
function _default(paper) {
  let text = paper.getText();
  text = (0, _htmlParser.default)(text);
  text = (0, _helpers.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);
  return {
    text: text,
    count: (0, _countWords.default)(text),
    unit: "word"
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/values/Clause.js":
/*!*************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/values/Clause.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Sentence clause which should be checked for passiveness.
 *
 */
class Clause {
  /**
   * Constructs a clause object.
   *
   * @param {string} clauseText The text in the clause.
   * @param {Array} auxiliaries The auxiliaries in the clause.
   *
   * @constructor
   */
  constructor(clauseText, auxiliaries) {
    this._clauseText = clauseText;
    this._auxiliaries = auxiliaries;
    this._isPassive = false;
    this._participles = [];
  }
  /**
   * Returns the clause text.
   *
   * @returns {string} The clause text.
   */
  getClauseText() {
    return this._clauseText;
  }

  /**
   * Returns true if the clause is passive.
   *
   * @returns {boolean} Whether the clause is passive.
   */
  isPassive() {
    return this._isPassive;
  }

  /**
   * Returns the auxiliaries of the clause.
   *
   * @returns {Array} The auxiliaries present in the clause.
   */
  getAuxiliaries() {
    return this._auxiliaries;
  }

  /**
   * Sets the passiveness of the clause.
   *
   * @param {boolean} passive	 Whether the clause is passive.
   *
   * @returns {void}
   */
  setPassive(passive) {
    this._isPassive = passive;
  }

  /**
   * Sets the participles.
   *
   * @param {Array} participles	The participles.
   *
   * @returns {void}
   */
  setParticiples(participles) {
    this._participles = participles;
  }

  /**
   * Returns the found participles.
   *
   * @returns {Array} The participles
   */
  getParticiples() {
    return this._participles;
  }

  /**
   * Serializes the Clause instance to an object.
   *
   * @returns {Object} The serialized Clause.
   */
  serialize() {
    return {
      _parseClass: "Clause",
      clauseText: this._clauseText,
      auxiliaries: this._auxiliaries,
      isPassive: this._isPassive,
      participles: this._participles
    };
  }

  /**
   * Parses the object to a Clause.
   *
   * @param {Object} serialized The serialized object.
   *
   * @returns {Clause} The parsed Clause.
   */
  parse(serialized) {
    const clause = new Clause(serialized.clauseText, serialized.auxiliaries);
    clause.setPassive(serialized.isPassive);
    return clause;
  }
}
var _default = exports["default"] = Clause;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/values/ProminentWord.js":
/*!********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/values/ProminentWord.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Represents a prominent word in the context of relevant words.
 *
 * @constructor
 *
 * @param {string} word             The word.
 * @param {string} [stem]           The stem / base form of the word, defaults to the word.
 * @param {number} [occurrences]    The number of occurrences, defaults to 0.
 */
function ProminentWord(word, stem, occurrences) {
  this._word = word;
  this._stem = stem ? stem : word;
  this._occurrences = occurrences || 0;
}

/**
 * Sets the word.
 *
 * @param {string} word The word to set.
 *
 * @returns {void}.
 */
ProminentWord.prototype.setWord = function (word) {
  this._word = word;
};

/**
 * Returns the word.
 *
 * @returns {string} The word.
 */
ProminentWord.prototype.getWord = function () {
  return this._word;
};

/**
 * Returns the stem of the word.
 *
 * @returns {string} The stem.
 */
ProminentWord.prototype.getStem = function () {
  return this._stem;
};

/**
 * Sets the number of occurrences to the word.
 *
 * @param {int} numberOfOccurrences The number of occurrences to set.
 *
 * @returns {void}.
 */
ProminentWord.prototype.setOccurrences = function (numberOfOccurrences) {
  this._occurrences = numberOfOccurrences;
};

/**
 * Returns the amount of occurrences of this word.
 *
 * @returns {number} The number of occurrences.
 */
ProminentWord.prototype.getOccurrences = function () {
  return this._occurrences;
};

/**
 * Serializes the ProminentWord instance to an object.
 *
 * @returns {Object} The serialized ProminentWord.
 */
ProminentWord.prototype.serialize = function () {
  return {
    _parseClass: "ProminentWord",
    word: this._word,
    stem: this._stem,
    occurrences: this._occurrences
  };
};

/**
 * Parses the object to a ProminentWord.
 *
 * @param {Object} serialized The serialized object.
 *
 * @returns {ProminentWord} The parsed ProminentWord.
 */
ProminentWord.parse = function (serialized) {
  return new ProminentWord(serialized.word, serialized.stem, serialized.occurrences);
};
var _default = exports["default"] = ProminentWord;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/values/Sentence.js":
/*!***************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/values/Sentence.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Construct the Sentence object and set the sentence text.
 *
 * @param {string} sentence The text of the sentence.
 * @constructor
 */
class Sentence {
  /**
   * Constructor.
   *
   * @param {string} sentence The sentence.
   * @constructor
   */
  constructor(sentence) {
    this._sentenceText = sentence || "";
    this._isPassive = false;
    this._clauses = [];
  }

  /**
   * Returns the sentence text.
   *
   * @returns {string} The sentence.
   */
  getSentenceText() {
    return this._sentenceText;
  }

  /**
   * Returns the passiveness of a sentence.
   *
   * @returns {boolean} True if passive, otherwise returns false.
   */
  isPassive() {
    return this._isPassive;
  }

  /**
   * Sets the passiveness of the sentence.
   *
   * @param {boolean} passive Whether the sentence is passive or not.
   * @returns {void}
   */
  setPassive(passive) {
    this._isPassive = passive;
  }

  /**
   * Returns an array of clauses.
   *
   * @returns {Clause[]} The clauses of the sentence.
   */
  getClauses() {
    return this._clauses;
  }

  /**
   * Sets the clauses.
   *
   * @param {Clause[]} clauses The clauses of the sentence.
   *
   * @returns {void}
   */
  setClauses(clauses) {
    this._clauses = clauses;

    // Directly set the sentence passiveness based on the passiveness of the clauses that are just set.
    this.setSentencePassiveness();
  }

  /**
   * Sets the passiveness of the sentence. A sentence is passive if it contains at least one passive clause.
   *
   * @returns {void}
   */
  setSentencePassiveness() {
    const passiveClauses = this.getClauses().filter(clause => clause.isPassive() === true);
    this.setPassive(passiveClauses.length > 0);
  }

  /**
   * Serializes the Sentence instance to an object.
   *
   * @returns {Object} The serialized Sentence.
   */
  serialize() {
    return {
      _parseClass: "Sentence",
      sentenceText: this._sentenceText,
      isPassive: this._isPassive,
      clauses: this._clauses
    };
  }

  /**
   * Parses the object to a Sentence.
   *
   * @param {Object} serialized The serialized object.
   *
   * @returns {Sentence} The parsed Sentence.
   */
  parse(serialized) {
    const sentence = new Sentence(serialized.sentenceText);
    sentence.setClauses(serialized.clauses);
    sentence.setPassive(serialized.isPassive);
    return sentence;
  }
}
var _default = exports["default"] = Sentence;

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/values/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/values/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Clause", ({
  enumerable: true,
  get: function () {
    return _Clause.default;
  }
}));
Object.defineProperty(exports, "ProminentWord", ({
  enumerable: true,
  get: function () {
    return _ProminentWord.default;
  }
}));
Object.defineProperty(exports, "Sentence", ({
  enumerable: true,
  get: function () {
    return _Sentence.default;
  }
}));
var _Clause = _interopRequireDefault(__webpack_require__(/*! ./Clause */ "./node_modules/yoastseo/build/languageProcessing/values/Clause.js"));
var _ProminentWord = _interopRequireDefault(__webpack_require__(/*! ./ProminentWord */ "./node_modules/yoastseo/build/languageProcessing/values/ProminentWord.js"));
var _Sentence = _interopRequireDefault(__webpack_require__(/*! ./Sentence */ "./node_modules/yoastseo/build/languageProcessing/values/Sentence.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/markers/addMark.js":
/*!********************************************************!*\
  !*** ./node_modules/yoastseo/build/markers/addMark.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Marks a text with HTML tags
 *
 * @param {string} text The unmarked text.
 * @returns {string} The marked text.
 */
function _default(text) {
  return "<yoastmark class='yoast-text-mark'>" + text + "</yoastmark>";
}

/***/ }),

/***/ "./node_modules/yoastseo/build/markers/addMarkSingleWord.js":
/*!******************************************************************!*\
  !*** ./node_modules/yoastseo/build/markers/addMarkSingleWord.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _stripWordBoundaries = __webpack_require__(/*! ../languageProcessing/helpers/sanitize/stripWordBoundaries */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripWordBoundaries.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Marks a text with HTML tags, deals with word boundaries that were matched by regexes, but which should not be marked.
 *
 * @param {string} text The unmarked text.
 *
 * @returns {string} The marked text.
 */
function _default(text) {
  // Strip the word boundaries at the start of the text.
  const strippedTextStart = (0, _stripWordBoundaries.stripWordBoundariesStart)(text);
  let wordBoundaryStart = "";
  let wordBoundaryEnd = "";

  // Get the actual word boundaries from the start of the text.
  if (strippedTextStart !== text) {
    const wordBoundaryStartIndex = text.search((0, _lodash.escapeRegExp)(strippedTextStart));
    wordBoundaryStart = text.substring(0, wordBoundaryStartIndex);
  }

  // Strip word boundaries at the end of the text.
  const strippedTextEnd = (0, _stripWordBoundaries.stripWordBoundariesEnd)(strippedTextStart);
  // Get the actual word boundaries from the end of the text.
  if (strippedTextEnd !== strippedTextStart) {
    const wordBoundaryEndIndex = strippedTextStart.search((0, _lodash.escapeRegExp)(strippedTextEnd)) + strippedTextEnd.length;
    wordBoundaryEnd = strippedTextStart.substring(wordBoundaryEndIndex);
  }
  return wordBoundaryStart + "<yoastmark class='yoast-text-mark'>" + strippedTextEnd + "</yoastmark>" + wordBoundaryEnd;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/markers/index.js":
/*!******************************************************!*\
  !*** ./node_modules/yoastseo/build/markers/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "addMark", ({
  enumerable: true,
  get: function () {
    return _addMark.default;
  }
}));
Object.defineProperty(exports, "removeMarks", ({
  enumerable: true,
  get: function () {
    return _removeMarks.default;
  }
}));
var _removeMarks = _interopRequireDefault(__webpack_require__(/*! ./removeMarks */ "./node_modules/yoastseo/build/markers/removeMarks.js"));
var _addMark = _interopRequireDefault(__webpack_require__(/*! ./addMark */ "./node_modules/yoastseo/build/markers/addMark.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/markers/removeDuplicateMarks.js":
/*!*********************************************************************!*\
  !*** ./node_modules/yoastseo/build/markers/removeDuplicateMarks.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Removes duplicate marks from an array.
 * If the marks object have position information, however,
 * we don't want to remove the duplicated objects with the same original strings.
 *
 * @param {Array} marks The marks to remove duplications from.
 *
 * @returns {Array} A list of de-duplicated marks.
 */
function removeDuplicateMarks(marks) {
  /*
   * We don't remove duplicates when mark has position information, for the reasons below:
   * 1. Not removing duplicates is simpler than removing the duplicates by looking at the value of mark.getPosition().
   * 2. Our current approach of creating a mark object with position information eliminates the chance of having duplicates.
   */
  if (!!marks && (marks.length === 0 || !!marks[0].hasPosition())) {
    return marks;
  }
  return (0, _lodash.uniqBy)(marks, function (mark) {
    return mark.getOriginal();
  });
}
var _default = exports["default"] = removeDuplicateMarks;

/***/ }),

/***/ "./node_modules/yoastseo/build/markers/removeMarks.js":
/*!************************************************************!*\
  !*** ./node_modules/yoastseo/build/markers/removeMarks.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Removes all marks from a text
 *
 * @param {string} text The marked text.
 * @returns {string} The unmarked text.
 */
function _default(text) {
  return text.replace(new RegExp("<yoastmark[^>]*>", "g"), "").replace(new RegExp("</yoastmark>", "g"), "");
}

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/build/build.js":
/*!**********************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/build/build.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = build;
var _parse = __webpack_require__(/*! parse5 */ "./node_modules/parse5/dist/cjs/index.js");
var _adapt = _interopRequireDefault(__webpack_require__(/*! ./private/adapt */ "./node_modules/yoastseo/build/parse/build/private/adapt.js"));
var _tokenize = _interopRequireDefault(__webpack_require__(/*! ./private/tokenize */ "./node_modules/yoastseo/build/parse/build/private/tokenize.js"));
var _filterTree = _interopRequireDefault(__webpack_require__(/*! ./private/filterTree */ "./node_modules/yoastseo/build/parse/build/private/filterTree.js"));
var _alwaysFilterElements = _interopRequireDefault(__webpack_require__(/*! ./private/alwaysFilterElements */ "./node_modules/yoastseo/build/parse/build/private/alwaysFilterElements.js"));
var _filterBeforeTokenizing = __webpack_require__(/*! ./private/filterBeforeTokenizing */ "./node_modules/yoastseo/build/parse/build/private/filterBeforeTokenizing.js");
var _parseBlocks = _interopRequireDefault(__webpack_require__(/*! ./private/parseBlocks */ "./node_modules/yoastseo/build/parse/build/private/parseBlocks.js"));
var _filterShortcodesFromTree = _interopRequireDefault(__webpack_require__(/*! ../../languageProcessing/helpers/sanitize/filterShortcodesFromTree */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/filterShortcodesFromTree.js"));
var _htmlEntities = __webpack_require__(/*! ../../helpers/htmlEntities */ "./node_modules/yoastseo/build/helpers/htmlEntities.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
// External dependencies.

// Internal dependencies.

/**
 * Parses the HTML string to a tree representation of the HTML document.
 *
 * @param {Paper} paper The paper to build the tree from.
 * @param {LanguageProcessor} languageProcessor The language processor to use.
 * @param {string[]} [shortcodes] An optional array of all active shortcodes.
 *
 * @returns {Node} The tree representation of the HTML string.
 */
function build(paper, languageProcessor, shortcodes) {
  let html = paper.getText();
  // Change HTML entities like "&amp;" to "#amp;" to prevent early conversion to "&" -- which would invalidate token positions.
  html = html.replace(_htmlEntities.htmlEntitiesRegex, "#$1");
  let tree = (0, _adapt.default)((0, _parse.parseFragment)(html, {
    sourceCodeLocationInfo: true
  }));
  if (tree.childNodes && tree.childNodes.length > 0) {
    (0, _parseBlocks.default)(paper, tree);
  }

  /*
   * Filter out some content from the tree so that it can be correctly tokenized. We don't want to tokenize text in
   * between tags such as 'code' and 'script', but we do want to take into account the length of those elements when
   * calculating sentence and token positions.
   */
  tree = (0, _filterBeforeTokenizing.filterBeforeTokenizing)(tree);

  // Add sentences and tokens to the tree's paragraph and heading nodes.
  tree = (0, _tokenize.default)(tree, languageProcessor);

  // Filter out shortcodes from the tree.
  if (shortcodes) {
    (0, _filterShortcodesFromTree.default)(tree, shortcodes);
  }

  /*
   * Filter out elements we don't want to include in the analysis. Only do this after tokenization as we need to
   * have all inline elements in the tree during tokenization to correctly calculate sentence and token positions.
   */
  return (0, _filterTree.default)(tree, _alwaysFilterElements.default);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/build/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/build/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "build", ({
  enumerable: true,
  get: function () {
    return _build.default;
  }
}));
var _build = _interopRequireDefault(__webpack_require__(/*! ./build */ "./node_modules/yoastseo/build/parse/build/build.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/build/private/adapt.js":
/*!******************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/build/private/adapt.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = adapt;
var _combineIntoImplicitParagraphs = _interopRequireDefault(__webpack_require__(/*! ./combineIntoImplicitParagraphs */ "./node_modules/yoastseo/build/parse/build/private/combineIntoImplicitParagraphs.js"));
var _adaptAttributes = _interopRequireDefault(__webpack_require__(/*! ./adaptAttributes */ "./node_modules/yoastseo/build/parse/build/private/adaptAttributes.js"));
var _isPhrasingContent = _interopRequireDefault(__webpack_require__(/*! ./isPhrasingContent */ "./node_modules/yoastseo/build/parse/build/private/isPhrasingContent.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _structure = __webpack_require__(/*! ../../structure */ "./node_modules/yoastseo/build/parse/structure/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Whether the element with the specified name is a paragraph.
 *
 * @param {string} nodeName The name/tag of the node.
 *
 * @returns {boolean} Whether the element is considered a paragraph.
 */
function isParagraph(nodeName) {
  return nodeName === "p";
}

/**
 * Whether the element with the specified name is a heading.
 *
 * @param {string} nodeName The name/tag of the node.
 *
 * @returns {boolean} Whether the element is considered a heading.
 */
function isHeading(nodeName) {
  return ["h1", "h2", "h3", "h4", "h5", "h6"].includes(nodeName);
}

/**
 * Whether the element is text.
 *
 * @param {string} nodeName The name/tag of the node.
 *
 * @returns {boolean} Whether the element is considered text.
 */
function isText(nodeName) {
  return nodeName === "#text";
}

/**
 * Whether the element with the specified name is a block level element.
 *
 * @param {string} nodeName The name/tag of the node.
 *
 * @returns {boolean} Whether the element is considered a block level element.
 */
function isBlockElement(nodeName) {
  return !(isParagraph(nodeName) || (0, _isPhrasingContent.default)(nodeName) || isHeading(nodeName));
}

/**
 * Checks whether the current node is an overarching paragraph.
 * Overarching paragraphs have double `<br>` nodes (line breaks) in their children.
 * We consider those to be indicating the end and start of an implicit paragraph, similar to the `autop` function in WordPress.
 *
 * @param {string} nodeName The name of the current node.
 * @param {Node[]} children The children of the current nodes.
 *
 * @returns {boolean} Whether the current node is an overarching paragraph.
 */
function isOverarchingParagraph(nodeName, children) {
  return isParagraph(nodeName) && children.some((node, index, childNodes) => {
    const nextNode = childNodes.length - 1 !== index && childNodes[index + 1];
    return node.name === "br" && nextNode && nextNode.name === "br";
  });
}

/**
 * Adapts the `parse5` tree to our own tree representation.
 *
 * By adapting the external `parse5` structure to our own tree representation
 * we reduce the coupling between our code and theirs, which makes our code
 * more robust against changes in the `parse5` library. [See also this blog post about coupling](https://mrpicky.dev/six-shades-of-coupling/)
 *
 * @param {Object} tree The parse5 tree representation.
 *
 * @returns {Node} The adapted tree.
 */
function adapt(tree) {
  if (isText(tree.nodeName)) {
    return new _structure.Text(tree);
  }
  let children = [];
  let isOverarching = false;
  if (!(0, _lodash.isEmpty)(tree.childNodes)) {
    children = tree.childNodes.map(adapt);
    if (isBlockElement(tree.nodeName)) {
      children = (0, _combineIntoImplicitParagraphs.default)(children, tree.sourceCodeLocation);
    }
    if (isOverarchingParagraph(tree.nodeName, children)) {
      isOverarching = true;
      children = (0, _combineIntoImplicitParagraphs.default)(children, tree.sourceCodeLocation);
    }
  }
  const attributes = (0, _adaptAttributes.default)(tree.attrs);
  if (isParagraph(tree.nodeName)) {
    return new _structure.Paragraph(attributes, children, tree.sourceCodeLocation, false, isOverarching);
  }
  if (isHeading(tree.nodeName)) {
    const headingLevel = parseInt(tree.nodeName[1], 10);
    return new _structure.Heading(headingLevel, attributes, children, tree.sourceCodeLocation);
  }
  return new _structure.Node(tree.nodeName, attributes, children, tree.sourceCodeLocation);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/build/private/adaptAttributes.js":
/*!****************************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/build/private/adaptAttributes.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _parseClassAttribute = _interopRequireDefault(__webpack_require__(/*! ./helpers/parseClassAttribute */ "./node_modules/yoastseo/build/parse/build/private/helpers/parseClassAttribute.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * @typedef Parse5Attribute
 * @property {string} name The name of the attribute.
 * @property {string} value The value of the attribute.
 */

/**
 * Adapts name-value attribute pairs as output by `parse5`
 * and transforms it into an easier to use object mapping attribute names
 * to values.
 *
 * @param {Parse5Attribute[]|null} parse5attributes The attributes as name-value pairs.
 *
 * @returns {Object} The attributes as an object mapping attribute name to value.
 */
function adaptAttributes(parse5attributes) {
  if (!parse5attributes) {
    return {};
  }
  const attributes = {};
  parse5attributes.forEach(({
    name,
    value
  }) => {
    if (name === "class") {
      value = (0, _parseClassAttribute.default)(value);
    }
    attributes[name] = value;
  });
  return attributes;
}
var _default = exports["default"] = adaptAttributes;

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/build/private/alwaysFilterElements.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/build/private/alwaysFilterElements.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.canBeChildOfParagraph = void 0;
var _filterHelpers = __webpack_require__(/*! ./filterHelpers */ "./node_modules/yoastseo/build/parse/build/private/filterHelpers.js");
/**
 * A config file that contains filters that should always apply.
 */

// These are elements that we don't want to include in the analysis and that can be child nodes of paragraphs or headings.
const canBeChildOfParagraph = exports.canBeChildOfParagraph = ["code", "kbd", "math", "q", "samp", "script", "var", "#comment", "cite", "form", "map", "noscript", "output"];
const permanentFilters = [
// Filters out Yoast blocks that don't need to be part of the analysis.
// The only Yoast blocks that are not filtered out are the FAQ and the How-to block.
// The other Yoast blocks we want to filter (i.e. Yoast siblings, Yoast subpages, Yoast breadcrumbs) enter the Paper as HTML comments.
// Comments are filtered out in `filterBeforeTokenizing.js` step.
(0, _filterHelpers.elementHasClass)("yoast-table-of-contents"), (0, _filterHelpers.elementHasClass)("yoast-reading-time__wrapper"),
// Filters for Elementor widgets
(0, _filterHelpers.elementHasID)("breadcrumbs"), (0, _filterHelpers.elementHasClass)("elementor-button-wrapper"), (0, _filterHelpers.elementHasClass)("elementor-divider"), (0, _filterHelpers.elementHasClass)("elementor-spacer"), (0, _filterHelpers.elementHasClass)("elementor-custom-embed"), (0, _filterHelpers.elementHasClass)("elementor-icon-wrapper"), (0, _filterHelpers.elementHasClass)("elementor-icon-box-wrapper"), (0, _filterHelpers.elementHasClass)("elementor-counter"), (0, _filterHelpers.elementHasClass)("elementor-progress-wrapper"),
// This element is used for the progress bar widget title.
(0, _filterHelpers.elementHasClass)("elementor-title"), (0, _filterHelpers.elementHasClass)("elementor-alert"), (0, _filterHelpers.elementHasClass)("elementor-soundcloud-wrapper"), (0, _filterHelpers.elementHasClass)("elementor-shortcode"), (0, _filterHelpers.elementHasClass)("elementor-menu-anchor"), (0, _filterHelpers.elementHasClass)("e-rating"),
// Filters out HTML elements.
/* Elements are filtered out when: they contain content outside of the author's control (incl. quotes and embedded
content); their content isn't natural language (e.g. code); they contain metadata hidden from the page visitor
(e.g. <style>); they are used to accept input from the visitor. Deprecated HTML elements are not included.*/
(0, _filterHelpers.elementHasName)("base"), (0, _filterHelpers.elementHasName)("blockquote"), (0, _filterHelpers.elementHasName)("canvas"), (0, _filterHelpers.elementHasName)("code"),
// It seems that the <head> element is filtered out by the parser we employ, but it's included here for completeness.
(0, _filterHelpers.elementHasName)("head"), (0, _filterHelpers.elementHasName)("iframe"), (0, _filterHelpers.elementHasName)("input"), (0, _filterHelpers.elementHasName)("kbd"), (0, _filterHelpers.elementHasName)("link"), (0, _filterHelpers.elementHasName)("math"), (0, _filterHelpers.elementHasName)("meta"), (0, _filterHelpers.elementHasName)("meter"), (0, _filterHelpers.elementHasName)("noscript"), (0, _filterHelpers.elementHasName)("object"), (0, _filterHelpers.elementHasName)("portal"), (0, _filterHelpers.elementHasName)("pre"), (0, _filterHelpers.elementHasName)("progress"), (0, _filterHelpers.elementHasName)("q"), (0, _filterHelpers.elementHasName)("samp"), (0, _filterHelpers.elementHasName)("script"), (0, _filterHelpers.elementHasName)("slot"), (0, _filterHelpers.elementHasName)("style"), (0, _filterHelpers.elementHasName)("svg"), (0, _filterHelpers.elementHasName)("template"), (0, _filterHelpers.elementHasName)("textarea"), (0, _filterHelpers.elementHasName)("title"), (0, _filterHelpers.elementHasName)("var"), (0, _filterHelpers.elementHasName)("#comment"), (0, _filterHelpers.elementHasName)("cite"), (0, _filterHelpers.elementHasName)("form"), (0, _filterHelpers.elementHasName)("map"), (0, _filterHelpers.elementHasName)("noscript"), (0, _filterHelpers.elementHasName)("output")];
var _default = exports["default"] = permanentFilters;

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/build/private/combineIntoImplicitParagraphs.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/build/private/combineIntoImplicitParagraphs.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _isPhrasingContent = _interopRequireDefault(__webpack_require__(/*! ./isPhrasingContent */ "./node_modules/yoastseo/build/parse/build/private/isPhrasingContent.js"));
var _structure = __webpack_require__(/*! ../../structure */ "./node_modules/yoastseo/build/parse/structure/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _SourceCodeLocation = _interopRequireDefault(__webpack_require__(/*! ../../structure/SourceCodeLocation */ "./node_modules/yoastseo/build/parse/structure/SourceCodeLocation.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Checks whether a node is inter-element whitespace.
 *
 * @see https://html.spec.whatwg.org/#inter-element-whitespace
 *
 * @param {Object} node The node to check.
 *
 * @returns {boolean} Whether the node is inter-element whitespace.
 */
function isInterElementWhitespace(node) {
  return node.name === "#text" && node.value && node.value.match(/^[\n\s]+$/g);
}

/**
 * Checks whether a node has any children.
 *
 * @param {Object} node The node to check.
 *
 * @returns {boolean} Whether the node has any children.
 */
function hasChildren(node) {
  return node && node.childNodes.length > 0;
}

/**
 * Updates the source code location of an implicit paragraph based on its children.
 * @param {Paragraph} implicitParagraph The implicit paragraph to update.
 * @returns {void}
 */
const updateImplicitParagraphLocation = implicitParagraph => {
  const [firstChild] = implicitParagraph.childNodes.slice(0);
  const [lastChild] = implicitParagraph.childNodes.slice(-1);
  if ((firstChild.sourceCodeRange || firstChild.sourceCodeLocation) && (lastChild.sourceCodeRange || lastChild.sourceCodeLocation)) {
    const startOffset = firstChild.sourceCodeRange ? firstChild.sourceCodeRange.startOffset : firstChild.sourceCodeLocation.startOffset;
    const endOffset = lastChild.sourceCodeRange ? lastChild.sourceCodeRange.endOffset : lastChild.sourceCodeLocation.endOffset;
    implicitParagraph.sourceCodeLocation = new _SourceCodeLocation.default({
      startOffset: startOffset,
      endOffset: endOffset
    });
  }
};

/**
 * Checks whether the current node is part of a double line break.
 * @param {Node} currentNode The current node.
 * @param {Node} prevNode The previous node (if available).
 * @param {Node} nextNode The next node (if available).
 * @returns {boolean} Whether the current node is part of a double line break
 */
const isPartOfDoubleBreak = (currentNode, prevNode, nextNode) => {
  const prevNodeIsBreak = prevNode && prevNode.name === "br";
  const nextNodeIsBreak = nextNode && nextNode.name === "br";
  return currentNode.name === "br" && (prevNodeIsBreak || nextNodeIsBreak);
};

/**
 * Combines series of consecutive phrasing content ("inline" tags like `a` and `span`, and text) into implicit paragraphs.
 *
 * @see https://html.spec.whatwg.org/#paragraphs
 *
 * @param {Array} nodes The nodes to combine where able to.
 * @param {Object} parentSourceCodeLocation This parent node's location in the source code, from parse5.
 *
 * @returns {Array} The combined nodes.
 */
function combineIntoImplicitParagraphs(nodes, parentSourceCodeLocation = {}) {
  const newNodes = [];
  let currentSourceCodeLocation = {};
  // For implicit paragraphs, strip off the start and end tag information from the parent's source code location.
  if ((0, _lodash.isEmpty)(parentSourceCodeLocation)) {
    const firstNode = nodes[0];
    const lastNode = nodes[nodes.length - 1];
    if (firstNode && lastNode && firstNode.sourceCodeLocation && lastNode.sourceCodeLocation) {
      currentSourceCodeLocation = new _SourceCodeLocation.default({
        startOffset: firstNode.sourceCodeLocation.startOffset,
        endOffset: lastNode.sourceCodeLocation.endOffset
      });
    }
  } else {
    currentSourceCodeLocation = new _SourceCodeLocation.default({
      startOffset: parentSourceCodeLocation.startTag ? parentSourceCodeLocation.startTag.endOffset : parentSourceCodeLocation.startOffset,
      endOffset: parentSourceCodeLocation.endTag ? parentSourceCodeLocation.endTag.startOffset : parentSourceCodeLocation.endOffset
    });
  }
  let implicitParagraph = _structure.Paragraph.createImplicit({}, [], currentSourceCodeLocation);
  nodes.forEach((node, index, allNodes) => {
    const prevNode = 0 !== index && allNodes[index - 1];
    const nextNode = allNodes.length - 1 !== index && allNodes[index + 1];
    if ((0, _isPhrasingContent.default)(node.name) && !isInterElementWhitespace(node) && !isPartOfDoubleBreak(node, prevNode, nextNode)) {
      // If the node is phrasing content, add it to the implicit paragraph.
      implicitParagraph.childNodes.push(node);
    } else {
      // If the node is not phrasing content, this means that the implicit paragraph has ended.
      if (hasChildren(implicitParagraph)) {
        // If the implicit paragraph has children this means an implicit paragraph was created:
        // end the current implicit paragraph and start a new one.

        // But before pushing, we need to update the source code location of the implicit paragraph based on its child nodes.
        updateImplicitParagraphLocation(implicitParagraph);

        // Update the startOffset of the next implicit paragraph to be the end of the current node.
        if (node.sourceCodeLocation) {
          currentSourceCodeLocation.startOffset = node.sourceCodeLocation.endOffset;
        }
        newNodes.push(implicitParagraph);
        implicitParagraph = _structure.Paragraph.createImplicit({}, [], currentSourceCodeLocation);
      }
      newNodes.push(node);
    }
  });
  if (hasChildren(implicitParagraph)) {
    updateImplicitParagraphLocation(implicitParagraph);
    newNodes.push(implicitParagraph);
  }
  return newNodes;
}
var _default = exports["default"] = combineIntoImplicitParagraphs;

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/build/private/filterBeforeTokenizing.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/build/private/filterBeforeTokenizing.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.filterBeforeTokenizing = filterBeforeTokenizing;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _alwaysFilterElements = __webpack_require__(/*! ./alwaysFilterElements */ "./node_modules/yoastseo/build/parse/build/private/alwaysFilterElements.js");
/**
 * Removes all child nodes from nodes that we want to exclude from the analysis, and that can be children of a paragraph
 * or heading.
 *
 * The child nodes are removed because we don't want to include any text between those nodes in the analysis.
 * If we don't remove them here, the text between those nodes will be considered as part of the paragraph's
 * inner text and will be tokenized.
 *
 * These changes are only necessary for elements that can be children of paragraphs or headings. For example, we also
 * don't want to analyze content in between `blockquote` tags, but these cannot be children of paragraphs/headings.
 * Because of that, they wouldn't interfere with tokenizing the text inside paragraphs and headings and calculating
 * the positions.
 *
 * @param {Node} node The node to check.
 *
 * @returns {Node} The filtered out node that's ready to be tokenized.
 */
function filterBeforeTokenizing(node) {
  if (_alwaysFilterElements.canBeChildOfParagraph.includes(node.name)) {
    node.childNodes = [];
  }

  // Recursively filters the node's children.
  if (!(0, _lodash.isEmpty)(node.childNodes)) {
    node.childNodes.map(filterBeforeTokenizing);
  }
  return node;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/build/private/filterHelpers.js":
/*!**************************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/build/private/filterHelpers.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.elementHasClass = elementHasClass;
exports.elementHasID = elementHasID;
exports.elementHasName = elementHasName;
/**
 * Filter helpers for the html tree filter.
 * All helpers are functions that return a callback with the element as the only argument.
 */

/**
 * Creates a callback that checks if an element has a specific name.
 *
 * @param {string} name The name to check.
 *
 * @returns {function(*)} A function that returns true if the element has a specific name.
 */
function elementHasName(name) {
  return element => {
    return element.name === name;
  };
}

/**
 * Creates a callback that checks the class of an element.
 *
 * @param {string} className The classname to filter out.
 *
 * @returns {function(*): boolean} A function that returns true if a Node has a certain class.
 */
function elementHasClass(className) {
  return blockElement => {
    return !!blockElement.attributes.class && blockElement.attributes.class.has(className);
  };
}

/**
 * Creates a callback that checks if an element has a certain ID.
 *
 * @param {string} id The ID we want to check against.
 *
 * @returns {function(*): boolean}  A function that returns true if an element has a certain ID.
 */
function elementHasID(id) {
  return element => {
    return element.attributes.id === id;
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/build/private/filterTree.js":
/*!***********************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/build/private/filterTree.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = filterTree;
var _structure = __webpack_require__(/*! ../../structure */ "./node_modules/yoastseo/build/parse/structure/index.js");
/**
 * Checks if a node should be kept or discarded.
 * @param {Node} 		node 		A node.
 * @param {Function[]} 	filters 	An array of filter callbacks.
 * @returns {boolean} True if the node should be kept, false if the node should be discarded.
 */
function shouldRemoveNode(node, filters) {
  // Always keep text nodes.
  if (node.name === "#text") {
    return false;
  }

  // If any of the filters returns true, the node will be discarded.
  return filters.some(filter => filter(node));
}

/**
 * A recursive function that removes all nodes based on an array of filters.
 * @param {Node} 		node 		A node. (Could be the entire tree.)
 * @param {Function[]} 	filters 	An array of callbacks. If a callback returns true, the node is discarded.
 * @returns {Node|undefined} A Node with all undesired subtrees removed.
 */
function filterTree(node, filters) {
  // Returns undefined when the node should be disregarded.
  if (shouldRemoveNode(node, filters)) {
    return;
  }

  // Recursively filters the node's children.
  if (node.childNodes) {
    node.childNodes = node.childNodes.filter(childNode => filterTree(childNode, filters));

    // Drops implicit paragraphs if all their child nodes have been removed.
    if (node.childNodes.length === 0 && node instanceof _structure.Paragraph && node.isImplicit) {
      return;
    }
  }
  return node;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/build/private/getTextElementPositions.js":
/*!************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/build/private/getTextElementPositions.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = getTextElementPositions;
var _structure = __webpack_require__(/*! ../../structure */ "./node_modules/yoastseo/build/parse/structure/index.js");
var _alwaysFilterElements = __webpack_require__(/*! ./alwaysFilterElements */ "./node_modules/yoastseo/build/parse/build/private/alwaysFilterElements.js");
/**
 * Gets the start and end positions of all descendant nodes' tags and stores them in an array.
 * Each object in the array represents an opening or closing tag for nodes that have tags, or the full node for nodes
 * without tags (such as 'comment' nodes).
 * The startOffset and endOffset properties of the objects correspond to the start and end positions of the tags, or the
 * start and end positions of the full node for nodes without tags.
 * Extracting this data into a separate array makes it easier to work with it (e.g. sort it and loop over it).
 *
 * @param {Node[]} descendantNodes	The descendant nodes to get positions from.
 *
 * @returns {SourceCodeRange[]}	An array of the locations of each start and end tag in the source code, or the start and
 * 								end locations of the full node for nodes without tags.
 *
 */
function getDescendantPositions(descendantNodes) {
  const descendantTagPositions = [];
  descendantNodes.forEach(node => {
    /*
     * For nodes whose content we don't want to analyze, we should add the length of the full node to the array, to
     * still take into account the whole element's length when calculating positions.
     */
    if (_alwaysFilterElements.canBeChildOfParagraph.includes(node.name)) {
      descendantTagPositions.push(node.sourceCodeLocation);
    } else {
      if (node.sourceCodeLocation.startTag) {
        const startRange = {
          startOffset: node.sourceCodeLocation.startTag.startOffset,
          endOffset: node.sourceCodeLocation.startTag.endOffset
        };
        /*
         * Here, we need to account for the fact that earlier (in innerText.js), we treated a <br> as a newline character.
         * Therefore, we need to subtract 1 from the endOffset to not count it twice.
         */
        if (node.name === "br") {
          startRange.endOffset = startRange.endOffset - 1;
        }
        descendantTagPositions.push(startRange);
      }
      /*
       * Check whether node has an end tag before adding it to the array.
       * Some nodes, such as the 'img' node, only have a start tag.
       */
      if (node.sourceCodeLocation.endTag) {
        descendantTagPositions.push(node.sourceCodeLocation.endTag);
      }
    }
  });
  // Sort the tag position objects by the start tag position in ascending order.
  descendantTagPositions.sort((a, b) => a.startOffset - b.startOffset);
  return descendantTagPositions;
}

/**
 * Adjusts the end position of the text element to account for descendant node tags that overlap with the text element.
 * We want to add the length of tags that are directly preceding the start of the text, or that are between the start
 * and end of the text, to the end position of the text element.
 * For example, if the text is "<span><em>Hello</em>, world!</span>", the length of all tags except for the closing
 * </span> tag should be added to the end position of the sentence.
 *
 * @param {SourceCodeRange[]}	descendantTagPositions	The positions of the descendant nodes' tags.
 * @param {number}				textElementStart		The start position of a text element.
 * @param {number}				textElementEnd			The end position of a text element.
 *
 * @returns {number}	The adjusted end position of the text element.
 */
function adjustElementEnd(descendantTagPositions, textElementStart, textElementEnd) {
  /*
   * If the start position of a descendant's node tag is between the start and end position of the text element, or is
   * the same as the start position of the text element, add the tag's length to the end position of the text element.
   */
  descendantTagPositions.forEach(position => {
    if (position.startOffset >= textElementStart && position.startOffset < textElementEnd) {
      textElementEnd += position.endOffset - position.startOffset;
    }
  });
  return textElementEnd;
}

/**
 * Adjusts the start position of the text element to exclude descendant node tags at the beginning of the text element.
 * For example, the start position of the text element `<span>Hello!</span>`
 * should be adjusted to start at the `H`, not at the start tag of the opening `<span>` tag.
 * @param {SourceCodeRange[]} descendantTagPositions The positions of the descendant nodes' tags.
 * @param {Number} textElementStart The start position of a text element.
 *
 * @returns {Number} The adjusted start position of the text element.
 */
function adjustTextElementStart(descendantTagPositions, textElementStart) {
  /*
   * If the start position of a descendant's node tag is between the start and end position of the text element, or is
   * the same as the start/end position of the text element, add the tag's length to the end position of the text element.
   */
  descendantTagPositions.forEach(position => {
    if (position.startOffset === textElementStart) {
      textElementStart += position.endOffset - position.startOffset;
    }
  });
  return textElementStart;
}

/**
 * Retrieves the initial start offset for the first text element.
 * Normally, that is the end offset of the start tag of the parent node.
 * In case of implicit paragraphs, we use the start offset of the node as a whole.
 *
 * @param {Paragraph|Heading} node The node to retrieve the start position from.
 * @returns {number} The start offset for the first text element.
 */
const getTextElementStart = node => {
  return node instanceof _structure.Paragraph && node.isImplicit ? node.sourceCodeLocation.startOffset : node.sourceCodeLocation.startTag.endOffset;
};

/**
 * Gets the start and end positions of text elements (sentences or tokens) in the source code.
 *
 * @param {Paragraph|Heading} 		node  			The paragraph or heading node.
 * @param {Sentence[]|Token[]} 		textElements 	The sentences or tokens in the node.
 * @param {number} 					startOffset 	The start position of the node in the source code.
 * Defaults to -1 which signals that it should not be used.
 *
 * @returns {Sentence[]|Token[]} The sentences or tokens, with their positions in the source code.
 */
function getTextElementPositions(node, textElements, startOffset = -1) {
  // We cannot calculate positions if there are no text elements, or if we don't know the node's source code location.
  if (textElements.length === 0 || !node.sourceCodeLocation) {
    return textElements;
  }

  /*
   * Set the (initial) start offset of the first text element.
   * If the start offset has been provided (in the case of Tokens), use that.
   * Otherwise, determine the start offset from the parent Paragraph or Heading node.
   */
  let textElementStart = startOffset >= 0 ? startOffset : getTextElementStart(node);
  let textElementEnd;
  let descendantTagPositions = [];

  /*
   * Check if the node has any descendant nodes that have a sourceCodeLocation property (all nodes other than Text nodes
   * should have this property). If such nodes exist, store the positions of each node's opening and closing tags in
   * an array. These positions will have to be taken into account when calculating the position of the text elements.
   */
  if (node.findAll) {
    const descendantNodes = node.findAll(descendantNode => descendantNode.sourceCodeLocation, true);
    if (descendantNodes.length > 0) {
      descendantTagPositions = getDescendantPositions(descendantNodes);
    }
  }
  textElements.forEach(textElement => {
    // Set the end position to the start position + the length of the textElement.
    textElementEnd = textElementStart + textElement.text.length;

    /*
     * If there are descendant tags, possibly adjust the textElementEnd and textElementStart.
     * The textElementEnd should be adjusted to include the length of any descendant tags until the end of the text, in
     * addition to the length of the text itself. Descendant tags AFTER the end of the text should not be included.
     * The textElementStart should be adjusted so that it is where the actual text starts, not including any descendant
     * tags preceding the text.
     */
    if (descendantTagPositions.length > 0) {
      textElementEnd = adjustElementEnd(descendantTagPositions, textElementStart, textElementEnd);
      textElementStart = adjustTextElementStart(descendantTagPositions, textElementStart);
    }

    // Add the start and end positions to the textElement object.
    textElement.sourceCodeRange = {
      startOffset: textElementStart,
      endOffset: textElementEnd
    };

    // Start position of the next textElement is the end position of current textElement.
    textElementStart = textElementEnd;
  });
  return textElements;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/build/private/helpers/parseClassAttribute.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/build/private/helpers/parseClassAttribute.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = parseClassAttribute;
/**
 * When splits a string of html classes into a set html classes.
 * @param {string} classString The value of the class attribute.
 * @returns {Set} A set containing all individual values of the class.
 */
function parseClassAttribute(classString) {
  return new Set(classString.split(" "));
}

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/build/private/isPhrasingContent.js":
/*!******************************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/build/private/isPhrasingContent.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Tag names of HTML elements that are considered phrasing content
 * in the HTML content model.
 *
 * @see https://html.spec.whatwg.org/#phrasing-content
 *
 * @type {string[]}
 */
const phrasingContentTags = ["b", "big", "i", "small", "tt", "abbr", "acronym", "cite", "code", "dfn", "em", "kbd", "strong", "samp", "time", "var", "a", "bdo", "br", "img", "map", "object", "q", "script", "span", "sub", "sup", "button", "input", "label", "select", "textarea"];

/**
 * Checks whether a node is considered phrasing content.
 *
 * @see https://html.spec.whatwg.org/#phrasing-content
 *
 * @param {string} nodeName The name/tag of the node to check if it is phrasing content.
 *
 * @returns {boolean} Whether the node is phrasing content.
 */
function isPhrasingContent(nodeName) {
  return phrasingContentTags.includes(nodeName) || nodeName === "#text";
}
var _default = exports["default"] = isPhrasingContent;

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/build/private/parseBlocks.js":
/*!************************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/build/private/parseBlocks.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
const blockTokenizer = /<!--\s+wp:([a-z][a-z0-9_-]*\/)?([a-z][a-z0-9_-]*)\s+({(?:(?=([^}]+|}+(?=})|(?!}\s+\/?-->)[^])*)\5|[^]*?)}\s+)?(\/)?-->/g;

/**
 * Get all the blocks including the inner blocks.
 *
 * @param {Paper} paper The paper to get all the blocks from.
 *
 * @returns {Object[]} An array of blocks.
 */
const getAllBlocks = paper => {
  const blocks = paper._attributes.wpBlocks;
  const flattenBlocks = [];
  if (!(blocks && blocks.length > 0)) {
    return [];
  }
  blocks.forEach(block => {
    if (block.innerBlocks.length > 0) {
      const innerBlocks = block.innerBlocks;
      flattenBlocks.push(block, ...innerBlocks);
    } else {
      flattenBlocks.push(block);
    }
  });
  return flattenBlocks;
};

/**
 * Gets the offset of each block and set it to the tree.
 *
 * @param {Object[]}	blocks An array of blocks.
 * @param {string}		text The text.
 *
 * @returns {void}
 */
function updateBlocksOffset(blocks, text) {
  if (blocks.length === 0) {
    return;
  }
  blocks.forEach(currentBlock => {
    const matches = blockTokenizer.exec(text);
    if (null === matches) {
      return;
    }
    const [match] = matches;
    const startedAt = matches.index;
    const length = match.length;
    currentBlock.startOffset = startedAt;
    currentBlock.contentOffset = startedAt + length + 1;
    if (currentBlock.innerBlocks && currentBlock.innerBlocks.length > 0) {
      updateBlocksOffset(currentBlock.innerBlocks, text);
    }
  });
}

/**
 * Gets the client id for each block and set it to the child nodes.
 * Additionally, when a node has an attribute with 'id' key, also set this id to the first.
 *
 * @param {Node}		rootNode The root node.
 * @param {Object[]}	blocks An array of blocks.
 * @param {string}		clientId The client id to set.
 *
 * @returns {void}
 */
function updateClientIdAndAttrIdForSubtree(rootNode, blocks, clientId) {
  if (!rootNode) {
    return;
  }
  let currentClientId = clientId;
  if (rootNode.sourceCodeLocation && rootNode.sourceCodeLocation.startOffset) {
    const foundBlock = blocks.find(block => block.contentOffset === rootNode.sourceCodeLocation.startOffset);
    if (foundBlock) {
      currentClientId = foundBlock.clientId;
    }
  }

  // If the clientId is not undefined, also set this to the root node.
  if (currentClientId) {
    rootNode.clientId = currentClientId;
  }

  // If the node has children, update the clientId for them.
  (rootNode.childNodes || []).forEach(node => {
    if (node.attributes && node.attributes.id) {
      /*
       * If the node's child has an attribute with 'id' key, also set this id to the first and third child node.
       * This step is specifically for parsing the Yoast blocks.
       *
       * For Yoast blocks, if a node has attribute with 'id' key, this means that this node represents a sub-block.
       * A sub-block has four child nodes:
       * 1. The first child node of the sub-block, represents the first section of that sub-block.
       *    - For example, in Yoast FAQ block, the first child node would represent the "question" section.
       * 2. The second child node of the sub-block, only contains a new line.
       * 3. The third child node of the sub-block, represents the second section of that sub-block.
       *    - For example, in Yoast FAQ block, the second child node would represent the "answer" section.
       * 4. The fourth child node of the sub-block, only contains a new line.
       */
      if (node.childNodes && node.childNodes.length > 3) {
        node.childNodes[0].attributeId = node.attributes.id;
        node.childNodes[0].isFirstSection = true;
        node.childNodes[2].attributeId = node.attributes.id;
        node.childNodes[2].isFirstSection = false;
      }
    }
    updateClientIdAndAttrIdForSubtree(node, blocks, currentClientId);
  });
}

/**
 * Parses blocks and updates the clientId for the subtree.
 * Additionally, when a node has an attribute with 'id' key, also set this id to the first and third child node of that node.
 *
 * @param {Paper} paper The paper to parse.
 * @param {Node} node	The node to parse.
 *
 * @returns {void}
 */
function _default(paper, node) {
  const blocks = paper._attributes.wpBlocks || [];
  blockTokenizer.lastIndex = 0;
  updateBlocksOffset(blocks, paper.getText());
  const rawBlocks = getAllBlocks(paper);

  // eslint-disable-next-line no-undefined
  updateClientIdAndAttrIdForSubtree(node, rawBlocks, undefined);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/build/private/tokenize.js":
/*!*********************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/build/private/tokenize.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _structure = __webpack_require__(/*! ../../structure */ "./node_modules/yoastseo/build/parse/structure/index.js");
var _getTextElementPositions = _interopRequireDefault(__webpack_require__(/*! ./getTextElementPositions */ "./node_modules/yoastseo/build/parse/build/private/getTextElementPositions.js"));
var _htmlEntities = __webpack_require__(/*! ../../../helpers/htmlEntities */ "./node_modules/yoastseo/build/helpers/htmlEntities.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Splits the sentence into tokens, determines their positions in the source code, and puts them on the sentence.
 *
 * @param {Paragraph|Heading} node The paragraph or heading node to split into sentences.
 * @param {Sentence} sentence The sentence.
 * @param {LanguageProcessor} languageProcessor The language processor for the current language.
 *
 * @returns {Sentence} The sentence, with tokens.
 */
function getTokens(node, sentence, languageProcessor) {
  sentence.tokens = languageProcessor.splitIntoTokens(sentence);
  sentence.tokens = (0, _getTextElementPositions.default)(node, sentence.tokens, sentence.sourceCodeRange.startOffset);
  return sentence;
}

/**
 * Splits the node's inner text into sentences, and the sentences into tokens,
 * using the language processor.
 *
 * @param {Paragraph|Heading} node 				The paragraph or heading node to split into sentences.
 * @param {LanguageProcessor} languageProcessor The language processor to use.
 *
 * @returns {Sentence[]} The node's sentences.
 */
function getSentences(node, languageProcessor) {
  // Split text into sentences.
  let sentences = languageProcessor.splitIntoSentences(node.innerText());
  // Add position information to the sentences.
  sentences = (0, _getTextElementPositions.default)(node, sentences);
  // Tokenize sentences into tokens.
  return sentences.map(sentence => {
    sentence = getTokens(node, sentence, languageProcessor);
    // Now positions have been determined, change HTML entities that had earlier been converted to hashed versions back to their short version.
    // For example, "&amp;" was earlier converted into "#amp;" and is now converted into "&".
    // We make this change in both the Sentence and the accompanying Tokens.
    _htmlEntities.hashedHtmlEntities.forEach((character, hashedHtmlEntity) => {
      // We use a global regex instead of replaceAll to support older browsers.
      const hashedHtmlEntityRegex = new RegExp(hashedHtmlEntity, "g");
      sentence.text = sentence.text.replace(hashedHtmlEntityRegex, character);
      sentence.tokens.map(token => {
        token.text = token.text.replace(hashedHtmlEntityRegex, character);
        return token;
      });
    });
    return sentence;
  });
}

/**
 * Splits any Paragraph and Heading nodes in the tree into sentences and tokens.
 * Excludes overarching Paragraphs, as those will have (implicit) paragraphs as their children.
 *
 * @param {Node} tree The tree to process.
 * @param {LanguageProcessor} languageProcessor The language processor to use.
 *
 * @returns {Node} The processed tree.
 */
function tokenize(tree, languageProcessor) {
  if (tree instanceof _structure.Paragraph && tree.name !== "p-overarching" || tree instanceof _structure.Heading) {
    tree.sentences = getSentences(tree, languageProcessor);
  }
  if (tree.childNodes) {
    tree.childNodes = tree.childNodes.map(child => tokenize(child, languageProcessor));
  }
  return tree;
}
var _default = exports["default"] = tokenize;

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/language/LanguageProcessor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/language/LanguageProcessor.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _Sentence = _interopRequireDefault(__webpack_require__(/*! ../structure/Sentence */ "./node_modules/yoastseo/build/parse/structure/Sentence.js"));
var _Token = _interopRequireDefault(__webpack_require__(/*! ../structure/Token */ "./node_modules/yoastseo/build/parse/structure/Token.js"));
var _splitIntoTokens = _interopRequireDefault(__webpack_require__(/*! ../../languageProcessing/helpers/word/splitIntoTokens */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/splitIntoTokens.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const whitespaceRegex = /^\s+$/;

/**
 * Contains language-specific logic for splitting a text into sentences and tokens.
 */
class LanguageProcessor {
  /**
   * Creates a new language processor.
   *
   * @param {Researcher} researcher The researcher to use.
   */
  constructor(researcher) {
    this.researcher = researcher;
  }

  /**
   * Split text into sentences.
   *
   * @param {string} text The text to split into sentences.
   *
   * @returns {Sentence[]} The sentences.
   */
  splitIntoSentences(text) {
    const memoizedTokenizer = this.researcher.getHelper("memoizedTokenizer");
    /*
     * Set the `trimSentences` flag to false. We want to keep whitespaces to be able to correctly assess the
     * position of sentences within the source code.
     */
    const sentences = memoizedTokenizer(text, false);

    /*
     * If the last element in the array of sentences contains only whitespaces, remove it.
     * This will be the case if the text ends in a whitespace - that whitespace ends up being tokenized as a
     * separate sentence. A space at the end of the text is not needed for calculating the position of
     * sentences, so it can be safely removed.
     */
    if (whitespaceRegex.test(sentences[sentences.length - 1])) {
      sentences.pop();
    }
    return sentences.map(function (sentence) {
      return new _Sentence.default(sentence);
    });
  }

  /**
   * Split sentence into tokens.
   *
   * @param {Sentence} sentence The sentence to split.
   *
   * @returns {Token[]} The tokens.
   */
  splitIntoTokens(sentence) {
    // Retrieve sentence from sentence class
    const sentenceText = sentence.text;

    // If there is a custom splitIntoTokens helper use its output for retrieving tokens.
    const tokenTextsCustom = this.researcher.getHelper("splitIntoTokensCustom");
    if (tokenTextsCustom) {
      const tokensCustom = tokenTextsCustom(sentenceText);
      return tokensCustom.map(tokenText => new _Token.default(tokenText));
    }
    const tokenTexts = (0, _splitIntoTokens.default)(sentenceText);
    return tokenTexts.map(tokenText => new _Token.default(tokenText));
  }
}
var _default = exports["default"] = LanguageProcessor;

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/structure/Heading.js":
/*!****************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/structure/Heading.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _Node = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yoastseo/build/parse/structure/Node.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * A heading in the tree.
 */
class Heading extends _Node.default {
  /**
   * Creates a new heading.
   *
   * @param {1|2|3|4|5|6} level The heading level (e.g. `1` for `h1` up to `6` for `h6`).
   * @param {Object} attributes This heading's attributes.
   * @param {(Node|Text)[]} childNodes This heading's child nodes.
   * @param {Object} sourceCodeLocationInfo This heading's location in the source code, from parse5.
   */
  constructor(level, attributes = {}, childNodes = [], sourceCodeLocationInfo = {}) {
    super(`h${level}`, attributes, childNodes, sourceCodeLocationInfo);
    /**
     * This heading's level (e.g. `1` for `h1`, `2` for `h2` etc.).
     *
     * @type {1|2|3|4|5|6}
     */
    this.level = level;
  }
}
var _default = exports["default"] = Heading;

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/structure/Node.js":
/*!*************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/structure/Node.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _traverse = __webpack_require__(/*! ../traverse */ "./node_modules/yoastseo/build/parse/traverse/index.js");
var _SourceCodeLocation = _interopRequireDefault(__webpack_require__(/*! ./SourceCodeLocation */ "./node_modules/yoastseo/build/parse/structure/SourceCodeLocation.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * A node in the tree.
 */
class Node {
  /**
   * Creates a new node.
   *
   * @param {string} 			name 					The node's name or tag.
   * @param {Object} 			attributes 				This node's attributes.
   * @param {(Node|Text)[]} 	childNodes 				This node's child nodes.
   * @param {Object} 			sourceCodeLocationInfo 	This node's location in the source code, from parse5.
   */
  constructor(name, attributes = {}, childNodes = [], sourceCodeLocationInfo = {}) {
    /**
     * This node's name or tag.
     * @type {string}
     */
    this.name = name;

    /**
     * This node's attributes.
     * @type {Object}
     */
    this.attributes = attributes;

    /**
     * This node's child nodes.
     * @type {(Node|Text)[]}
     */
    this.childNodes = childNodes;

    // Don't add the source code location when unavailable.
    if (!(0, _lodash.isEmpty)(sourceCodeLocationInfo)) {
      /**
       * The location of this node inside the HTML.
       * @type {SourceCodeLocation}
       */
      this.sourceCodeLocation = new _SourceCodeLocation.default(sourceCodeLocationInfo);
    }
  }

  /**
   * Finds all nodes in the tree that satisfies the given condition.
   *
   * @param {function} 	condition 					The condition that a node should satisfy to end up in the list.
   * @param {boolean} 	recurseFoundNodes=false 	Whether to recurse into found nodes to see if the condition
   *  also applies to sub-nodes of the found node.
   *
   * @returns {(Node|Text|Paragraph|Heading)[]} The list of nodes that satisfy the condition.
   */
  findAll(condition, recurseFoundNodes = false) {
    return (0, _traverse.findAllInTree)(this, condition, recurseFoundNodes);
  }

  /**
   * Returns the inner text (text without any markup) from this node.
   *
   * @returns {string} The inner text from this node.
   */
  innerText() {
    return (0, _traverse.innerText)(this);
  }
}
var _default = exports["default"] = Node;

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/structure/Paragraph.js":
/*!******************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/structure/Paragraph.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _Node = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yoastseo/build/parse/structure/Node.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * A paragraph in the tree.
 *
 * @see https://html.spec.whatwg.org/dev/dom.html#paragraphs
 */
class Paragraph extends _Node.default {
  /**
   * Creates a new paragraph.
   *
   * @param {Object} attributes The paragraph's attributes.
   * @param {(Node|Text)[]} childNodes This paragraph's child nodes.
   * @param {Object} sourceCodeLocationInfo This paragraph's location in the source code, from parse5.
   * @param {boolean} isImplicit Whether this paragraph is an implicit paragraph, or an explicit paragraph.
   * @param {boolean} isOverarching Whether this paragraph is overarching text that is separated by double line breaks.
   */
  constructor(attributes = {}, childNodes = [], sourceCodeLocationInfo = {}, isImplicit = false, isOverarching = false) {
    // We rename any overarching `<p>` element to not match it as a stand-alone paragraph downstream.
    const name = isOverarching ? "p-overarching" : "p";
    super(name, attributes, childNodes, sourceCodeLocationInfo);
    /**
     * Whether this paragraph is explicit (defined by an explicit `<p>` tag within the markup),
     * or implicit (defined by a run of phrasing content).
     *
     * @see https://html.spec.whatwg.org/dev/dom.html#paragraphs
     *
     * @type {boolean}
     */
    this.isImplicit = isImplicit;
  }

  /**
   * Creates and returns a new implicit paragraph.
   *
   * @param {Object} attributes The paragraph's attributes.
   * @param {(Node|Text)[]} childNodes This paragraph's child nodes.
   * @param {Object} sourceCodeLocationInfo This paragraph's location in the source code, from parse5.
   *
   * @returns {Paragraph} A new implicit paragraph.
   */
  static createImplicit(attributes = {}, childNodes = [], sourceCodeLocationInfo = {}) {
    return new Paragraph(attributes, childNodes, sourceCodeLocationInfo, true);
  }
}
var _default = exports["default"] = Paragraph;

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/structure/Sentence.js":
/*!*****************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/structure/Sentence.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * A sentence within a text.
 */
class Sentence {
  /**
   * Creates a sentence.
   *
   * @param {string} text The sentence's text.
   */
  constructor(text) {
    /**
     * The text in this sentence.
     *
     * @type {string}
     */
    this.text = text;
    /**
     * The tokens in this sentence.
     * @type {Token[]}
     */
    this.tokens = [];
    /**
     * The start and end positions of the sentence in the source code.
     * @type {SourceCodeRange}
     */
    this.sourceCodeRange = {};
  }
}
var _default = exports["default"] = Sentence;

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/structure/SourceCodeLocation.js":
/*!***************************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/structure/SourceCodeLocation.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Represents a range in the source code.
 *
 * @typedef {Object} SourceCodeRange
 * @property {number} startOffset The start position of the range.
 * @property {number} endOffset The end position of the range.
 */

/**
 * Represents a location of a node in the HTML tree.
 *
 * @extends SourceCodeRange
 * @property {SourceCodeRange?} startTag The location of the start tag of the element, if it has one.
 * @property {SourceCodeRange?} endTag The location of the end tag of the element, if it has one.
 */
class SourceCodeLocation {
  /**
   * Creates a new SourceCodeLocation.
   *
   * @param {Object} sourceCodeLocationInfo This node's location in the source code, from parse5.
   */
  constructor(sourceCodeLocationInfo) {
    if (sourceCodeLocationInfo.startTag) {
      this.startTag = {
        startOffset: sourceCodeLocationInfo.startTag.startOffset,
        endOffset: sourceCodeLocationInfo.startTag.endOffset
      };
    }
    if (sourceCodeLocationInfo.endTag) {
      this.endTag = {
        startOffset: sourceCodeLocationInfo.endTag.startOffset,
        endOffset: sourceCodeLocationInfo.endTag.endOffset
      };
    }
    this.startOffset = sourceCodeLocationInfo.startOffset;
    this.endOffset = sourceCodeLocationInfo.endOffset;
  }
}
var _default = exports["default"] = SourceCodeLocation;

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/structure/Text.js":
/*!*************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/structure/Text.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _SourceCodeLocation = _interopRequireDefault(__webpack_require__(/*! ./SourceCodeLocation */ "./node_modules/yoastseo/build/parse/structure/SourceCodeLocation.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * A text.
 */
class Text {
  /**
   * Creates a new Text object, that consist of some text and a source code range.
   *
   * @param {object} textNode The current #text node in the parse5 tree.
   */
  constructor(textNode) {
    this.name = "#text";
    /**
     * This text's content.
     *
     * @type {string}
     */
    this.value = textNode.value;
    this.sourceCodeRange = new _SourceCodeLocation.default({
      startOffset: textNode.sourceCodeLocation.startOffset,
      endOffset: textNode.sourceCodeLocation.endOffset
    });
  }
}
var _default = exports["default"] = Text;

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/structure/Token.js":
/*!**************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/structure/Token.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _languageProcessing = __webpack_require__(/*! ../../languageProcessing */ "./node_modules/yoastseo/build/languageProcessing/index.js");
/**
 * A token representing a word, whitespace or punctuation in the sentence.
 */
class Token {
  /**
   * Creates a new token.
   *
   * @param {string} text The token's text.
   * @param {SourceCodeRange} sourceCodeRange The start and end positions of the token in the source code.
   */
  constructor(text, sourceCodeRange = {}) {
    // Normalize single quotes so that tokens can be matched with strings regardless of single quote type.
    this.text = (0, _languageProcessing.normalizeSingle)(text);
    /**
     * The start and end positions of the token in the source code.
     * @type {SourceCodeRange}
     */
    this.sourceCodeRange = sourceCodeRange;
  }
}
var _default = exports["default"] = Token;

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/structure/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/structure/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Heading", ({
  enumerable: true,
  get: function () {
    return _Heading.default;
  }
}));
Object.defineProperty(exports, "Node", ({
  enumerable: true,
  get: function () {
    return _Node.default;
  }
}));
Object.defineProperty(exports, "Paragraph", ({
  enumerable: true,
  get: function () {
    return _Paragraph.default;
  }
}));
Object.defineProperty(exports, "Text", ({
  enumerable: true,
  get: function () {
    return _Text.default;
  }
}));
var _Node = _interopRequireDefault(__webpack_require__(/*! ./Node */ "./node_modules/yoastseo/build/parse/structure/Node.js"));
var _Heading = _interopRequireDefault(__webpack_require__(/*! ./Heading */ "./node_modules/yoastseo/build/parse/structure/Heading.js"));
var _Paragraph = _interopRequireDefault(__webpack_require__(/*! ./Paragraph */ "./node_modules/yoastseo/build/parse/structure/Paragraph.js"));
var _Text = _interopRequireDefault(__webpack_require__(/*! ./Text */ "./node_modules/yoastseo/build/parse/structure/Text.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/traverse/findAllInTree.js":
/*!*********************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/traverse/findAllInTree.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = findAllInTree;
/**
 * Finds all nodes in the tree that satisfies the given condition.
 *
 * @param {Object} 		tree 						The tree.
 * @param {function} 	condition 					The condition that a node should satisfy to end up in the list.
 * @param {boolean} 	recurseFoundNodes=false 	Whether to recurse into found nodes to see if the condition also applies to
 * sub-nodes of the found node.
 * If false, as soon as a node is found that satisfies the condition, it is added to the list and no further recursion is done through its children.
 * If true, the node is added to the list and its children are also checked for the condition.
 * If they satisfy the condition, they are also added to the list.
 * This comes with the risk of adding the same node multiple times to the list.
 *
 * Example:
 * HTML: <div><div><div>foo</div></div></div>
 * Condition: node => node.nodeName === 'div'
 * If recurseFoundNodes is false, this will return: [ <div><div><div>foo</div></div></div> ]
 *
 * If recurseFoundNodes is true, this will return: [ <div><div><div>foo</div></div></div>, <div><div>foo</div></div>, <div>foo</div> ]
 *
 * In assessments where you want to count the number of occurrences of a certain type of node, you should set recurseFoundNodes to false.
 * For example in the list assessment with a nested list: you only want to count the outer list.
 *
 * <ul>
 *   <li>Coffee</li>
 *   <li>Tea
 *     <ul>
 *       <li>Black tea</li>
 *       <li>Green tea</li>
 *     </ul>
 *   </li>
 *   <li>Milk</li>
 * </ul>
 *
 * In getTextElementPositions, you want to find all descendant nodes that have position information.
 * In this case you want to recurse into found nodes.
 *
 * @returns {Object[]} The list of nodes that satisfy the condition.
 */
function findAllInTree(tree, condition, recurseFoundNodes = false) {
  const nodes = [];
  if (!tree.childNodes) {
    return nodes;
  }
  tree.childNodes.forEach(child => {
    if (condition(child)) {
      nodes.push(child);
      if (recurseFoundNodes) {
        nodes.push(...findAllInTree(child, condition, recurseFoundNodes));
      }
    } else {
      nodes.push(...findAllInTree(child, condition, recurseFoundNodes));
    }
  });
  return nodes;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/traverse/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/traverse/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "findAllInTree", ({
  enumerable: true,
  get: function () {
    return _findAllInTree.default;
  }
}));
Object.defineProperty(exports, "innerText", ({
  enumerable: true,
  get: function () {
    return _innerText.default;
  }
}));
var _findAllInTree = _interopRequireDefault(__webpack_require__(/*! ./findAllInTree */ "./node_modules/yoastseo/build/parse/traverse/findAllInTree.js"));
var _innerText = _interopRequireDefault(__webpack_require__(/*! ./innerText */ "./node_modules/yoastseo/build/parse/traverse/innerText.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/parse/traverse/innerText.js":
/*!*****************************************************************!*\
  !*** ./node_modules/yoastseo/build/parse/traverse/innerText.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = innerText;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Gathers the text content of the given node.
 *
 * @param {Object} node The node to gather the text content from.
 *
 * @returns {string} The text content.
 */
function innerText(node) {
  let text = "";
  if (!(0, _lodash.isEmpty)(node.childNodes)) {
    node.childNodes.forEach(child => {
      if (child.name === "#text") {
        text += child.value;
      } else if (child.name === "br") {
        text += "\n";
      } else {
        text += innerText(child);
      }
    });
  }
  return text;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/pluggable.js":
/*!**************************************************!*\
  !*** ./node_modules/yoastseo/build/pluggable.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _invalidType = _interopRequireDefault(__webpack_require__(/*! ./errors/invalidType */ "./node_modules/yoastseo/build/errors/invalidType.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * The plugins object takes care of plugin registrations, preloading and managing data modifications.
 *
 * Please note that there is a newer copy of this plugin in `packages/js/src/lib/Pluggable.js`.
 * For internal use, please use the newer copy for all interfaces except for registering assessments.
 *
 * A plugin for YoastSEO.js is basically a piece of JavaScript that hooks into YoastSEO.js by registering modifications.
 * In order to do so, it must first register itself as a plugin with YoastSEO.js. To keep our content analysis fast, we
 * don't allow asynchronous modifications. That's why we require plugins to preload all data they need in order to modify
 * the content. If plugins need to preload data, they can first register, then preload using AJAX and call `ready` once
 * preloaded.
 *
 * To minimize client side memory usage, we request plugins to preload as little data as possible. If you need to dynamically
 * fetch more data in the process of content creation, you can reload your data set and let YoastSEO.js know you've reloaded
 * by calling `reloaded`.
 */

/**
 * Setup Pluggable and set its default values.
 *
 * @constructor
 * @param       {App}       app                 The App object to attach to.
 * @property    {number}    preloadThreshold	The maximum time plugins are allowed to preload before we load our content analysis.
 * @property    {object}    plugins             The plugins that have been registered.
 * @property    {object}    modifications 	    The modifications that have been registered. Every modification contains an array with callables.
 * @property    {Array}     customTests         All tests added by plugins.
 */
var Pluggable = function (app) {
  this.app = app;
  this.loaded = false;
  this.preloadThreshold = 3000;
  this.plugins = {};
  this.modifications = {};
  this.customTests = [];

  // Allow plugins 1500 ms to register before we start polling their
  setTimeout(this._pollLoadingPlugins.bind(this), 1500);
};

//  ***** DSL IMPLEMENTATION ***** //

/**
 * Register a plugin with YoastSEO. A plugin can be declared "ready" right at registration or later using `this.ready`.
 *
 * @param {string}  pluginName      The name of the plugin to be registered.
 * @param {object}  options         The options passed by the plugin.
 * @param {string}  options.status  The status of the plugin being registered. Can either be "loading" or "ready".
 * @returns {boolean}               Whether or not the plugin was successfully registered.
 */
Pluggable.prototype._registerPlugin = function (pluginName, options) {
  if (typeof pluginName !== "string") {
    console.error("Failed to register plugin. Expected parameter `pluginName` to be a string.");
    return false;
  }
  if (!(0, _lodash.isUndefined)(options) && typeof options !== "object") {
    console.error("Failed to register plugin " + pluginName + ". Expected parameters `options` to be a object.");
    return false;
  }
  if (this._validateUniqueness(pluginName) === false) {
    console.error("Failed to register plugin. Plugin with name " + pluginName + " already exists");
    return false;
  }
  this.plugins[pluginName] = options;
  return true;
};

/**
 * Declare a plugin "ready". Use this if you need to preload data with AJAX.
 *
 * @param {string} pluginName	The name of the plugin to be declared as ready.
 * @returns {boolean}           Whether or not the plugin was successfully declared ready.
 */
Pluggable.prototype._ready = function (pluginName) {
  if (typeof pluginName !== "string") {
    console.error("Failed to modify status for plugin " + pluginName + ". Expected parameter `pluginName` to be a string.");
    return false;
  }
  if ((0, _lodash.isUndefined)(this.plugins[pluginName])) {
    console.error("Failed to modify status for plugin " + pluginName + ". The plugin was not properly registered.");
    return false;
  }
  this.plugins[pluginName].status = "ready";
  return true;
};

/**
 * Used to declare a plugin has been reloaded. If an analysis is currently running. We will reset it to ensure running the latest modifications.
 *
 * @param {string} pluginName   The name of the plugin to be declared as reloaded.
 * @returns {boolean}           Whether or not the plugin was successfully declared as reloaded.
 */
Pluggable.prototype._reloaded = function (pluginName) {
  if (typeof pluginName !== "string") {
    console.error("Failed to reload Content Analysis for " + pluginName + ". Expected parameter `pluginName` to be a string.");
    return false;
  }
  if ((0, _lodash.isUndefined)(this.plugins[pluginName])) {
    console.error("Failed to reload Content Analysis for plugin " + pluginName + ". The plugin was not properly registered.");
    return false;
  }
  this.app.refresh();
  return true;
};

/**
 * Enables hooking a callable to a specific data filter supported by YoastSEO. Can only be performed for plugins that have finished loading.
 *
 * @param {string}      modification	The name of the filter
 * @param {function}    callable 	    The callable
 * @param {string}      pluginName 	    The plugin that is registering the modification.
 * @param {number}      priority	    (optional) Used to specify the order in which the callables associated with a particular filter are called.
 * 									    Lower numbers correspond with earlier execution.
 * @returns {boolean}                   Whether or not applying the hook was successful.
 */
Pluggable.prototype._registerModification = function (modification, callable, pluginName, priority) {
  if (typeof modification !== "string") {
    console.error("Failed to register modification for plugin " + pluginName + ". Expected parameter `modification` to be a string.");
    return false;
  }
  if (typeof callable !== "function") {
    console.error("Failed to register modification for plugin " + pluginName + ". Expected parameter `callable` to be a function.");
    return false;
  }
  if (typeof pluginName !== "string") {
    console.error("Failed to register modification for plugin " + pluginName + ". Expected parameter `pluginName` to be a string.");
    return false;
  }

  // Validate origin
  if (this._validateOrigin(pluginName) === false) {
    console.error("Failed to register modification for plugin " + pluginName + ". The integration has not finished loading yet.");
    return false;
  }

  // Default priority to 10
  var prio = typeof priority === "number" ? priority : 10;
  var callableObject = {
    callable: callable,
    origin: pluginName,
    priority: prio
  };

  // Make sure modification is defined on modifications object
  if ((0, _lodash.isUndefined)(this.modifications[modification])) {
    this.modifications[modification] = [];
  }
  this.modifications[modification].push(callableObject);
  return true;
};

/**
 * Register test for a specific plugin
 *
 * @returns {void}
 *
 * @deprecated
 */
Pluggable.prototype._registerTest = function () {
  console.error("This function is deprecated, please use _registerAssessment");
};

/**
 * Register an assessment for a specific plugin
 *
 * @param {object} assessor The assessor object where the assessments needs to be added.
 * @param {string} name The name of the assessment.
 * @param {function} assessment The function to run as an assessment.
 * @param {string} pluginName The name of the plugin associated with the assessment.
 * @returns {boolean} Whether registering the assessment was successful.
 * @private
 */
Pluggable.prototype._registerAssessment = function (assessor, name, assessment, pluginName) {
  if (!(0, _lodash.isString)(name)) {
    throw new _invalidType.default("Failed to register test for plugin " + pluginName + ". Expected parameter `name` to be a string.");
  }
  if (!(0, _lodash.isObject)(assessment)) {
    throw new _invalidType.default("Failed to register assessment for plugin " + pluginName + ". Expected parameter `assessment` to be a function.");
  }
  if (!(0, _lodash.isString)(pluginName)) {
    throw new _invalidType.default("Failed to register assessment for plugin " + pluginName + ". Expected parameter `pluginName` to be a string.");
  }

  // Prefix the name with the pluginName so the test name is always unique.
  name = pluginName + "-" + name;
  assessor.addAssessment(name, assessment);
  return true;
};

// ***** PRIVATE HANDLERS *****//

/**
 * Poller to handle loading of plugins. Plugins can register with our app to let us know they are going to hook into our Javascript. They are allowed
 * 5 seconds of pre-loading time to fetch all the data they need to be able to perform their data modifications. We will only apply data modifications
 * from plugins that have declared ready within the pre-loading time in order to safeguard UX and data integrity.
 *
 * @param   {number} pollTime (optional) The accumulated time to compare with the pre-load threshold.
 * @returns {void}
 * @private
 */
Pluggable.prototype._pollLoadingPlugins = function (pollTime) {
  pollTime = (0, _lodash.isUndefined)(pollTime) ? 0 : pollTime;
  if (this._allReady() === true) {
    this.loaded = true;
    this.app.pluginsLoaded();
  } else if (pollTime >= this.preloadThreshold) {
    this._pollTimeExceeded();
  } else {
    pollTime += 50;
    setTimeout(this._pollLoadingPlugins.bind(this, pollTime), 50);
  }
};

/**
 * Checks if all registered plugins have finished loading
 *
 * @returns {boolean} Whether or not all registered plugins are loaded.
 * @private
 */
Pluggable.prototype._allReady = function () {
  return (0, _lodash.reduce)(this.plugins, function (allReady, plugin) {
    return allReady && plugin.status === "ready";
  }, true);
};

/**
 * Removes the plugins that were not loaded within time and calls `pluginsLoaded` on the app.
 *
 * @returns {void}
 * @private
 */
Pluggable.prototype._pollTimeExceeded = function () {
  (0, _lodash.forEach)(this.plugins, function (plugin, pluginName) {
    if (!(0, _lodash.isUndefined)(plugin.options) && plugin.options.status !== "ready") {
      console.error("Error: Plugin " + pluginName + ". did not finish loading in time.");
      delete this.plugins[pluginName];
    }
  });
  this.loaded = true;
  this.app.pluginsLoaded();
};

/**
 * Calls the callables added to a modification hook. See the YoastSEO.js Readme for a list of supported modification hooks.
 *
 * @param	{string}    modification	The name of the filter
 * @param   {*}         data 		    The data to filter
 * @param   {*}         context		    (optional) Object for passing context parameters to the callable.
 * @returns {*} 		                The filtered data
 * @private
 */
Pluggable.prototype._applyModifications = function (modification, data, context) {
  var callChain = this.modifications[modification];
  if (callChain instanceof Array && callChain.length > 0) {
    callChain = this._stripIllegalModifications(callChain);
    callChain.sort(function (a, b) {
      return a.priority - b.priority;
    });
    (0, _lodash.forEach)(callChain, function (callableObject) {
      var callable = callableObject.callable;
      var newData = callable(data, context);
      if (typeof newData === typeof data) {
        data = newData;
      } else {
        console.error("Modification with name " + modification + " performed by plugin with name " + callableObject.origin + " was ignored because the data that was returned by it was of a different type than the data we had passed it.");
      }
    });
  }
  return data;
};

/**
 * Adds new tests to the analyzer and it's scoring object.
 *
 * @param {YoastSEO.Analyzer} analyzer The analyzer object to add the tests to
 * @returns {void}
 * @private
 */
Pluggable.prototype._addPluginTests = function (analyzer) {
  this.customTests.map(function (customTest) {
    this._addPluginTest(analyzer, customTest);
  }, this);
};

/**
 * Adds one new test to the analyzer and it's scoring object.
 *
 * @param {YoastSEO.Analyzer} analyzer              The analyzer that the test will be added to.
 * @param {Object}            pluginTest            The test to be added.
 * @param {string}            pluginTest.name       The name of the test.
 * @param {function}          pluginTest.callable   The function associated with the test.
 * @param {function}          pluginTest.analysis   The function associated with the analyzer.
 * @param {Object}            pluginTest.scoring    The scoring object to be used.
 * @returns {void}
 * @private
 */
Pluggable.prototype._addPluginTest = function (analyzer, pluginTest) {
  analyzer.addAnalysis({
    name: pluginTest.name,
    callable: pluginTest.analysis
  });
  analyzer.analyzeScorer.addScoring({
    name: pluginTest.name,
    scoring: pluginTest.scoring
  });
};

/**
 * Strips modifications from a callChain if they were not added with a valid origin.
 *
 * @param   {Array} callChain	 The callChain that contains items with possible invalid origins.
 * @returns {Array} callChain 	 The stripped version of the callChain.
 * @private
 */
Pluggable.prototype._stripIllegalModifications = function (callChain) {
  (0, _lodash.forEach)(callChain, function (callableObject, index) {
    if (this._validateOrigin(callableObject.origin) === false) {
      delete callChain[index];
    }
  }.bind(this));
  return callChain;
};

/**
 * Validates if origin of a modification has been registered and finished preloading.
 *
 * @param 	{string}    pluginName      The name of the plugin that needs to be validated.
 * @returns {boolean}                   Whether or not the origin is valid.
 * @private
 */
Pluggable.prototype._validateOrigin = function (pluginName) {
  if (this.plugins[pluginName].status !== "ready") {
    return false;
  }
  return true;
};

/**
 * Validates if registered plugin has a unique name.
 *
 * @param 	{string}    pluginName      The name of the plugin that needs to be validated for uniqueness.
 * @returns {boolean}                   Whether or not the plugin has a unique name.
 * @private
 */
Pluggable.prototype._validateUniqueness = function (pluginName) {
  if (!(0, _lodash.isUndefined)(this.plugins[pluginName])) {
    return false;
  }
  return true;
};
var _default = exports["default"] = Pluggable;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/assessment.js":
/*!***********************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/assessment.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _languageProcessing = __webpack_require__(/*! ../../languageProcessing */ "./node_modules/yoastseo/build/languageProcessing/index.js");
var _helpers = __webpack_require__(/*! ../../languageProcessing/helpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/index.js");
/* eslint-disable no-unused-vars */

/**
 * The base class for an Assessment.
 */
class Assessment {
  /**
   * Executes the assessment and return its result.
   *
   * @param {Paper}       paper       The paper to run this assessment on.
   * @param {Researcher}  researcher  The researcher used for the assessment.
   *
   * @returns {AssessmentResult} The result of the assessment.
   */
  getResult(paper, researcher) {
    throw "The method getResult is not implemented";
  }

  /**
   * Checks whether the assessment is applicable.
   *
   * @param {Paper}       paper       The paper to run this assessment on.
   * @param {Researcher}  researcher  The researcher used for the assessment.
   *
   * @returns {boolean} Whether the assessment is applicable, defaults to `true`.
   */
  isApplicable(paper, researcher) {
    return true;
  }

  /**
   * Tests whether a `Paper` has enough content for assessments to be displayed.
   *
   * @param {Paper} paper 						The paper to run this assessment on.
   * @param {number} contentNeededForAssessment	The minimum length in characters a text must have for assessments to be displayed.
   *
   * @returns {boolean} `true` if the text is of the required length, `false` otherwise.
   */
  hasEnoughContentForAssessment(paper, contentNeededForAssessment = 50) {
    let text = paper.getText();
    text = (0, _helpers.removeHtmlBlocks)(text);
    text = (0, _helpers.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);
    return (0, _languageProcessing.sanitizeString)(text).length >= contentNeededForAssessment;
  }
}

/* eslint-enable no-unused-vars */
var _default = exports["default"] = Assessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/InclusiveLanguageAssessment.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/InclusiveLanguageAssessment.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _Mark = _interopRequireDefault(__webpack_require__(/*! ../../../values/Mark */ "./node_modules/yoastseo/build/values/Mark.js"));
var _addMark = _interopRequireDefault(__webpack_require__(/*! ../../../markers/addMark */ "./node_modules/yoastseo/build/markers/addMark.js"));
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _languageProcessing = __webpack_require__(/*! ../../../languageProcessing */ "./node_modules/yoastseo/build/languageProcessing/index.js");
var _includesConsecutiveWords = __webpack_require__(/*! ./helpers/includesConsecutiveWords */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/includesConsecutiveWords.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * An inclusive language assessment.
 *
 * Based on the configuration given to it in the constructor, it assesses
 * whether a paper's text contains potentially non-inclusive phrases and
 * suggests a potentially more inclusive alternative.
 */
class InclusiveLanguageAssessment {
  /**
   * Creates a new inclusive language assessment.
   *
   * @param {object} config The assessment configuration.
   *
   * @param {string} config.identifier The identifier of this assessment.
   * @param {string[]} config.nonInclusivePhrases The non-inclusive phrases.
   * @param {string|array} config.inclusiveAlternatives The suggested alternative, more inclusive, phrase(s).
   * @param {number} config.score The score to give if the non-inclusive phrase is recognized in the text.
   * @param {string} config.feedbackFormat The feedback format string,
   * 									should include a `%1$s` placeholder for the non-inclusive phrase
   * 									and `%2$s` (and potentially further replacements) for the suggested alternative(s).
   * @param {string} config.learnMoreUrl The URL to an article explaining more about this specific assessment.
   * @param {function} [config.rule] A potential additional rule for targeting the non-inclusive phrases.
   * @param {boolean} [config.caseSensitive=false] If the inclusive phrase is case-sensitive, defaults to `false`.
   *
   * @returns {void}
   */
  constructor({
    identifier,
    nonInclusivePhrases,
    inclusiveAlternatives,
    score,
    feedbackFormat,
    learnMoreUrl,
    rule,
    caseSensitive,
    category
  }) {
    this.identifier = identifier;
    this.nonInclusivePhrases = nonInclusivePhrases;
    this.inclusiveAlternatives = inclusiveAlternatives;
    if ((0, _lodash.isString)(this.inclusiveAlternatives)) {
      this.inclusiveAlternatives = [this.inclusiveAlternatives];
    }
    this.score = score;
    this.feedbackFormat = feedbackFormat;
    this.learnMoreUrl = (0, _shortlinker.createAnchorOpeningTag)(learnMoreUrl);
    this.rule = rule || _includesConsecutiveWords.includesConsecutiveWords;
    this.caseSensitive = caseSensitive || false;
    this.category = category;
  }

  /**
   * Checks whether the assessment is applicable for the given paper.
   *
   * @param {Paper} paper The paper to check.
   * @param {Researcher} researcher The researcher.
   *
   * @returns {boolean} Whether the assessment is applicable for the given paper.
   */
  isApplicable(paper, researcher) {
    const sentences = researcher.getResearch("sentences");

    // Also include the text title in the analysis as a separate sentence.
    const textTitle = paper.getTextTitle();
    sentences.push(textTitle);
    this.foundPhrases = [];
    sentences.forEach(sentence => {
      let words = (0, _languageProcessing.getWords)(sentence, "\\s", false);
      if (!this.caseSensitive) {
        words = words.map(word => word.toLocaleLowerCase());
      }
      const foundPhrase = this.nonInclusivePhrases.find(phrase => this.rule(words, (0, _languageProcessing.getWords)(phrase, "\\s", false)).length >= 1);
      if (foundPhrase) {
        this.foundPhrases.push({
          sentence: sentence,
          phrase: foundPhrase
        });
      }
    });
    return this.foundPhrases.length >= 1;
  }

  /**
   * Execute the Assessment and return a result.
   *
   * @returns {AssessmentResult} The result of the assessment, containing both a score and a descriptive text.
   */
  getResult() {
    const link = (0, _i18n.sprintf)("%1$sLearn more.%2$s", this.learnMoreUrl, "</a>");
    const text = (0, _i18n.sprintf)(this.feedbackFormat, this.foundPhrases[0].phrase, ...this.inclusiveAlternatives);
    const result = new _AssessmentResult.default({
      score: this.score,
      text: `${text} ${link}`
    });
    result.setIdentifier(this.identifier);
    result.setHasMarks(true);
    return result;
  }

  /**
   * Marks text for the inclusive language assessment.
   *
   * @returns {Array<Mark>} A list of marks that should be applied.
   */
  getMarks() {
    if (!this.foundPhrases) {
      return [];
    }
    return this.foundPhrases.map(foundPhrase => new _Mark.default({
      original: foundPhrase.sentence,
      marked: (0, _addMark.default)(foundPhrase.sentence)
    }));
  }
}
exports["default"] = InclusiveLanguageAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/ageAssessments.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/ageAssessments.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _feedbackStrings = __webpack_require__(/*! ./feedbackStrings */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/feedbackStrings.js");
var _isPrecededByException = __webpack_require__(/*! ../helpers/isPrecededByException */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isPrecededByException.js");
var _isFollowedByException = __webpack_require__(/*! ../helpers/isFollowedByException */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isFollowedByException.js");
var _includesConsecutiveWords = __webpack_require__(/*! ../helpers/includesConsecutiveWords */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/includesConsecutiveWords.js");
var _scores = __webpack_require__(/*! ./scores */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/scores.js");
var _notInclusiveWhenStandalone = _interopRequireDefault(__webpack_require__(/*! ../helpers/notInclusiveWhenStandalone */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/notInclusiveWhenStandalone.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/*
 * The last sentence of strings for the non-inclusive terms for 'older people/person'.
 *
 * "Or, if possible, be specific about the group you are referring to (e.g. %3$s)."
 */
const specificAgeGroup = "Or, if possible, be specific about the group you are referring to (e.g. %3$s).";
/*
 * Used to suggest an alternative for 'senile'.
 *
 * "Consider using an alternative, such as a specific characteristic or experience if it is known (e.g. <i>has Alzheimer's</i>)."
 */
const characteristicIfKnown = "Consider using an alternative, such as a specific characteristic or experience if it is known" + " (e.g. <i>has Alzheimer's</i>).";
const ageAssessments = [{
  identifier: "seniorCitizen",
  nonInclusivePhrases: ["senior citizen"],
  inclusiveAlternatives: ["<i>older person, older citizen</i>", "<i>person older than 70</i>"],
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.potentiallyHarmfulUnless, specificAgeGroup].join(" ")
}, {
  identifier: "seniorCitizens",
  nonInclusivePhrases: ["senior citizens"],
  inclusiveAlternatives: ["<i>older people, older citizens</i>", "<i>people older than 70</i>"],
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.potentiallyHarmfulUnless, specificAgeGroup].join(" ")
}, {
  identifier: "agingDependants",
  nonInclusivePhrases: ["aging dependants"],
  inclusiveAlternatives: ["<i>older people</i>", "<i>people older than 70</i>"],
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.potentiallyHarmfulUnless, specificAgeGroup].join(" ")
}, {
  identifier: "elderly",
  nonInclusivePhrases: ["elderly"],
  inclusiveAlternatives: ["<i>older people</i>", "<i>people older than 70</i>"],
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.potentiallyHarmfulUnless, specificAgeGroup].join(" ")
}, {
  identifier: "senile",
  nonInclusivePhrases: ["senile"],
  inclusiveAlternatives: "",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.harmfulNonInclusive, characteristicIfKnown].join(" ")
}, {
  identifier: "senility",
  nonInclusivePhrases: ["senility"],
  inclusiveAlternatives: "<i>dementia</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "seniors",
  nonInclusivePhrases: ["seniors"],
  inclusiveAlternatives: ["<i>older people</i>", "<i>people older than 70</i>"],
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.potentiallyHarmfulUnless, specificAgeGroup].join(" "),
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isPrecededByException.isNotPrecededByException)(words, ["high school", "college", "graduating", "juniors and"])).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, ["in high school", "in college", "who are graduating"]));
  }
}, {
  identifier: "theAged",
  nonInclusivePhrases: ["the aged"],
  inclusiveAlternatives: ["<i>older people</i>", "<i>people older than 70</i>"],
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.potentiallyHarmful, specificAgeGroup].join(" "),
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _notInclusiveWhenStandalone.default)(words, nonInclusivePhrase));
  }
}];
ageAssessments.forEach(assessment => {
  assessment.category = "age";
  assessment.learnMoreUrl = "https://yoa.st/inclusive-language-age";
});
var _default = exports["default"] = ageAssessments;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/appearanceAssessments.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/appearanceAssessments.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _feedbackStrings = __webpack_require__(/*! ./feedbackStrings */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/feedbackStrings.js");
var _scores = __webpack_require__(/*! ./scores */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/scores.js");
var _includesConsecutiveWords = __webpack_require__(/*! ../helpers/includesConsecutiveWords */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/includesConsecutiveWords.js");
var _notInclusiveWhenStandalone = _interopRequireDefault(__webpack_require__(/*! ../helpers/notInclusiveWhenStandalone */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/notInclusiveWhenStandalone.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const appearanceAssessments = [{
  identifier: "albinos",
  nonInclusivePhrases: ["albinos"],
  inclusiveAlternatives: "<i>people with albinism, albino people</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless
}, {
  identifier: "anAlbino",
  nonInclusivePhrases: ["an albino"],
  inclusiveAlternatives: "<i>person with albinism, albino person</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless,
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _notInclusiveWhenStandalone.default)(words, nonInclusivePhrase));
  }
}, {
  identifier: "obese",
  nonInclusivePhrases: ["obese", "overweight"],
  inclusiveAlternatives: "<i>has a higher weight, " + "higher-weight person, person in higher weight body, heavier person</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.potentiallyHarmfulUnless, _feedbackStrings.preferredDescriptorIfKnown].join(" ")
}, {
  identifier: "obesitySingular",
  nonInclusivePhrases: ["person with obesity", "fat person"],
  inclusiveAlternatives: "<i>person who has a higher weight, " + "higher-weight person, person in higher weight body, heavier person</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.potentiallyHarmfulUnless, _feedbackStrings.preferredDescriptorIfKnown].join(" ")
}, {
  identifier: "obesityPlural",
  nonInclusivePhrases: ["people with obesity", "fat people"],
  inclusiveAlternatives: "<i>people who have a higher weight, " + "higher-weight people, people in higher weight bodies, heavier people</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.potentiallyHarmfulUnless].join(" ")
}, {
  identifier: "verticallyChallenged",
  nonInclusivePhrases: ["vertically challenged"],
  inclusiveAlternatives: "<i>little person, has short stature, someone with dwarfism</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "midget",
  nonInclusivePhrases: ["midget"],
  inclusiveAlternatives: "<i>little person, has short stature, someone with dwarfism</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "midgets",
  nonInclusivePhrases: ["midgets"],
  inclusiveAlternatives: "<i>little people, have short stature, people with dwarfism</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "harelip",
  nonInclusivePhrases: ["harelip"],
  inclusiveAlternatives: "<i>cleft lip, cleft palate</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}];
appearanceAssessments.forEach(assessment => {
  assessment.category = "appearance";
  assessment.learnMoreUrl = "https://yoa.st/inclusive-language-appearance";
});
var _default = exports["default"] = appearanceAssessments;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/cultureAssessments.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/cultureAssessments.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _scores = __webpack_require__(/*! ./scores */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/scores.js");
var _includesConsecutiveWords = __webpack_require__(/*! ../helpers/includesConsecutiveWords */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/includesConsecutiveWords.js");
var _isFollowedByException = __webpack_require__(/*! ../helpers/isFollowedByException */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isFollowedByException.js");
var _feedbackStrings = __webpack_require__(/*! ./feedbackStrings */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/feedbackStrings.js");
/*
 * Used for culturally appropriative terms, such as 'tribe' or 'spirit animal'.
 *
 * "Be careful when using <i>%1$s</i> as it is potentially harmful. Consider using an alternative, such as %2$s instead, unless you are referring to
 * the culture in which this term originated."
 */
const potentiallyHarmfulUnlessCulture = "Be careful when using <i>%1$s</i> as it is potentially harmful. " + "Consider using an alternative, such as %2$s instead, unless you are referring to the culture " + "in which this term originated.";
const cultureAssessments = [{
  identifier: "firstWorld",
  nonInclusivePhrases: ["First World"],
  inclusiveAlternatives: "the specific name for the region or country",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  caseSensitive: true,
  rule: (words, nonInclusivePhrase) => (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, ["War", "war", "Assembly", "assembly"]))
}, {
  identifier: "thirdWorld",
  nonInclusivePhrases: ["Third World"],
  inclusiveAlternatives: "the specific name for the region or country",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  caseSensitive: true,
  rule: (words, nonInclusivePhrase) => (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, ["War", "war", "Quarterly", "quarterly", "country"]))
}, {
  identifier: "tribe",
  nonInclusivePhrases: ["tribe"],
  inclusiveAlternatives: "<i>group, cohort, crew, league, guild, team, union</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  /*
   * Replace 'the culture in which this term originated' with 'a culture that uses this term' in the 'unless you are
   * referring to...' part of the potentiallyHarmfulUnlessCulture string.
   */
  feedbackFormat: potentiallyHarmfulUnlessCulture.slice(0, -42) + "a culture that uses this term."
}, {
  identifier: "tribes",
  nonInclusivePhrases: ["tribes"],
  inclusiveAlternatives: "<i>groups, cohorts, crews, leagues, guilds, teams, unions</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  /*
   * Replace 'the culture in which this term originated' with 'a culture that uses this term' in the 'unless you are
   * referring to...' part of the potentiallyHarmfulUnlessCulture string.
   */
  feedbackFormat: potentiallyHarmfulUnlessCulture.slice(0, -42) + "a culture that uses this term."
}, {
  identifier: "exotic",
  nonInclusivePhrases: ["exotic"],
  inclusiveAlternatives: "<i>unfamiliar, foreign, peculiar, fascinating, alluring, bizarre, non-native, introduced</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.harmfulPotentiallyNonInclusive + " Unless you are referring to animals, " + "consider using an alternative, such as %2$s.",
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, ["longhair", "longhairs", "shorthair", "shorthairs"]));
  }
}, {
  identifier: "sherpa",
  nonInclusivePhrases: ["sherpa"],
  inclusiveAlternatives: "<i>commander, coach, mastermind, coach, mentor</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: potentiallyHarmfulUnlessCulture
}, {
  identifier: "guru",
  nonInclusivePhrases: ["guru"],
  inclusiveAlternatives: "<i>mentor, doyen, coach, mastermind, virtuoso, expert</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: potentiallyHarmfulUnlessCulture
}, {
  identifier: "gurus",
  nonInclusivePhrases: ["gurus"],
  inclusiveAlternatives: "<i>mentors, doyens, coaches, masterminds, virtuosos, experts</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: potentiallyHarmfulUnlessCulture
}, {
  identifier: "nonWhite",
  nonInclusivePhrases: ["non-white"],
  inclusiveAlternatives: "<i>people of color, POC, BIPOC</i> or specifying the racial groups mentioned",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "oriental",
  nonInclusivePhrases: ["oriental"],
  inclusiveAlternatives: "<i>Asian</i>. When possible, be more specific (e.g. <i>East Asian</i>)",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnlessAnimalsObjects
}, {
  identifier: "asianAmerican",
  nonInclusivePhrases: ["Asian-American"],
  inclusiveAlternatives: "<i>Asian American</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  caseSensitive: true
}, {
  identifier: "asianAmericans",
  nonInclusivePhrases: ["Asian-Americans"],
  inclusiveAlternatives: "<i>Asian Americans</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  caseSensitive: true
}, {
  identifier: "africanAmerican",
  nonInclusivePhrases: ["African-American"],
  inclusiveAlternatives: "<i>African American, Black, American of African descent</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  caseSensitive: true
}, {
  identifier: "africanAmericans",
  nonInclusivePhrases: ["African-Americans"],
  inclusiveAlternatives: "<i>African Americans, Black, Americans of African descent</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  caseSensitive: true
}, {
  identifier: "whiteRace",
  nonInclusivePhrases: ["the White race"],
  inclusiveAlternatives: "",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.harmfulNonInclusive,
  caseSensitive: true
}, {
  identifier: "whitelist",
  nonInclusivePhrases: ["whitelist"],
  inclusiveAlternatives: "<i>allowlist</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "whitelists",
  nonInclusivePhrases: ["whitelists"],
  inclusiveAlternatives: "<i>allowlists</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "whitelisting",
  nonInclusivePhrases: ["whitelisting"],
  inclusiveAlternatives: "<i>allowlisting</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "whitelisted",
  nonInclusivePhrases: ["whitelisted"],
  inclusiveAlternatives: "<i>allowlisted</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "blacklist",
  nonInclusivePhrases: ["blacklist"],
  inclusiveAlternatives: "<i>blocklist, denylist, faillist, redlist</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "blacklists",
  nonInclusivePhrases: ["blacklists"],
  inclusiveAlternatives: "<i>blocklists, denylists, faillists, redlists</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "blacklisting",
  nonInclusivePhrases: ["blacklisting"],
  inclusiveAlternatives: "<i>blocklisting, denylisting, faillisting, redlisting</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "blacklisted",
  nonInclusivePhrases: ["blacklisted"],
  inclusiveAlternatives: "<i>blocklisted, denylisted, faillisted, redlisted</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "gyp",
  nonInclusivePhrases: ["gyp"],
  inclusiveAlternatives: "<i>fraud, cheat, swindle, rip-off</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "gyps",
  nonInclusivePhrases: ["gyps"],
  inclusiveAlternatives: "<i>frauds, cheats, swindles, rips off, rip-offs</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "gypped",
  nonInclusivePhrases: ["gypped"],
  inclusiveAlternatives: "<i>cheated, swindled, ripped off</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "gypping",
  nonInclusivePhrases: ["gypping"],
  inclusiveAlternatives: "<i>cheating, swindling, ripping off</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "gypsy",
  nonInclusivePhrases: ["gypsy", "gipsy"],
  inclusiveAlternatives: ["<i>Rom, Roma person, Romani, Romani person</i>", "<i>traveler, wanderer, free-spirited</i>"],
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.potentiallyHarmfulUnless, "If you are referring to a lifestyle rather than the ethnic group or " + "their music, consider using an alternative such as %3$s."].join(" ")
}, {
  identifier: "gypsies",
  nonInclusivePhrases: ["gypsies", "gipsies"],
  inclusiveAlternatives: ["<i>Roma, Romani, Romani people</i>", "<i>travelers, wanderers, free-spirited</i>"],
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.potentiallyHarmfulUnless, "If you are referring to a lifestyle rather than the ethnic group or " + "their music, consider using an alternative such as %3$s."].join(" ")
}, {
  identifier: "eskimo",
  nonInclusivePhrases: ["eskimo", "eskimos"],
  inclusiveAlternatives: "the specific name of the Indigenous community (for example, <i>Inuit</i>)",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless
}, {
  identifier: "coloredPerson",
  nonInclusivePhrases: ["colored person"],
  inclusiveAlternatives: "<i>person of color, POC, BIPOC</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "coloredPeople",
  nonInclusivePhrases: ["colored people"],
  inclusiveAlternatives: "<i>people of color, POC, BIPOC</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "americanIndians",
  nonInclusivePhrases: ["American Indian", "American Indians"],
  inclusiveAlternatives: "<i>Native American(s), Indigenous peoples of America</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless,
  caseSensitive: true
}, {
  identifier: "mulatto",
  nonInclusivePhrases: ["mulatto", "mulattos", "mulattoes"],
  inclusiveAlternatives: "<i>mixed, biracial, multiracial</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "savage",
  nonInclusivePhrases: ["savage"],
  inclusiveAlternatives: "<i>severe, dreadful, untamed, brutal, fearless, fierce, brilliant, amazing</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "civilized",
  nonInclusivePhrases: ["civilized"],
  inclusiveAlternatives: "<i>proper, well-mannered, enlightened, respectful</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "primitive",
  nonInclusivePhrases: ["primitive"],
  inclusiveAlternatives: "<i>early, rudimentary</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "powWow",
  nonInclusivePhrases: ["pow-wow"],
  inclusiveAlternatives: "<i>chat, brief conversation, brainstorm, huddle</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: potentiallyHarmfulUnlessCulture
}, {
  identifier: "lowManOnTheTotemPole",
  nonInclusivePhrases: ["low man on the totem pole"],
  inclusiveAlternatives: "<i>person of lower rank, junior-level</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "spiritAnimal",
  nonInclusivePhrases: ["spirit animal"],
  inclusiveAlternatives: "<i>inspiration, hero, icon, idol</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: potentiallyHarmfulUnlessCulture
}, {
  identifier: "firstWorldCountries",
  nonInclusivePhrases: ["first world countries"],
  inclusiveAlternatives: "the specific name for the regions or countries",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "firstWorldHyphen",
  nonInclusivePhrases: ["first-world"],
  inclusiveAlternatives: "the specific name for the region or country",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "third-worldCountry",
  nonInclusivePhrases: ["third-world country"],
  inclusiveAlternatives: "<i>low-income country, developing country</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "third-worldCountry",
  nonInclusivePhrases: ["third world country"],
  inclusiveAlternatives: "<i>low-income country, developing country</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "underdevelopedCountry",
  nonInclusivePhrases: ["underdeveloped country"],
  inclusiveAlternatives: "developing country",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: "Avoid using <i>%1$s</i> as it is potentially harmful. Consider using an alternative, " + "such as <i>%2$s</i> instead or be more specific about what aspect this word refers to."
}, {
  identifier: "underdevelopedCountries",
  nonInclusivePhrases: ["underdeveloped countries"],
  inclusiveAlternatives: "developing countries",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: "Avoid using <i>%1$s</i> as it is potentially harmful. Consider using an alternative, " + "such as <i>%2$s</i> instead or be more specific about what aspect this word refers to."
}];
cultureAssessments.forEach(assessment => {
  assessment.category = "culture";
  assessment.learnMoreUrl = "https://yoa.st/inclusive-language-culture";
});
var _default = exports["default"] = cultureAssessments;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/disabilityAssessments.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/disabilityAssessments.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _feedbackStrings = __webpack_require__(/*! ./feedbackStrings */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/feedbackStrings.js");
var _isPrecededByException = __webpack_require__(/*! ../helpers/isPrecededByException */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isPrecededByException.js");
var _isFollowedByException = __webpack_require__(/*! ../helpers/isFollowedByException */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isFollowedByException.js");
var _isFollowedAndPrecededByException = __webpack_require__(/*! ../helpers/isFollowedAndPrecededByException */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isFollowedAndPrecededByException.js");
var _includesConsecutiveWords = __webpack_require__(/*! ../helpers/includesConsecutiveWords */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/includesConsecutiveWords.js");
var _scores = __webpack_require__(/*! ./scores */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/scores.js");
var _notInclusiveWhenStandalone = _interopRequireDefault(__webpack_require__(/*! ../helpers/notInclusiveWhenStandalone */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/notInclusiveWhenStandalone.js"));
var _disabilityRulesData = __webpack_require__(/*! ./disabilityRulesData */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/disabilityRulesData.js");
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/*
 * Used for derogatory terms, such as 'cripple'.
 *
 * "Avoid using <i>%1$s</i> as it is derogatory. Consider using an alternative, such as %2$s."
 */
const derogatory = "Avoid using <i>%1$s</i> as it is derogatory. Consider using an alternative, such as %2$s.";

/*
 * Used for terms that are inclusive only if you are referring to a medical condition, for example 'manic' or 'OCD'.
 *
 * "Avoid using <i>%1$s</i> as it is potentially harmful. Unless you are referencing the specific medical condition, consider using another
 * alternative to describe the trait or behavior, such as %2$s. "
 */
const medicalCondition = _feedbackStrings.harmfulPotentiallyNonInclusive + " Unless you are referencing the specific medical condition, consider using another alternative to describe the trait or behavior, such as %2$s.";
/*
 * Used for the term 'special needs'.
 *
 * "Avoid using <i>%1$s</i> as it is potentially harmful. Consider using an alternative, such as %2$s when referring to someone's needs,
 * or %3$s when referring to a person."
 */
const potentiallyHarmfulTwoAlternatives = "Avoid using <i>%1$s</i> as it is potentially harmful. " + "Consider using an alternative, such as %2$s when referring to someone's needs, or %3$s when referring to a person.";
const disabilityAssessments = [{
  identifier: "binge",
  nonInclusivePhrases: ["binge"],
  inclusiveAlternatives: "<i>indulge, satiate, wallow, spree, marathon, consume excessively</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: "Be careful when using <i>%1$s</i>, unless talking about a symptom of a medical condition. " + "If you are not referencing a symptom, consider other alternatives to describe the trait or behavior, such as %2$s.",
  rule: (words, nonInclusivePhrase) => (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, ["drink", "drinks", "drinking", "eating disorder", "and purge", "behavior", "behaviors", "behaviour", "behaviours"]))
}, {
  identifier: "bingeing",
  nonInclusivePhrases: ["bingeing", "binging"],
  inclusiveAlternatives: "<i>indulging, satiating, wallowing, spreeing, marathoning, consuming excessively</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: "Be careful when using <i>%1$s</i>, unless talking about a symptom of a medical condition. " + "If you are not referencing a symptom, consider other alternatives to describe the trait or behavior, such as %2$s.",
  rule: (words, nonInclusivePhrase) => (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, ["and purging", "behavior", "behaviors", "behaviour", "behaviours"]))
}, {
  identifier: "binged",
  nonInclusivePhrases: ["binged"],
  inclusiveAlternatives: "<i>indulged, satiated, wallowed, spreed, marathoned, consumed excessively</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: "Be careful when using <i>%1$s</i>, unless talking about a symptom of a medical condition. " + "If you are not referencing a symptom, consider other alternatives to describe the trait or behavior, such as %2$s.",
  rule: (words, nonInclusivePhrase) => (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, ["and purged"]))
}, {
  identifier: "binges",
  nonInclusivePhrases: ["binges"],
  inclusiveAlternatives: "<i>indulges, satiates, wallows, sprees, marathons, consumes excessively</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: "Be careful when using <i>%1$s</i>, unless talking about a symptom of a medical condition. " + "If you are not referencing a symptom, consider other alternatives to describe the trait or behavior, such as %2$s.",
  rule: (words, nonInclusivePhrase) => (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, ["and purges"]))
}, {
  identifier: "wheelchairBound",
  nonInclusivePhrases: ["wheelchair-bound", "wheelchair bound", "confined to a wheelchair"],
  inclusiveAlternatives: "<i>uses a wheelchair, is a wheelchair user</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "mentallyRetarded",
  nonInclusivePhrases: ["mentally retarded"],
  inclusiveAlternatives: "<i>person with an intellectual disability</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "retarded",
  nonInclusivePhrases: ["retarded"],
  inclusiveAlternatives: "<i>uninformed, ignorant, foolish, irrational, insensible</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: derogatory,
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isPrecededByException.isNotPrecededByException)(words, ["mentally"]));
  }
}, {
  identifier: "alcoholic",
  nonInclusivePhrases: ["an alcoholic"],
  inclusiveAlternatives: "<i>person with alcohol use disorder</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless,
  rule: (words, nonInclusivePhrase) => (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, ["drink", "beverage"]))
}, {
  identifier: "alcoholics",
  nonInclusivePhrases: ["alcoholics"],
  inclusiveAlternatives: "<i>people with alcohol use disorder</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless,
  rule: (words, nonInclusivePhrase) => (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, ["anonymous"]))
}, {
  identifier: "cripple",
  nonInclusivePhrases: ["a cripple"],
  inclusiveAlternatives: "<i>person with a physical disability, a physically disabled person</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: derogatory
}, {
  identifier: "crippled",
  nonInclusivePhrases: ["crippled"],
  inclusiveAlternatives: "<i>has a physical disability, is physically disabled</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "daft",
  nonInclusivePhrases: ["daft"],
  inclusiveAlternatives: "<i>uninformed, ignorant, foolish, inconsiderate, irrational, reckless</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "handicapped",
  nonInclusivePhrases: ["handicapped"],
  inclusiveAlternatives: "<i>disabled, person with a disability</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "handicap",
  nonInclusivePhrases: ["handicap"],
  inclusiveAlternatives: "<i>disability</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  rule: (words, nonInclusivePhrase) => (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, ["toilet", "toilets", "parking", "bathroom", "bathrooms", "stall", "stalls"]))
}, {
  identifier: "insane",
  nonInclusivePhrases: ["insane"],
  inclusiveAlternatives: "<i>wild, confusing, unpredictable, impulsive, reckless, out of control, " + "unbelievable, amazing, incomprehensible, nonsensical, outrageous, ridiculous</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "imbecile",
  nonInclusivePhrases: ["imbecile"],
  inclusiveAlternatives: "<i>uninformed, ignorant, foolish, inconsiderate, irrational, reckless</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: derogatory
}, {
  identifier: "specialNeeds",
  nonInclusivePhrases: ["special needs"],
  inclusiveAlternatives: ["<i>functional needs, support needs</i>", "<i>disabled, person with a disability</i>"],
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: potentiallyHarmfulTwoAlternatives
}, {
  identifier: "hardOfHearing",
  nonInclusivePhrases: ["hard-of-hearing"],
  inclusiveAlternatives: "<i>hard of hearing, partially deaf, has partial hearing loss</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "hearingImpaired",
  nonInclusivePhrases: ["hearing impaired"],
  inclusiveAlternatives: "<i>deaf or hard of hearing, partially deaf, has partial hearing loss</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "functioning",
  nonInclusivePhrases: ["high functioning", "low functioning"],
  inclusiveAlternatives: "describing the specific characteristic or experience",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: "Be careful when using <i>%1$s</i> as it is potentially harmful. " + "Consider using an alternative, such as %2$s, unless referring to how you characterize your own condition.",
  rule: (words, nonInclusivePhrase) => (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, ["autism"]))
}, {
  identifier: "autismHigh",
  nonInclusivePhrases: ["high functioning autism", "high-functioning autism"],
  inclusiveAlternatives: "<i>autism with high support needs</i> or describing the specific characteristic or experience",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: "Avoid using <i>%1$s</i> as it is potentially harmful. " + "Consider using an alternative, such as %2$s, unless referring to how you characterize your own condition."
}, {
  identifier: "autismLow",
  nonInclusivePhrases: ["low functioning autism", "low-functioning autism"],
  inclusiveAlternatives: "<i>autism with low support needs</i> or describing the specific characteristic or experience",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: "Avoid using <i>%1$s</i> as it is potentially harmful. " + "Consider using an alternative, such as %2$s, unless referring to how you characterize your own condition."
}, {
  identifier: "lame",
  nonInclusivePhrases: ["lame"],
  inclusiveAlternatives: "<i>boring, lousy, unimpressive, sad, corny</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "lamer",
  nonInclusivePhrases: ["lamer"],
  inclusiveAlternatives: "<i>more boring, lousier, more unimpressive, sadder, cornier</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "lamest",
  nonInclusivePhrases: ["lamest"],
  inclusiveAlternatives: "<i>most boring, lousiest, most unimpressive, saddest, corniest</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "commitSuicide",
  nonInclusivePhrases: ["commit suicide"],
  inclusiveAlternatives: "<i>take one's life, die by suicide, kill oneself</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "committingSuicide",
  nonInclusivePhrases: ["committing suicide"],
  inclusiveAlternatives: "<i>taking one's life, dying by suicide, killing oneself</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "commitsSuicide",
  nonInclusivePhrases: ["commits suicide"],
  inclusiveAlternatives: "<i>takes one's life, dies by suicide, kills oneself</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "committedSuicide",
  nonInclusivePhrases: ["committed suicide"],
  inclusiveAlternatives: "<i>took one's life, died by suicide, killed themself</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "handicapParking",
  nonInclusivePhrases: ["handicap parking"],
  inclusiveAlternatives: "<i>accessible parking</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "fellOnDeafEars",
  nonInclusivePhrases: ["fell on deaf ears"],
  inclusiveAlternatives: "<i>was not addressed, was ignored, was disregarded</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "turnOnBlindEye",
  nonInclusivePhrases: ["turn a blind eye"],
  inclusiveAlternatives: "<i>ignore, pretend not to notice</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "blindLeadingBlind",
  nonInclusivePhrases: ["the blind leading the blind"],
  inclusiveAlternatives: "<i>ignorant, misguided, incompetent, unqualified, insensitive, unaware</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "handicapBathroom",
  nonInclusivePhrases: ["handicap bathroom", "handicap bathrooms"],
  inclusiveAlternatives: "<i>accessible bathroom(s)</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "handicapToilet",
  nonInclusivePhrases: ["handicap toilet", "handicap toilets"],
  inclusiveAlternatives: "<i>accessible toilet(s)</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "handicapStall",
  nonInclusivePhrases: ["handicap stall", "handicap stalls"],
  inclusiveAlternatives: "<i>accessible stall(s)</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "stupid",
  nonInclusivePhrases: ["stupid"],
  inclusiveAlternatives: ["<i>uninformed, ignorant, foolish, inconsiderate, irrational, reckless</i>"],
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "dumb",
  nonInclusivePhrases: ["dumb", "dumber", "dumbest"],
  inclusiveAlternatives: ["<i>uninformed, ignorant, foolish, inconsiderate, irrational, reckless</i>"],
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isPrecededByException.isNotPrecededByException)(words, ["deaf and"]));
  }
}, {
  identifier: "deaf",
  nonInclusivePhrases: ["deaf-mute", "deaf and dumb"],
  inclusiveAlternatives: "<i>deaf</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "addict",
  nonInclusivePhrases: ["addict"],
  inclusiveAlternatives: "<i>person with a (drug, alcohol, ...) addiction, person with substance abuse disorder</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless
}, {
  identifier: "addicts",
  nonInclusivePhrases: ["addicts"],
  inclusiveAlternatives: "<i>people with a (drug, alcohol, ...) addiction, people with substance abuse disorder</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless
}, {
  identifier: "brainDamaged",
  nonInclusivePhrases: ["brain-damaged"],
  inclusiveAlternatives: "<i>person with a (traumatic) brain injury</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless
}, {
  identifier: "differentlyAbled",
  nonInclusivePhrases: ["differently abled", "differently-abled"],
  inclusiveAlternatives: "<i>disabled, person with a disability</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless
}, {
  identifier: "epilepticFit",
  nonInclusivePhrases: ["epileptic fit"],
  inclusiveAlternatives: "<i>epileptic seizure</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "epilepticFits",
  nonInclusivePhrases: ["epileptic fits"],
  inclusiveAlternatives: "<i>epileptic seizures</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "sanityCheck",
  nonInclusivePhrases: ["sanity check"],
  inclusiveAlternatives: "<i>final check, confidence check, rationality check, soundness check</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "to not be crazy about",
  nonInclusivePhrases: ["crazy about"],
  inclusiveAlternatives: "<i>to not be impressed by, to not be enthusiastic about, to not be into, to not like</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: ["Avoid using <i>to not be crazy about</i> as it is potentially harmful.", _feedbackStrings.alternative].join(" "),
  // Target only when preceded by a form of "to be", the negation "not", and an optional intensifier (e.g. "is not so crazy about" ).
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isPrecededByException.isPrecededByException)(words, _disabilityRulesData.formsOfToBeNotWithOptionalIntensifier));
  }
}, {
  identifier: "to be crazy about",
  nonInclusivePhrases: ["crazy about"],
  inclusiveAlternatives: "<i>to love, to be obsessed with, to be infatuated with</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: ["Avoid using <i>to be crazy about</i> as it is potentially harmful.", _feedbackStrings.alternative].join(" "),
  // Target only when preceded by a form of "to be" and an optional intensifier (e.g. "am so crazy about")
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isPrecededByException.isPrecededByException)(words, _disabilityRulesData.formsOfToBeWithOptionalIntensifier));
  }
}, {
  identifier: "crazy in love",
  nonInclusivePhrases: ["crazy in love"],
  inclusiveAlternatives: "<i>wildly in love, head over heels, infatuated</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "to go crazy",
  nonInclusivePhrases: ["crazy"],
  inclusiveAlternatives: "<i>to go wild, to go out of control, to go up the wall, to be aggravated," + " to get confused</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: ["Avoid using <i>to go crazy</i> as it is potentially harmful.", _feedbackStrings.alternative].join(" "),
  // Target only when preceded by a form of "to go" (e.g. 'going crazy').
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isPrecededByException.isPrecededByException)(words, _disabilityRulesData.formsOfToGo));
  }
}, {
  identifier: "to drive crazy",
  nonInclusivePhrases: ["crazy"],
  inclusiveAlternatives: "<i>to drive one to their limit, to get on one's last nerve, to make one livid, to aggravate, " + "to make one's blood boil, to exasperate, to get into one's head</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: ["Avoid using <i>to drive crazy</i> as it is potentially harmful.", _feedbackStrings.alternative].join(" "),
  // Target only when preceded by a form of 'to drive' and an object pronoun (e.g. 'driving me crazy', 'drove everyone crazy').
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isPrecededByException.isPrecededByException)(words, _disabilityRulesData.combinationsOfDriveAndObjectPronoun));
  }
}, {
  identifier: "crazy",
  nonInclusivePhrases: ["crazy"],
  inclusiveAlternatives: "<i>wild, baffling, out of control, inexplicable, unbelievable, aggravating, shocking, intense, impulsive, chaotic, " + "confused, mistaken, obsessed</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  // Don't target when 'crazy' is part of a more specific phrase that we target.
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isPrecededByException.isNotPrecededByException)(words, _disabilityRulesData.shouldNotPrecedeStandaloneCrazy)).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, _disabilityRulesData.shouldNotFollowStandaloneCrazy)).filter((0, _isFollowedAndPrecededByException.isNotFollowedAndPrecededByException)(words, nonInclusivePhrase, _disabilityRulesData.shouldNotPrecedeStandaloneCrazyWhenFollowedByAbout, _disabilityRulesData.shouldNotFollowStandaloneCrazyWhenPrecededByToBe));
  }
}, {
  identifier: "crazier",
  nonInclusivePhrases: ["crazier"],
  inclusiveAlternatives: "<i>more wild, baffling, out of control, inexplicable, unbelievable, aggravating, shocking, intense, impulsive, " + "chaotic, confused, mistaken, obsessed</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "craziest",
  nonInclusivePhrases: ["craziest"],
  inclusiveAlternatives: "<i>most wild, baffling, out of control, inexplicable, unbelievable, aggravating, shocking, intense, impulsive, " + "chaotic, confused, mistaken, obsessed</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "psychopathic",
  nonInclusivePhrases: ["psychopath", "psychopaths", "psychopathic"],
  inclusiveAlternatives: "<i>toxic, manipulative, unpredictable, impulsive, reckless, out of control</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "schizophrenic",
  nonInclusivePhrases: ["schizophrenic", "bipolar"],
  inclusiveAlternatives: "<i>of two minds, chaotic, confusing</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: medicalCondition,
  rule: (words, nonInclusivePhrase) => (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, ["disorder"]))
}, {
  identifier: "paranoid",
  nonInclusivePhrases: ["paranoid"],
  inclusiveAlternatives: "<i>overly suspicious, unreasonable, defensive</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: medicalCondition,
  rule: (words, nonInclusivePhrase) => (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, ["personality disorder", "delusion", "delusions", "ideation"]))
}, {
  identifier: "manic",
  nonInclusivePhrases: ["manic"],
  inclusiveAlternatives: "<i>excited, raving, unbalanced, wild</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: medicalCondition,
  rule: (words, nonInclusivePhrase) => (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, ["episode", "episodes", "state", "states", "symptoms", "and depressive episodes", "and hypomanic", "or hypomanic"]))
}, {
  identifier: "hysterical",
  nonInclusivePhrases: ["hysterical"],
  inclusiveAlternatives: "<i>intense, vehement, piercing, chaotic</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "psycho",
  nonInclusivePhrases: ["psycho", "psychos"],
  inclusiveAlternatives: "<i>toxic, distraught, unpredictable, reckless, out of control</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "neurotic",
  nonInclusivePhrases: ["neurotic", "lunatic"],
  inclusiveAlternatives: "<i>distraught, unstable, startling, confusing, baffling</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "sociopath",
  nonInclusivePhrases: ["sociopath"],
  inclusiveAlternatives: ["<i>person with antisocial personality disorder</i>", "<i>toxic, manipulative, cruel</i>"],
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: "Be careful when using <i>%1$s</i> as it is potentially harmful. If you are referencing the " + "medical condition, use %2$s instead, unless referring to someone who explicitly wants to be referred to with this term. " + "If you are not referencing the medical condition, consider other alternatives to describe the trait or behavior, such as %3$s."
}, {
  identifier: "sociopaths",
  nonInclusivePhrases: ["sociopaths"],
  inclusiveAlternatives: ["<i>people with antisocial personality disorder</i>", "<i>toxic, manipulative, cruel</i>"],
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: "Be careful when using <i>%1$s</i> as it is potentially harmful. If you are referencing the " + "medical condition, use %2$s instead, unless referring to someone who explicitly wants to be referred to with this term. " + "If you are not referencing the medical condition, consider other alternatives to describe the trait or behavior, such as %3$s."
}, {
  identifier: "narcissistic",
  nonInclusivePhrases: ["narcissistic"],
  inclusiveAlternatives: ["<i>person with narcissistic personality disorder</i>", "<i>selfish, egotistical, self-centered, self-absorbed, vain, toxic, manipulative</i>"],
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: "Be careful when using <i>%1$s</i> as it is potentially harmful. If you are referencing the " + "medical condition, use %2$s instead, unless referring to someone who explicitly wants to be referred to with this term." + " If you are not referencing the medical condition, consider other alternatives to describe the trait or behavior, such as %3$s.",
  rule: (words, nonInclusivePhrase) => (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isFollowedByException.isNotFollowedByException)(words, nonInclusivePhrase, ["personality disorder"]))
}, {
  identifier: "OCD",
  nonInclusivePhrases: ["ocd"],
  inclusiveAlternatives: "<i>pedantic, obsessed, perfectionist</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  // We make sure to always capitalize "OCD" by pre-filling the first replacement variable.
  feedbackFormat: [(0, _i18n.sprintf)(medicalCondition, "OCD", "%2$s"), "If you are referring to someone who has the medical condition, " + "then state that they have OCD rather than that they are OCD."].join(" "),
  // Only target 'OCD' when preceded by a form of 'to be/to get' followed by an optional intensifier.
  rule: (words, inclusivePhrases) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, inclusivePhrases).filter((0, _isPrecededByException.isPrecededByException)(words, _disabilityRulesData.formsOfToBeAndToBeNotWithOptionalIntensifier));
  }
}, {
  identifier: "theMentallyIll",
  nonInclusivePhrases: ["the mentally ill"],
  inclusiveAlternatives: "<i>people who are mentally ill</i>, <i>mentally ill people</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _notInclusiveWhenStandalone.default)(words, nonInclusivePhrase));
  }
}, {
  identifier: "theDisabled",
  nonInclusivePhrases: ["the disabled"],
  inclusiveAlternatives: "<i>people who have a disability</i>, <i>disabled people</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _notInclusiveWhenStandalone.default)(words, nonInclusivePhrase));
  }
}];
disabilityAssessments.forEach(assessment => {
  assessment.category = "disability";
  assessment.learnMoreUrl = "https://yoa.st/inclusive-language-disability";
});
var _default = exports["default"] = disabilityAssessments;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/disabilityRulesData.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/disabilityRulesData.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.shouldNotPrecedeStandaloneCrazyWhenFollowedByAbout = exports.shouldNotPrecedeStandaloneCrazy = exports.shouldNotFollowStandaloneCrazyWhenPrecededByToBe = exports.shouldNotFollowStandaloneCrazy = exports.formsOfToGo = exports.formsOfToBeWithOptionalIntensifier = exports.formsOfToBeNotWithOptionalIntensifier = exports.formsOfToBeAndToBeNotWithOptionalIntensifier = exports["default"] = exports.combinationsOfDriveAndObjectPronoun = void 0;
var _passiveVoiceAuxiliaries = _interopRequireDefault(__webpack_require__(/*! ../../../../languageProcessing/languages/en/config/internal/passiveVoiceAuxiliaries */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/internal/passiveVoiceAuxiliaries.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const intensifiersAndAdverbs = ["so", "very", "a bit", "really", "pretty", "kind of", "that", "too", "totally", "completely", "absolutely", "even", "also", "as"];
const formsOfToDrive = ["driving", "drive", "drove", "drives", "driven"];
const objectPronouns = ["me", "you", "them", "him", "her", "someone", "somebody", "anyone", "anybody", "everyone", "everybody"];
// Remove 'having' and 'what's' from the auxiliaries. We don't want to use them for any rules.
const formsOfToBeAndToGet = _passiveVoiceAuxiliaries.default.slice(0, -2);
/*
 * Move the negated forms ("isn't", "weren't", "wasn't", "aren't") to a separate array "negatedFormsOfToBe".
 * The .splice() method is a mutating method.
 * It means that after invoking this method on "formsOfToBeAndToGet" list, the "formsOfToBeAndToGet" will also be mutated.
 * In this case, the negated forms ("isn't", "weren't", "wasn't", "aren't") will also be removed from the array.
 */
const negatedFormsOfToBe = formsOfToBeAndToGet.splice(19, 4);

/**
 * Creates an array of all possible combinations of strings from two arrays.
 * For example, if array 1 is [ "fluffy", "cute" ] and array 2 is [ "cats", "dogs" ],
 * it creates the array [ "cute cats", "cute dogs", "fluffy cats", "fluffy dogs" ].
 *
 * @param {string[]} arrayOne The first array of strings.
 * @param {string[]} arrayTwo The second array of strings.
 *
 * @returns {string[]} An array containing all possible combinations of strings from two arrays.
 */
const createCombinationsFromTwoArrays = function (arrayOne, arrayTwo) {
  return (0, _lodash.flatMap)(arrayOne, stringFromArrayOne => (0, _lodash.flatMap)(arrayTwo, stringFromArrayTwo => `${stringFromArrayOne} ${stringFromArrayTwo}`));
};

/*
 * Create an array of strings that should precede the non-negated version of 'crazy about'.
 * It includes all forms of 'to be/to get', optionally followed by an intensifier or a specific adverb (e.g., 'is', 'is very', 'are even').
 */
const combinationsOfToBeAndIntensifier = createCombinationsFromTwoArrays(formsOfToBeAndToGet, intensifiersAndAdverbs);
const formsOfToBeWithOptionalIntensifier = exports.formsOfToBeWithOptionalIntensifier = combinationsOfToBeAndIntensifier.concat(formsOfToBeAndToGet);

/*
 * Create an array of strings that should precede the negated version of 'crazy about'.
 * It includes all forms of 'to be/to get', followed by 'not/'nt' and an optional intensifier or specific adverb (e.g., 'is not', 'aren't even').
 */
let formsOfToBeNot = (0, _lodash.flatMap)(formsOfToBeAndToGet, verbTobe => `${verbTobe} not`);
formsOfToBeNot = formsOfToBeNot.concat(negatedFormsOfToBe);
const combinationsOfToBeNotAndIntensifier = createCombinationsFromTwoArrays(formsOfToBeNot, intensifiersAndAdverbs);
const formsOfToBeNotWithOptionalIntensifier = exports.formsOfToBeNotWithOptionalIntensifier = combinationsOfToBeNotAndIntensifier.concat(formsOfToBeNot);

/*
 * Create an array of strings that should precede 'OCD'.
 * It includes both negated and non-negated forms of 'to be/get' followed by an optional intensifier or specific adverb (e.g., 'is very', 'are not').
*/
const formsOfToBeAndToBeNotWithOptionalIntensifier = exports.formsOfToBeAndToBeNotWithOptionalIntensifier = formsOfToBeWithOptionalIntensifier.concat(formsOfToBeNotWithOptionalIntensifier);

/*
 * Create an array of strings that should precede 'crazy' to target the expression 'to drive someone crazy'.
 * It contains all possible combinations of forms of 'to drive' followed by an object pronoun.
 */
const combinationsOfDriveAndObjectPronoun = exports.combinationsOfDriveAndObjectPronoun = createCombinationsFromTwoArrays(formsOfToDrive, objectPronouns);

// Create an array of strings that should precede 'crazy' to follow the expression 'to go crazy'.
const formsOfToGo = exports.formsOfToGo = ["go", "goes", "going", "gone", "went"];

/*
 * Create arrays of strings that should not follow and/or precede standalone 'crazy'.
 * This prevents showing the feedback for standalone 'crazy' when it's part of a more specific phrase that we target.
*/
const shouldNotPrecedeStandaloneCrazy = exports.shouldNotPrecedeStandaloneCrazy = combinationsOfDriveAndObjectPronoun.concat(formsOfToGo);
const shouldNotFollowStandaloneCrazy = exports.shouldNotFollowStandaloneCrazy = ["in love"];
const shouldNotPrecedeStandaloneCrazyWhenFollowedByAbout = exports.shouldNotPrecedeStandaloneCrazyWhenFollowedByAbout = formsOfToBeWithOptionalIntensifier.concat(formsOfToBeNotWithOptionalIntensifier);
const shouldNotFollowStandaloneCrazyWhenPrecededByToBe = exports.shouldNotFollowStandaloneCrazyWhenPrecededByToBe = ["about"];
var _default = exports["default"] = {
  formsOfToBeWithOptionalIntensifier,
  formsOfToBeNotWithOptionalIntensifier,
  formsOfToBeAndToBeNotWithOptionalIntensifier,
  combinationsOfDriveAndObjectPronoun,
  formsOfToGo,
  shouldNotPrecedeStandaloneCrazy,
  shouldNotFollowStandaloneCrazy,
  shouldNotPrecedeStandaloneCrazyWhenFollowedByAbout,
  shouldNotFollowStandaloneCrazyWhenPrecededByToBe
};

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/feedbackStrings.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/feedbackStrings.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.preferredDescriptorIfKnown = exports.potentiallyHarmfulUnlessAnimalsObjects = exports.potentiallyHarmfulUnless = exports.potentiallyHarmfulCareful = exports.potentiallyHarmful = exports.harmfulPotentiallyNonInclusive = exports.harmfulNonInclusive = exports.alternative = void 0;
/*
 * The default first sentence of feedback strings for terms that receive a red traffic light.
 *
 * "Avoid using <i>%1$s</i> as it is potentially harmful."
 */
const harmfulNonInclusive = exports.harmfulNonInclusive = "Avoid using <i>%1$s</i> as it is potentially harmful.";
/*
 * The default first sentence of feedback strings for terms that receive an orange traffic light.
 *
 * "Be careful when using <i>%1$s</i> as it is potentially harmful."
 */
const harmfulPotentiallyNonInclusive = exports.harmfulPotentiallyNonInclusive = "Be careful when using <i>%1$s</i> as it is potentially harmful.";
/*
 * The default second sentence of feedback strings for terms that receive a red traffic light.
 *
 * "Consider using an alternative, such as %2$s."
 */
const alternative = exports.alternative = "Consider using an alternative, such as %2$s.";
/*
 * The default second sentence of feedback strings for terms that receive an orange traffic light and that some people want to be referred to with.
 *
 * "Consider using an alternative, such as %2$s, unless referring to someone who explicitly wants to be referred to with this term."
*/
const alternativeUnless = "Consider using an alternative, such as %2$s, unless referring to " + "someone who explicitly wants to be referred to with this term.";
/*
 * The default feedback string for terms that receive a red traffic light.
 *
 * "Avoid using <i>%1$s</i> as it is potentially harmful. Consider using an alternative, such as %2$s."
*/
const potentiallyHarmful = exports.potentiallyHarmful = [harmfulNonInclusive, alternative].join(" ");
/*
 * Used to create some feedback strings for terms that receive an orange traffic light (usually, an explanation of contexts in which this term is
 * inclusive is appended at the end of this string).
 *
 * "Be careful when using <i>%1$s</i> as it is potentially harmful. Consider using an alternative, such as %2$s."
*/
const potentiallyHarmfulCareful = exports.potentiallyHarmfulCareful = [harmfulPotentiallyNonInclusive, alternative].join(" ");
/*
 * The default feedback string for terms that receive an orange traffic light and which some people may want to be referred to with.
 * For example, 'Eskimo' or 'fat'.
 *
 * "Be careful when using <i>%1$s</i> as it is potentially harmful. Consider using an alternative, such as %2$s, unless referring to someone who
 * explicitly wants to be referred to with this term."
 */
const potentiallyHarmfulUnless = exports.potentiallyHarmfulUnless = [harmfulPotentiallyNonInclusive, alternativeUnless].join(" ");

/*
 * An additional string for offering alternatives for some terms that receive an orange traffic light, such as 'fat' or 'obese'.
 *
 * "Alternatively, if talking about a specific person, use their preferred descriptor if known."
 */
const preferredDescriptorIfKnown = exports.preferredDescriptorIfKnown = "Alternatively, if talking about a specific person, use their preferred descriptor if known.";

// An additional string to target phrases that are potentially non-inclusive unless referring to animals or objects.
const potentiallyHarmfulUnlessAnimalsObjects = exports.potentiallyHarmfulUnlessAnimalsObjects = [harmfulPotentiallyNonInclusive, "Unless you are referring to objects or animals, consider using an alternative, such as %2$s."].join(" ");

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/genderAssessments.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/genderAssessments.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _feedbackStrings = __webpack_require__(/*! ./feedbackStrings */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/feedbackStrings.js");
var _scores = __webpack_require__(/*! ./scores */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/scores.js");
var _includesConsecutiveWords = __webpack_require__(/*! ../helpers/includesConsecutiveWords */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/includesConsecutiveWords.js");
var _notInclusiveWhenStandalone = _interopRequireDefault(__webpack_require__(/*! ../helpers/notInclusiveWhenStandalone */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/notInclusiveWhenStandalone.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/*
 * Used for exclusionary terms, such as 'mankind'.
 *
 * "Avoid using <i>%1$s</i> as it is exclusionary. Consider using an alternative, such as %2$s."
 */
const exclusionary = "Avoid using <i>%1$s</i> as it is exclusionary. " + "Consider using an alternative, such as %2$s.";
/*
 * Used for potentially exclusionary terms that receive an orange traffic light, such as 'he or she'.
 *
 * "Be careful when using <i>%1$s</i> as it is potentially exclusionary. Consider using an alternative, such as %2$s."
 */
const potentiallyExclusionary = "Be careful when using <i>%1$s</i> as it is potentially exclusionary. " + "Consider using an alternative, such as %2$s.";
/*
 * Used for potentially exclusionary terms that receive an orange traffic light, such as 'female-bodied'.
 *
 * "Be careful when using <i>%1$s</i> as it is potentially exclusionary. Consider using an alternative, such as %2$s."
 */
const potentiallyExclusionaryAvoid = "Avoid using <i>%1$s</i> as it is potentially exclusionary. " + "Consider using an alternative, such as %2$s.";
/*
 * Used for terms that are exclusionary unless they describe a group that only consists of the people that the term mentions.
 * For example, "boys and girls".
 *
 * "Be careful when using <i>%1$s</i> as it can be exclusionary. Unless you are sure that the group you refer to only consists of %1$s,
 *  use an alternative, such as %2$s."
 */
const exclusionaryUnless = "Be careful when using <i>%1$s</i> as it can be exclusionary. " + "Unless you are sure that the group you refer to only consists of %1$s, use an alternative, such as %2$s.";
/*
 * Used for terms that are exclusionary unless the group this term describes only consists of men, for example "firemen"."
 *
 * Be careful when using <i>%1$s</i> as it can be exclusionary. Unless you are sure that the group you refer to only consists of %1$s,
 *  use an alternative, such as %2$s."
 */
const exclusionaryUnlessMen = "Be careful when using <i>%1$s</i> as it can be exclusionary. " + "Unless you are sure that the group you refer to only consists of men, use an alternative, such as %2$s.";
/*
 * Used for terms that are exclusionary unless the group this term describes only consists of men and women, for example "ladies and gentlemen".
 *
 * "Be careful when using <i>%1$s</i> as it can be exclusionary. Unless you are sure that the group you refer to only consists of men and women,
 *  use an alternative, such as %2$s."
 */
const exclusionaryUnlessMenAndWomen = "Be careful when using <i>%1$s</i> as it can be exclusionary. " + "Unless you are sure that the group you refer to only consists of men and women, use an alternative, such as %2$s.";
/*
 * Used for terms that are exclusionary unless the group this term describes only consists of two genders, for example "both genders".
 *
 * "Be careful when using <i>%1$s</i> as it can be exclusionary. Unless you are sure that the group you refer to only consists of two genders,
 *  use an alternative, such as %2$s."
 */
const exclusionaryUnlessTwoGenders = "Be careful when using <i>%1$s</i> as it can be exclusionary. " + "Unless you are sure that the group you refer to only consists of two genders, use an alternative, such as %2$s.";
/*
 * Used for terms that are exclusionary unless all members of the group use this term to refer to themselves, for example "mothers and fathers".
 *
 * "Be careful when using <i>%1$s</i> as it can be exclusionary. Unless you are sure that the group you refer to only consists of people who use
 *  this term, use an alternative, such as %2$s."
 */
const exclusionaryUnlessUseTheTerm = "Be careful when using <i>%1$s</i> as it can be exclusionary. " + "Unless you are sure that the group you refer to only consists of people who use this term, use an alternative, such as %2$s.";
/*
 * Used for derogatory terms, such as "he-she".
 *
 * "Avoid using <i>%1$s</i> as it is derogatory."
 */
const derogatory = "Avoid using <i>%1$s</i> as it is derogatory.";
const genderAssessments = [{
  identifier: "firemen",
  nonInclusivePhrases: ["firemen"],
  inclusiveAlternatives: "<i>firefighters</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: exclusionaryUnlessMen
}, {
  identifier: "policemen",
  nonInclusivePhrases: ["policemen"],
  inclusiveAlternatives: "<i>police officers</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: exclusionaryUnlessMen
}, {
  identifier: "menAndWomen",
  nonInclusivePhrases: ["men and women", "women and men"],
  inclusiveAlternatives: "<i>people, people of all genders, individuals, human beings</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: exclusionaryUnless
}, {
  identifier: "boysAndGirls",
  nonInclusivePhrases: ["boys and girls", "girls and boys"],
  inclusiveAlternatives: "<i>kids, children</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: exclusionaryUnless
}, {
  identifier: "heOrShe",
  nonInclusivePhrases: ["he/she", "he or she", "she or he", "(s)he"],
  inclusiveAlternatives: "<i>they</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: potentiallyExclusionary
}, {
  identifier: "birthSex",
  nonInclusivePhrases: ["birth sex", "natal sex"],
  inclusiveAlternatives: "<i>assigned sex, assigned sex at birth</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "mankind",
  nonInclusivePhrases: ["mankind"],
  inclusiveAlternatives: "<i>individuals, people, persons, human beings, humanity</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: exclusionary
}, {
  identifier: "preferredPronouns",
  nonInclusivePhrases: ["preferred pronouns"],
  inclusiveAlternatives: "<i>pronouns</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.potentiallyHarmfulCareful.slice(0, -1), ", unless referring to someone who explicitly wants to use" + " this term to describe their own pronouns."].join("")
}, {
  identifier: "oppositeGender",
  nonInclusivePhrases: ["opposite gender"],
  inclusiveAlternatives: "<i>another gender</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: exclusionary
}, {
  identifier: "oppositeSex",
  nonInclusivePhrases: ["opposite sex"],
  inclusiveAlternatives: "<i>another sex</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: exclusionary
}, {
  identifier: "femaleBodied",
  nonInclusivePhrases: ["female-bodied"],
  inclusiveAlternatives: "<i>assigned female at birth</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: potentiallyExclusionaryAvoid.slice(0, -1) + " if you are discussing a person based on their sex or assigned gender at birth. " + "If talking about human anatomy, use the specific anatomical phrase as opposed to <i>%1$s</i>."
}, {
  identifier: "maleBodied",
  nonInclusivePhrases: ["male-bodied"],
  inclusiveAlternatives: "<i>assigned male at birth</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: potentiallyExclusionaryAvoid.slice(0, -1) + " if you are discussing a person based on their sex or assigned gender at birth. " + "If talking about human anatomy, use the specific anatomical phrase as opposed to <i>%1$s</i>."
}, {
  identifier: "hermaphrodite",
  nonInclusivePhrases: ["hermaphrodite"],
  inclusiveAlternatives: "<i>intersex</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "hermaphrodites",
  nonInclusivePhrases: ["hermaphrodites"],
  inclusiveAlternatives: "<i>intersex people</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "bothGenders",
  nonInclusivePhrases: ["both genders"],
  inclusiveAlternatives: "<i>people, folks, human beings, all genders</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: exclusionaryUnlessTwoGenders
}, {
  identifier: "ladiesAndGentleman",
  nonInclusivePhrases: ["ladies and gentlemen"],
  inclusiveAlternatives: "<i>everyone, folks, honored guests</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: exclusionaryUnlessMenAndWomen
}, {
  identifier: "husbandAndWife",
  nonInclusivePhrases: ["husband and wife", "husbands and wives"],
  inclusiveAlternatives: "<i>spouses, partners</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: potentiallyExclusionary.slice(0, -1) + ", unless referring to someone who explicitly wants to be referred to with this term."
}, {
  identifier: "mothersAndFathers",
  nonInclusivePhrases: ["mothers and fathers", "fathers and mothers"],
  inclusiveAlternatives: "<i>parents</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: exclusionaryUnlessUseTheTerm
}, {
  identifier: "manHours",
  nonInclusivePhrases: ["man-hours"],
  inclusiveAlternatives: "<i>person-hours, business hours</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: exclusionary
}, {
  identifier: "preferredName",
  nonInclusivePhrases: ["preferred name"],
  inclusiveAlternatives: "<i>name, affirming name</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.potentiallyHarmfulCareful.slice(0, -1), ", unless referring to someone who explicitly wants to use" + " this term to describe their own name."].join("")
}, {
  identifier: "transgenders",
  nonInclusivePhrases: ["transgenders"],
  inclusiveAlternatives: "<i>trans people, transgender people</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: [derogatory, _feedbackStrings.alternative].join(" ")
}, {
  identifier: "transsexual",
  nonInclusivePhrases: ["transsexual"],
  inclusiveAlternatives: "<i>transgender</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless
}, {
  identifier: "transsexuals",
  nonInclusivePhrases: ["transsexuals"],
  inclusiveAlternatives: "<i>trans people, transgender people</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless
}, {
  identifier: "transWoman",
  nonInclusivePhrases: ["transwoman"],
  inclusiveAlternatives: "<i>trans woman, transgender woman</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless
}, {
  identifier: "transWomen",
  nonInclusivePhrases: ["transwomen"],
  inclusiveAlternatives: "<i>trans women, transgender women</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless
}, {
  identifier: "transMan",
  nonInclusivePhrases: ["transman"],
  inclusiveAlternatives: "<i>trans man, transgender man</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless
}, {
  identifier: "transMen",
  nonInclusivePhrases: ["transmen"],
  inclusiveAlternatives: "<i>trans men, transgender men</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless
}, {
  identifier: "transgendered",
  nonInclusivePhrases: ["transgendered"],
  inclusiveAlternatives: ["<i>transgender, trans</i>", "transitioned, went through a gender transition"],
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.potentiallyHarmful.slice(0, -1), "if referring to a person. If referring to a transition process," + " consider using an alternative such as <i>%3$s</i>."].join(" ")
}, {
  identifier: "maleToFemale",
  nonInclusivePhrases: ["male-to-female", "mtf"],
  inclusiveAlternatives: "<i>trans woman, transgender woman</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless
}, {
  identifier: "femaleToMale",
  nonInclusivePhrases: ["female-to-male", "ftm"],
  inclusiveAlternatives: "<i>trans man, transgender man</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless
}, {
  identifier: "heShe",
  nonInclusivePhrases: ["he-she"],
  inclusiveAlternatives: "",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: derogatory
}, {
  identifier: "shemale",
  nonInclusivePhrases: ["shemale", "she-male"],
  inclusiveAlternatives: "",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: derogatory
}, {
  identifier: "manMade",
  nonInclusivePhrases: ["man-made", "manmade"],
  inclusiveAlternatives: "<i>artificial, synthetic, machine-made</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: exclusionary
}, {
  identifier: "toEachTheirOwn",
  nonInclusivePhrases: ["to each his own"],
  inclusiveAlternatives: "<i>to each their own</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: exclusionary
}, {
  identifier: "manned",
  nonInclusivePhrases: ["manned"],
  inclusiveAlternatives: "<i>crewed</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: exclusionary
}, {
  identifier: "aTransgender",
  nonInclusivePhrases: ["a transgender", "the transgender"],
  inclusiveAlternatives: "<i>transgender person</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _notInclusiveWhenStandalone.default)(words, nonInclusivePhrase));
  }
}];
genderAssessments.forEach(assessment => {
  assessment.category = "gender";
  assessment.learnMoreUrl = "https://yoa.st/inclusive-language-gender";
});
var _default = exports["default"] = genderAssessments;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/index.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/index.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _ageAssessments = _interopRequireDefault(__webpack_require__(/*! ./ageAssessments */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/ageAssessments.js"));
var _appearanceAssessments = _interopRequireDefault(__webpack_require__(/*! ./appearanceAssessments */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/appearanceAssessments.js"));
var _disabilityAssessments = _interopRequireDefault(__webpack_require__(/*! ./disabilityAssessments */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/disabilityAssessments.js"));
var _genderAssessments = _interopRequireDefault(__webpack_require__(/*! ./genderAssessments */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/genderAssessments.js"));
var _cultureAssessments = _interopRequireDefault(__webpack_require__(/*! ./cultureAssessments */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/cultureAssessments.js"));
var _sesAssessments = _interopRequireDefault(__webpack_require__(/*! ./sesAssessments */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/sesAssessments.js"));
var _otherAssessments = _interopRequireDefault(__webpack_require__(/*! ./otherAssessments */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/otherAssessments.js"));
var _sexualOrientationAssessments = _interopRequireDefault(__webpack_require__(/*! ./sexualOrientationAssessments */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/sexualOrientationAssessments.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _default = exports["default"] = [..._ageAssessments.default, ..._appearanceAssessments.default, ..._disabilityAssessments.default, ..._genderAssessments.default, ..._cultureAssessments.default, ..._sesAssessments.default, ..._otherAssessments.default, ..._sexualOrientationAssessments.default];

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/otherAssessments.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/otherAssessments.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _scores = __webpack_require__(/*! ./scores */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/scores.js");
var _feedbackStrings = __webpack_require__(/*! ./feedbackStrings */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/feedbackStrings.js");
var _includesConsecutiveWords = __webpack_require__(/*! ../helpers/includesConsecutiveWords */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/includesConsecutiveWords.js");
var _isPrecededByException = __webpack_require__(/*! ../helpers/isPrecededByException */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isPrecededByException.js");
const otherAssessments = [{
  identifier: "minorities",
  nonInclusivePhrases: ["minorities"],
  inclusiveAlternatives: ["<i>members of the LGBTQ+ community</i>", "<i>Indigenous peoples</i>", "<i>marginalized groups</i>", "<i>religious minorities</i>"],
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.harmfulPotentiallyNonInclusive, "Consider using an alternative" + " by being specific about which group(s) of people you are referring to. For example: %2$s, %3$s, %4$s. " + "In case an alternative is not available, make sure to specify the type of minorities you are referring to, e.g., %5$s."].join(" ")
}, {
  identifier: "normalPerson",
  nonInclusivePhrases: ["normal person"],
  inclusiveAlternatives: ["<i>typical person, average person</i> or describing the person's specific trait, " + "experience, or behavior"],
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isPrecededByException.isNotPrecededByException)(words, ["mentally", "behaviorally", "behaviourally"]));
  }
}, {
  identifier: "normalPeople",
  nonInclusivePhrases: ["normal people", "Normal people"],
  inclusiveAlternatives: ["<i>typical people, average people</i> or describing people's specific trait, " + "experience, or behavior"],
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  caseSensitive: true,
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _isPrecededByException.isNotPrecededByException)(words, ["mentally", "behaviorally", "behaviourally"]));
  }
}, {
  identifier: "mentallyNormal",
  nonInclusivePhrases: ["mentally normal"],
  inclusiveAlternatives: ["<i>people without mental health conditions</i>, <i>mentally healthy people</i>"],
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.harmfulNonInclusive, "Consider using an alternative, such as %2$s. If possible, be more specific." + " For example: <i>people who don’t have anxiety disorders</i>, <i>people who haven't experienced trauma</i>, etc." + " Be careful when using mental health descriptors and try to avoid making assumptions about someone's mental health."].join(" ")
}, {
  identifier: "behaviorallyNormal",
  nonInclusivePhrases: ["behaviorally normal", "behaviourally normal"],
  inclusiveAlternatives: ["<i>showing typical behavior</i> or describing the specific behavior"],
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnlessAnimalsObjects
}, {
  identifier: "abnormalPerson",
  nonInclusivePhrases: ["abnormal person"],
  inclusiveAlternatives: ["describing the person's specific trait, experience, or behavior"],
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "abnormalPeople",
  nonInclusivePhrases: ["abnormal people"],
  inclusiveAlternatives: ["describing people's specific trait, experience, or behavior"],
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "mentallyAbnormal",
  nonInclusivePhrases: ["mentally abnormal"],
  inclusiveAlternatives: ["<i>people with a mental health condition</i>, <i>people with mental health problems</i>"],
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.harmfulNonInclusive, "Consider using an alternative, such as %2$s. If possible, be more specific." + " For example: <i>people who have anxiety disorders, people who have experienced trauma</i>, etc." + " Be careful when using mental health descriptors and try to avoid making assumptions about someone's mental health."].join(" ")
}, {
  identifier: "behaviorallyAbnormal",
  nonInclusivePhrases: ["behaviorally abnormal", "behaviourally abnormal"],
  inclusiveAlternatives: ["<i>showing atypical behavior, showing dysfunctional behavior</i> " + "or describing the specific behavior"],
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnlessAnimalsObjects
}, {
  identifier: "abnormalBehavior",
  nonInclusivePhrases: ["abnormal behavior", "abnormal behaviour"],
  inclusiveAlternatives: ["<i>atypical behavior, unusual behavior</i> " + "or describing the specific behavior"],
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnlessAnimalsObjects
}];
otherAssessments.forEach(assessment => {
  assessment.category = "other";
  assessment.learnMoreUrl = "https://yoa.st/inclusive-language-other";
});
var _default = exports["default"] = otherAssessments;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/scores.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/scores.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SCORES = void 0;
/**
 * Scores for inclusive language.
 * @enum
 */
const SCORES = exports.SCORES = {
  /**
   * Score given to a phrase that is generally considered non-inclusive.
   * Returns a red bullet.
   */
  NON_INCLUSIVE: 3,
  /**
   * Score given to a phrase that is potentially non-inclusive.
   * Returns an orange bullet.
   */
  POTENTIALLY_NON_INCLUSIVE: 6
};

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/sesAssessments.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/sesAssessments.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _feedbackStrings = __webpack_require__(/*! ./feedbackStrings */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/feedbackStrings.js");
var _scores = __webpack_require__(/*! ./scores */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/scores.js");
var _includesConsecutiveWords = __webpack_require__(/*! ../helpers/includesConsecutiveWords */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/includesConsecutiveWords.js");
var _notInclusiveWhenStandalone = _interopRequireDefault(__webpack_require__(/*! ../helpers/notInclusiveWhenStandalone */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/notInclusiveWhenStandalone.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const sesAssessments = [{
  identifier: "illegalImmigrant",
  nonInclusivePhrases: ["illegal immigrant", "illegal alien"],
  inclusiveAlternatives: "<i>undocumented person, person without papers, immigrant without papers</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "illegalImmigrants",
  nonInclusivePhrases: ["illegal immigrants", "illegal aliens"],
  inclusiveAlternatives: "<i>undocumented people, people without papers, immigrants without papers</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "povertyStricken",
  nonInclusivePhrases: ["poverty stricken"],
  inclusiveAlternatives: "<i>people whose income is below the poverty threshold, people with low-income</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "welfareReliant",
  nonInclusivePhrases: ["welfare reliant"],
  inclusiveAlternatives: "<i>receiving welfare</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "prostitute",
  nonInclusivePhrases: ["prostitute"],
  inclusiveAlternatives: "<i>sex worker</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless
}, {
  identifier: "prostitutes",
  nonInclusivePhrases: ["prostitutes"],
  inclusiveAlternatives: "<i>sex workers</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmfulUnless
}, {
  identifier: "ex-con",
  nonInclusivePhrases: ["ex-con"],
  inclusiveAlternatives: "<i>person who has had felony convictions, person who has been incarcerated</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "ex-cons",
  nonInclusivePhrases: ["ex-cons"],
  inclusiveAlternatives: "<i>people who have had felony convictions, people who have been incarcerated</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "felon",
  nonInclusivePhrases: ["felon"],
  inclusiveAlternatives: "<i>person with felony convictions, person who has been incarcerated</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "felons",
  nonInclusivePhrases: ["felons"],
  inclusiveAlternatives: "<i>people with felony convictions, people who have been incarcerated</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "ex-offender",
  nonInclusivePhrases: ["ex-offender"],
  inclusiveAlternatives: "<i>formerly incarcerated person</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "ex-offenders",
  nonInclusivePhrases: ["ex-offenders"],
  inclusiveAlternatives: "<i>formerly incarcerated people</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful
}, {
  identifier: "theHomeless",
  nonInclusivePhrases: ["the homeless"],
  inclusiveAlternatives: "<i>people experiencing homelessness</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _notInclusiveWhenStandalone.default)(words, nonInclusivePhrase));
  }
}, {
  identifier: "theUndocumented",
  nonInclusivePhrases: ["the undocumented"],
  inclusiveAlternatives: "<i>people who are undocumented, undocumented people, people without papers</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _notInclusiveWhenStandalone.default)(words, nonInclusivePhrase));
  }
}, {
  identifier: "thePoor",
  nonInclusivePhrases: ["the poor"],
  inclusiveAlternatives: "<i>people whose income is below the poverty threshold, people with low-income</i>",
  score: _scores.SCORES.NON_INCLUSIVE,
  feedbackFormat: _feedbackStrings.potentiallyHarmful,
  rule: (words, nonInclusivePhrase) => {
    return (0, _includesConsecutiveWords.includesConsecutiveWords)(words, nonInclusivePhrase).filter((0, _notInclusiveWhenStandalone.default)(words, nonInclusivePhrase));
  }
}];
sesAssessments.forEach(assessment => {
  assessment.category = "ses";
  assessment.learnMoreUrl = "https://yoa.st/inclusive-language-ses";
});
var _default = exports["default"] = sesAssessments;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/sexualOrientationAssessments.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/sexualOrientationAssessments.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _scores = __webpack_require__(/*! ./scores */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/scores.js");
var _feedbackStrings = __webpack_require__(/*! ./feedbackStrings */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/feedbackStrings.js");
const sexualOrientationAssessments = [{
  identifier: "homosexuals",
  nonInclusivePhrases: ["homosexuals"],
  inclusiveAlternatives: "<i>gay people, queer people, lesbians, gay men, people in same-gender relationships</i>",
  score: _scores.SCORES.POTENTIALLY_NON_INCLUSIVE,
  feedbackFormat: [_feedbackStrings.potentiallyHarmfulUnless, "Be as specific possible and use people's preferred labels if they are known."].join(" ")
}];
sexualOrientationAssessments.forEach(assessment => {
  assessment.category = "sexualOrientation";
  assessment.learnMoreUrl = "https://yoa.st/inclusive-language-orientation";
});
var _default = exports["default"] = sexualOrientationAssessments;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/includesConsecutiveWords.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/includesConsecutiveWords.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.includesConsecutiveWords = includesConsecutiveWords;
var _includesWordsAtPosition = __webpack_require__(/*! ./includesWordsAtPosition */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/includesWordsAtPosition.js");
/**
 * Checks whether a list of words contains a sequence of words in the given order.
 * For example, whether [ "the", "cat", "is", "sleeping" ] contains the words ["is", "sleeping"] in that order.
 *
 * @param {string[]} words The list of words.
 * @param {string[]} consecutiveWords The sequence of words in the given order to find in the list.
 *
 * @returns {number[]} The indices where the sequence of words can be found in the list of words.
 */
function includesConsecutiveWords(words, consecutiveWords) {
  const foundIndices = [];
  words.forEach((_, i) => {
    if ((0, _includesWordsAtPosition.includesWordsAtPosition)(consecutiveWords, i, words)) {
      foundIndices.push(i);
    }
  });
  return foundIndices;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/includesWordsAtPosition.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/includesWordsAtPosition.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.includesWordsAtPosition = includesWordsAtPosition;
/**
 * Checks whether a sequence of words in a particular order can be found at the given index in the word list.
 *
 * @param {string[]} consecutiveWords The sequence of words in a particular order.
 * @param {number} index The position at which to find the consecutive word.
 * @param {string[]} words The text.
 *
 * @returns {boolean} Whether consecutiveWords can be found at the given index in words.
 */
function includesWordsAtPosition(consecutiveWords, index, words) {
  return consecutiveWords.every((word, j) => words[index + j] === word);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isFollowedAndPrecededByException.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isFollowedAndPrecededByException.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isFollowedAndPrecededByException = isFollowedAndPrecededByException;
exports.isNotFollowedAndPrecededByException = isNotFollowedAndPrecededByException;
var _isFollowedByException = __webpack_require__(/*! ./isFollowedByException */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isFollowedByException.js");
var _isPrecededByException = __webpack_require__(/*! ./isPrecededByException */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isPrecededByException.js");
/**
 * Returns a callback that checks whether a non-inclusive phrase is both preceded and followed by specific exceptions.
 * For example, if a non-inclusive phrase is "crazy", a preceding exception is "to be", and a following exception is "about":
 * - returns true for "to be crazy about".
 * - returns false for "to be crazy in love"
 * - returns false for "there's something crazy about this".
 *
 * @param {string[]} words A list of words that is being queried.
 * @param {string[]} nonInclusivePhrase A list of words that are the non-inclusive phrase.
 * @param {string[]} precedingExceptions A list of exceptions to check .
 * @param {string[]} followingExceptions A list of words that are the non-inclusive phrase.
 *
 * @returns {function} A callback that checks whether a non-inclusive term is both preceded and followed by an exception.
 */
function isFollowedAndPrecededByException(words, nonInclusivePhrase, precedingExceptions, followingExceptions) {
  return index => {
    return (0, _isFollowedByException.isFollowedByException)(words, nonInclusivePhrase, followingExceptions)(index) && (0, _isPrecededByException.isPrecededByException)(words, precedingExceptions)(index);
  };
}

/**
 * Returns a callback that checks whether a non-inclusive phrase is NOT preceded and followed by specific exceptions.
 * For example, if a non-inclusive phrase is "crazy", a preceding exception is "to be", and a following exception is "about":
 * - returns false for "to be crazy about".
 * - returns true for "to be crazy in love"
 * - returns true for "there's something crazy about this".
 *
 * @param {string[]} words A list of words that is being queried.
 * @param {string[]} nonInclusivePhrase A list of words that are the non-inclusive phrase.
 * @param {string[]} precedingExceptions A list of words that are the non-inclusive phrase.
 * @param {string[]} followingExceptions A list of words that are the non-inclusive phrase.
 *
 * @returns {function} A callback that checks whether a non-inclusive term is both preceded and followed by an exception.
 */
function isNotFollowedAndPrecededByException(words, nonInclusivePhrase, precedingExceptions, followingExceptions) {
  return index => {
    return !isFollowedAndPrecededByException(words, nonInclusivePhrase, precedingExceptions, followingExceptions)(index);
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isFollowedByException.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isFollowedByException.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isFollowedByException = isFollowedByException;
exports.isNotFollowedByException = isNotFollowedByException;
var _languageProcessing = __webpack_require__(/*! ../../../../languageProcessing */ "./node_modules/yoastseo/build/languageProcessing/index.js");
var _includesWordsAtPosition = __webpack_require__(/*! ./includesWordsAtPosition */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/includesWordsAtPosition.js");
/**
 * Checks whether a list of words contains a sequence of words in the given order, excluding cases when
 * they are followed by one of the exceptions.
 *
 * @param {string[]} words The list of words.
 * @param {string[]} consecutiveWords The sequence of words in the given order to find in the list.
 * @param {string[]} exceptions The list of exception phrases.
 *
 * @returns {function} A function that checks whether the given list of words is contained in another list of words in the given order.
 */
function isFollowedByException(words, consecutiveWords, exceptions) {
  const splitExceptions = exceptions.map(exception => (0, _languageProcessing.getWords)(exception, "\\s", false));
  return index => splitExceptions.some(exception => {
    const startIndex = index + consecutiveWords.length;
    if (startIndex >= 0) {
      return (0, _includesWordsAtPosition.includesWordsAtPosition)(exception, startIndex, words);
    }
    return false;
  });
}

/**
 * Checks whether the given list of words contains another list of words in the given order,
 * but only when they are followed by one of the exceptions.
 *
 * @param {string[]} words The list of words.
 * @param {string[]} consecutiveWords The list of words to find.
 * @param {string[]} exceptions The list of exception phrases.
 *
 * @returns {function} A function that checks whether the given list of words is contained in another list of words in the given order.
 */
function isNotFollowedByException(words, consecutiveWords, exceptions) {
  return index => !isFollowedByException(words, consecutiveWords, exceptions)(index);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isFollowedByParticiple.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isFollowedByParticiple.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isFollowedByParticiple = isFollowedByParticiple;
exports.isParticiple = isParticiple;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _passiveVoiceIrregulars = _interopRequireDefault(__webpack_require__(/*! ../../../../languageProcessing/languages/en/config/internal/passiveVoiceIrregulars */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/internal/passiveVoiceIrregulars.js"));
var _regularParticiplesRegex = __webpack_require__(/*! ../../../../languageProcessing/languages/en/config/regularParticiplesRegex */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/regularParticiplesRegex.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Checks if a given word is a participle.
 *
 * @param {string} word The word that needs to be checked for whether it is a participle.
 * @returns {boolean} True if the words is a participle, false otherwise.
 */
function isParticiple(word) {
  const participleMatch = word.match(_regularParticiplesRegex.regularParticiplesRegex);
  return !(0, _lodash.isNull)(participleMatch) && participleMatch[0] === word || (0, _lodash.includes)(_passiveVoiceIrregulars.default, word);
}

/**
 * Generates a callback that checks if a non-inclusive phrase is followed by a participle.
 *
 * @param {string[]} words an array of the words that form the text that contains the non inclusive phrase.
 * @param {string[]} nonInclusivePhrase a list of words that are a non inclusive phrase.
 * @returns {function} a callback function that checks if the word after a non inclusive phrase is a participle.
 */
function isFollowedByParticiple(words, nonInclusivePhrase) {
  return index => {
    const followingWordIndex = index + nonInclusivePhrase.length;
    if (followingWordIndex < words.length) {
      const followingWord = words[followingWordIndex];
      return isParticiple(followingWord);
    }
    return false;
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isPrecededByException.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isPrecededByException.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isNotPrecededByException = isNotPrecededByException;
exports.isPrecededByException = isPrecededByException;
var _languageProcessing = __webpack_require__(/*! ../../../../languageProcessing */ "./node_modules/yoastseo/build/languageProcessing/index.js");
var _includesWordsAtPosition = __webpack_require__(/*! ./includesWordsAtPosition */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/includesWordsAtPosition.js");
/**
 * Checks whether the given list of words contains another list of words in the given order,
 * but not when they are preceded by one of the exceptions.
 *
 * @param {string[]} words The list of words.
 * @param {string[]} exceptions The list of exception phrases.
 *
 * @returns {function} A function that checks whether the given list of words is contained in another list of words in the given order.
 */
function isPrecededByException(words, exceptions) {
  const splitExceptions = exceptions.map(exception => (0, _languageProcessing.getWords)(exception, "\\s", false));
  return index => splitExceptions.some(exception => {
    const startIndex = index - exception.length;
    if (startIndex >= 0) {
      return (0, _includesWordsAtPosition.includesWordsAtPosition)(exception, startIndex, words);
    }
    return false;
  });
}

/**
 * The reverse of isPrecededByException
 * Checks whether the given list of words contains another list of words in the given order,
 * but only when they are preceded by one of the exceptions.
 *
 * @param {string[]} words The list of words.
 * @param {string[]} exception The list of exception phrases.
 * @returns {function} A function that checks whether the given list of words is not contained in another list of words in the given order.
 */
function isNotPrecededByException(words, exception) {
  return index => !isPrecededByException(words, exception)(index);
}

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/notInclusiveWhenStandalone.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/notInclusiveWhenStandalone.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = notInclusiveWhenStandalone;
var _isFollowedByException = __webpack_require__(/*! ./isFollowedByException */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isFollowedByException.js");
var _isFollowedByParticiple = __webpack_require__(/*! ./isFollowedByParticiple */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/helpers/isFollowedByParticiple.js");
var _functionWords = __webpack_require__(/*! ../../../../languageProcessing/languages/en/config/functionWords */ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/functionWords.js");
var _removePunctuation = __webpack_require__(/*! ../../../../languageProcessing/helpers/sanitize/removePunctuation */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/removePunctuation.js");
var _languageProcessing = __webpack_require__(/*! ../../../../languageProcessing */ "./node_modules/yoastseo/build/languageProcessing/index.js");
// Filter tokens from the exception lists that cause trouble when passed to getWords.

// Some punctuation marks are still removed in getWords, as they are not in our punctuation list.
// Those are filtered here out to prevent getWords returning an empty list.
const filteredPunctuationList = _removePunctuation.punctuationList.filter(punctuationMark => (0, _languageProcessing.getWords)(punctuationMark, "\\s", false).length > 0);

/**
 * Returns a callback that checks whether a non-inclusive word is standalone:
 * "The undocumented are there". is not inclusive, "The undocumented" is standalone.
 * "The undocumented people are there." is inclusive, in "The undocumented people", "the undocumented" is not standalone.
 * @param {string[]} words A list of words that is being queried.
 * @param {string[]} nonInclusivePhrase A list of words that are the non-inclusive phrase.
 * @returns {function} A callback that checks whether a non-inclusive term is standalone.
 */
function notInclusiveWhenStandalone(words, nonInclusivePhrase) {
  return index => {
    return (0, _isFollowedByException.isFollowedByException)(words, nonInclusivePhrase, _functionWords.nonNouns)(index) || (0, _isFollowedByParticiple.isFollowedByParticiple)(words, nonInclusivePhrase)(index) || (0, _isFollowedByException.isFollowedByException)(words, nonInclusivePhrase, filteredPunctuationList)(index);
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.seo = exports.readability = exports.inclusiveLanguage = void 0;
var _ParagraphTooLongAssessment = _interopRequireDefault(__webpack_require__(/*! ./readability/ParagraphTooLongAssessment */ "./node_modules/yoastseo/build/scoring/assessments/readability/ParagraphTooLongAssessment.js"));
var _PassiveVoiceAssessment = _interopRequireDefault(__webpack_require__(/*! ./readability/PassiveVoiceAssessment */ "./node_modules/yoastseo/build/scoring/assessments/readability/PassiveVoiceAssessment.js"));
var _SentenceBeginningsAssessment = _interopRequireDefault(__webpack_require__(/*! ./readability/SentenceBeginningsAssessment */ "./node_modules/yoastseo/build/scoring/assessments/readability/SentenceBeginningsAssessment.js"));
var _SentenceLengthInTextAssessment = _interopRequireDefault(__webpack_require__(/*! ./readability/SentenceLengthInTextAssessment */ "./node_modules/yoastseo/build/scoring/assessments/readability/SentenceLengthInTextAssessment.js"));
var _SubheadingDistributionTooLongAssessment = _interopRequireDefault(__webpack_require__(/*! ./readability/SubheadingDistributionTooLongAssessment */ "./node_modules/yoastseo/build/scoring/assessments/readability/SubheadingDistributionTooLongAssessment.js"));
var _TextPresenceAssessment = _interopRequireDefault(__webpack_require__(/*! ./readability/TextPresenceAssessment */ "./node_modules/yoastseo/build/scoring/assessments/readability/TextPresenceAssessment.js"));
var _TransitionWordsAssessment = _interopRequireDefault(__webpack_require__(/*! ./readability/TransitionWordsAssessment */ "./node_modules/yoastseo/build/scoring/assessments/readability/TransitionWordsAssessment.js"));
var _TextAlignmentAssessment = _interopRequireDefault(__webpack_require__(/*! ./readability/TextAlignmentAssessment */ "./node_modules/yoastseo/build/scoring/assessments/readability/TextAlignmentAssessment.js"));
var _WordComplexityAssessment = _interopRequireDefault(__webpack_require__(/*! ./readability/WordComplexityAssessment */ "./node_modules/yoastseo/build/scoring/assessments/readability/WordComplexityAssessment.js"));
var _ListAssessment = _interopRequireDefault(__webpack_require__(/*! ./readability/ListAssessment */ "./node_modules/yoastseo/build/scoring/assessments/readability/ListAssessment.js"));
var _FunctionWordsInKeyphraseAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/FunctionWordsInKeyphraseAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/FunctionWordsInKeyphraseAssessment.js"));
var _InternalLinksAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/InternalLinksAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/InternalLinksAssessment.js"));
var _IntroductionKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/IntroductionKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/IntroductionKeywordAssessment.js"));
var _KeyphraseLengthAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/KeyphraseLengthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseLengthAssessment.js"));
var _KeywordDensityAssessment = _interopRequireWildcard(__webpack_require__(/*! ./seo/KeywordDensityAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeywordDensityAssessment.js"));
var _MetaDescriptionKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/MetaDescriptionKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/MetaDescriptionKeywordAssessment.js"));
var _MetaDescriptionLengthAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/MetaDescriptionLengthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/MetaDescriptionLengthAssessment.js"));
var _OutboundLinksAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/OutboundLinksAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/OutboundLinksAssessment.js"));
var _PageTitleWidthAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/PageTitleWidthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/PageTitleWidthAssessment.js"));
var _SingleH1Assessment = _interopRequireDefault(__webpack_require__(/*! ./seo/SingleH1Assessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/SingleH1Assessment.js"));
var _SubHeadingsKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/SubHeadingsKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/SubHeadingsKeywordAssessment.js"));
var _TextCompetingLinksAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/TextCompetingLinksAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/TextCompetingLinksAssessment.js"));
var _TextLengthAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/TextLengthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/TextLengthAssessment.js"));
var _KeyphraseInSEOTitleAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/KeyphraseInSEOTitleAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseInSEOTitleAssessment.js"));
var _UrlKeywordAssessment = __webpack_require__(/*! ./seo/UrlKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/UrlKeywordAssessment.js");
var _KeyphraseInImageTextAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/KeyphraseInImageTextAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseInImageTextAssessment.js"));
var _ImageCountAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/ImageCountAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/ImageCountAssessment.js"));
var _KeyphraseDistributionAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/KeyphraseDistributionAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseDistributionAssessment.js"));
var _TextTitleAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/TextTitleAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/TextTitleAssessment.js"));
var _ImageAltTagsAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/ImageAltTagsAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/ImageAltTagsAssessment.js"));
var _ProductIdentifiersAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/ProductIdentifiersAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/ProductIdentifiersAssessment.js"));
var _ProductSKUAssessment = _interopRequireDefault(__webpack_require__(/*! ./seo/ProductSKUAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/ProductSKUAssessment.js"));
var _InclusiveLanguageAssessment = _interopRequireDefault(__webpack_require__(/*! ./inclusiveLanguage/InclusiveLanguageAssessment */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/InclusiveLanguageAssessment.js"));
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function (e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != typeof e && "function" != typeof e) return {
    default: e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n.default = e, t && t.set(e, n), n;
}
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
// Readability assessments.

// Readability assessments (premium)

// Readability assessments (product)

// SEO assessments.

// SEO assessments (premium)

// SEO assessments (product)

const readability = exports.readability = {
  ListAssessment: _ListAssessment.default,
  ParagraphTooLongAssessment: _ParagraphTooLongAssessment.default,
  PassiveVoiceAssessment: _PassiveVoiceAssessment.default,
  SentenceBeginningsAssessment: _SentenceBeginningsAssessment.default,
  SentenceLengthInTextAssessment: _SentenceLengthInTextAssessment.default,
  SubheadingDistributionTooLongAssessment: _SubheadingDistributionTooLongAssessment.default,
  TextAlignmentAssessment: _TextAlignmentAssessment.default,
  TextPresenceAssessment: _TextPresenceAssessment.default,
  TransitionWordsAssessment: _TransitionWordsAssessment.default,
  WordComplexityAssessment: _WordComplexityAssessment.default
};

// We expose the deprecated assessments for backwards compatibility.
const seo = exports.seo = {
  FunctionWordsInKeyphraseAssessment: _FunctionWordsInKeyphraseAssessment.default,
  ImageAltTagsAssessment: _ImageAltTagsAssessment.default,
  ImageCountAssessment: _ImageCountAssessment.default,
  ImageKeyphraseAssessment: _KeyphraseInImageTextAssessment.default,
  InternalLinksAssessment: _InternalLinksAssessment.default,
  IntroductionKeywordAssessment: _IntroductionKeywordAssessment.default,
  KeyphraseDistributionAssessment: _KeyphraseDistributionAssessment.default,
  KeyphraseInSEOTitleAssessment: _KeyphraseInSEOTitleAssessment.default,
  KeyphraseLengthAssessment: _KeyphraseLengthAssessment.default,
  KeyphraseDensityAssessment: _KeywordDensityAssessment.default,
  KeywordDensityAssessment: _KeywordDensityAssessment.KeywordDensityAssessment,
  MetaDescriptionKeywordAssessment: _MetaDescriptionKeywordAssessment.default,
  MetaDescriptionLengthAssessment: _MetaDescriptionLengthAssessment.default,
  OutboundLinksAssessment: _OutboundLinksAssessment.default,
  PageTitleWidthAssessment: _PageTitleWidthAssessment.default,
  ProductIdentifiersAssessment: _ProductIdentifiersAssessment.default,
  ProductSKUAssessment: _ProductSKUAssessment.default,
  SingleH1Assessment: _SingleH1Assessment.default,
  SubheadingsKeywordAssessment: _SubHeadingsKeywordAssessment.default,
  TextCompetingLinksAssessment: _TextCompetingLinksAssessment.default,
  TextLengthAssessment: _TextLengthAssessment.default,
  TextTitleAssessment: _TextTitleAssessment.default,
  SlugKeywordAssessment: _UrlKeywordAssessment.SlugKeywordAssessment,
  UrlKeywordAssessment: _UrlKeywordAssessment.UrlKeywordAssessment
};
const inclusiveLanguage = exports.inclusiveLanguage = {
  InclusiveLanguageAssessment: _InclusiveLanguageAssessment.default
};

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/readability/ListAssessment.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/readability/ListAssessment.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _helpers = __webpack_require__(/*! ../../../helpers */ "./node_modules/yoastseo/build/helpers/index.js");
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ../../../languageProcessing/helpers/html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment that will look if the text has a list (only applicable for product pages).
 */
class ListAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {object} config The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      urlTitle: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/shopify38"),
      urlCallToAction: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/shopify39"),
      scores: {
        bad: 3,
        good: 9
      }
    };
    this._config = (0, _lodash.merge)(defaultConfig, config);
    this.identifier = "listsPresence";
  }

  /**
   * Checks whether there is an ordered or unordered list in the text.
   *
   * @param {Paper}	paper	The paper object to get the text from.
   *
   * @returns {boolean} Whether there is a list in the paper text.
   */
  findList(paper) {
    const regex = /<[uo]l.*>[\s\S]*<\/[uo]l>/;
    let text = paper.getText();
    text = (0, _htmlParser.default)(text);
    return regex.test(text);
  }

  /**
   * Execute the Assessment and return a result.
   *
   * @param {Paper}       paper       The Paper object to assess.
   *
   * @returns {AssessmentResult} The result of the assessment, containing both a score and a descriptive text.
   */
  getResult(paper) {
    this.textContainsList = this.findList(paper);
    const calculatedScore = this.calculateResult();
    const assessmentResult = new _AssessmentResult.default();
    assessmentResult.setScore(calculatedScore.score);
    assessmentResult.setText(calculatedScore.resultText);
    return assessmentResult;
  }

  /**
   * Checks whether the paper has text.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   *
   * @returns {boolean} True when there is text.
   */
  isApplicable(paper) {
    return this.hasEnoughContentForAssessment(paper);
  }

  /**
   * Calculate the result based on the availability of lists in the text.
   *
   * @returns {Object} The calculated result.
   */
  calculateResult() {
    // Text with at least one list.
    if (this.textContainsList) {
      return {
        score: this._config.scores.good,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sLists%2$s: There is at least one list on this page. Great!", "yoast-woo-seo"), this._config.urlTitle, "</a>")
      };
    }

    // Text with no lists.
    return {
      score: this._config.scores.bad,
      resultText: (0, _i18n.sprintf)(
      /* translators: %1$s expands to a link on yoast.com,
       * %2$s expands to the anchor end tag. */
      (0, _i18n.__)("%1$sLists%3$s: No lists appear on this page. %2$sAdd at least one ordered or unordered list%3$s!", "yoast-woo-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
    };
  }
}
exports["default"] = ListAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/readability/ParagraphTooLongAssessment.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/readability/ParagraphTooLongAssessment.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _stripHTMLTags = __webpack_require__(/*! ../../../languageProcessing/helpers/sanitize/stripHTMLTags */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripHTMLTags.js");
var _addMark = _interopRequireDefault(__webpack_require__(/*! ../../../markers/addMark */ "./node_modules/yoastseo/build/markers/addMark.js"));
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _inRange = __webpack_require__(/*! ../../helpers/assessments/inRange */ "./node_modules/yoastseo/build/scoring/helpers/assessments/inRange.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _Mark = _interopRequireDefault(__webpack_require__(/*! ../../../values/Mark */ "./node_modules/yoastseo/build/values/Mark.js"));
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment that will look if the text has too long paragraphs.
 */
class ParagraphTooLongAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {object} config       The configuration to use.
   * @param {boolean} isProduct   Whether product configuration should be used.
   *
   * @returns {void}
   */
  constructor(config = {}, isProduct = false) {
    super();
    const defaultConfig = {
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/35d"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/35e"),
      countTextIn: (0, _i18n.__)("words", "wordpress-seo"),
      parameters: {
        recommendedLength: 150,
        maximumRecommendedLength: 200
      }
    };
    this.identifier = "textParagraphTooLong";
    this._config = (0, _lodash.merge)(defaultConfig, config);
    this._isProduct = isProduct;
  }

  /**
   * Returns an array containing only the paragraphs longer than the recommended length.
   *
   * @param {array} paragraphsLength The array containing the lengths of individual paragraphs.
   * @param {object} config          The config to use.
   *
   * @returns {array} The number of too long paragraphs.
   */
  getTooLongParagraphs(paragraphsLength, config) {
    const recommendedLength = config.parameters.recommendedLength;
    return (0, _lodash.filter)(paragraphsLength, function (paragraph) {
      return paragraph.countLength > recommendedLength;
    });
  }

  /**
   * Check if there is language-specific config, and if so, overwrite the current config with it.
   *
   * @param {Researcher} researcher The researcher to use.
   *
   * @returns {Object} The config that should be used.
   */
  getConfig(researcher) {
    const currentConfig = this._config;
    const languageSpecificConfig = researcher.getConfig("paragraphLength");

    /*
     * If a language has a specific paragraph length config, check further if the assessment is run in product pages.
     * If it's run in product pages, override the default config parameters with the language specific config for product pages,
     * otherwise override it with the language specific config for default pages analysis.
     */
    if (languageSpecificConfig) {
      currentConfig.parameters = this._isProduct ? languageSpecificConfig.productPageParams : languageSpecificConfig.defaultPageParams;
    }
    return currentConfig;
  }

  /**
   * Returns the scores and text for the ParagraphTooLongAssessment.
   *
   * @param {array} paragraphsLength  The array containing the lengths of individual paragraphs.
   * @param {array} tooLongParagraphs The number of too long paragraphs.
   * @param {object} config           The config to use.
   *
   * @returns {{score: number, text: string }} The assessmentResult.
   */
  calculateResult(paragraphsLength, tooLongParagraphs, config) {
    let score;
    if (paragraphsLength.length === 0) {
      return {};
    }
    const longestParagraphLength = paragraphsLength[0].countLength;
    if (longestParagraphLength <= config.parameters.recommendedLength) {
      // Green indicator.
      score = 9;
    }
    if ((0, _inRange.inRangeEndInclusive)(longestParagraphLength, config.parameters.recommendedLength, config.parameters.maximumRecommendedLength)) {
      // Orange indicator.
      score = 6;
    }
    if (longestParagraphLength > config.parameters.maximumRecommendedLength) {
      // Red indicator.
      score = 3;
    }
    if (score >= 7) {
      return {
        score: score,
        hasMarks: false,
        text: (0, _i18n.sprintf)(/* translators:  %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sParagraph length%2$s: None of the paragraphs are too long. Great job!", "wordpress-seo"), config.urlTitle, "</a>")
      };
    }
    return {
      score: score,
      hasMarks: true,
      text: (0, _i18n.sprintf)(
      /* translators: %1$s and %5$s expand to a link on yoast.com, %2$s expands to the anchor end tag,
      %3$d expands to the number of paragraphs over the recommended word / character limit, %4$d expands to the word / character limit,
      %6$s expands to the word 'words' or 'characters'. */
      (0, _i18n._n)("%1$sParagraph length%2$s: %3$d of the paragraphs contains more than the recommended maximum of %4$d %6$s. %5$sShorten your paragraphs%2$s!", "%1$sParagraph length%2$s: %3$d of the paragraphs contain more than the recommended maximum of %4$d %6$s. %5$sShorten your paragraphs%2$s!", tooLongParagraphs.length, "wordpress-seo"), config.urlTitle, "</a>", tooLongParagraphs.length, config.parameters.recommendedLength, config.urlCallToAction, this._config.countTextIn)
    };
  }

  /**
   * Sort the paragraphs based on word count.
   *
   * @param {Array} paragraphs The array with paragraphs.
   *
   * @returns {Array} The array sorted on word counts.
   */
  sortParagraphs(paragraphs) {
    return paragraphs.sort(function (a, b) {
      return b.countLength - a.countLength;
    });
  }

  /**
   * Creates a marker for the paragraphs.
   *
   * @param {object} paper        The paper to use for the assessment.
   * @param {Researcher} researcher   The researcher used for calling research.
   *
   * @returns {Array} An array with marked paragraphs.
   */
  getMarks(paper, researcher) {
    const paragraphsLength = researcher.getResearch("getParagraphLength");
    const tooLongParagraphs = this.getTooLongParagraphs(paragraphsLength, this.getConfig(researcher));
    return (0, _lodash.map)(tooLongParagraphs, function (paragraph) {
      const paragraphText = (0, _stripHTMLTags.stripBlockTagsAtStartEnd)(paragraph.text);
      const marked = (0, _addMark.default)(paragraphText);
      return new _Mark.default({
        original: paragraphText,
        marked: marked
      });
    });
  }

  /**
   * Runs the getParagraphLength module, based on this returns an assessment result with score and text.
   *
   * @param {Paper} paper             The paper to use for the assessment.
   * @param {Researcher} researcher   The researcher used for calling research.
   *
   * @returns {object} The assessment result.
   */
  getResult(paper, researcher) {
    let paragraphsLength = researcher.getResearch("getParagraphLength");
    const countTextInCharacters = researcher.getConfig("countCharacters");
    if (countTextInCharacters) {
      this._config.countTextIn = (0, _i18n.__)("characters", "wordpress-seo");
    }
    paragraphsLength = this.sortParagraphs(paragraphsLength);
    const config = this.getConfig(researcher);
    const tooLongParagraphs = this.getTooLongParagraphs(paragraphsLength, config);
    const paragraphLengthResult = this.calculateResult(paragraphsLength, tooLongParagraphs, config);
    const assessmentResult = new _AssessmentResult.default();
    assessmentResult.setScore(paragraphLengthResult.score);
    assessmentResult.setText(paragraphLengthResult.text);
    assessmentResult.setHasMarks(paragraphLengthResult.hasMarks);
    return assessmentResult;
  }

  /**
   * Checks if the paragraphTooLong assessment is applicable to the paper.
   *
   * @param {Paper} paper The paper to check.
   *
   * @returns {boolean} Returns true if the assessment is applicable to the paper.
   */
  isApplicable(paper) {
    return this.hasEnoughContentForAssessment(paper);
  }
}
exports["default"] = ParagraphTooLongAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/readability/PassiveVoiceAssessment.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/readability/PassiveVoiceAssessment.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _formatNumber = _interopRequireDefault(__webpack_require__(/*! ../../../helpers/formatNumber */ "./node_modules/yoastseo/build/helpers/formatNumber.js"));
var _inRange = __webpack_require__(/*! ../../helpers/assessments/inRange */ "./node_modules/yoastseo/build/scoring/helpers/assessments/inRange.js");
var _addMark = _interopRequireDefault(__webpack_require__(/*! ../../../markers/addMark */ "./node_modules/yoastseo/build/markers/addMark.js"));
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _stripHTMLTags = __webpack_require__(/*! ../../../languageProcessing/helpers/sanitize/stripHTMLTags */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripHTMLTags.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _Mark = _interopRequireDefault(__webpack_require__(/*! ../../../values/Mark */ "./node_modules/yoastseo/build/values/Mark.js"));
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment that checks whether there are passive sentences in the text.
 */
class PassiveVoiceAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {object} config The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34t"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34u")
    };
    this.identifier = "passiveVoice";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Calculates the result based on the number of sentences and passives.
   *
   * @param {object} passiveVoice     The object containing the number of sentences and passives.
   *
   * @returns {{score: number, text}} resultobject with score and text.
   */
  calculatePassiveVoiceResult(passiveVoice) {
    let score;
    let percentage = 0;
    const recommendedValue = 10;

    // Prevent division by zero errors.
    if (passiveVoice.total !== 0) {
      percentage = (0, _formatNumber.default)(passiveVoice.passives.length / passiveVoice.total * 100);
    }
    const hasMarks = percentage > 0;
    if (percentage <= 10) {
      // Green indicator.
      score = 9;
    }
    if ((0, _inRange.inRangeEndInclusive)(percentage, 10, 15)) {
      // Orange indicator.
      score = 6;
    }
    if (percentage > 15) {
      // Red indicator.
      score = 3;
    }
    if (score >= 7) {
      return {
        score: score,
        hasMarks: hasMarks,
        text: (0, _i18n.sprintf)(/* translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag. */
        (0, _i18n.__)("%1$sPassive voice%2$s: You're using enough active voice. That's great!", "wordpress-seo"), this._config.urlTitle, "</a>")
      };
    }
    return {
      score: score,
      hasMarks: hasMarks,
      text: (0, _i18n.sprintf)(
      /* translators: %1$s and %5$s expand to a link on yoast.com, %2$s expands to the anchor end tag,
      %3$s expands to the percentage of sentences in passive voice, %4$s expands to the recommended value. */
      (0, _i18n.__)("%1$sPassive voice%2$s: %3$s of the sentences contain passive voice, which is more than the recommended maximum of %4$s. %5$sTry to use their active counterparts%2$s.", "wordpress-seo"), this._config.urlTitle, "</a>", percentage + "%", recommendedValue + "%", this._config.urlCallToAction)
    };
  }

  /**
   * Marks all sentences that have the passive voice.
   *
   * @param {object} paper        The paper to use for the assessment.
   * @param {object} researcher   The researcher used for calling research.
   *
   * @returns {object} All marked sentences.
   */
  getMarks(paper, researcher) {
    const passiveVoice = researcher.getResearch("getPassiveVoiceResult");
    return (0, _lodash.map)(passiveVoice.passives, function (sentence) {
      sentence = (0, _stripHTMLTags.stripIncompleteTags)(sentence);
      const marked = (0, _addMark.default)(sentence);
      return new _Mark.default({
        original: sentence,
        marked: marked
      });
    });
  }

  /**
   * Runs the passiveVoice module, based on this returns an assessment result with score and text.
   *
   * @param {object} paper        The paper to use for the assessment.
   * @param {object} researcher   The researcher used for calling research.
   *
   * @returns {object} the Assessmentresult
   */
  getResult(paper, researcher) {
    const passiveVoice = researcher.getResearch("getPassiveVoiceResult");
    const passiveVoiceResult = this.calculatePassiveVoiceResult(passiveVoice);
    const assessmentResult = new _AssessmentResult.default();
    assessmentResult.setScore(passiveVoiceResult.score);
    assessmentResult.setText(passiveVoiceResult.text);
    assessmentResult.setHasMarks(passiveVoiceResult.hasMarks);
    return assessmentResult;
  }

  /**
   * Checks if passive voice analysis is available for the language of the paper.
   *
   * @param {Paper}       paper       The paper to check.
   * @param {Researcher}  researcher  The researcher object.
   *
   * @returns {boolean} Returns true if the language is available and the paper is not empty.
   */
  isApplicable(paper, researcher) {
    return this.hasEnoughContentForAssessment(paper) && researcher.hasResearch("getPassiveVoiceResult");
  }
}
exports["default"] = PassiveVoiceAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/readability/SentenceBeginningsAssessment.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/readability/SentenceBeginningsAssessment.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _addMark = _interopRequireDefault(__webpack_require__(/*! ../../../markers/addMark */ "./node_modules/yoastseo/build/markers/addMark.js"));
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _stripHTMLTags = __webpack_require__(/*! ../../../languageProcessing/helpers/sanitize/stripHTMLTags */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripHTMLTags.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _Mark = _interopRequireDefault(__webpack_require__(/*! ../../../values/Mark */ "./node_modules/yoastseo/build/values/Mark.js"));
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const maximumConsecutiveDuplicates = 2;

/**
 * Represents the assessment that checks whether there are three or more consecutive sentences beginning with the same word.
 */
class SentenceBeginningsAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {object} config The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/35f"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/35g")
    };
    this.identifier = "sentenceBeginnings";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Counts and groups the number too often used sentence beginnings and determines the lowest count within that group.
   *
   * @param {array} sentenceBeginnings The array containing the objects containing the beginning words and counts.
   *
   * @returns {object} The object containing the total number of too often used beginnings and the lowest count within those.
   */
  groupSentenceBeginnings(sentenceBeginnings) {
    const tooOften = (0, _lodash.partition)(sentenceBeginnings, function (word) {
      return word.count > maximumConsecutiveDuplicates;
    });
    if (tooOften[0].length === 0) {
      return {
        total: 0
      };
    }
    const sortedCounts = (0, _lodash.sortBy)(tooOften[0], function (word) {
      return word.count;
    });
    return {
      total: tooOften[0].length,
      lowestCount: sortedCounts[0].count
    };
  }

  /**
   * Calculates the score based on sentence beginnings.
   *
   * @param {object} groupedSentenceBeginnings    The object with grouped sentence beginnings.
   *
   * @returns {{score: number, text: string, hasMarks: boolean}} result object with score and text.
   */
  calculateSentenceBeginningsResult(groupedSentenceBeginnings) {
    if (groupedSentenceBeginnings.total > 0) {
      return {
        score: 3,
        hasMarks: true,
        text: (0, _i18n.sprintf)(
        /* translators: %1$s and %5$s expand to a link on yoast.com, %2$s expands to the anchor end tag,
        %3$d expands to the number of consecutive sentences starting with the same word,
        %4$d expands to the number of instances where 3 or more consecutive sentences start with the same word. */
        (0, _i18n._n)("%1$sConsecutive sentences%2$s: The text contains %3$d consecutive sentences starting with the same word. %5$sTry to mix things up%2$s!", "%1$sConsecutive sentences%2$s: The text contains %4$d instances where %3$d or more consecutive sentences start with the same word. %5$sTry to mix things up%2$s!", groupedSentenceBeginnings.total, "wordpress-seo"), this._config.urlTitle, "</a>", groupedSentenceBeginnings.lowestCount, groupedSentenceBeginnings.total, this._config.urlCallToAction)
      };
    }
    return {
      score: 9,
      hasMarks: false,
      text: (0, _i18n.sprintf)(/* translators:  %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag */
      (0, _i18n.__)("%1$sConsecutive sentences%2$s: There is enough variety in your sentences. That's great!", "wordpress-seo"), this._config.urlTitle, "</a>")
    };
  }

  /**
   * Marks all consecutive sentences with the same beginnings.
   *
   * @param {object} paper        The paper to use for the assessment.
   * @param {object} researcher   The researcher used for calling research.
   *
   * @returns {object} All marked sentences.
   */
  getMarks(paper, researcher) {
    let sentenceBeginnings = researcher.getResearch("getSentenceBeginnings");
    sentenceBeginnings = (0, _lodash.filter)(sentenceBeginnings, function (sentenceBeginning) {
      return sentenceBeginning.count > maximumConsecutiveDuplicates;
    });
    const sentences = (0, _lodash.map)(sentenceBeginnings, function (begin) {
      return begin.sentences;
    });
    return (0, _lodash.map)((0, _lodash.flatten)(sentences), function (sentence) {
      sentence = (0, _stripHTMLTags.stripIncompleteTags)(sentence);
      const marked = (0, _addMark.default)(sentence);
      return new _Mark.default({
        original: sentence,
        marked: marked
      });
    });
  }

  /**
   * Scores the repetition of sentence beginnings in consecutive sentences.
   *
   * @param {object} paper        The paper to use for the assessment.
   * @param {object} researcher   The researcher used for calling research.
   *
   * @returns {object} The Assessment result
   */
  getResult(paper, researcher) {
    const sentenceBeginnings = researcher.getResearch("getSentenceBeginnings");
    const groupedSentenceBeginnings = this.groupSentenceBeginnings(sentenceBeginnings);
    const sentenceBeginningsResult = this.calculateSentenceBeginningsResult(groupedSentenceBeginnings);
    const assessmentResult = new _AssessmentResult.default();
    assessmentResult.setScore(sentenceBeginningsResult.score);
    assessmentResult.setText(sentenceBeginningsResult.text);
    assessmentResult.setHasMarks(sentenceBeginningsResult.hasMarks);
    return assessmentResult;
  }

  /**
   * Checks if the sentence beginnings assessment is applicable to the paper.
   *
   * @param {Object}      paper       The paper to check.
   * @param {Researcher}  researcher  The researcher object.
   *
   * @returns {boolean} Returns true if the language is available and the paper is not empty.
   */
  isApplicable(paper, researcher) {
    return this.hasEnoughContentForAssessment(paper) && researcher.hasResearch("getSentenceBeginnings");
  }
}
exports["default"] = SentenceBeginningsAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/readability/SentenceLengthInTextAssessment.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/readability/SentenceLengthInTextAssessment.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _checkForTooLongSentences = _interopRequireDefault(__webpack_require__(/*! ../../helpers/assessments/checkForTooLongSentences */ "./node_modules/yoastseo/build/scoring/helpers/assessments/checkForTooLongSentences.js"));
var _formatNumber = _interopRequireDefault(__webpack_require__(/*! ../../../helpers/formatNumber */ "./node_modules/yoastseo/build/helpers/formatNumber.js"));
var _inRange = __webpack_require__(/*! ../../helpers/assessments/inRange */ "./node_modules/yoastseo/build/scoring/helpers/assessments/inRange.js");
var _addMark = _interopRequireDefault(__webpack_require__(/*! ../../../markers/addMark */ "./node_modules/yoastseo/build/markers/addMark.js"));
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _stripHTMLTags = __webpack_require__(/*! ../../../languageProcessing/helpers/sanitize/stripHTMLTags */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripHTMLTags.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _Mark = _interopRequireDefault(__webpack_require__(/*! ../../../values/Mark */ "./node_modules/yoastseo/build/values/Mark.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment that will calculate the length of sentences in the text.
 */
class SentenceLengthInTextAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {object} config			The scoring configuration that should be used.
   * @param {boolean} isCornerstone	Whether cornerstone configuration should be used.
   * @param {boolean} isProduct		Whether product configuration should be used.
  	 * @returns {void}
   */
  constructor(config = {}, isCornerstone = false, isProduct = false) {
    super();
    const defaultConfig = {
      recommendedLength: 20,
      slightlyTooMany: 25,
      farTooMany: 30,
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34v"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34w"),
      countTextIn: (0, _i18n.__)("words", "wordpress-seo")
    };

    // Add cornerstone and/or product-specific config if applicable.
    this._config = (0, _lodash.merge)(defaultConfig, config);
    this._isCornerstone = isCornerstone;
    this._isProduct = isProduct;
    this.identifier = "textSentenceLength";
  }

  /**
   * Scores the percentage of sentences including more than the recommended number of words.
   *
   * @param {Paper} paper The paper to use for the assessment.
   * @param {Researcher} researcher The researcher used for calling research.
   *
   * @returns {AssessmentResult} The Assessment result.
   */
  getResult(paper, researcher) {
    const sentences = researcher.getResearch("countSentencesFromText");
    if (researcher.getConfig("sentenceLength")) {
      this._config = this.getLanguageSpecificConfig(researcher);
    }
    const countTextInCharacters = researcher.getConfig("countCharacters");
    if (countTextInCharacters) {
      this._config.countTextIn = (0, _i18n.__)("characters", "wordpress-seo");
    }
    const percentage = this.calculatePercentage(sentences);
    const score = this.calculateScore(percentage);
    const assessmentResult = new _AssessmentResult.default();
    assessmentResult.setScore(score);
    assessmentResult.setText(this.translateScore(score, percentage));
    assessmentResult.setHasMarks(percentage > 0);
    return assessmentResult;
  }

  /**
   * Checks whether the paper has text.
   *
   * @param {Paper} paper The paper to use for the assessment.
   *
   * @returns {boolean} True when there is text.
   */
  isApplicable(paper) {
    return this.hasEnoughContentForAssessment(paper);
  }

  /**
   * Mark the sentences.
   *
   * @param {Paper} paper The paper to use for the marking.
   * @param {Researcher} researcher The researcher to use.
   *
   * @returns {Array} Array with all the marked sentences.
   */
  getMarks(paper, researcher) {
    const sentenceCount = researcher.getResearch("countSentencesFromText");
    if (researcher.getConfig("sentenceLength")) {
      this._config = this.getLanguageSpecificConfig(researcher);
    }
    const sentenceObjects = this.getTooLongSentences(sentenceCount);
    return (0, _lodash.map)(sentenceObjects, function (sentenceObject) {
      const sentence = (0, _stripHTMLTags.stripIncompleteTags)(sentenceObject.sentence);
      return new _Mark.default({
        original: sentence,
        marked: (0, _addMark.default)(sentence)
      });
    });
  }

  /**
   * Check if there is language-specific config, and if so, overwrite the current config with it.
   *
   * @param {Researcher} researcher The researcher to use.
   *
   * @returns {Object} The config that should be used.
   */
  getLanguageSpecificConfig(researcher) {
    const currentConfig = this._config;
    const languageSpecificConfig = researcher.getConfig("sentenceLength");
    if (languageSpecificConfig.hasOwnProperty("recommendedLength")) {
      currentConfig.recommendedLength = languageSpecificConfig.recommendedLength;
    }

    // Check if a language has specific cornerstone configuration for non-product pages.
    if (this._isCornerstone === true && this._isProduct === false && languageSpecificConfig.hasOwnProperty("cornerstonePercentages")) {
      return (0, _lodash.merge)(currentConfig, languageSpecificConfig.cornerstonePercentages);
    }
    // Check if a language has specific configuration for non-product, non-cornerstone pages.
    if (this._isCornerstone === false && this._isProduct === false && languageSpecificConfig.hasOwnProperty("percentages")) {
      return (0, _lodash.merge)(currentConfig, languageSpecificConfig.percentages);
    }
    // More conditions should be added below once we add language-specific config for product pages.
    return currentConfig;
  }

  /**
   * Translates the score to a message the user can understand.
   *
   * @param {number} score The score.
   * @param {number} percentage The percentage.
   *
   * @returns {string} A string.
   */
  translateScore(score, percentage) {
    if (score >= 7) {
      return (0, _i18n.sprintf)(/* translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag */
      (0, _i18n.__)("%1$sSentence length%2$s: Great!", "wordpress-seo"), this._config.urlTitle, "</a>");
    }
    return (0, _i18n.sprintf)(
    /* translators: %1$s and %6$s expand to a link on yoast.com, %2$s expands to the anchor end tag,
    %3$d expands to percentage of sentences, %4$s expands to the recommended maximum sentence length,
    %5$s expands to the recommended maximum percentage, %7$s expands to the word 'words' or 'characters'. */
    (0, _i18n.__)("%1$sSentence length%2$s: %3$s of the sentences contain more than %4$s %7$s, which is more than the recommended maximum of %5$s. %6$sTry to shorten the sentences%2$s.", "wordpress-seo"), this._config.urlTitle, "</a>", percentage + "%", this._config.recommendedLength, this._config.slightlyTooMany + "%", this._config.urlCallToAction, this._config.countTextIn);
  }

  /**
   * Calculates the percentage of sentences that are too long.
   *
   * @param {Array} sentences The sentences to calculate the percentage for.
   * @returns {number} The calculates percentage of too long sentences.
   */
  calculatePercentage(sentences) {
    let percentage = 0;
    if (sentences.length !== 0) {
      const tooLongTotal = this.countTooLongSentences(sentences);
      percentage = (0, _formatNumber.default)(tooLongTotal / sentences.length * 100);
    }
    return percentage;
  }

  /**
   * Calculates the score for the given percentage.
   *
   * @param {number} percentage The percentage to calculate the score for.
   * @returns {number} The calculated score.
   */
  calculateScore(percentage) {
    let score;

    // Green indicator.
    if (percentage <= this._config.slightlyTooMany) {
      score = 9;
    }

    // Orange indicator.
    if ((0, _inRange.inRangeEndInclusive)(percentage, this._config.slightlyTooMany, this._config.farTooMany)) {
      score = 6;
    }

    // Red indicator.
    if (percentage > this._config.farTooMany) {
      score = 3;
    }
    return score;
  }

  /**
   * Gets the sentences that are qualified as being too long.
   *
   * @param {array} sentences The sentences to filter through.
   * @returns {array} Array with all the sentences considered to be too long.
   */
  getTooLongSentences(sentences) {
    return (0, _checkForTooLongSentences.default)(sentences, this._config.recommendedLength);
  }

  /**
   * Get the total amount of sentences that are qualified as being too long.
   *
   * @param {Array} sentences The sentences to filter through.
   * @returns {Number} The amount of sentences that are considered too long.
   */
  countTooLongSentences(sentences) {
    return this.getTooLongSentences(sentences).length;
  }
}
var _default = exports["default"] = SentenceLengthInTextAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/readability/SubheadingDistributionTooLongAssessment.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/readability/SubheadingDistributionTooLongAssessment.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _addMark = _interopRequireDefault(__webpack_require__(/*! ../../../markers/addMark */ "./node_modules/yoastseo/build/markers/addMark.js"));
var _Mark = _interopRequireDefault(__webpack_require__(/*! ../../../values/Mark */ "./node_modules/yoastseo/build/values/Mark.js"));
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _inRange = __webpack_require__(/*! ../../helpers/assessments/inRange */ "./node_modules/yoastseo/build/scoring/helpers/assessments/inRange.js");
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _getSubheadings = __webpack_require__(/*! ../../../languageProcessing/helpers/html/getSubheadings */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/getSubheadings.js");
var _getWords = _interopRequireDefault(__webpack_require__(/*! ../../../languageProcessing/helpers/word/getWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _stripHTMLTags = __webpack_require__(/*! ../../../languageProcessing/helpers/sanitize/stripHTMLTags */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripHTMLTags.js");
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ../../../languageProcessing/helpers/html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
var _helpers = __webpack_require__(/*! ../../../languageProcessing/helpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment for calculating the text after each subheading.
 */
class SubheadingsDistributionTooLong extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} config The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      parameters: {
        // The maximum recommended value of the subheading text.
        recommendedMaximumLength: 300,
        slightlyTooMany: 300,
        farTooMany: 350
      },
      countTextIn: (0, _i18n.__)("words", "wordpress-seo"),
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34x"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34y"),
      scores: {
        goodShortTextNoSubheadings: 9,
        goodSubheadings: 9,
        okSubheadings: 6,
        badSubheadings: 3,
        badLongTextNoSubheadings: 2
      },
      applicableIfTextLongerThan: 300,
      shouldNotAppearInShortText: false,
      cornerstoneContent: false
    };
    this.identifier = "subheadingsTooLong";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Checks if the text before the first subheading is long or very long.
   *
   * @param {array} foundSubheadings  An array contains found subheading objects.
   *
   * @returns {{isVeryLong: boolean, isLong: boolean}}    An object containing an information
   *                                                      whether the text before the first subheading is long or very long.
   */
  checkTextBeforeFirstSubheadingLength(foundSubheadings) {
    let textBeforeFirstSubheading = {
      isLong: false,
      isVeryLong: false
    };
    // There is a text if the subheading string of the first object in foundSubheadings is empty and the text is not empty.
    if (foundSubheadings.length > 0 && foundSubheadings[0].subheading === "" && foundSubheadings[0].text !== "") {
      // Retrieve the length of the text before the first subheading.
      const textBeforeFirstSubheadingLength = foundSubheadings[0].countLength;
      textBeforeFirstSubheading = {
        isLong: (0, _inRange.inRangeEndInclusive)(textBeforeFirstSubheadingLength, this._config.parameters.slightlyTooMany, this._config.parameters.farTooMany),
        isVeryLong: textBeforeFirstSubheadingLength > this._config.parameters.farTooMany
      };
    }
    return textBeforeFirstSubheading;
  }

  /**
   * Gets the text length from the paper. Remove unwanted element first before calculating.
   *
   * @param { Paper } paper The Paper object to analyse.
   * @param { Researcher } researcher The researcher to use.
   * @returns {number} The length of the text.
   */
  getTextLength(paper, researcher) {
    // Give specific feedback for cases where the post starts with a long text without subheadings.
    const customCountLength = researcher.getHelper("customCountLength");
    let text = paper.getText();
    text = (0, _htmlParser.default)(text);
    text = (0, _helpers.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);
    return customCountLength ? customCountLength(text) : (0, _getWords.default)(text).length;
  }

  /**
   * Runs the getSubheadingTextLength research and checks scores based on length.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   * @param {Researcher}  researcher  The researcher used for calling research.
   *
   * @returns {AssessmentResult} The assessment result.
   */
  getResult(paper, researcher) {
    this._subheadingTextsLength = researcher.getResearch("getSubheadingTextLengths");
    if (researcher.getConfig("subheadingsTooLong")) {
      this._config = this.getLanguageSpecificConfig(researcher);
    }
    // The configuration to use for Japanese texts.
    const countTextInCharacters = researcher.getConfig("countCharacters");
    if (countTextInCharacters) {
      this._config.countTextIn = (0, _i18n.__)("characters", "wordpress-seo");
    }

    // First check if there is text before the first subheading and check its length.
    // It's important that this check is done before we sort the `this._subheadingTextsLength` array.
    const textBeforeFirstSubheading = this.checkTextBeforeFirstSubheadingLength(this._subheadingTextsLength);
    this._subheadingTextsLength = this._subheadingTextsLength.sort(function (a, b) {
      return b.countLength - a.countLength;
    });
    const assessmentResult = new _AssessmentResult.default();
    assessmentResult.setIdentifier(this.identifier);
    this._hasSubheadings = this.hasSubheadings(paper);
    this._tooLongTextsNumber = this.getTooLongSubheadingTexts().length;
    this._textLength = this.getTextLength(paper, researcher);
    const calculatedResult = this.calculateResult(textBeforeFirstSubheading);
    calculatedResult.resultTextPlural = calculatedResult.resultTextPlural || "";
    assessmentResult.setScore(calculatedResult.score);
    assessmentResult.setText(calculatedResult.resultText);
    assessmentResult.setHasMarks(calculatedResult.hasMarks);
    return assessmentResult;
  }

  /**
   * Check if there is language-specific config, and if so, overwrite the current config with it.
   *
   * @param {Researcher} researcher The researcher to use.
   *
   * @returns {Object} The config that should be used.
   */
  getLanguageSpecificConfig(researcher) {
    const currentConfig = this._config;
    const languageSpecificConfig = researcher.getConfig("subheadingsTooLong");
    // Check if a language has a default cornerstone configuration.
    if (currentConfig.cornerstoneContent === true && languageSpecificConfig.hasOwnProperty("cornerstoneParameters")) {
      return (0, _lodash.merge)(currentConfig, languageSpecificConfig.cornerstoneParameters);
    }

    // Use the default language-specific config for non-cornerstone condition
    return (0, _lodash.merge)(currentConfig, languageSpecificConfig.defaultParameters);
  }

  /**
   * Checks the applicability of the assessment based on the presence of text, and, if required, text length.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   * @param {Researcher}  researcher  The language-specific or default researcher.
   *
   * @returns {boolean} True when there is text or when text is longer than the specified length and "shouldNotAppearInShortText" is set to true.
   */
  isApplicable(paper, researcher) {
    /**
     * If the assessment should not appear for shorter texts, only set the assessment as applicable if the text meets the minimum required length.
     * Language-specific length requirements and methods of counting text length may apply (e.g. for Japanese, the text should be counted in
     * characters instead of words, which also makes the minimum required length higher).
    **/
    if (this._config.shouldNotAppearInShortText) {
      if (researcher.getConfig("subheadingsTooLong")) {
        this._config = this.getLanguageSpecificConfig(researcher);
      }
      const textLength = this.getTextLength(paper, researcher);

      // Do not use hasEnoughContentForAssessment as it is redundant with textLength > this._config.applicableIfTextLongerThan.
      return textLength > this._config.applicableIfTextLongerThan;
    }
    return this.hasEnoughContentForAssessment(paper);
  }

  /**
   * Checks whether the paper has subheadings.
   *
   * @param {Paper} paper The paper to use for the assessment.
   *
   * @returns {boolean} True when there is at least one subheading.
   */
  hasSubheadings(paper) {
    const subheadings = (0, _getSubheadings.getSubheadings)(paper.getText());
    return subheadings.length > 0;
  }

  /**
   * Creates a marker for each subheading that precedes a text that is too long.
   *
   * @returns {Array} All markers for the current text.
   */
  getMarks() {
    const marks = (0, _lodash.map)(this.getTooLongSubheadingTexts(), function ({
      subheading
    }) {
      subheading = (0, _stripHTMLTags.stripFullTags)(subheading);
      const marked = (0, _addMark.default)(subheading);
      return new _Mark.default({
        original: subheading,
        marked: marked,
        fieldsToMark: ["heading"]
      });
    });
    // This is to ensure that an empty subheading doesn't receive marker tags.
    // If an empty subheading string receives marker tags, clicking on the eye icon next to the assessment will lead to page crashing.
    return (0, _lodash.filter)(marks, mark => mark.getOriginal() !== "");
  }

  /**
   * Counts the number of subheading texts that are too long.
   *
   * @returns {Array} The array containing subheading texts that are too long.
   */
  getTooLongSubheadingTexts() {
    return (0, _lodash.filter)(this._subheadingTextsLength, function (subheading) {
      return subheading.countLength > this._config.parameters.recommendedMaximumLength;
    }.bind(this));
  }

  /**
   * Calculates the score and creates a feedback string based on the subheading texts length.
   *
   * @param {Object} textBeforeFirstSubheading   An object containing information whether the text before the first subheading is long or very long.
   *
   * @returns {Object} The calculated result.
   */
  calculateResult(textBeforeFirstSubheading) {
    if (this._textLength > this._config.applicableIfTextLongerThan) {
      if (this._hasSubheadings) {
        if (textBeforeFirstSubheading.isLong && this._tooLongTextsNumber < 2) {
          /*
           * Orange indicator. Returns this feedback if the text preceding the first subheading is very long
           * and the total number of too long texts is less than 2.
           */
          return {
            score: this._config.scores.okSubheadings,
            hasMarks: false,
            resultText: (0, _i18n.sprintf)(
            /* translators: %1$s and %3$s expand to a link to https://yoa.st/headings, %2$s expands to the link closing tag.
             * %4$s expands to the recommended number of words following a subheading,
             * %5$s expands to the word 'words' or 'characters'.
             */
            (0, _i18n.__)("%1$sSubheading distribution%2$s: The beginning of your text is longer than %4$s %5$s and is not separated by any subheadings. %3$sAdd subheadings to improve readability.%2$s", "wordpress-seo"), this._config.urlTitle, "</a>", this._config.urlCallToAction, this._config.parameters.recommendedMaximumLength, this._config.countTextIn)
          };
        }
        if (textBeforeFirstSubheading.isVeryLong && this._tooLongTextsNumber < 2) {
          /*
           * Red indicator. Returns this feedback if the text preceding the first subheading is very long
           * and the total number of too long texts is less than 2.
           */
          return {
            score: this._config.scores.badSubheadings,
            hasMarks: false,
            resultText: (0, _i18n.sprintf)(
            /* translators: %1$s and %3$s expand to a link to https://yoa.st/headings, %2$s expands to the link closing tag.
             * %4$s expands to the recommended number of words following a subheading,
             * %5$s expands to the word 'words' or 'characters'.
             */
            (0, _i18n.__)("%1$sSubheading distribution%2$s: The beginning of your text is longer than %4$s %5$s and is not separated by any subheadings. %3$sAdd subheadings to improve readability.%2$s", "wordpress-seo"), this._config.urlTitle, "</a>", this._config.urlCallToAction, this._config.parameters.recommendedMaximumLength, this._config.countTextIn)
          };
        }
        const longestSubheadingTextLength = this._subheadingTextsLength[0].countLength;
        if (longestSubheadingTextLength <= this._config.parameters.slightlyTooMany) {
          // Green indicator.
          return {
            score: this._config.scores.goodSubheadings,
            hasMarks: false,
            resultText: (0, _i18n.sprintf)(
            // translators: %1$s expands to a link to https://yoa.st/headings, %2$s expands to the link closing tag.
            (0, _i18n.__)("%1$sSubheading distribution%2$s: Great job!", "wordpress-seo"), this._config.urlTitle, "</a>")
          };
        }
        if ((0, _inRange.inRangeEndInclusive)(longestSubheadingTextLength, this._config.parameters.slightlyTooMany, this._config.parameters.farTooMany)) {
          // Orange indicator.
          return {
            score: this._config.scores.okSubheadings,
            hasMarks: true,
            resultText: (0, _i18n.sprintf)(
            /* translators: %1$s and %5$s expand to a link on yoast.com, %3$d to the number of text sections
            not separated by subheadings, %4$d expands to the recommended number of words or characters following a
            subheading, %6$s expands to the word 'words' or 'characters', %2$s expands to the link closing tag. */
            (0, _i18n._n)("%1$sSubheading distribution%2$s: %3$d section of your text is longer than %4$d %6$s and is not separated by any subheadings. %5$sAdd subheadings to improve readability%2$s.", "%1$sSubheading distribution%2$s: %3$d sections of your text are longer than %4$d %6$s and are not separated by any subheadings. %5$sAdd subheadings to improve readability%2$s.", this._tooLongTextsNumber, "wordpress-seo"), this._config.urlTitle, "</a>", this._tooLongTextsNumber, this._config.parameters.recommendedMaximumLength, this._config.urlCallToAction, this._config.countTextIn)
          };
        }

        // Red indicator.
        return {
          score: this._config.scores.badSubheadings,
          hasMarks: true,
          resultText: (0, _i18n.sprintf)(
          /* translators: %1$s and %5$s expand to a link on yoast.com, %3$d to the number of text sections
          not separated by subheadings, %4$d expands to the recommended number of words or characters following a
          subheading, %6$s expands to the word 'words' or 'characters', %2$s expands to the link closing tag. */
          (0, _i18n._n)("%1$sSubheading distribution%2$s: %3$d section of your text is longer than %4$d %6$s and is not separated by any subheadings. %5$sAdd subheadings to improve readability%2$s.", "%1$sSubheading distribution%2$s: %3$d sections of your text are longer than %4$d %6$s and are not separated by any subheadings. %5$sAdd subheadings to improve readability%2$s.", this._tooLongTextsNumber, "wordpress-seo"), this._config.urlTitle, "</a>", this._tooLongTextsNumber, this._config.parameters.recommendedMaximumLength, this._config.urlCallToAction, this._config.countTextIn)
        };
      }
      // Red indicator, use '2' so we can differentiate in external analysis.
      return {
        score: this._config.scores.badLongTextNoSubheadings,
        hasMarks: false,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s and %3$s expand to a link to https://yoa.st/headings, %2$s expands to the link closing tag. */
        (0, _i18n.__)("%1$sSubheading distribution%2$s: You are not using any subheadings, although your text is rather long. %3$sTry and add some subheadings%2$s.", "wordpress-seo"), this._config.urlTitle, "</a>", this._config.urlCallToAction)
      };
    }
    if (this._hasSubheadings) {
      // Green indicator.
      return {
        score: this._config.scores.goodSubheadings,
        hasMarks: false,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s expands to a link to https://yoa.st/headings, %2$s expands to the link closing tag. */
        (0, _i18n.__)("%1$sSubheading distribution%2$s: Great job!", "wordpress-seo"), this._config.urlTitle, "</a>")
      };
    }
    // Green indicator.
    return {
      score: this._config.scores.goodShortTextNoSubheadings,
      hasMarks: false,
      resultText: (0, _i18n.sprintf)(/* translators: %1$s expands to a link to https://yoa.st/headings, %2$s expands to the link closing tag. */
      (0, _i18n.__)("%1$sSubheading distribution%2$s: You are not using any subheadings, but your text is short enough and probably doesn't need them.", "wordpress-seo"), this._config.urlTitle, "</a>")
    };
  }
}
var _default = exports["default"] = SubheadingsDistributionTooLong;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/readability/TextAlignmentAssessment.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/readability/TextAlignmentAssessment.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _Mark = _interopRequireDefault(__webpack_require__(/*! ../../../values/Mark */ "./node_modules/yoastseo/build/values/Mark.js"));
var _addMark = _interopRequireDefault(__webpack_require__(/*! ../../../markers/addMark */ "./node_modules/yoastseo/build/markers/addMark.js"));
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _helpers = __webpack_require__(/*! ../../../helpers */ "./node_modules/yoastseo/build/helpers/index.js");
var _stripHTMLTags = __webpack_require__(/*! ../../../languageProcessing/helpers/sanitize/stripHTMLTags */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripHTMLTags.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment that checks whether there is an over-use of center-alignment in the text.
 */
class TextAlignmentAssessment extends _assessment.default {
  /**
   * Constructs a new TextAlignmentAssessment.
   *
   * @param {object} config The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      urlTitle: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/assessment-alignment"),
      urlCallToAction: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/assessment-alignment-cta"),
      scores: {
        bad: 2
      }
    };
    this._config = (0, _lodash.merge)(defaultConfig, config);
    this.identifier = "textAlignment";
  }

  /**
   * Executes the assessment and returns a result.
   *
   * @param {Paper}       paper       The Paper object to assess.
   * @param {Researcher}  researcher  The researcher used in the assessment.
   *
   * @returns {AssessmentResult} The result of the assessment, containing both a score and a descriptive text.
   */
  getResult(paper, researcher) {
    const longCenterAlignedTexts = researcher.getResearch("getLongCenterAlignedTexts");
    const numberOfLongCenterAlignedTexts = longCenterAlignedTexts.length;
    const assessmentResult = new _AssessmentResult.default();
    // We don't want to show the assessment and its feedback when the paper doesn't contain center-aligned text.
    if (numberOfLongCenterAlignedTexts === 0) {
      return assessmentResult;
    }
    const calculatedScore = this.calculateResult(paper, numberOfLongCenterAlignedTexts);
    assessmentResult.setScore(calculatedScore.score);
    assessmentResult.setText(calculatedScore.resultText);
    // We always want to highlight the long center-aligned element.
    assessmentResult.setHasMarks(true);
    return assessmentResult;
  }

  /**
   * Creates the mark objects for all long center-aligned texts.
   *
   * @param {Paper}       paper        The paper to use for the assessment.
   * @param {Researcher}  researcher   The researcher used in the assessment.
   *
   * @returns {object} Mark objects for all long center-aligned texts.
   */
  getMarks(paper, researcher) {
    const longCenterAlignedTexts = researcher.getResearch("getLongCenterAlignedTexts");
    // For example: [ {text: "abc", elementType: "heading"}, {text: "123", elementType: "paragraph"} ].
    return longCenterAlignedTexts.map(longCenterAlignedText => {
      const text = longCenterAlignedText.text;
      const fieldsToMark = longCenterAlignedText.elementType;
      /*
       * Strip the HTML block tags at the beginning and end of the text before applying the yoastmark.
       * This is because applying yoastmark tags to un-sanitized text could lead to highlighting problem(s).
       */
      const marked = (0, _addMark.default)((0, _stripHTMLTags.stripBlockTagsAtStartEnd)(text));
      return new _Mark.default({
        original: text,
        marked: marked,
        fieldsToMark: fieldsToMark
      });
    });
  }

  /**
   * Checks whether the assessment is applicable.
   * The assessment is applicable when the paper has at least 50 characters (after sanitation)
   * and when the researcher has `getLongCenterAlignedText` research.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   * @param {Researcher}  researcher  The researcher used in the assessment.
   *
   * @returns {boolean} True when the paper has at least 50 characters (after sanitation)
   * and when the researcher has `getLongCenterAlignedText` research.
   */
  isApplicable(paper, researcher) {
    return this.hasEnoughContentForAssessment(paper) && researcher.hasResearch("getLongCenterAlignedTexts");
  }

  /**
   * Calculates the result based on the number of center-aligned text found in the paper.
   *
   * @param {Paper}   paper                           The Paper object to assess.
   * @param {number}  numberOfLongCenterAlignedTexts  The number of paragraphs and/or headings
   * that are center aligned and longer than 50 characters.
   *
   * @returns {Object} The calculated result.
   */
  calculateResult(paper, numberOfLongCenterAlignedTexts) {
    if (numberOfLongCenterAlignedTexts > 0) {
      if (paper.getWritingDirection() === "RTL") {
        return {
          score: this._config.scores.bad,
          resultText: (0, _i18n.sprintf)(
          /* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag,
          %4$s expands to the number of the long center-aligned sections in the text */
          (0, _i18n._n)("%1$sAlignment%3$s: There is a long section of center-aligned text. %2$sWe recommend making it right-aligned%3$s.", "%1$sAlignment%3$s: There are %4$s long sections of center-aligned text. " + "%2$sWe recommend making them right-aligned%3$s.", numberOfLongCenterAlignedTexts, "wordpress-seo-premium"), this._config.urlTitle, this._config.urlCallToAction, "</a>", numberOfLongCenterAlignedTexts)
        };
      }
      return {
        score: this._config.scores.bad,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag,
        	%4$s expands to the number of the long center-aligned sections in the text */
        (0, _i18n._n)("%1$sAlignment%3$s: There is a long section of center-aligned text. %2$sWe recommend making it left-aligned%3$s.", "%1$sAlignment%3$s: There are %4$s long sections of center-aligned text. " + "%2$sWe recommend making them left-aligned%3$s.", numberOfLongCenterAlignedTexts, "wordpress-seo-premium"), this._config.urlTitle, this._config.urlCallToAction, "</a>", numberOfLongCenterAlignedTexts)
      };
    }
  }
}
exports["default"] = TextAlignmentAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/readability/TextPresenceAssessment.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/readability/TextPresenceAssessment.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment that checks whether there is enough text in the paper.
 */
class TextPresenceAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {object} config The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/35h"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/35i")
    };
    this.identifier = "textPresence";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Assesses that the paper has at least a little bit of content.
   *
   * @param {Paper} paper The paper to assess.
   *
   * @returns {AssessmentResult} The result of this assessment.
   */
  getResult(paper) {
    if (!this.hasEnoughContentForAssessment(paper)) {
      const result = new _AssessmentResult.default();
      result.setText((0, _i18n.sprintf)(
      /* translators: %1$s and %3$s expand to links to articles on Yoast.com,
      %2$s expands to the anchor end tag*/
      (0, _i18n.__)("%1$sNot enough content%2$s: %3$sPlease add some content to enable a good analysis%2$s.", "wordpress-seo"), this._config.urlTitle, "</a>", this._config.urlCallToAction));
      result.setScore(3);
      return result;
    }
    return new _AssessmentResult.default();
  }
}
exports["default"] = TextPresenceAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/readability/TransitionWordsAssessment.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/readability/TransitionWordsAssessment.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _formatNumber = _interopRequireDefault(__webpack_require__(/*! ../../../helpers/formatNumber */ "./node_modules/yoastseo/build/helpers/formatNumber.js"));
var _inRange = __webpack_require__(/*! ../../helpers/assessments/inRange */ "./node_modules/yoastseo/build/scoring/helpers/assessments/inRange.js");
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _stripHTMLTags = __webpack_require__(/*! ../../../languageProcessing/helpers/sanitize/stripHTMLTags */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/stripHTMLTags.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _Mark = _interopRequireDefault(__webpack_require__(/*! ../../../values/Mark.js */ "./node_modules/yoastseo/build/values/Mark.js"));
var _addMark = _interopRequireDefault(__webpack_require__(/*! ../../../markers/addMark.js */ "./node_modules/yoastseo/build/markers/addMark.js"));
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ../../../languageProcessing/helpers/html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
var _getWords = _interopRequireDefault(__webpack_require__(/*! ../../../languageProcessing/helpers/word/getWords */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getWords.js"));
var _helpers = __webpack_require__(/*! ../../../languageProcessing/helpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment that checks whether there are enough transition words in the text.
 */
class TransitionWordsAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {object} config The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34z"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/35a"),
      applicableIfTextLongerThan: 200
    };
    this.identifier = "textTransitionWords";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Calculates the actual percentage of transition words in the sentences.
   *
   * @param {object} sentences The object containing the total number of sentences and the number of sentences containing
   * a transition word.
   *
   * @returns {number} The percentage of sentences containing a transition word.
   */
  calculateTransitionWordPercentage(sentences) {
    if (sentences.transitionWordSentences === 0 || sentences.totalSentences === 0) {
      return 0;
    }
    return (0, _formatNumber.default)(sentences.transitionWordSentences / sentences.totalSentences * 100);
  }

  /**
   * Calculates the score for the assessment based on the percentage of sentences containing transition words.
   *
   * @param {number} percentage The percentage of sentences containing transition words.
   *
   * @returns {number} The score.
   */
  calculateScoreFromPercentage(percentage) {
    if (percentage < 20) {
      // Red indicator.
      return 3;
    }
    if ((0, _inRange.inRangeStartInclusive)(percentage, 20, 30)) {
      // Orange indicator.
      return 6;
    }

    // Green indicator.
    return 9;
  }

  /**
   * Calculates transition word result.
   *
   * @param {object} transitionWordSentences  The object containing the total number of sentences and the number of sentences containing
   *                                          a transition word.
   *
   * @returns {object} Object containing score and text.
   */
  calculateTransitionWordResult(transitionWordSentences) {
    const percentage = this.calculateTransitionWordPercentage(transitionWordSentences);
    const score = this.calculateScoreFromPercentage(percentage);
    const hasMarks = percentage > 0;
    if (score < 7 && percentage === 0) {
      return {
        score: (0, _formatNumber.default)(score),
        hasMarks: hasMarks,
        text: (0, _i18n.sprintf)(/* translators: %1$s and %3$s expand to a link to yoast.com, %2$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sTransition words%2$s: None of the sentences contain transition words. %3$sUse some%2$s.", "wordpress-seo"), this._config.urlTitle, "</a>", this._config.urlCallToAction)
      };
    }
    if (score < 7) {
      return {
        score: (0, _formatNumber.default)(score),
        hasMarks: hasMarks,
        text: (0, _i18n.sprintf)(
        /* translators: %1$s and %4$s expand to a link to yoast.com, %2$s expands to the anchor end tag,
        %3$s expands to the percentage of sentences containing transition words */
        (0, _i18n.__)("%1$sTransition words%2$s: Only %3$s of the sentences contain transition words, which is not enough. %4$sUse more of them%2$s.", "wordpress-seo"), this._config.urlTitle, "</a>", percentage + "%", this._config.urlCallToAction)
      };
    }
    return {
      score: (0, _formatNumber.default)(score),
      hasMarks: hasMarks,
      text: (0, _i18n.sprintf)(/* translators: %1$s expands to a link on yoast.com, %3$s expands to the anchor end tag. */
      (0, _i18n.__)("%1$sTransition words%2$s: Well done!", "wordpress-seo"), this._config.urlTitle, "</a>")
    };
  }

  /**
   * Scores the percentage of sentences including one or more transition words.
   *
   * @param {object} paper        The paper to use for the assessment.
   * @param {object} researcher   The researcher used for calling research.
   *
   * @returns {object} The Assessment result.
   */
  getResult(paper, researcher) {
    const transitionWordSentences = researcher.getResearch("findTransitionWords");
    const transitionWordResult = this.calculateTransitionWordResult(transitionWordSentences);
    const assessmentResult = new _AssessmentResult.default();
    assessmentResult.setScore(transitionWordResult.score);
    assessmentResult.setText(transitionWordResult.text);
    assessmentResult.setHasMarks(transitionWordResult.hasMarks);
    return assessmentResult;
  }

  /**
   * Marks text for the transition words assessment.
   *
   * @param {Paper}       paper       The paper to use for the marking.
   * @param {Researcher}  researcher  The researcher containing the necessary research.
   *
   * @returns {Array<Mark>} A list of marks that should be applied.
   */
  getMarks(paper, researcher) {
    const transitionWordSentences = researcher.getResearch("findTransitionWords");
    return (0, _lodash.map)(transitionWordSentences.sentenceResults, function (sentenceResult) {
      let sentence = sentenceResult.sentence;
      sentence = (0, _stripHTMLTags.stripIncompleteTags)(sentence);
      return new _Mark.default({
        original: sentence,
        marked: (0, _addMark.default)(sentence)
      });
    });
  }

  /**
   * Checks if the transition words assessment is applicable to the paper. Language-specific length requirements and methods of counting text length
   * may apply (e.g. for Japanese, the text should be counted in characters instead of words, which also makes the minimum required length higher).
   *
   * @param {Paper}       paper       The paper to check.
   * @param {Researcher}  researcher  The researcher object.
   *
   * @returns {boolean} Returns true if the language is available, the paper is not empty and the text is longer than the minimum required length.
   */
  isApplicable(paper, researcher) {
    const customCountLength = researcher.getHelper("customCountLength");
    const customApplicabilityConfig = researcher.getConfig("assessmentApplicability").transitionWords;
    if (customApplicabilityConfig) {
      this._config.applicableIfTextLongerThan = customApplicabilityConfig;
    }
    let text = paper.getText();
    text = (0, _htmlParser.default)(text);
    text = (0, _helpers.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);
    const textLength = customCountLength ? customCountLength(text) : (0, _getWords.default)(text).length;

    // Do not use hasEnoughContent in this assessment as it is mostly redundant with `textLength >= this._config.applicableIfTextLongerThan`
    return textLength >= this._config.applicableIfTextLongerThan && researcher.hasResearch("findTransitionWords");
  }
}
exports["default"] = TransitionWordsAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/readability/WordComplexityAssessment.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/readability/WordComplexityAssessment.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _Mark = _interopRequireDefault(__webpack_require__(/*! ../../../values/Mark */ "./node_modules/yoastseo/build/values/Mark.js"));
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _helpers = __webpack_require__(/*! ../../../helpers */ "./node_modules/yoastseo/build/helpers/index.js");
var _markWordsInSentences = __webpack_require__(/*! ../../../languageProcessing/helpers/word/markWordsInSentences */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/markWordsInSentences.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment that checks whether there are too many complex words in the text.
 * This assessment is not bundled in Yoast SEO.
 */
class WordComplexityAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {object} config The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      scores: {
        acceptableAmount: 6,
        goodAmount: 9
      },
      urlTitle: "https://yoa.st/4ls",
      urlCallToAction: "https://yoa.st/4lt"
    };

    /*
     * translators: This is the name of the 'Word complexity' readability assessment.
           * It appears before the feedback in the analysis, for example in the feedback string:
           * "Word complexity: You are not using too many complex words, which makes your text easy to read. Good job!"
           */
    this.name = (0, _i18n.__)("Word complexity", "wordpress-seo-premium");
    this.identifier = "wordComplexity";
    this._config = (0, _lodash.merge)(defaultConfig, config);

    // Creates an anchor opening tag for the shortlinks.
    this._config.urlTitle = (0, _helpers.createAnchorOpeningTag)(this._config.urlTitle);
    this._config.urlCallToAction = (0, _helpers.createAnchorOpeningTag)(this._config.urlCallToAction);
  }

  /**
   * Scores the percentage of sentences including one or more transition words.
   *
   * @param {Paper} paper        The paper to use for the assessment.
   * @param {Researcher} researcher   The researcher used for calling research.
   *
   * @returns {object} The Assessment result.
   */
  getResult(paper, researcher) {
    this._wordComplexity = researcher.getResearch("wordComplexity");
    const calculatedScore = this.calculateResult();
    const assessmentResult = new _AssessmentResult.default();
    assessmentResult.setScore(calculatedScore.score);
    assessmentResult.setText(calculatedScore.resultText);
    assessmentResult.setHasMarks(calculatedScore.hasMarks);
    return assessmentResult;
  }

  /**
   * Calculates word complexity word result.
   *
   * @returns {object} Object containing the score, the result text and the information whether there is a mark..
   */
  calculateResult() {
    const complexWordsPercentage = this._wordComplexity.percentage;
    const hasMarks = complexWordsPercentage > 0;
    const assessmentLink = this._config.urlTitle + this.name + "</a>";
    if (complexWordsPercentage < 10) {
      return {
        score: this._config.scores.goodAmount,
        hasMarks: hasMarks,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$s expands to the title of the "Word complexity" assessment (translated to the current language)
         and links to an article on yoast.com.*/
        (0, _i18n.__)("%1$s: You are not using too many complex words, which makes your text easy to read. Good job!", "wordpress-seo-premium"), assessmentLink)
      };
    }
    return {
      score: this._config.scores.acceptableAmount,
      hasMarks: hasMarks,
      resultText: (0, _i18n.sprintf)(
      /* translators: %1$s expands to the title of the "Word complexity" assessment (translated to the current language)
      	 and links to an article on yoast.com. %2$s expand to the percentage of the complex words found in the text.
      	 %3$s expand to a link on yoast.com, %4$s expands to the anchor end tag. */
      (0, _i18n.__)("%1$s: %2$s of the words in your text are considered complex. %3$sTry to use shorter and more familiar words to improve readability%4$s.", "wordpress-seo-premium"), assessmentLink, complexWordsPercentage + "%", this._config.urlCallToAction, "</a>")
    };
  }

  /**
   * Marks text for the word complexity assessment.
   *
   * @param {Paper}       paper       The paper to use for the marking.
   * @param {Researcher}  researcher  The researcher containing the necessary research.
   *
   * @returns {Array<Mark>} A list of marks that should be applied.
   */
  getMarks(paper, researcher) {
    const wordComplexityResults = researcher.getResearch("wordComplexity").complexWords;
    const matchWordCustomHelper = researcher.getHelper("matchWordCustomHelper");
    const markings = [];
    wordComplexityResults.forEach(result => {
      const complexWords = result.complexWords;
      const sentence = result.sentence;
      if (complexWords.length > 0) {
        markings.push(new _Mark.default({
          original: sentence,
          marked: (0, _markWordsInSentences.collectMarkingsInSentence)(sentence, complexWords, matchWordCustomHelper)
        }));
      }
    });
    return markings;
  }

  /**
   * Checks if the word complexity assessment is applicable to the paper.
   *
   * @param {Paper}       paper       The paper to check.
   * @param {Researcher}  researcher  The researcher object.
   *
   * @returns {boolean} Returns true if the paper has text and the researcher has word complexity research.
   */
  isApplicable(paper, researcher) {
    return this.hasEnoughContentForAssessment(paper) && researcher.hasResearch("wordComplexity");
  }
}
exports["default"] = WordComplexityAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/FunctionWordsInKeyphraseAssessment.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/FunctionWordsInKeyphraseAssessment.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Assessment to check whether the keyphrase only contains function words.
 */
class FunctionWordsInKeyphraseAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} [config] The configuration to use.
   * @param {number} [config.scores.onlyFunctionWords] The score to return if the keyphrase contains only function words.
   * @param {string} [config.urlTitle] The URL to the relevant KB article.
   * @param {string} [config.urlCallToAction] The URL to the call-to-action article.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      scores: {
        onlyFunctionWords: 0
      },
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/functionwordskeyphrase-1"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/functionwordskeyphrase-2")
    };
    this.identifier = "functionWordsInKeyphrase";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Runs the functionWordsInKeyphrase researcher, based on this returns an assessment result with score.
   *
   * @param {Paper} 		paper 		The paper to use for the assessment.
   * @param {Researcher} 	researcher 	The researcher used for calling research.
   *
   * @returns {AssessmentResult} The result of the assessment.
   */
  getResult(paper, researcher) {
    this._functionWordsInKeyphrase = researcher.getResearch("functionWordsInKeyphrase");
    this._keyword = (0, _lodash.escape)(paper.getKeyword());
    const assessmentResult = new _AssessmentResult.default();
    if (this._functionWordsInKeyphrase) {
      assessmentResult.setScore(this._config.scores.onlyFunctionWords);
      assessmentResult.setText((0, _i18n.sprintf)(
      /**
       * translators:
       * %1$s and %2$s expand to links on yoast.com,
       * %3$s expands to the anchor end tag,
       * %4$s expands to the focus keyphrase of the article.
       */
      (0, _i18n.__)("%1$sFunction words in keyphrase%3$s: Your keyphrase \"%4$s\" contains function words only. %2$sLearn more about what makes a good keyphrase.%3$s", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>", this._keyword));
      assessmentResult.setHasJumps(true);
      assessmentResult.setEditFieldName((0, _i18n.__)("keyphrase", "wordpress-seo"));
    }
    return assessmentResult;
  }

  /**
   * Checks if assessment is applicable to the paper.
   *
   * @param {Paper} 		paper 			The paper to be analyzed.
   * @param {Researcher}  researcher  	The researcher object.
   *
   * @returns {boolean} Whether the paper has a keyword and the researcher has the relevant research.
   */
  isApplicable(paper, researcher) {
    return paper.hasKeyword() && researcher.hasResearch("functionWordsInKeyphrase");
  }
}
var _default = exports["default"] = FunctionWordsInKeyphraseAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/ImageAltTagsAssessment.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/ImageAltTagsAssessment.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _helpers = __webpack_require__(/*! ../../../helpers */ "./node_modules/yoastseo/build/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment that checks if all images have alt tags (only applicable for product pages).
 */
class ImageAltTagsAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {object}  config      The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      scores: {
        bad: 3,
        good: 9
      },
      urlTitle: (0, _helpers.createAnchorOpeningTag)(""),
      urlCallToAction: (0, _helpers.createAnchorOpeningTag)("")
    };
    this.identifier = "imageAltTags";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Executes the Assessment and return a result.
   *
   * @param {Paper}       paper       The Paper object to assess.
   * @param {Researcher}  researcher  The Researcher object containing all available researches.
   *
   * @returns {AssessmentResult} The result of the assessment, containing both a score and a descriptive text.
   */
  getResult(paper, researcher) {
    this.altTagsProperties = researcher.getResearch("altTagCount");
    this.imageCount = researcher.getResearch("imageCount");
    const calculatedScore = this.calculateResult();
    const assessmentResult = new _AssessmentResult.default();
    assessmentResult.setScore(calculatedScore.score);
    assessmentResult.setText(calculatedScore.resultText);
    return assessmentResult;
  }

  /**
   * Checks whether the paper has text with at least 1 image.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   * @param {Researcher}  researcher  The Researcher object containing all available researches.
   *
   * @returns {boolean} True when there is text.
   */
  isApplicable(paper, researcher) {
    this.imageCount = researcher.getResearch("imageCount");
    return paper.hasText() && this.imageCount > 0;
  }

  /**
   * Calculates the result based on the availability of images in the text, including videos in product pages.
   *
   * @returns {Object} The calculated result.
   */
  calculateResult() {
    // The number of images with no alt tags.
    const imagesNoAlt = this.altTagsProperties.noAlt;

    // None of the images has alt tags.
    if (imagesNoAlt === this.imageCount) {
      return {
        score: this._config.scores.bad,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sImage alt tags%3$s: None of the images has alt attributes. %2$sAdd alt attributes to your images%3$s!", "yoast-woo-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }

    // Not all images have alt tags.
    if (imagesNoAlt > 0) {
      return {
        score: this._config.scores.bad,
        resultText: (0, _i18n.sprintf)(
        /* translators: %3$s and %4$s expand to links on yoast.com, %5$s expands to the anchor end tag,
        * %1$d expands to the number of images without alt tags,
        * %2$d expands to the number of images found in the text, */
        (0, _i18n._n)("%3$sImage alt tags%5$s: %1$d image out of %2$d doesn't have alt attributes. %4$sAdd alt attributes to your images%5$s!", "%3$sImage alt tags%5$s: %1$d images out of %2$d don't have alt attributes. %4$sAdd alt attributes to your images%5$s!", imagesNoAlt, "yoast-woo-seo"), imagesNoAlt, this.imageCount, this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }

    // All images have alt tags.
    return {
      score: this._config.scores.good,
      resultText: (0, _i18n.sprintf)(
      /* translators: %1$s expands to a link on yoast.com,
       * %2$s expands to the anchor end tag. */
      (0, _i18n.__)("%1$sImage alt tags%2$s: All images have alt attributes. Good job!", "yoast-woo-seo"), this._config.urlTitle, "</a>")
    };
  }
}
exports["default"] = ImageAltTagsAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/ImageCountAssessment.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/ImageCountAssessment.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _inRange = __webpack_require__(/*! ../../helpers/assessments/inRange */ "./node_modules/yoastseo/build/scoring/helpers/assessments/inRange.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment that checks if the text has any images present, including videos in product pages.
 */
class TextImagesAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {object}  config      The configuration to use.
   * @param {boolean} countVideos Whether videos are also included in the assessment or not.
   *
   * @returns {void}
   */
  constructor(config = {}, countVideos = false) {
    super();
    const defaultConfig = {
      scores: {
        bad: 3,
        good: 9
      },
      recommendedCount: 1,
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/4f4"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/4f5")
    };
    this.identifier = "images";
    this._config = (0, _lodash.merge)(defaultConfig, config);
    this._countVideos = countVideos;
  }

  /**
   * Execute the Assessment and return a result.
   *
   * @param {Paper}       paper       The Paper object to assess.
   * @param {Researcher}  researcher  The Researcher object containing all available researches.
   *
   * @returns {AssessmentResult} The result of the assessment, containing both a score and a descriptive text.
   */
  getResult(paper, researcher) {
    this.imageCount = researcher.getResearch("imageCount");
    this.videoCount = researcher.getResearch("videoCount");
    const calculatedScore = this.calculateResult();
    const assessmentResult = new _AssessmentResult.default();
    assessmentResult.setScore(calculatedScore.score);
    assessmentResult.setText(calculatedScore.resultText);
    return assessmentResult;
  }

  /**
   * Checks whether the paper has text.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   *
   * @returns {boolean} True when there is text.
   */
  isApplicable(paper) {
    return paper.hasText();
  }

  /**
   * Calculate the result based on the availability of images in the text, including videos in product pages.
   *
   * @returns {Object} The calculated result.
   */
  calculateResult() {
    // If "countVideos" is on, we include videos in the assessment
    const mediaCount = this._countVideos ? this.imageCount + this.videoCount : this.imageCount;

    // No images.
    if (mediaCount === 0) {
      if (this._countVideos) {
        return {
          score: this._config.scores.bad,
          resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
          (0, _i18n.__)("%1$sImages and videos%3$s: No images or videos appear on this page. %2$sAdd some%3$s!", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
        };
      }
      return {
        score: this._config.scores.bad,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sImages%3$s: No images appear on this page. %2$sAdd some%3$s!", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }
    if (this._config.scores.okay) {
      if ((0, _inRange.inRangeStartEndInclusive)(mediaCount, 1, 3) && !this._countVideos) {
        return {
          score: this._config.scores.okay,
          resultText: (0, _i18n.sprintf)(
          /* translators: %3$s and %4$s expand to links on yoast.com, %5$s expands to the anchor end tag,
          * %1$d expands to the number of images found in the text,
          * %2$d expands to the recommended number of images in the text, */
          (0, _i18n._n)("%3$sImages%5$s: Only %1$d image appears on this page. We recommend at least %2$d. %4$sAdd more relevant images%5$s!", "%3$sImages%5$s: Only %1$d images appear on this page. We recommend at least %2$d. %4$sAdd more relevant images%5$s!", mediaCount, "wordpress-seo"), mediaCount, this._config.recommendedCount, this._config.urlTitle, this._config.urlCallToAction, "</a>")
        };
      } else if ((0, _inRange.inRangeStartEndInclusive)(mediaCount, 1, 3) && this._countVideos) {
        return {
          score: this._config.scores.okay,
          resultText: (0, _i18n.sprintf)(
          /* translators: %3$s and %4$s expand to links on yoast.com, %5$s expands to the anchor end tag,
          * %1$d expands to the number of images found in the text,
          * %2$d expands to the recommended number of images in the text, */
          (0, _i18n._n)("%3$sImages and videos%5$s: Only %1$d image or video appears on this page. We recommend at least %2$d. %4$sAdd more relevant images or videos%5$s!", "%3$sImages and videos%5$s: Only %1$d images or videos appear on this page. We recommend at least %2$d. %4$sAdd more relevant images or videos%5$s!", mediaCount, "wordpress-seo"), mediaCount, this._config.recommendedCount, this._config.urlTitle, this._config.urlCallToAction, "</a>")
        };
      }
    }
    if (this._countVideos) {
      // Text with at least one image or one video.
      return {
        score: this._config.scores.good,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$s expands to a link on yoast.com,
         * %2$s expands to the anchor end tag. */
        (0, _i18n.__)("%1$sImages and videos%2$s: Good job!", "wordpress-seo"), this._config.urlTitle, "</a>")
      };
    }

    // Text with at least one image.
    return {
      score: this._config.scores.good,
      resultText: (0, _i18n.sprintf)(
      /* translators: %1$s expands to a link on yoast.com,
       * %2$s expands to the anchor end tag. */
      (0, _i18n.__)("%1$sImages%2$s: Good job!", "wordpress-seo"), this._config.urlTitle, "</a>")
    };
  }
}
exports["default"] = TextImagesAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/InternalLinksAssessment.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/InternalLinksAssessment.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Assessment to check whether the text has internal links and whether they are followed or no-followed.
 */
class InternalLinksAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} [config] The configuration to use.
   * @param {number} [config.parameters.recommendedMinimum] The recommended minimum number of internal links in the text.
   * @param {number} [config.scores.allInternalFollow] The score to return if all internal links are do-follow.
   * @param {number} [config.scores.someInternalFollow] The score to return if some but not all internal links are do-follow.
   * @param {number} [config.scores.noneInternalFollow] The score to return if all internal links are no-follow.
   * @param {number} [config.scores.noInternal] The score to return if there are no internal links.
   * @param {string} [config.url] The URL to the relevant KB article.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      parameters: {
        recommendedMinimum: 1
      },
      scores: {
        allInternalFollow: 9,
        someInternalFollow: 8,
        noneInternalFollow: 7,
        noInternal: 3
      },
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/33z"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34a")
    };
    this.identifier = "internalLinks";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Runs the getLinkStatistics module, based on this returns an assessment result with score.
   *
   * @param {Paper} paper The paper to use for the assessment.
   * @param {Researcher} researcher The researcher used for calling research.
   *
   * @returns {AssessmentResult} The result of the assessment.
   */
  getResult(paper, researcher) {
    this.linkStatistics = researcher.getResearch("getLinkStatistics");
    const assessmentResult = new _AssessmentResult.default();
    const calculatedResult = this.calculateResult();
    assessmentResult.setScore(calculatedResult.score);
    assessmentResult.setText(calculatedResult.resultText);
    return assessmentResult;
  }

  /**
   * Checks if assessment is applicable to the paper.
   *
   * @param {Paper} paper The paper to be analyzed.
   *
   * @returns {boolean} Whether the paper has text.
   */
  isApplicable(paper) {
    return paper.hasText();
  }

  /**
   * Returns a score and text based on the linkStatistics object.
   *
   * @returns {Object} ResultObject with score and text
   */
  calculateResult() {
    if (this.linkStatistics.internalTotal === 0) {
      return {
        score: this._config.scores.noInternal,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sInternal links%3$s: No internal links appear in this page, %2$smake sure to add some%3$s!", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }
    if (this.linkStatistics.internalNofollow === this.linkStatistics.internalTotal) {
      return {
        score: this._config.scores.noneInternalFollow,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sInternal links%3$s: The internal links in this page are all nofollowed. %2$sAdd some good internal links%3$s.", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }
    if (this.linkStatistics.internalDofollow === this.linkStatistics.internalTotal) {
      return {
        score: this._config.scores.allInternalFollow,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sInternal links%2$s: You have enough internal links. Good job!", "wordpress-seo"), this._config.urlTitle, "</a>")
      };
    }
    return {
      score: this._config.scores.someInternalFollow,
      resultText: (0, _i18n.sprintf)(/* translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag */
      (0, _i18n.__)("%1$sInternal links%2$s: There are both nofollowed and normal internal links on this page. Good job!", "wordpress-seo"), this._config.urlTitle, "</a>")
    };
  }
}
var _default = exports["default"] = InternalLinksAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/IntroductionKeywordAssessment.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/IntroductionKeywordAssessment.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Assessment to check whether the keyphrase or synonyms are encountered in the first paragraph of the article.
 */
class IntroductionKeywordAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} [config] The configuration to use.
   * @param {number} [config.scores.good] The score to return if there is a match within one sentence in the first paragraph.
   * @param {number} [config.scores.okay] The score to return if all words are matched in the first paragraph.
   * @param {number} [config.scores.bad] The score to return if not all words are matched in the first paragraph.
   * @param {string} [config.url] The URL to the relevant article on Yoast.com.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      scores: {
        good: 9,
        okay: 6,
        bad: 3
      },
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/33e"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/33f")
    };
    this.identifier = "introductionKeyword";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Assesses the presence of keyphrase or synonyms in the first paragraph.
   *
   * @param {Paper} paper The paper to use for the assessment.
   * @param {Researcher} researcher The researcher used for calling research.
   *
   * @returns {AssessmentResult} The result of this assessment.
   */
  getResult(paper, researcher) {
    const assessmentResult = new _AssessmentResult.default();
    this._firstParagraphMatches = researcher.getResearch("findKeywordInFirstParagraph");
    const calculatedResult = this.calculateResult();
    assessmentResult.setScore(calculatedResult.score);
    assessmentResult.setText(calculatedResult.resultText);
    return assessmentResult;
  }

  /**
   * Checks if the paper has both keyword and text.
   *
   * @param {Paper} paper The paper to be analyzed.
   *
   * @returns {boolean} Whether the assessment is applicable or not.
   */
  isApplicable(paper) {
    return paper.hasKeyword() && paper.hasText();
  }

  /**
   * Returns a result based on the number of occurrences of keyphrase in the first paragraph.
   *
   * @returns {Object} result object with a score and translation text.
   */
  calculateResult() {
    if (this._firstParagraphMatches.foundInOneSentence) {
      return {
        score: this._config.scores.good,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag. */
        (0, _i18n.__)("%1$sKeyphrase in introduction%2$s: Well done!", "wordpress-seo"), this._config.urlTitle, "</a>")
      };
    }
    if (this._firstParagraphMatches.foundInParagraph) {
      return {
        score: this._config.scores.okay,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag. */
        (0, _i18n.__)("%1$sKeyphrase in introduction%3$s: Your keyphrase or its synonyms appear in the first paragraph of the copy, but not within one sentence. %2$sFix that%3$s!", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }
    return {
      score: this._config.scores.bad,
      resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag. */
      (0, _i18n.__)("%1$sKeyphrase in introduction%3$s: Your keyphrase or its synonyms do not appear in the first paragraph. %2$sMake sure the topic is clear immediately%3$s.", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
    };
  }
}
var _default = exports["default"] = IntroductionKeywordAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseDistributionAssessment.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseDistributionAssessment.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _helpers = __webpack_require__(/*! ../../../helpers */ "./node_modules/yoastseo/build/helpers/index.js");
var _getSentences = _interopRequireDefault(__webpack_require__(/*! ../../../languageProcessing/helpers/sentence/getSentences */ "./node_modules/yoastseo/build/languageProcessing/helpers/sentence/getSentences.js"));
var _htmlParser = _interopRequireDefault(__webpack_require__(/*! ../../../languageProcessing/helpers/html/htmlParser */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/htmlParser.js"));
var _helpers2 = __webpack_require__(/*! ../../../languageProcessing/helpers */ "./node_modules/yoastseo/build/languageProcessing/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents an assessment that returns a score based on the largest percentage of text in which no keyword occurs.
 */
class KeyphraseDistributionAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} [config] The configuration to use.
   * @param {number} [config.parameters.goodDistributionScore]
   *      The average distribution score that needs to be received from the step function to get a GOOD result.
   * @param {number} [config.parameters.acceptableDistributionScore]
   *      The average distribution score that needs to be received from the step function to get an OKAY result.
   * @param {number} [config.scores.good]             The score to return if keyword occurrences are evenly distributed.
   * @param {number} [config.scores.okay]             The score to return if keyword occurrences are somewhat unevenly distributed.
   * @param {number} [config.scores.bad]              The score to return if there is way too much text between keyword occurrences.
   * @param {number} [config.scores.consideration]    The score to return if there are no keyword occurrences.
   * @param {string} [config.urlTitle]                The URL to the article about this assessment.
   * @param {string} [config.urlCallToAction]         The URL to the help article for this assessment.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      parameters: {
        goodDistributionScore: 30,
        acceptableDistributionScore: 50
      },
      scores: {
        good: 9,
        okay: 6,
        bad: 1,
        consideration: 0
      },
      urlTitle: "https://yoa.st/33q",
      urlCallToAction: "https://yoa.st/33u"
    };
    this.identifier = "keyphraseDistribution";
    this._config = (0, _lodash.merge)(defaultConfig, config);

    // Creates an anchor opening tag for the shortlinks.
    this._config.urlTitle = (0, _helpers.createAnchorOpeningTag)(this._config.urlTitle);
    this._config.urlCallToAction = (0, _helpers.createAnchorOpeningTag)(this._config.urlCallToAction);
  }

  /**
   * Runs the keyphraseDistribution research and based on this returns an assessment result.
   *
   * @param {Paper}      paper      The paper to use for the assessment.
   * @param {Researcher} researcher The researcher used for calling research.
   *
   * @returns {AssessmentResult} The assessment result.
   */
  getResult(paper, researcher) {
    this._keyphraseDistribution = researcher.getResearch("keyphraseDistribution");
    const assessmentResult = new _AssessmentResult.default();
    const calculatedResult = this.calculateResult();
    assessmentResult.setScore(calculatedResult.score);
    assessmentResult.setText(calculatedResult.resultText);
    assessmentResult.setHasMarks(calculatedResult.hasMarks);
    return assessmentResult;
  }

  /**
   * Calculates the result based on the keyphraseDistribution research.
   *
   * @returns {Object} Object with score and feedback text.
   */
  calculateResult() {
    const distributionScore = this._keyphraseDistribution.keyphraseDistributionScore;
    const hasMarks = this._keyphraseDistribution.sentencesToHighlight.length > 0;
    if (distributionScore === 100) {
      return {
        score: this._config.scores.consideration,
        hasMarks: hasMarks,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$s and %2$s expand to links to Yoast.com articles,
        %3$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sKeyphrase distribution%3$s: %2$sInclude your keyphrase or its synonyms in the text so that we can check keyphrase distribution%3$s.", "wordpress-seo-premium"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }
    if (distributionScore > this._config.parameters.acceptableDistributionScore) {
      return {
        score: this._config.scores.bad,
        hasMarks: hasMarks,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$s and %2$s expand to links to Yoast.com articles,
        %3$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sKeyphrase distribution%3$s: Very uneven. Large parts of your text do not contain the keyphrase or its synonyms. %2$sDistribute them more evenly%3$s.", "wordpress-seo-premium"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }
    if (distributionScore > this._config.parameters.goodDistributionScore && distributionScore <= this._config.parameters.acceptableDistributionScore) {
      return {
        score: this._config.scores.okay,
        hasMarks: hasMarks,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$s and %2$s expand to links to Yoast.com articles,
        %3$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sKeyphrase distribution%3$s: Uneven. Some parts of your text do not contain the keyphrase or its synonyms. %2$sDistribute them more evenly%3$s.", "wordpress-seo-premium"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }
    return {
      score: this._config.scores.good,
      hasMarks: hasMarks,
      resultText: (0, _i18n.sprintf)(/* translators: %1$s expands to links to Yoast.com articles, %2$s expands to the anchor end tag */
      (0, _i18n.__)("%1$sKeyphrase distribution%2$s: Good job!", "wordpress-seo-premium"), this._config.urlTitle, "</a>")
    };
  }

  /**
   * Creates a marker for all content words in keyphrase and synonyms.
   *
   * @returns {Array} All markers for the current text.
   */
  getMarks() {
    return this._keyphraseDistribution.sentencesToHighlight;
  }

  /**
   * Checks whether the paper has a text with at least 15 sentences and a keyword,
   * and whether the researcher has keyphraseDistribution research.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   * @param {Researcher}  researcher  The researcher object.
   *
   * @returns {boolean}   Returns true when there is a keyword and a text with 15 sentences or more
   *                      and the researcher has keyphraseDistribution research.
   */
  isApplicable(paper, researcher) {
    const memoizedTokenizer = researcher.getHelper("memoizedTokenizer");
    let text = paper.getText();
    text = (0, _htmlParser.default)(text);
    text = (0, _helpers2.filterShortcodesFromHTML)(text, paper._attributes && paper._attributes.shortcodes);
    const sentences = (0, _getSentences.default)(text, memoizedTokenizer);
    return paper.hasText() && paper.hasKeyword() && sentences.length >= 15 && researcher.hasResearch("keyphraseDistribution");
  }
}
var _default = exports["default"] = KeyphraseDistributionAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseInImageTextAssessment.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseInImageTextAssessment.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _inRange = __webpack_require__(/*! ../../helpers/assessments/inRange.js */ "./node_modules/yoastseo/build/scoring/helpers/assessments/inRange.js");
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment that checks if there are keyphrase or synonyms in the alt attributes of images.
 */
class KeyphraseInImagesAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {object} config The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      parameters: {
        lowerBoundary: 0.3,
        upperBoundary: 0.75
      },
      scores: {
        withAltGoodNumberOfKeywordMatches: 9,
        withAltTooFewKeywordMatches: 6,
        withAltTooManyKeywordMatches: 6,
        withAltNonKeyword: 6,
        withAlt: 6,
        noAlt: 6
      },
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/4f7"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/4f6")
    };
    this.identifier = "imageKeyphrase";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Execute the Assessment and return a result.
   *
   * @param {Paper}       paper       The Paper object to assess.
   * @param {Researcher}  researcher  The Researcher object containing all available researches.
   *
   * @returns {AssessmentResult} The result of the assessment, containing both a score and a descriptive text.
   */
  getResult(paper, researcher) {
    this.imageCount = researcher.getResearch("imageCount");
    this.altProperties = researcher.getResearch("altTagCount");
    this._minNumberOfKeywordMatches = Math.ceil(this.imageCount * this._config.parameters.lowerBoundary);
    this._maxNumberOfKeywordMatches = Math.floor(this.imageCount * this._config.parameters.upperBoundary);
    const calculatedScore = this.calculateResult();
    const assessmentResult = new _AssessmentResult.default();
    assessmentResult.setScore(calculatedScore.score);
    assessmentResult.setText(calculatedScore.resultText);
    return assessmentResult;
  }

  /**
   * Checks whether the paper has text with at least 1 image.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   * @param {Researcher}  researcher  The Researcher object containing all available researches.
   *
   * @returns {boolean} True when there is text.
   */
  isApplicable(paper, researcher) {
    this.imageCount = researcher.getResearch("imageCount");
    return paper.hasText() && this.imageCount > 0;
  }

  /**
   * Checks whether there are too few alt tags with keywords. This check is applicable when there are
   * 5 or more images.
   *
   * @returns {boolean} Returns true if there are at least 5 images and the number of alt tags
   * with keywords is under the specified recommended minimum.
   */
  hasTooFewMatches() {
    return this.imageCount > 4 && this.altProperties.withAltKeyword > 0 && this.altProperties.withAltKeyword < this._minNumberOfKeywordMatches;
  }

  /**
   * Checks whether there is a sufficient number of alt tags with keywords. There are different recommended
   * ranges for less than 5 keywords, exactly 5 keywords, and more than 5 keywords.
   *
   * @returns {boolean} Returns true if the number of alt tags with keywords is within the recommended range.
   */
  hasGoodNumberOfMatches() {
    return this.imageCount < 5 && this.altProperties.withAltKeyword > 0 || this.imageCount === 5 && (0, _inRange.inRangeStartEndInclusive)(this.altProperties.withAltKeyword, 2, 4) || this.imageCount > 4 && (0, _inRange.inRangeStartEndInclusive)(this.altProperties.withAltKeyword, this._minNumberOfKeywordMatches, this._maxNumberOfKeywordMatches);
  }

  /**
   * Checks whether there is a sufficient number of alt tags with keywords. This check is applicable when there are
   * 5 or more images.
   *
   * @returns {boolean} Returns true if there are at least 5 images and the number of alt tags with keywords
   * is above the recommended range.
   */
  hasTooManyMatches() {
    return this.imageCount > 4 && this.altProperties.withAltKeyword > this._maxNumberOfKeywordMatches;
  }

  /**
   * Calculate the result based on the current image count and current image alt-tag count.
   *
   * @returns {Object} The calculated result.
   */
  calculateResult() {
    // Has alt-tags, but no keyword is set.
    if (this.altProperties.withAlt > 0) {
      return {
        score: this._config.scores.withAlt,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sImage Keyphrase%3$s: Images on this page have alt attributes, but you have not set your keyphrase. %2$sFix that%3$s!", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }

    // Has alt-tags, but no keywords while a keyword is set.
    if (this.altProperties.withAltNonKeyword > 0 && this.altProperties.withAltKeyword === 0) {
      return {
        score: this._config.scores.withAltNonKeyword,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sImage Keyphrase%3$s: Images on this page do not have alt attributes with at least half of the words from your keyphrase. %2$sFix that%3$s!", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }

    // Image count ≥5, has alt-tags with too few keywords.
    if (this.hasTooFewMatches()) {
      return {
        score: this._config.scores.withAltTooFewKeywordMatches,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$d expands to the number of images containing an alt attribute with the keyword,
         * %2$d expands to the total number of images, %3$s and %4$s expand to links on yoast.com,
         * %5$s expands to the anchor end tag. */
        (0, _i18n._n)("%3$sImage Keyphrase%5$s: Out of %2$d images on this page, only %1$d has an alt attribute that reflects the topic of your text. %4$sAdd your keyphrase or synonyms to the alt tags of more relevant images%5$s!", "%3$sImage Keyphrase%5$s: Out of %2$d images on this page, only %1$d have alt attributes that reflect the topic of your text. %4$sAdd your keyphrase or synonyms to the alt tags of more relevant images%5$s!", this.altProperties.withAltKeyword, "wordpress-seo"), this.altProperties.withAltKeyword, this.imageCount, this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }

    /*
     * The hasGoodNumberOfMatches check needs to be made before the check for too many matches because of the special rule for
     * exactly 5 matches.
     */
    if (this.hasGoodNumberOfMatches()) {
      return {
        score: this._config.scores.withAltGoodNumberOfKeywordMatches,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$s expands to a link on yoast.com,
         * %2$s expands to the anchor end tag. */
        (0, _i18n.__)("%1$sImage Keyphrase%2$s: Good job!", "wordpress-seo"), this._config.urlTitle, "</a>")
      };
    }
    if (this.hasTooManyMatches()) {
      return {
        score: this._config.scores.withAltTooManyKeywordMatches,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$d expands to the number of images containing an alt attribute with the keyword,
                        * %2$d expands to the total number of images, %3$s and %4$s expand to a link on yoast.com,
         * %5$s expands to the anchor end tag. */
        (0, _i18n.__)("%3$sImage Keyphrase%5$s: Out of %2$d images on this page, %1$d have alt attributes with words from your keyphrase or synonyms. That's a bit much. %4$sOnly include the keyphrase or its synonyms when it really fits the image%5$s.", "wordpress-seo"), this.altProperties.withAltKeyword, this.imageCount, this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }

    // Images, but no alt tags.
    return {
      score: this._config.scores.noAlt,
      resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
      (0, _i18n.__)("%1$sImage Keyphrase%3$s: Images on this page do not have alt attributes that reflect the topic of your text. %2$sAdd your keyphrase or synonyms to the alt tags of relevant images%3$s!", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
    };
  }
}
exports["default"] = KeyphraseInImagesAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseInSEOTitleAssessment.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseInSEOTitleAssessment.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _getLanguage = _interopRequireDefault(__webpack_require__(/*! ../../../languageProcessing/helpers/language/getLanguage */ "./node_modules/yoastseo/build/languageProcessing/helpers/language/getLanguage.js"));
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Assessment to check whether the keyphrase is included in (the beginning of) the SEO title.
 */
class KeyphraseInSEOTitleAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} [config] The configuration to use.
   * @param {number} [config.parameters.recommendedPosition] The recommended position of the keyphrase within the SEO title.
   * @param {number} [config.scores.good] The score to return if the keyphrase is found at the recommended position.
   * @param {number} [config.scores.okay] The score to return if the keyphrase is found, but not at the recommended position.
   * @param {number} [config.scores.bad] The score to return if there are fewer keyphrase occurrences than the recommended minimum.
   * @param {string} [config.url] The URL to the relevant article on Yoast.com.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      parameters: {
        recommendedPosition: 0
      },
      scores: {
        good: 9,
        okay: 6,
        bad: 2
      },
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/33g"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/33h"),
      feedbackStrings: {
        bad: (0, _i18n.__)("For the best SEO results write the exact match of your keyphrase in the SEO title, " + "and put the keyphrase at the beginning of the title", "wordpress-seo")
      }
    };
    this.identifier = "keyphraseInSEOTitle";

    /* translators: This is the name of the 'Keyphrase in SEO title' SEO assessment.
     It appears before the feedback in the analysis, for example in the feedback string:
     "Keyphrase in SEO title: The focus keyphrase appears at the beginning of the SEO title. Good job!" */
    this.name = (0, _i18n.__)("Keyphrase in SEO title", "wordpress-seo");
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Executes the SEO title keyphrase assessment and returns an assessment result.
   *
   * @param {Paper}       paper       The Paper object to assess.
   * @param {Researcher}  researcher  The Researcher object containing all available researches.
   *
   * @returns {AssessmentResult} The result of the assessment with text and score.
   */
  getResult(paper, researcher) {
    const language = (0, _getLanguage.default)(paper.getLocale());
    this._keyphraseMatches = researcher.getResearch("findKeyphraseInSEOTitle");
    this._keyphrase = (0, _lodash.escape)(paper.getKeyword());
    const assessmentResult = new _AssessmentResult.default();
    const calculatedResult = this.calculateResult(this._keyphrase, language);
    assessmentResult.setScore(calculatedResult.score);
    assessmentResult.setText(calculatedResult.resultText);
    if (assessmentResult.getScore() < 9) {
      assessmentResult.setHasJumps(true);
      assessmentResult.setEditFieldName((0, _i18n.__)("SEO title", "wordpress-seo"));
    }
    return assessmentResult;
  }

  /**
   * Checks whether the assessment is applicable to the paper
   *
   * @param {Paper} paper The Paper object to assess.
   *
   * @returns {boolean} Whether the paper has a keyphrase and an SEO title.
   */
  isApplicable(paper) {
    return paper.hasKeyword() && paper.hasTitle();
  }

  /**
   * Calculates the result based on whether and how the keyphrase was matched in the SEO title. Returns GOOD result if
   * an exact match of the keyphrase is found in the beginning of the SEO title. Returns OK results if all content words
   * from the keyphrase are in the SEO title (in any form). Returns BAD otherwise.
   *
   * @param {string}  keyphrase   The keyphrase of the paper (to be returned in the feedback strings).
   * @param {string}  language    The language to check.
   *
   * @returns {Object} Object with score and text.
   */
  calculateResult(keyphrase, language) {
    const feedbackStrings = this._config.feedbackStrings;
    if (language === "ja") {
      feedbackStrings.bad = (0, _i18n.__)("For the best SEO results include all words of your keyphrase in the SEO title, " + "and put the keyphrase at the beginning of the title", "wordpress-seo");
    }
    const exactMatchFound = this._keyphraseMatches.exactMatchFound;
    const position = this._keyphraseMatches.position;
    const allWordsFound = this._keyphraseMatches.allWordsFound;
    const exactMatchKeyphrase = this._keyphraseMatches.exactMatchKeyphrase;
    const assessmentLink = this._config.urlTitle + this.name + "</a>";
    if (exactMatchFound === true) {
      if (position === 0) {
        return {
          score: this._config.scores.good,
          resultText: (0, _i18n.sprintf)(
          /* translators: %1$s expands to the title of the "Keyphrase in SEO title" assessment (translated to the current language)
           and links to an article on yoast.com. */
          (0, _i18n.__)("%1$s: The exact match of the focus keyphrase appears at the beginning of the SEO title. Good job!", "wordpress-seo"), assessmentLink)
        };
      }
      return {
        score: this._config.scores.okay,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$s expands to the title of the "Keyphrase in SEO title" assessment (translated to the current language)
         and links to an article on yoast.com. %2$s expand to a link on yoast.com, %3$s expands to the anchor end tag. */
        (0, _i18n.__)("%1$s: The exact match of the focus keyphrase appears in the SEO title, but not at the beginning. %2$sMove it to the beginning for the best results%3$s.", "wordpress-seo"), assessmentLink, this._config.urlCallToAction, "</a>")
      };
    }
    if (allWordsFound) {
      if (language === "ja") {
        if (position === 0) {
          return {
            score: this._config.scores.good,
            resultText: (0, _i18n.sprintf)(
            /* translators: %1$s expands to the title of the "Keyphrase in SEO title" assessment (translated to the current language)
             and links to an article on yoast.com. */
            (0, _i18n.__)("%1$s: The focus keyphrase appears at the beginning of the SEO title. Good job!", "wordpress-seo"), assessmentLink, "</a>")
          };
        }
        return {
          score: this._config.scores.okay,
          resultText: (0, _i18n.sprintf)(
          /* translators: %1$s expands to the title of the "Keyphrase in SEO title" assessment (translated to the current language)
           and links to an article on yoast.com. %2$s expands to a link on yoast.com, %3$s expands to the anchor end tag. */
          (0, _i18n.__)("%1$s: Title does not begin with the focus keyphrase. %2$sMove your focus keyphrase to the beginning of the title%3$s.", "wordpress-seo"), assessmentLink, this._config.urlCallToAction, "</a>")
        };
      }
      return {
        score: this._config.scores.okay,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$s expands to the title of the "Keyphrase in SEO title" assessment (translated to the current language)
         and links to an article on yoast.com. %2$s expands to a link on yoast.com, %3$s expands to the anchor end tag. */
        (0, _i18n.__)("%1$s: Does not contain the exact match. %2$sTry to write the exact match of your keyphrase in the SEO title and put it at the beginning of the title%3$s.", "wordpress-seo"), assessmentLink, this._config.urlCallToAction, "</a>")
      };
    }
    if (exactMatchKeyphrase) {
      return {
        score: this._config.scores.bad,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$s expands to the title of the "Keyphrase in SEO title" assessment (translated to the current language)
         and links to an article on yoast.com. %2$s expands to a link on yoast.com, %3$s expands to the anchor end tag. */
        (0, _i18n.__)("%1$s: Does not contain the exact match. %2$sTry to write the exact match of your keyphrase in the SEO title and put it at the beginning of the title%3$s.", "wordpress-seo"), assessmentLink, this._config.urlCallToAction, "</a>", keyphrase)
      };
    }
    return {
      score: this._config.scores.bad,
      resultText: (0, _i18n.sprintf)(
      /* translators: %1$s expands to the title of the "Keyphrase in SEO title" assessment (translated to the current language)
       and links to an article on yoast.com. %2$s expands to a link on yoast.com, %3$s expands to the anchor end tag,
       %4$s expands to the keyphrase of the article, %5$s expands to the call to action text. */
      (0, _i18n.__)("%1$s: Not all the words from your keyphrase \"%4$s\" appear in the SEO title. %2$s%5$s%3$s.", "wordpress-seo"), assessmentLink, this._config.urlCallToAction, "</a>", keyphrase, feedbackStrings.bad)
    };
  }
}
var _default = exports["default"] = KeyphraseInSEOTitleAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseLengthAssessment.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseLengthAssessment.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _helpers = __webpack_require__(/*! ../../../helpers */ "./node_modules/yoastseo/build/helpers/index.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _inRange = __webpack_require__(/*! ../../helpers/assessments/inRange */ "./node_modules/yoastseo/build/scoring/helpers/assessments/inRange.js");
var _processExactMatchRequest = _interopRequireDefault(__webpack_require__(/*! ../../../languageProcessing/helpers/match/processExactMatchRequest */ "./node_modules/yoastseo/build/languageProcessing/helpers/match/processExactMatchRequest.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Assessment to check whether the keyphrase has a good length.
 */
class KeyphraseLengthAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} [config] The configuration to use.
   * @param {boolean} isProductPage Whether product page scoring is used or not.
   * @param {number} [config.parameters.recommendedMinimum] The recommended minimum length of the keyphrase (in words).
   * @param {number} [config.parameters.acceptableMaximum] The acceptable maximum length of the keyphrase (in words).
   * @param {number} [config.scores.veryBad] The score to return if the length of the keyphrase is below recommended minimum.
   * @param {number} [config.scores.consideration] The score to return if the length of the keyphrase is above acceptable maximum.
   *
   * @returns {void}
   */
  constructor(config, isProductPage = false) {
    super();
    this.defaultConfig = {
      parameters: {
        recommendedMinimum: 1,
        recommendedMaximum: 4,
        acceptableMaximum: 8
      },
      parametersNoFunctionWordSupport: {
        recommendedMaximum: 6,
        acceptableMaximum: 9
      },
      scores: {
        veryBad: -999,
        bad: 3,
        okay: 6,
        good: 9
      },
      countTextIn: {
        singular: (0, _i18n.__)("word", "wordpress-seo"),
        plural: (0, _i18n.__)("words", "wordpress-seo")
      },
      urlTitle: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/33i"),
      urlCallToAction: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/33j"),
      isRelatedKeyphrase: false
    };
    this.identifier = "keyphraseLength";
    this._config = (0, _lodash.merge)(this.defaultConfig, config);
    this._isProductPage = isProductPage;
  }

  /**
   * Assesses the keyphrase presence and length.
   *
   * @param {Paper} paper The paper to use for the assessment.
   * @param {Researcher} researcher The researcher used for calling research.
   *
   * @returns {AssessmentResult} The result of this assessment.
   */
  getResult(paper, researcher) {
    this._keyphraseLengthData = researcher.getResearch("keyphraseLength");
    const assessmentResult = new _AssessmentResult.default();
    const countTextInCharacters = researcher.getConfig("countCharacters");
    if (countTextInCharacters) {
      this._config.countTextIn.singular = (0, _i18n.__)("character", "wordpress-seo");
      this._config.countTextIn.plural = (0, _i18n.__)("characters", "wordpress-seo");
    }

    /*
     * Checks whether the keyphrase length is calculated with function words filtered out AND whether the keyphrase doesn't use double quotes.
     * If both conditions are true, then the feedback string should output 'content words' instead of only 'words'.
     * */
    const keyphrase = paper.getKeyword();
    if (this._keyphraseLengthData.functionWords.length > 0 && !(0, _processExactMatchRequest.default)(keyphrase).exactMatchRequested) {
      this._config.countTextIn.singular = (0, _i18n.__)("content word", "wordpress-seo");
      this._config.countTextIn.plural = (0, _i18n.__)("content words", "wordpress-seo");
    }

    /*
     * Checks whether the researcher has custom config for the scoring boundaries and overrides the current config with it.
     * If no custom config is found, makes boundaries less strict if the language doesn't have function word support.
     * */
    const customConfig = researcher.getConfig("keyphraseLength");
    if (customConfig) {
      this._config = this.getCustomConfig(researcher);
    } else if (this._keyphraseLengthData.functionWords.length === 0) {
      this._config.parameters = (0, _lodash.merge)({}, this._config.parameters, this._config.parametersNoFunctionWordSupport);
    }

    // Set a variable that contains the scoring boundaries.
    this._boundaries = this._config.parameters;
    const calculatedResult = this.calculateResult();
    assessmentResult.setScore(calculatedResult.score);
    assessmentResult.setText(calculatedResult.resultText);
    if (assessmentResult.getScore() < 9) {
      assessmentResult.setHasJumps(true);
      assessmentResult.setEditFieldName((0, _i18n.__)("keyphrase", "wordpress-seo"));
    }
    return assessmentResult;
  }
  /**
   * Merges language-specific configurations for product/regular pages.
   *
   * @param {Researcher} researcher The researcher used for calling research.
   *
   * @returns {Object} Configuration to use.
   */
  getCustomConfig(researcher) {
    const customKeyphraseLengthConfig = researcher.getConfig("keyphraseLength");
    if (this._isProductPage && customKeyphraseLengthConfig.hasOwnProperty("productPages")) {
      // If a language has specific configuration for keyphrase length in product pages, that configuration is used.
      return (0, _lodash.merge)(this._config, customKeyphraseLengthConfig.productPages);
    }

    // If a language has a configuration for keyphrase length for regular pages, that configuration is used.
    return (0, _lodash.merge)(this._config, customKeyphraseLengthConfig.defaultAnalysis);
  }

  /**
   * Calculates the result for product pages based on the keyphraseLength research.
   *
   * @returns {Object} Object with score and text.
   */
  calculateResultForProduct() {
    // Calculates very bad score for product pages.
    if (this._keyphraseLengthData.keyphraseLength === 0) {
      if (this._config.isRelatedKeyphrase) {
        return {
          score: this._config.scores.veryBad,
          resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
          (0, _i18n.__)("%1$sKeyphrase length%3$s: %2$sSet a keyphrase in order to calculate your SEO score%3$s.", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
        };
      }
      return {
        score: this._config.scores.veryBad,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sKeyphrase length%3$s: No focus keyphrase was set for this page. %2$sSet a keyphrase in order to calculate your SEO score%3$s.", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }
    // Calculates bad score for product pages.
    if (this._keyphraseLengthData.keyphraseLength <= this._boundaries.acceptableMinimum) {
      return {
        score: this._config.scores.bad,
        resultText: (0, _i18n.sprintf)(
        /* translators:
        %1$d expands to the number of words / characters in the keyphrase,
        %2$d expands to the recommended maximum of words / characters in the keyphrase,
        %3$s and %4$s expand to links on yoast.com, %5$s expands to the anchor end tag,
        %6$s expands to the word 'word' or 'character' or 'content word',
        %7$s expands to the word 'words' or 'characters' or 'content words'. */
        (0, _i18n._n)("%3$sKeyphrase length%5$s: The keyphrase contains %1$d %6$s. That's way less than the recommended minimum of %2$d %7$s. %4$sMake it longer%5$s!", "%3$sKeyphrase length%5$s: The keyphrase contains %1$d %7$s. That's way less than the recommended minimum of %2$d %7$s. %4$sMake it longer%5$s!", this._keyphraseLengthData.keyphraseLength, "wordpress-seo"), this._keyphraseLengthData.keyphraseLength, this._boundaries.recommendedMinimum, this._config.urlTitle, this._config.urlCallToAction, "</a>", this._config.countTextIn.singular, this._config.countTextIn.plural)
      };
    }
    if (this._keyphraseLengthData.keyphraseLength > this._boundaries.acceptableMaximum) {
      return {
        score: this._config.scores.bad,
        resultText: (0, _i18n.sprintf)(
        /* translators:
        %1$d expands to the number of words / characters in the keyphrase,
        %2$d expands to the recommended maximum of words / characters in the keyphrase,
        %3$s and %4$s expand to links on yoast.com,
        %5$s expands to the anchor end tag,
        %6$s expands to the word 'words' or 'characters' or 'content words'. */
        (0, _i18n.__)("%3$sKeyphrase length%5$s: The keyphrase contains %1$d %6$s. That's way more than the recommended maximum of %2$d %6$s. %4$sMake it shorter%5$s!", "wordpress-seo"), this._keyphraseLengthData.keyphraseLength, this._boundaries.recommendedMaximum, this._config.urlTitle, this._config.urlCallToAction, "</a>", this._config.countTextIn.plural)
      };
    }
    // Calculates okay score for product pages.
    if ((0, _lodash.inRange)(this._keyphraseLengthData.keyphraseLength, this._boundaries.acceptableMinimum, this._boundaries.recommendedMinimum)) {
      return {
        score: this._config.scores.okay,
        resultText: (0, _i18n.sprintf)(
        /* translators:
        %1$d expands to the number of words / characters in the keyphrase,
        %2$d expands to the recommended maximum of words / characters in the keyphrase,
        %3$s and %4$s expand to links on yoast.com,
        %5$s expands to the anchor end tag,
        %6$s expands to the word 'words' or 'characters' or 'content words'. */
        (0, _i18n.__)("%3$sKeyphrase length%5$s: The keyphrase contains %1$d %6$s. That's less than the recommended minimum of %2$d %6$s. %4$sMake it longer%5$s!", "wordpress-seo"), this._keyphraseLengthData.keyphraseLength, this._boundaries.recommendedMinimum, this._config.urlTitle, this._config.urlCallToAction, "</a>", this._config.countTextIn.plural)
      };
    }
    if ((0, _inRange.inRangeEndInclusive)(this._keyphraseLengthData.keyphraseLength, this._boundaries.recommendedMaximum, this._boundaries.acceptableMaximum)) {
      return {
        score: this._config.scores.okay,
        resultText: (0, _i18n.sprintf)(
        /* translators:
        %1$d expands to the number of words / characters in the keyphrase,
        %2$d expands to the recommended maximum of words / characters in the keyphrase,
        %3$s and %4$s expand to links on yoast.com,
        %5$s expands to the anchor end tag,
        %6$s expands to the word 'words' or 'characters' or 'content words'. */
        (0, _i18n.__)("%3$sKeyphrase length%5$s: The keyphrase contains %1$d %6$s. That's more than the recommended maximum of %2$d %6$s. %4$sMake it shorter%5$s!", "wordpress-seo"), this._keyphraseLengthData.keyphraseLength, this._boundaries.recommendedMaximum, this._config.urlTitle, this._config.urlCallToAction, "</a>", this._config.countTextIn.plural)
      };
    }
    // Calculates good score for product pages.
    if ((0, _inRange.inRangeStartEndInclusive)(this._keyphraseLengthData.keyphraseLength, this._boundaries.recommendedMinimum, this._boundaries.recommendedMaximum)) {
      return {
        score: this._config.scores.good,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag. */
        (0, _i18n.__)("%1$sKeyphrase length%2$s: Good job!", "wordpress-seo"), this._config.urlTitle, "</a>")
      };
    }
  }

  /**
   * Calculates the result based on the keyphraseLength research.
   *
   * @returns {Object} Object with score and text.
   */
  calculateResult() {
    if (this._isProductPage) {
      return this.calculateResultForProduct();
    }

    // Calculates scores for regular pages
    if (this._keyphraseLengthData.keyphraseLength < this._boundaries.recommendedMinimum) {
      if (this._config.isRelatedKeyphrase) {
        return {
          score: this._config.scores.veryBad,
          resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
          (0, _i18n.__)("%1$sKeyphrase length%3$s: %2$sSet a keyphrase in order to calculate your SEO score%3$s.", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
        };
      }
      return {
        score: this._config.scores.veryBad,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sKeyphrase length%3$s: No focus keyphrase was set for this page. %2$sSet a keyphrase in order to calculate your SEO score%3$s.", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }
    if ((0, _lodash.inRange)(this._keyphraseLengthData.keyphraseLength, this._boundaries.recommendedMinimum, this._boundaries.recommendedMaximum + 1)) {
      return {
        score: this._config.scores.good,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag. */
        (0, _i18n.__)("%1$sKeyphrase length%2$s: Good job!", "wordpress-seo"), this._config.urlTitle, "</a>")
      };
    }
    if ((0, _lodash.inRange)(this._keyphraseLengthData.keyphraseLength, this._boundaries.recommendedMaximum + 1, this._boundaries.acceptableMaximum + 1)) {
      return {
        score: this._config.scores.okay,
        resultText: (0, _i18n.sprintf)(
        /* translators:
        %1$d expands to the number of words / characters in the keyphrase,
        %2$d expands to the recommended maximum of words / characters in the keyphrase,
        %3$s and %4$s expand to links on yoast.com,
        %5$s expands to the anchor end tag,
        %6$s expands to the word 'words' or 'characters' or 'content words'. */
        (0, _i18n.__)("%3$sKeyphrase length%5$s: The keyphrase contains %1$d %6$s. That's more than the recommended maximum of %2$d %6$s. %4$sMake it shorter%5$s!", "wordpress-seo"), this._keyphraseLengthData.keyphraseLength, this._boundaries.recommendedMaximum, this._config.urlTitle, this._config.urlCallToAction, "</a>", this._config.countTextIn.plural)
      };
    }
    return {
      score: this._config.scores.bad,
      resultText: (0, _i18n.sprintf)(
      /* translators:
      %1$d expands to the number of words / characters in the keyphrase,
      %2$d expands to the recommended maximum of words / characters in the keyphrase,
      %3$s and %4$s expand to links on yoast.com,
      %5$s expands to the anchor end tag,
      %6$s expands to the word 'words' or 'characters' or 'content words'. */
      (0, _i18n.__)("%3$sKeyphrase length%5$s: The keyphrase contains %1$d %6$s. That's way more than the recommended maximum of %2$d %6$s. %4$sMake it shorter%5$s!", "wordpress-seo"), this._keyphraseLengthData.keyphraseLength, this._boundaries.recommendedMaximum, this._config.urlTitle, this._config.urlCallToAction, "</a>", this._config.countTextIn.plural)
    };
  }
}
var _default = exports["default"] = KeyphraseLengthAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/KeywordDensityAssessment.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/KeywordDensityAssessment.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.KeywordDensityAssessment = exports.KeyphraseDensityAssessment = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _recommendedKeywordCount = _interopRequireDefault(__webpack_require__(/*! ../../helpers/assessments/recommendedKeywordCount.js */ "./node_modules/yoastseo/build/scoring/helpers/assessments/recommendedKeywordCount.js"));
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _inRange = __webpack_require__(/*! ../../helpers/assessments/inRange */ "./node_modules/yoastseo/build/scoring/helpers/assessments/inRange.js");
var _helpers = __webpack_require__(/*! ../../../helpers */ "./node_modules/yoastseo/build/helpers/index.js");
var _keyphraseLengthFactor = _interopRequireDefault(__webpack_require__(/*! ../../helpers/assessments/keyphraseLengthFactor.js */ "./node_modules/yoastseo/build/scoring/helpers/assessments/keyphraseLengthFactor.js"));
var _getAllWordsFromTree = _interopRequireDefault(__webpack_require__(/*! ../../../languageProcessing/helpers/word/getAllWordsFromTree */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getAllWordsFromTree.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment that will look if the keyphrase density is within the recommended range.
 */
class KeyphraseDensityAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} [config] The configuration to use.
   *
   * If word forms are not available:
   * @param {number} [config.parameters.noWordForms.overMaximum] The percentage of keyphrase instances in the text that
   * is way over the maximum.
   * @param {number} [config.parameters.noWordForms.maximum] The maximum percentage of keyphrase instances in the text.
   * @param {number} [config.parameters.noWordForms.minimum] The minimum percentage of keyphrase instances in the text.
   *
   * If word forms are available:
   * @param {number} [config.parameters.multipleWordForms.overMaximum] The percentage of keyphrase instances in the text that
   * is way over the maximum.
   * @param {number} [config.parameters.multipleWordForms.maximum] The maximum percentage of keyphrase instances in the text.
   * @param {number} [config.parameters.multipleWordForms.minimum] The minimum percentage of keyphrase instances in the text.
   *
   * @param {number} [config.scores.wayOverMaximum] The score to return if there are way too many instances of keyphrase in the text.
   * @param {number} [config.scores.overMaximum] The score to return if there are too many instances of keyphrase in the text.
   * @param {number} [config.scores.correctDensity] The score to return if there is a good number of keyphrase instances in the text.
   * @param {number} [config.scores.underMinimum] The score to return if there is not enough keyphrase instances in the text.
   *
   * @param {string} [config.url] The URL to the relevant KB article.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      parameters: {
        noWordForms: {
          overMaximum: 4,
          maximum: 3,
          minimum: 0.5
        },
        multipleWordForms: {
          overMaximum: 4,
          maximum: 3.5,
          minimum: 0.5
        }
      },
      scores: {
        wayOverMaximum: -50,
        overMaximum: -10,
        correctDensity: 9,
        underMinimum: 4
      },
      urlTitle: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/33v"),
      urlCallToAction: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/33w"),
      applicableIfTextLongerThan: 100
    };
    this.identifier = "keyphraseDensity";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Determines correct boundaries depending on the availability of morphological forms.
   *
   * @param {Paper} paper The paper to analyze.
   * @param {number} keyphraseLength The length of the keyphrase in words.
   * @param {function} customGetWords A helper to get words from the text for languages that don't use the default approach.
   *
   * @returns {void}
   */
  setBoundaries(paper, keyphraseLength, customGetWords) {
    if (this._hasMorphologicalForms) {
      this._boundaries = this._config.parameters.multipleWordForms;
    } else {
      this._boundaries = this._config.parameters.noWordForms;
    }
    this._minRecommendedKeyphraseCount = (0, _recommendedKeywordCount.default)(paper, keyphraseLength, this._boundaries.minimum, "min", customGetWords);
    this._maxRecommendedKeyphraseCount = (0, _recommendedKeywordCount.default)(paper, keyphraseLength, this._boundaries.maximum, "max", customGetWords);
  }

  /**
   * Runs the keyphrase density module, based on this returns an assessment
   * result with score.
   *
   * @param {Paper} paper The paper to use for the assessment.
   * @param {Researcher} researcher The researcher used for calling the research.
   *
   * @returns {AssessmentResult} The result of the assessment.
   */
  getResult(paper, researcher) {
    const customGetWords = researcher.getHelper("getWordsCustomHelper");
    this._keyphraseCount = researcher.getResearch("getKeyphraseCount");
    const keyphraseLength = this._keyphraseCount.keyphraseLength;
    const assessmentResult = new _AssessmentResult.default();
    this._keyphraseDensity = researcher.getResearch("getKeyphraseDensity");
    this._hasMorphologicalForms = researcher.getData("morphology") !== false;
    this.setBoundaries(paper, keyphraseLength, customGetWords);
    this._keyphraseDensity = this._keyphraseDensity * (0, _keyphraseLengthFactor.default)(keyphraseLength);
    const calculatedScore = this.calculateResult();
    assessmentResult.setScore(calculatedScore.score);
    assessmentResult.setText(calculatedScore.resultText);
    assessmentResult.setHasMarks(this._keyphraseCount.count > 0);
    return assessmentResult;
  }

  /**
   * Checks whether there are no keyphrase matches in the text.
   *
   * @returns {boolean} Returns true if the keyphrase count is 0.
   */
  hasNoMatches() {
    return this._keyphraseCount.count === 0;
  }

  /**
   * Checks whether there are too few keyphrase matches in the text.
   *
   * @returns {boolean} Returns true if the rounded keyphrase density is between 0 and the recommended minimum
   * or if there is only 1 keyphrase match (regardless of the density).
   */
  hasTooFewMatches() {
    return (0, _inRange.inRangeStartInclusive)(this._keyphraseDensity, 0, this._boundaries.minimum) || this._keyphraseCount.count === 1;
  }

  /**
   * Checks whether there is a good number of keyphrase matches in the text.
   *
   * @returns {boolean} Returns true if the rounded keyphrase density is between the recommended minimum
   * and the recommended maximum or if the keyphrase count is 2 and the recommended minimum is lower than 2.
   */
  hasGoodNumberOfMatches() {
    return (0, _inRange.inRangeStartEndInclusive)(this._keyphraseDensity, this._boundaries.minimum, this._boundaries.maximum) || this._keyphraseCount.count === 2 && this._minRecommendedKeyphraseCount <= 2;
  }

  /**
   * Checks whether the number of keyphrase matches in the text is between the
   * recommended maximum and the specified overMaximum value.
   *
   * @returns {boolean} Returns true if the rounded keyphrase density is between
   *                    the recommended maximum and the specified overMaximum
   *                    value.
   */
  hasTooManyMatches() {
    return (0, _inRange.inRangeEndInclusive)(this._keyphraseDensity, this._boundaries.maximum, this._boundaries.overMaximum);
  }

  /**
   * Returns the score for the keyphrase density.
   *
   * @returns {Object} The object with calculated score and resultText.
   */
  calculateResult() {
    if (this.hasNoMatches()) {
      return {
        score: this._config.scores.underMinimum,
        resultText: (0, _i18n.sprintf)(
        /* translators:
        %1$s and %4$s expand to links to Yoast.com,
        %2$s expands to the anchor end tag,
        %3$d expands to the recommended minimal number of times the keyphrase should occur in the text. */
        (0, _i18n.__)("%1$sKeyphrase density%2$s: The keyphrase was found 0 times. That's less than the recommended minimum of %3$d times for a text of this length. %4$sFocus on your keyphrase%2$s!", "wordpress-seo"), this._config.urlTitle, "</a>", this._minRecommendedKeyphraseCount, this._config.urlCallToAction)
      };
    }
    if (this.hasTooFewMatches()) {
      return {
        score: this._config.scores.underMinimum,
        resultText: (0, _i18n.sprintf)(
        /* translators:
        %1$s and %4$s expand to links to Yoast.com,
        %2$s expands to the anchor end tag,
        %3$d expands to the recommended minimal number of times the keyphrase should occur in the text,
        %5$d expands to the number of times the keyphrase occurred in the text. */
        (0, _i18n._n)("%1$sKeyphrase density%2$s: The keyphrase was found %5$d time. That's less than the recommended minimum of %3$d times for a text of this length. %4$sFocus on your keyphrase%2$s!", "%1$sKeyphrase density%2$s: The keyphrase was found %5$d times. That's less than the recommended minimum of %3$d times for a text of this length. %4$sFocus on your keyphrase%2$s!", this._keyphraseCount.count, "wordpress-seo"), this._config.urlTitle, "</a>", this._minRecommendedKeyphraseCount, this._config.urlCallToAction, this._keyphraseCount.count)
      };
    }
    if (this.hasGoodNumberOfMatches()) {
      return {
        score: this._config.scores.correctDensity,
        resultText: (0, _i18n.sprintf)(
        /* translators:
        %1$s expands to a link to Yoast.com,
        %2$s expands to the anchor end tag,
        %3$d expands to the number of times the keyphrase occurred in the text. */
        (0, _i18n._n)("%1$sKeyphrase density%2$s: The keyphrase was found %3$d time. This is great!", "%1$sKeyphrase density%2$s: The keyphrase was found %3$d times. This is great!", this._keyphraseCount.count, "wordpress-seo"), this._config.urlTitle, "</a>", this._keyphraseCount.count)
      };
    }
    if (this.hasTooManyMatches()) {
      return {
        score: this._config.scores.overMaximum,
        resultText: (0, _i18n.sprintf)(
        /* translators:
        %1$s and %4$s expand to links to Yoast.com,
        %2$s expands to the anchor end tag,
        %3$d expands to the recommended maximal number of times the keyphrase should occur in the text,
        %5$d expands to the number of times the keyphrase occurred in the text. */
        (0, _i18n._n)("%1$sKeyphrase density%2$s: The keyphrase was found %5$d time. That's more than the recommended maximum of %3$d times for a text of this length. %4$sDon't overoptimize%2$s!", "%1$sKeyphrase density%2$s: The keyphrase was found %5$d times. That's more than the recommended maximum of %3$d times for a text of this length. %4$sDon't overoptimize%2$s!", this._keyphraseCount.count, "wordpress-seo"), this._config.urlTitle, "</a>", this._maxRecommendedKeyphraseCount, this._config.urlCallToAction, this._keyphraseCount.count)
      };
    }

    // Implicitly returns this if the rounded keyphrase density is higher than overMaximum.
    return {
      score: this._config.scores.wayOverMaximum,
      resultText: (0, _i18n.sprintf)(
      /* translators:
      %1$s and %4$s expand to links to Yoast.com,
      %2$s expands to the anchor end tag,
      %3$d expands to the recommended maximal number of times the keyphrase should occur in the text,
      %5$d expands to the number of times the keyphrase occurred in the text. */
      (0, _i18n._n)("%1$sKeyphrase density%2$s: The keyphrase was found %5$d time. That's way more than the recommended maximum of %3$d times for a text of this length. %4$sDon't overoptimize%2$s!", "%1$sKeyphrase density%2$s: The keyphrase was found %5$d times. That's way more than the recommended maximum of %3$d times for a text of this length. %4$sDon't overoptimize%2$s!", this._keyphraseCount.count, "wordpress-seo"), this._config.urlTitle, "</a>", this._maxRecommendedKeyphraseCount, this._config.urlCallToAction, this._keyphraseCount.count)
    };
  }

  /**
   * Marks the occurrences of keyphrase in the text for the keyphrase density assessment.
   *
   * @returns {Array<Mark>} Marks that should be applied.
   */
  getMarks() {
    return this._keyphraseCount.markings;
  }

  /**
   * Checks whether the paper has a text of the minimum required length and a keyphrase is set. Language-specific length requirements and methods
   * of counting text length may apply (e.g. for Japanese, the text should be counted in characters instead of words, which also makes the minimum
   * required length higher).
   *
   * @param {Paper} 		paper 		The paper to use for the assessment.
   * @param {Researcher}  researcher  The paper to use for the assessment.
   *
   * @returns {boolean} True if applicable.
   */
  isApplicable(paper, researcher) {
    const customCountLength = researcher.getHelper("customCountLength");
    const customApplicabilityConfig = researcher.getConfig("assessmentApplicability").keyphraseDensity;
    if (customApplicabilityConfig) {
      this._config.applicableIfTextLongerThan = customApplicabilityConfig;
    }
    const textLength = customCountLength ? customCountLength(paper.getText()) : (0, _getAllWordsFromTree.default)(paper).length;
    return paper.hasText() && paper.hasKeyword() && textLength >= this._config.applicableIfTextLongerThan;
  }
}

/**
 * This assessment checks if the keyphrase density is within the recommended range.
 * KeywordDensityAssessment was the previous name for KeyphraseDensityAssessment (hence the name of this file).
 * We keep (and expose) this assessment for backwards compatibility.
 *
 * @deprecated Use KeyphraseDensityAssessment instead.
 */
exports.KeyphraseDensityAssessment = KeyphraseDensityAssessment;
class KeywordDensityAssessment extends KeyphraseDensityAssessment {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} config   The configuration to use.
   * @returns {void}
   */
  constructor(config = {}) {
    super(config);
    this.identifier = "keywordDensity";
    console.warn("This object is deprecated, use KeyphraseDensityAssessment instead.");
  }
}
exports.KeywordDensityAssessment = KeywordDensityAssessment;
var _default = exports["default"] = KeyphraseDensityAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/MetaDescriptionKeywordAssessment.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/MetaDescriptionKeywordAssessment.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Assessment for checking the keyword matches in the meta description.
 */
class MetaDescriptionKeywordAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} [config] The configuration to use.
   * @param {number} [config.parameters.recommendedMinimum] The recommended minimum of keyword occurrences in the meta description.
   * @param {number} [config.scores.good] The score to return if there are enough keyword occurrences in the meta description.
   * @param {number} [config.scores.bad] The score to return if there aren't enough keyword occurrences in the meta description.
   * @param {string} [config.url] The URL to the relevant article on Yoast.com.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      parameters: {
        recommendedMinimum: 1
      },
      scores: {
        good: 9,
        ok: 6,
        bad: 3
      },
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/33k"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/33l")
    };
    this.identifier = "metaDescriptionKeyword";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Runs the metaDescriptionKeyword researcher and based on this, returns an assessment result with score.
   *
   * @param {Paper}      paper      The paper to use for the assessment.
   * @param {Researcher} researcher The researcher used for calling research.
   *
   * @returns {AssessmentResult} The assessment result.
   */
  getResult(paper, researcher) {
    this._keyphraseCounts = researcher.getResearch("metaDescriptionKeyword");
    const assessmentResult = new _AssessmentResult.default();
    const calculatedResult = this.calculateResult();
    assessmentResult.setScore(calculatedResult.score);
    assessmentResult.setText(calculatedResult.resultText);
    if (assessmentResult.getScore() < 9) {
      assessmentResult.setHasJumps(true);
      assessmentResult.setEditFieldName((0, _i18n.__)("meta description", "wordpress-seo"));
    }
    return assessmentResult;
  }

  /**
   * Returns the result object based on the number of keyword matches in the meta description.
   *
   * @returns {Object} Result object with score and text.
   */
  calculateResult() {
    // GOOD result when the meta description contains a keyphrase or synonym 1 or 2 times.
    if (this._keyphraseCounts === 1 || this._keyphraseCounts === 2) {
      return {
        score: this._config.scores.good,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag. */
        (0, _i18n.__)("%1$sKeyphrase in meta description%2$s: Keyphrase or synonym appear in the meta description. Well done!", "wordpress-seo"), this._config.urlTitle, "</a>")
      };
    }

    // BAD if the description contains every keyword term more than twice.
    if (this._keyphraseCounts >= 3) {
      return {
        score: this._config.scores.bad,
        resultText: (0, _i18n.sprintf)(
        /**
         * translators:
         * %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag,
         * %3$s expands to the number of sentences containing the keyphrase,
         * %4$s expands to a link on yoast.com, %5$s expands to the anchor end tag.
         */
        (0, _i18n.__)("%1$sKeyphrase in meta description%2$s: The meta description contains the keyphrase %3$s times, which is over the advised maximum of 2 times. %4$sLimit that%5$s!", "wordpress-seo"), this._config.urlTitle, "</a>", this._keyphraseCounts, this._config.urlCallToAction, "</a>")
      };
    }

    // BAD if the keyphrases is not contained in the meta description.
    return {
      score: this._config.scores.bad,
      resultText: (0, _i18n.sprintf)(
      /**
       * translators:
       * %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag.
       * %3$s expands to a link on yoast.com, %4$s expands to the anchor end tag.
       */
      (0, _i18n.__)("%1$sKeyphrase in meta description%2$s: The meta description has been specified, but it does not contain the keyphrase. %3$sFix that%4$s!", "wordpress-seo"), this._config.urlTitle, "</a>", this._config.urlCallToAction, "</a>")
    };
  }

  /**
   * Checks whether the paper has a keyword and a meta description.
   *
   * @param {Paper} paper The paper to use for the assessment.
   *
   * @returns {boolean} True if the paper has a keyword and a meta description.
   */
  isApplicable(paper) {
    return paper.hasKeyword() && paper.hasDescription();
  }
}
var _default = exports["default"] = MetaDescriptionKeywordAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/MetaDescriptionLengthAssessment.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/MetaDescriptionLengthAssessment.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _metaDescriptionLength = _interopRequireDefault(__webpack_require__(/*! ../../../languageProcessing/languages/ja/config/metaDescriptionLength */ "./node_modules/yoastseo/build/languageProcessing/languages/ja/config/metaDescriptionLength.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Assessment for calculating the length of the meta description.
 */
class MetaDescriptionLengthAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} [config] The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      recommendedMaximumLength: 120,
      maximumLength: 156,
      scores: {
        noMetaDescription: 1,
        tooLong: 6,
        tooShort: 6,
        correctLength: 9
      },
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34d"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34e")
    };
    this.identifier = "metaDescriptionLength";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Returns the maximum length.
   *
   * @param {string}  locale  The locale.
   *
   * @returns {number} The maximum length.
   */
  getMaximumLength(locale) {
    return this.getConfig(locale).maximumLength;
  }

  /**
   * Checks if language specific config is available, and overwrite the default config if it is.
   *
   * This method of returning the configuration by checking the locale is necessary since this assessment is also
   * initialized for calculations outside content analysis where we don't have access to the Researcher.
   *
   * @param {string}  locale  The locale.
   *
   * @returns {object}    The configuration to use.
   */
  getConfig(locale) {
    let config = this._config;
    if (locale === "ja") {
      config = (0, _lodash.merge)(config, _metaDescriptionLength.default);
    }
    return config;
  }

  /**
   * Runs the metaDescriptionLength module, based on this returns an assessment result with score.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   * @param {Researcher}  researcher  The researcher used for calling research.
   *
   * @returns {AssessmentResult} The assessment result.
   */
  getResult(paper, researcher) {
    const descriptionLength = researcher.getResearch("metaDescriptionLength");
    const assessmentResult = new _AssessmentResult.default();
    const locale = researcher.getConfig("language");
    const config = this.getConfig(locale);
    assessmentResult.setScore(this.calculateScore(descriptionLength, locale));
    assessmentResult.setText(this.translateScore(descriptionLength, config));
    if (assessmentResult.getScore() < 9) {
      assessmentResult.setHasJumps(true);
      assessmentResult.setEditFieldName((0, _i18n.__)("meta description", "wordpress-seo"));
    }

    // Max and actual are used in the snippet editor progress bar.
    assessmentResult.max = config.maximumLength;
    assessmentResult.actual = descriptionLength;
    return assessmentResult;
  }

  /**
   * Returns the score for the descriptionLength.
   *
   * @param {number}  descriptionLength The length of the meta description.
   * @param {string}  locale            The locale.
   *
   * @returns {number} The calculated score.
   */
  calculateScore(descriptionLength, locale) {
    const config = this.getConfig(locale);
    if (descriptionLength === 0) {
      return config.scores.noMetaDescription;
    }
    if (descriptionLength <= this._config.recommendedMaximumLength) {
      return config.scores.tooShort;
    }
    if (descriptionLength > this._config.maximumLength) {
      return config.scores.tooLong;
    }
    return config.scores.correctLength;
  }

  /**
   * Translates the descriptionLength to a message the user can understand.
   *
   * @param {number}  descriptionLength   The length of the meta description.
   * @param {object}  config              The configuration to use.
   *
   * @returns {string} The translated string.
   */
  translateScore(descriptionLength, config) {
    if (descriptionLength === 0) {
      return (0, _i18n.sprintf)(/* translators:  %1$s and %2$s expand to a links on yoast.com, %3$s expands to the anchor end tag */
      (0, _i18n.__)("%1$sMeta description length%3$s:  No meta description has been specified. Search engines will display copy from the page instead. %2$sMake sure to write one%3$s!", "wordpress-seo"), config.urlTitle, config.urlCallToAction, "</a>");
    }
    if (descriptionLength <= config.recommendedMaximumLength) {
      return (0, _i18n.sprintf)(
      /* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag,
      %4$d expands to the number of characters in the meta description, %5$d expands to
      the total available number of characters in the meta description */
      (0, _i18n.__)("%1$sMeta description length%3$s: The meta description is too short (under %4$d characters). Up to %5$d characters are available. %2$sUse the space%3$s!", "wordpress-seo"), config.urlTitle, config.urlCallToAction, "</a>", config.recommendedMaximumLength, config.maximumLength);
    }
    if (descriptionLength > config.maximumLength) {
      return (0, _i18n.sprintf)(
      /* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag,
      %4$d expands to	the total available number of characters in the meta description */
      (0, _i18n.__)("%1$sMeta description length%3$s: The meta description is over %4$d characters. To ensure the entire description will be visible, %2$syou should reduce the length%3$s!", "wordpress-seo"), config.urlTitle, config.urlCallToAction, "</a>", config.maximumLength);
    }
    return (0, _i18n.sprintf)(/* translators:  %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag */
    (0, _i18n.__)("%1$sMeta description length%2$s: Well done!", "wordpress-seo"), config.urlTitle, "</a>");
  }
}
exports["default"] = MetaDescriptionLengthAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/OutboundLinksAssessment.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/OutboundLinksAssessment.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Assessment for calculating the outbound links in the text.
 */
class OutboundLinksAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} [config] The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      scores: {
        noLinks: 3,
        allNofollowed: 7,
        someNoFollowed: 8,
        allFollowed: 9
      },
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34f"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34g")
    };
    this.identifier = "externalLinks";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Runs the getLinkStatistics module, based on this returns an assessment result with score.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   * @param {Researcher}  researcher  The researcher used for calling research.
   *
   * @returns {AssessmentResult} The assessment result.
   */
  getResult(paper, researcher) {
    const linkStatistics = researcher.getResearch("getLinkStatistics");
    const assessmentResult = new _AssessmentResult.default();
    if (!(0, _lodash.isEmpty)(linkStatistics)) {
      assessmentResult.setScore(this.calculateScore(linkStatistics));
      assessmentResult.setText(this.translateScore(linkStatistics));
    }
    return assessmentResult;
  }

  /**
   * Checks whether paper has text.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   *
   * @returns {boolean} True when there is text.
   */
  isApplicable(paper) {
    return paper.hasText();
  }

  /**
   * Returns a score based on the linkStatistics object.
   *
   * @param {object} linkStatistics The object with all link statistics.
   *
   * @returns {number|null} The calculated score.
   */
  calculateScore(linkStatistics) {
    if (linkStatistics.externalTotal === 0) {
      return this._config.scores.noLinks;
    }
    if (linkStatistics.externalNofollow === linkStatistics.externalTotal) {
      return this._config.scores.allNofollowed;
    }
    if (linkStatistics.externalDofollow < linkStatistics.externalTotal) {
      return this._config.scores.someNoFollowed;
    }
    if (linkStatistics.externalDofollow === linkStatistics.externalTotal) {
      return this._config.scores.allFollowed;
    }
    return null;
  }

  /**
   * Translates the score to a message the user can understand.
   *
   * @param {Object}  linkStatistics  The object with all link statistics.
   *
   * @returns {string} The translated string.
   */
  translateScore(linkStatistics) {
    if (linkStatistics.externalTotal === 0) {
      return (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
      (0, _i18n.__)("%1$sOutbound links%3$s: No outbound links appear in this page. %2$sAdd some%3$s!", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>");
    }
    if (linkStatistics.externalNofollow === linkStatistics.externalTotal) {
      return (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
      (0, _i18n.__)("%1$sOutbound links%3$s: All outbound links on this page are nofollowed. %2$sAdd some normal links%3$s.", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>");
    }
    if (linkStatistics.externalDofollow === linkStatistics.externalTotal) {
      return (0, _i18n.sprintf)(/* translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag */
      (0, _i18n.__)("%1$sOutbound links%2$s: Good job!", "wordpress-seo"), this._config.urlTitle, "</a>");
    }
    if (linkStatistics.externalDofollow < linkStatistics.externalTotal) {
      return (0, _i18n.sprintf)(/* translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag */
      (0, _i18n.__)("%1$sOutbound links%2$s: There are both nofollowed and normal outbound links on this page. Good job!", "wordpress-seo"), this._config.urlTitle, "</a>");
    }
    return "";
  }
}
exports["default"] = OutboundLinksAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/PageTitleWidthAssessment.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/PageTitleWidthAssessment.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _inRange = __webpack_require__(/*! ../../helpers/assessments/inRange */ "./node_modules/yoastseo/build/scoring/helpers/assessments/inRange.js");
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const maximumLength = 600;

/**
 * Represents the assessment that assesses the SEO title width and gives the feedback accordingly.
 */
class PageTitleWidthAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object}  [config]        The configuration to use.
   * @param {boolean} allowShortTitle Whether the short title width is penalized with a bad score or not.
   *
   * @returns {void}
   */
  constructor(config = {}, allowShortTitle = false) {
    super();
    const defaultConfig = {
      minLength: 400,
      maxLength: maximumLength,
      scores: {
        noTitle: 1,
        widthTooShort: 6,
        widthTooLong: 3,
        widthCorrect: 9
      },
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34h"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34i")
    };
    this._allowShortTitle = allowShortTitle;
    this.identifier = "titleWidth";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Returns the maximum length.
   *
   * @returns {number} The maximum length.
   */
  getMaximumLength() {
    return maximumLength;
  }

  /**
   * Runs the pageTitleWidth module, based on this returns an assessment result with score.
   *
   * @param {Paper} paper The paper to use for the assessment.
   * @param {Researcher} researcher The researcher used for calling research.
   *
   * @returns {AssessmentResult} The assessment result.
   */
  getResult(paper, researcher) {
    const pageTitleWidth = researcher.getResearch("pageTitleWidth");
    const assessmentResult = new _AssessmentResult.default();
    assessmentResult.setScore(this.calculateScore(pageTitleWidth));
    assessmentResult.setText(this.translateScore(pageTitleWidth));
    if (assessmentResult.getScore() < 9) {
      assessmentResult.setHasJumps(true);
      assessmentResult.setEditFieldName((0, _i18n.__)("SEO title", "wordpress-seo"));
    }

    // Max and actual are used in the snippet editor progress bar.
    assessmentResult.max = this._config.maxLength;
    assessmentResult.actual = pageTitleWidth;
    return assessmentResult;
  }

  /**
   * Returns the score for the SEO title width calculation.
   *
   * @param {number} pageTitleWidth The width of the SEO title.
   *
   * @returns {number} The calculated score.
   */
  calculateScore(pageTitleWidth) {
    if ((0, _inRange.inRangeEndInclusive)(pageTitleWidth, 1, 400)) {
      return this._config.scores.widthTooShort;
    }
    if ((0, _inRange.inRangeEndInclusive)(pageTitleWidth, this._config.minLength, this._config.maxLength)) {
      return this._config.scores.widthCorrect;
    }
    if (pageTitleWidth > this._config.maxLength) {
      return this._config.scores.widthTooLong;
    }
    return this._config.scores.noTitle;
  }

  /**
   * Translates the score of the SEO title width calculation to a message the user can understand.
   *
   * @param {number} pageTitleWidth The width of the SEO title.
   *
   * @returns {string} The translated string.
   */
  translateScore(pageTitleWidth) {
    if ((0, _inRange.inRangeEndInclusive)(pageTitleWidth, 1, 400)) {
      if (this._allowShortTitle) {
        return (0, _i18n.sprintf)(/* translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sSEO title width%2$s: Good job!", "wordpress-seo"), this._config.urlTitle, "</a>");
      }
      return (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
      (0, _i18n.__)("%1$sSEO title width%3$s: The SEO title is too short. %2$sUse the space to add keyphrase variations or create compelling call-to-action copy%3$s.", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>");
    }
    if ((0, _inRange.inRangeEndInclusive)(pageTitleWidth, this._config.minLength, this._config.maxLength)) {
      return (0, _i18n.sprintf)(/* translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag */
      (0, _i18n.__)("%1$sSEO title width%2$s: Good job!", "wordpress-seo"), this._config.urlTitle, "</a>");
    }
    if (pageTitleWidth > this._config.maxLength) {
      return (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
      (0, _i18n.__)("%1$sSEO title width%3$s: The SEO title is wider than the viewable limit. %2$sTry to make it shorter%3$s.", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>");
    }
    return (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
    (0, _i18n.__)("%1$sSEO title width%3$s: %2$sPlease create an SEO title%3$s.", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>");
  }
}
exports["default"] = PageTitleWidthAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/ProductIdentifiersAssessment.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/ProductIdentifiersAssessment.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _helpers = __webpack_require__(/*! ../../../helpers */ "./node_modules/yoastseo/build/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment that checks whether a product has identifier(s).
 */
class ProductIdentifiersAssessment extends _assessment.default {
  /**
   * Constructs a product identifier assessment.
   *
   * @param {Object} config   Potential additional config for the assessment.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      scores: {
        good: 9,
        ok: 6
      },
      urlTitle: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/4ly"),
      urlCallToAction: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/4lz"),
      assessVariants: true,
      productIdentifierOrBarcode: "Product identifier",
      shouldShowEditButton: true
    };
    this.identifier = "productIdentifier";
    this._config = (0, _lodash.merge)(defaultConfig, config);
    this.name = (0, _i18n.__)(this._config.productIdentifierOrBarcode, "yoast-woo-seo");
  }

  /**
   * Executes the assessment and returns a result based on the research.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   *
   * @returns {AssessmentResult} An assessment result with the score and formatted text.
   */
  getResult(paper) {
    const productIdentifierData = paper.getCustomData();
    const result = this.scoreProductIdentifier(productIdentifierData, this._config);
    const assessmentResult = new _AssessmentResult.default();
    if (result) {
      assessmentResult.setScore(result.score);
      assessmentResult.setText(result.text);
    }
    if (assessmentResult.getScore() < 9 && this._config.shouldShowEditButton) {
      assessmentResult.setHasJumps(true);
      assessmentResult.setEditFieldName((0, _i18n.__)("Product identifiers", "yoast-woo-seo"));
    }
    return assessmentResult;
  }

  /**
   * Checks whether the assessment is applicable. It is applicable unless the product has variants and we don't want to
   * assess variants (this is the case for Shopify since we cannot at the moment easily access variant data in Shopify).
   *
   * @param {Paper} paper The paper to check.
   *
   * @returns {Boolean} Whether the assessment is applicable.
   */
  isApplicable(paper) {
    const customData = paper.getCustomData();

    /*
     * If the global identifier cannot be retrieved, the assessment shouldn't be applicable if the product is a simple
     * or external product, or doesn't have variants. Even though in reality a simple or external product doesn't have variants,
     * this double check is added because the hasVariants variable doesn't always update correctly when changing product type.
     */
    if (customData.canRetrieveGlobalIdentifier === false && (["simple", "external", "grouped"].includes(customData.productType) || customData.hasVariants === false)) {
      return false;
    }

    // If variant identifiers cannot be retrieved for a variable product with variants, the assessment shouldn't be applicable.
    if (customData.canRetrieveVariantIdentifiers === false && customData.hasVariants === true && customData.productType === "variable") {
      return false;
    }

    // Assessment is not applicable if we don't want to assess variants and the product has variants.
    return !(this._config.assessVariants === false && customData.hasVariants);
  }

  /**
   * Returns a score based on whether the product (variants) have an identifier.
   *
   * @param {Object} productIdentifierData  Whether product has variants, global identifier, and variant identifiers.
   * @param {Object} config                 The configuration to use.
   *
   * @returns {{score: number, text: string} | {}}	The result object with score and text
   * 													or empty object if no score should be returned.
   */
  scoreProductIdentifier(productIdentifierData, config) {
    let feedbackStrings;
    if (this._config.productIdentifierOrBarcode === "Product identifier") {
      feedbackStrings = {
        okNoVariants: (0, _i18n.__)("Your product is missing an identifier (like a GTIN code)", "yoast-woo-seo"),
        goodNoVariants: (0, _i18n.__)("Your product has an identifier", "yoast-woo-seo"),
        okWithVariants: (0, _i18n.__)("Not all your product variants have an identifier", "yoast-woo-seo"),
        goodWithVariants: (0, _i18n.__)("All your product variants have an identifier", "yoast-woo-seo")
      };
    } else {
      feedbackStrings = {
        okNoVariants: (0, _i18n.__)("Your product is missing a barcode (like a GTIN code)", "yoast-woo-seo"),
        goodNoVariants: (0, _i18n.__)("Your product has a barcode", "yoast-woo-seo"),
        okWithVariants: (0, _i18n.__)("Not all your product variants have a barcode", "yoast-woo-seo"),
        goodWithVariants: (0, _i18n.__)("All your product variants have a barcode", "yoast-woo-seo")
      };
    }

    // Apply the following scoring conditions to products without variants.
    if (["simple", "grouped", "external"].includes(productIdentifierData.productType) || productIdentifierData.productType === "variable" && !productIdentifierData.hasVariants) {
      if (!productIdentifierData.hasGlobalIdentifier) {
        return {
          score: config.scores.ok,
          text: (0, _i18n.sprintf)(
          /* translators: %1$s and %4$s expand to links on yoast.com, %5$s expands to the anchor end tag,
          * %2$s expands to the string "Barcode" or "Product identifier", %3$s expands to the feedback string
          * "Your product is missing a product identifier (like a GTIN code)"
          * or "Your product is missing a barcode (like a GTIN code)" */
          (0, _i18n.__)("%1$s%2$s%5$s: %3$s. %4$sInclude it if you can, as it " + "will help search engines to better understand your content.%5$s", "yoast-woo-seo"), this._config.urlTitle, this.name, feedbackStrings.okNoVariants, this._config.urlCallToAction, "</a>")
        };
      }
      return {
        score: config.scores.good,
        text: (0, _i18n.sprintf)(
        /* translators: %1$s expands to a link on yoast.com, %4$s expands to the anchor end tag,
        * %2$s expands to the string "Barcode" or "Product identifier", %3$s expands to the feedback string
        * "Your product has a product identifier" or "Your product has a barcode" */
        (0, _i18n.__)("%1$s%2$s%4$s: %3$s. Good job!", "yoast-woo-seo"), this._config.urlTitle, this.name, feedbackStrings.goodNoVariants, "</a>")
      };
    } else if (productIdentifierData.productType === "variable" && productIdentifierData.hasVariants) {
      if (!productIdentifierData.doAllVariantsHaveIdentifier) {
        // If we want to assess variants, and if product has variants but not all variants have an identifier, return orange bullet.
        // If all variants have an identifier, return green bullet.
        return {
          score: config.scores.ok,
          text: (0, _i18n.sprintf)(
          /* translators: %1$s and %4$s expand to links on yoast.com, %5$s expands to the anchor end tag,
          * %2$s expands to the string "Barcode" or "Product identifier", %3$s expands to the string
          * "Not all your product variants have a product identifier"
          * or "Not all your product variants have a barcode" */
          (0, _i18n.__)("%1$s%2$s%5$s: %3$s. %4$sInclude it if you can, as it will help search engines to better understand your content.%5$s", "yoast-woo-seo"), this._config.urlTitle, this.name, feedbackStrings.okWithVariants, this._config.urlCallToAction, "</a>")
        };
      }
      return {
        score: config.scores.good,
        text: (0, _i18n.sprintf)(
        /* translators: %1$s expands to a link on yoast.com, %4$s expands to the anchor end tag,
        * %2$s expands to the string "Barcode" or "Product identifier" , %3$s expands to the feedback string
        * "All your product variants have a product identifier" or "All your product variants have a barcode" */
        (0, _i18n.__)("%1$s%2$s%4$s: %3$s. Good job!", "yoast-woo-seo"), this._config.urlTitle, this.name, feedbackStrings.goodWithVariants, "</a>")
      };
    }
    return {};
  }
}
exports["default"] = ProductIdentifiersAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/ProductSKUAssessment.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/ProductSKUAssessment.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _helpers = __webpack_require__(/*! ../../../helpers */ "./node_modules/yoastseo/build/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment checks whether the product has a SKU.
 */
class ProductSKUAssessment extends _assessment.default {
  /**
   * Constructs a product SKU assessment.
   *
   * @param {Object} config   Potential additional config for the assessment.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      scores: {
        good: 9,
        ok: 6
      },
      urlTitle: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/4lw"),
      urlCallToAction: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/4lx"),
      assessVariants: true,
      addSKULocation: false
    };
    this.identifier = "productSKU";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Executes the assessment and returns an result based on the research.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   *
   * @returns {AssessmentResult} An assessment result with the score and formatted text.
   */
  getResult(paper) {
    const productSKUData = paper.getCustomData();
    const result = this.scoreProductSKU(productSKUData, this._config);
    const assessmentResult = new _AssessmentResult.default();
    if (result) {
      assessmentResult.setScore(result.score);
      assessmentResult.setText(result.text);
    }
    if (assessmentResult.getScore() < 9 && this._config.shouldShowEditButton) {
      assessmentResult.setHasJumps(true);
      assessmentResult.setEditFieldName((0, _i18n.__)("SKU", "yoast-woo-seo"));
    }
    return assessmentResult;
  }

  /**
   * Checks whether the assessment is applicable.
   * It is not applicable when the product has variants and we don't want to assess variants (this is the case for Shopify
   * since we cannot at the moment easily access variant data in Shopify).
   * It is also not applicable when we cannot retrieve the SKU (this can be the case if other plugins remove/change the SKU
   * input field in such as way that we cannot detect it.
   *
   * @param {Paper} paper The paper to check.
   *
   * @returns {Boolean} Whether the assessment is applicable.
   */
  isApplicable(paper) {
    const customData = paper.getCustomData();

    /*
       * If the global SKU cannot be retrieved, the assessment shouldn't be applicable if the product is a simple
       * or external product, or doesn't have variants. Even though in reality a simple or external product doesn't have variants,
       * this double check is added because the hasVariants variable doesn't always update correctly when changing product type.
       */
    if (customData.canRetrieveGlobalSku === false && (["simple", "external"].includes(customData.productType) || customData.hasVariants === false)) {
      return false;
    }

    // If variant identifiers cannot be retrieved for a variable product with variants, the assessment shouldn't be applicable.
    if (customData.canRetrieveVariantSkus === false && customData.hasVariants === true && customData.productType === "variable") {
      return false;
    }

    // Assessment is not applicable if we don't want to assess variants and the product has variants.
    return !(this._config.assessVariants === false && customData.hasVariants);
  }

  /**
   * Returns a score based on whether the product (variants) have a SKU.
   *
   * @param {Object} productSKUData         Whether product has variants, global SKU, and variant SKU.
   * @param {Object} config                 The configuration to use.
   *
   * @returns {{score: number, text: string} | {}}	The result object with score and text
   * 													or empty object if no score should be returned.
   */
  scoreProductSKU(productSKUData, config) {
    // Apply the following scoring conditions to products without variants.
    if (["simple", "external", "grouped"].includes(productSKUData.productType) || productSKUData.productType === "variable" && !productSKUData.hasVariants) {
      if (!productSKUData.hasGlobalSKU) {
        return {
          score: config.scores.ok,
          text: (0, _i18n.sprintf)(
          // translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag.
          (0, _i18n.__)("%1$sSKU%3$s: Your product is missing a SKU." + " %2$sInclude it if you can, as it will help search engines to better understand your content.%3$s", "yoast-woo-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
        };
      }
      return {
        score: config.scores.good,
        text: (0, _i18n.sprintf)(
        // translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag.
        (0, _i18n.__)("%1$sSKU%2$s: Your product has a SKU. Good job!", "yoast-woo-seo"), this._config.urlTitle, "</a>")
      };
    } else if (productSKUData.productType === "variable" && productSKUData.hasVariants) {
      // If we want to assess variants, if product has variants and not all variants have a SKU, return orange bullet.
      // If all variants have a SKU, return green bullet.
      if (!productSKUData.doAllVariantsHaveSKU) {
        return {
          score: config.scores.ok,
          text: (0, _i18n.sprintf)(
          // translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag.
          (0, _i18n.__)("%1$sSKU%3$s: Not all your product variants have a SKU. " + "You can add a SKU via the \"Variations\" tab in the Product data box." + " %2$sInclude it if you can, as it will help search engines to better understand your content.%3$s", "yoast-woo-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
        };
      }
      return {
        score: config.scores.good,
        text: (0, _i18n.sprintf)(
        // translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag.
        (0, _i18n.__)("%1$sSKU%2$s: All your product variants have a SKU. Good job!", "yoast-woo-seo"), this._config.urlTitle, "</a>")
      };
    }
    return {};
  }
}
exports["default"] = ProductSKUAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/SingleH1Assessment.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/SingleH1Assessment.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment.js */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _helpers = __webpack_require__(/*! ../../../helpers */ "./node_modules/yoastseo/build/helpers/index.js");
var _addMark = _interopRequireDefault(__webpack_require__(/*! ../../../markers/addMark.js */ "./node_modules/yoastseo/build/markers/addMark.js"));
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult.js */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _Mark = _interopRequireDefault(__webpack_require__(/*! ../../../values/Mark.js */ "./node_modules/yoastseo/build/values/Mark.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Assessment to check whether the body of the text contains more than 1 H1s in the body.
 * This assessment doesn't penalize H1 that is not in the very beginning of the body.
 */
class SingleH1Assessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} config The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      scores: {
        textContainsSuperfluousH1: 1
      },
      urlTitle: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/3a6"),
      urlCallToAction: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/3a7")
    };
    this.identifier = "singleH1";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Runs the h1 research and based on this returns an assessment result with a score.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   * @param {Researcher}  researcher  The researcher used for calling the research.
   *
   * @returns {AssessmentResult} The assessment result.
   */
  getResult(paper, researcher) {
    this._h1s = researcher.getResearch("h1s");
    const assessmentResult = new _AssessmentResult.default();
    const calculatedResult = this.calculateResult();
    if (!(0, _lodash.isUndefined)(calculatedResult)) {
      assessmentResult.setScore(calculatedResult.score);
      assessmentResult.setText(calculatedResult.resultText);
      assessmentResult.setHasMarks(true);
    }
    return assessmentResult;
  }

  /**
   * Returns the score and the feedback string for the single H1 assessment.
   *
   * @returns {Object|null} The calculated score and the feedback string.
   */
  calculateResult() {
    // Returns the default assessment result if the h1 is not more than 1 in the body, regardless of its position.
    if (this._h1s.length <= 1) {
      return;
    }
    return {
      score: this._config.scores.textContainsSuperfluousH1,
      resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
      (0, _i18n.__)("%1$sSingle title%3$s: H1s should only be used as your main title. Find all H1s in your text that aren't your main title and %2$schange them to a lower heading level%3$s!", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
    };
  }

  /**
   * Marks all H1s in the body of the text, regardless of their position in the text.
   *
   * @returns {Array} Array with all the marked H1s.
   */
  getMarks() {
    return this._h1s.map(function (h1) {
      return new _Mark.default({
        original: "<h1>" + h1.content + "</h1>",
        marked: "<h1>" + (0, _addMark.default)(h1.content) + "</h1>",
        position: {
          startOffset: h1.position.startOffset,
          endOffset: h1.position.endOffset,
          startOffsetBlock: 0,
          endOffsetBlock: h1.position.endOffset - h1.position.startOffset,
          clientId: h1.position.clientId
        }
      });
    });
  }

  /**
   * Checks whether the paper has a text.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   *
   * @returns {boolean} True when there is text.
   */
  isApplicable(paper) {
    return paper.hasText();
  }
}
var _default = exports["default"] = SingleH1Assessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/SubHeadingsKeywordAssessment.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/SubHeadingsKeywordAssessment.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _getSubheadings = __webpack_require__(/*! ../../../languageProcessing/helpers/html/getSubheadings */ "./node_modules/yoastseo/build/languageProcessing/helpers/html/getSubheadings.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _inRange = __webpack_require__(/*! ../../helpers/assessments/inRange.js */ "./node_modules/yoastseo/build/scoring/helpers/assessments/inRange.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment that checks if the keyword is present in one of the subheadings.
 */
class SubHeadingsKeywordAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {object} config The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      parameters: {
        lowerBoundary: 0.3,
        upperBoundary: 0.75
      },
      scores: {
        noMatches: 3,
        tooFewMatches: 3,
        goodNumberOfMatches: 9,
        tooManyMatches: 3
      },
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/33m"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/33n")
    };
    this.identifier = "subheadingsKeyword";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Runs the matchKeywordInSubheadings research and based on this returns an assessment result.
   *
   * @param {Paper} paper             The paper to use for the assessment.
   * @param {Researcher} researcher   The researcher used for calling research.
   *
   * @returns {AssessmentResult} The assessment result.
   */
  getResult(paper, researcher) {
    this._subHeadings = researcher.getResearch("matchKeywordInSubheadings");
    const assessmentResult = new _AssessmentResult.default();
    this._minNumberOfSubheadings = Math.ceil(this._subHeadings.count * this._config.parameters.lowerBoundary);
    this._maxNumberOfSubheadings = Math.floor(this._subHeadings.count * this._config.parameters.upperBoundary);
    const calculatedResult = this.calculateResult();
    assessmentResult.setScore(calculatedResult.score);
    assessmentResult.setText(calculatedResult.resultText);
    return assessmentResult;
  }

  /**
   * Checks whether the paper has a subheadings.
   *
   * @param {Paper} paper The paper to use for the check.
   *
   * @returns {boolean} True when there is at least one subheading.
   */
  hasSubheadings(paper) {
    const subheadings = (0, _getSubheadings.getSubheadingsTopLevel)(paper.getText());
    return subheadings.length > 0;
  }

  /**
   * Checks whether the paper has a text and a keyword.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   *
   * @returns {boolean} True when there is text and a keyword.
   */
  isApplicable(paper) {
    return paper.hasText() && paper.hasKeyword() && this.hasSubheadings(paper);
  }

  /**
   * Checks whether there are too few subheadings with the keyphrase.
   *
   * This is the case if the number of subheadings with the keyphrase is more than 0 but less than the specified
   * recommended minimum.
   *
   * @returns {boolean} Returns true if the keyphrase is included in too few subheadings.
   */
  hasTooFewMatches() {
    return this._subHeadings.matches > 0 && this._subHeadings.matches < this._minNumberOfSubheadings;
  }

  /**
   * Checks whether there are too many subheadings with the keyphrase.
   *
   * The upper limit is only applicable if there is more than one subheading. If there is only one subheading with
   * the keyphrase this would otherwise always lead to a 100% match rate.
   *
   * @returns {boolean} Returns true if there is more than one subheading and if the keyphrase is included in less
   *                    subheadings than the recommended maximum.
   */
  hasTooManyMatches() {
    return this._subHeadings.count > 1 && this._subHeadings.matches > this._maxNumberOfSubheadings;
  }

  /**
   * Checks whether there is only one higher-level subheading and this subheading includes the keyphrase.
   *
   * @returns {boolean} Returns true if there is exactly one higher-level subheading and this
   * subheading has a keyphrase match.
   */
  isOneOfOne() {
    return this._subHeadings.count === 1 && this._subHeadings.matches === 1;
  }

  /**
   * Checks whether there is a good number of subheadings with the keyphrase.
   *
   * This is the case if there is only one subheading and that subheading includes the keyphrase or if the number of
   * subheadings with the keyphrase is within the specified recommended range.
   *
   * @returns {boolean} Returns true if the keyphrase is included in a sufficient number of subheadings.
   */
  hasGoodNumberOfMatches() {
    return (0, _inRange.inRangeStartEndInclusive)(this._subHeadings.matches, this._minNumberOfSubheadings, this._maxNumberOfSubheadings);
  }

  /**
   * Determines the score and the Result text for the subheadings.
   *
   * @returns {Object} The object with the calculated score and the result text.
   */
  calculateResult() {
    if (this.hasTooFewMatches()) {
      return {
        score: this._config.scores.tooFewMatches,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to a link on yoast.com, %3$s expands to the anchor end tag. */
        (0, _i18n.__)("%1$sKeyphrase in subheading%3$s: %2$sUse more keyphrases or synonyms in your H2 and H3 subheadings%3$s!", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }
    if (this.hasTooManyMatches()) {
      return {
        score: this._config.scores.tooManyMatches,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to a link on yoast.com, %3$s expands to the anchor end tag. */
        (0, _i18n.__)("%1$sKeyphrase in subheading%3$s: More than 75%% of your H2 and H3 subheadings reflect the topic of your copy. That's too much. %2$sDon't over-optimize%3$s!", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }
    if (this.isOneOfOne()) {
      return {
        score: this._config.scores.goodNumberOfMatches,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag,
        %3$d expands to the number of subheadings containing the keyphrase. */
        (0, _i18n.__)("%1$sKeyphrase in subheading%2$s: Your H2 or H3 subheading reflects the topic of your copy. Good job!", "wordpress-seo"), this._config.urlTitle, "</a>", this._subHeadings.matches)
      };
    }
    if (this.hasGoodNumberOfMatches()) {
      return {
        score: this._config.scores.goodNumberOfMatches,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag,
        %3$d expands to the number of subheadings containing the keyphrase. */
        (0, _i18n._n)("%1$sKeyphrase in subheading%2$s: %3$s of your H2 and H3 subheadings reflects the topic of your copy. Good job!", "%1$sKeyphrase in subheading%2$s: %3$s of your H2 and H3 subheadings reflect the topic of your copy. Good job!", this._subHeadings.matches, "wordpress-seo"), this._config.urlTitle, "</a>", this._subHeadings.matches)
      };
    }
    return {
      score: this._config.scores.noMatches,
      resultText: (0, _i18n.sprintf)(/* translators: %1$s and %2$s expand to a link on yoast.com, %3$s expands to the anchor end tag. */
      (0, _i18n.__)("%1$sKeyphrase in subheading%3$s: %2$sUse more keyphrases or synonyms in your H2 and H3 subheadings%3$s!", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
    };
  }
}
exports["default"] = SubHeadingsKeywordAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/TextCompetingLinksAssessment.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/TextCompetingLinksAssessment.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _helpers = __webpack_require__(/*! ../../../helpers */ "./node_modules/yoastseo/build/helpers/index.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Assessment to check whether you're linking to a different page with the keyword from this page.
 */
class TextCompetingLinksAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} [config] The configuration to use.
   * @param {number} [config.parameters.recommendedMaximum] The recommended maximum number of links using the same keyword as this paper.
   * @param {string} [config.scores.bad] The score to return if there are more links with the same keyword than the recommended maximum.
   * @param {string} [config.url] The URL to the relevant article on Yoast.com.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      parameters: {
        recommendedMaximum: 0
      },
      scores: {
        bad: 2
      },
      urlTitle: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/34l"),
      urlCallToAction: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/34m")
    };
    this.identifier = "textCompetingLinks";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Runs the linkCount module, based on this returns an assessment result with score.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   * @param {Researcher}  researcher  The researcher used for calling research.
   *
   * @returns {Object} The AssessmentResult.
   */
  getResult(paper, researcher) {
    const assessmentResult = new _AssessmentResult.default();
    this.totalAnchorsWithKeyphrase = researcher.getResearch("getAnchorsWithKeyphrase").anchorsWithKeyphraseCount;
    const calculatedResult = this.calculateResult();
    if ((0, _lodash.isUndefined)(calculatedResult)) {
      return assessmentResult;
    }
    assessmentResult.setScore(calculatedResult.score);
    assessmentResult.setText(calculatedResult.resultText);
    assessmentResult.setHasMarks(false);
    return assessmentResult;
  }

  /**
   * Determines if the assessment is applicable to the paper.
   *
   * @param {Paper}       paper       The paper to check
   *
   * @returns {boolean} Whether the paper has text and a keyword
   */
  isApplicable(paper) {
    return paper.hasText() && paper.hasKeyword();
  }

  /**
   * Returns a result based on the number of links.
   *
   * @returns {Object} ResultObject with score and text.
   */
  calculateResult() {
    if (this.totalAnchorsWithKeyphrase > this._config.parameters.recommendedMaximum) {
      return {
        score: this._config.scores.bad,
        resultText: (0, _i18n.sprintf)(/* translators:  %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sLink keyphrase%3$s: You're linking to another page with the words you want this page to rank for. %2$sDon't do that%3$s!", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }
  }
}
var _default = exports["default"] = TextCompetingLinksAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/TextLengthAssessment.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/TextLengthAssessment.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents an assessment that checks the length of the text and gives feedback accordingly.
 */
class TextLengthAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} [config] The configuration to use.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      recommendedMinimum: 300,
      slightlyBelowMinimum: 250,
      belowMinimum: 200,
      veryFarBelowMinimum: 100,
      scores: {
        recommendedMinimum: 9,
        slightlyBelowMinimum: 6,
        belowMinimum: 3,
        farBelowMinimum: -10,
        veryFarBelowMinimum: -20
      },
      countTextIn: {
        singular: (0, _i18n.__)("word", "wordpress-seo"),
        plural: (0, _i18n.__)("words", "wordpress-seo")
      },
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34n"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/34o"),
      cornerstoneContent: false,
      customContentType: ""
    };
    this.identifier = "textLength";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Executes the Assessment and returns a result.
   *
   * @param {Paper}       paper       The Paper object to assess.
   * @param {Researcher}  researcher  The Researcher object containing all available researches.
   *
   * @returns {AssessmentResult} The result of the assessment, containing both a score and a descriptive text.
   */
  getResult(paper, researcher) {
    const wordCount = researcher.getResearch("wordCountInText");
    if (researcher.getConfig("textLength")) {
      this._config = this.getLanguageSpecificConfig(researcher);
    }
    const countTextInCharacters = researcher.getConfig("countCharacters");
    if (countTextInCharacters) {
      this._config.countTextIn.singular = (0, _i18n.__)("character", "wordpress-seo");
      this._config.countTextIn.plural = (0, _i18n.__)("characters", "wordpress-seo");
    }
    const calculatedResult = this.calculateResult(wordCount.count);
    const assessmentResult = new _AssessmentResult.default();
    assessmentResult.setScore(calculatedResult.score);
    assessmentResult.setText(calculatedResult.resultText);
    return assessmentResult;
  }

  /**
   * Checks if there is language-specific config, and if so, overwrites the current config with it.
   *
   * @param {Researcher} researcher The researcher to use.
   *
   * @returns {Object} The config that should be used.
   */
  getLanguageSpecificConfig(researcher) {
    const currentConfig = this._config;
    const languageSpecificConfig = researcher.getConfig("textLength");

    // Checks if a language has configuration for custom content types.
    if (languageSpecificConfig.hasOwnProperty(currentConfig.customContentType)) {
      return (0, _lodash.merge)(currentConfig, languageSpecificConfig[currentConfig.customContentType]);
    }

    // Checks if a language has a default cornerstone configuration.
    if (currentConfig.cornerstoneContent === true && currentConfig.customContentType === "" && languageSpecificConfig.hasOwnProperty("defaultCornerstone")) {
      return (0, _lodash.merge)(currentConfig, languageSpecificConfig.defaultCornerstone);
    }

    // Uses the default language-specific config for posts and pages.
    return (0, _lodash.merge)(currentConfig, languageSpecificConfig.defaultAnalysis);
  }

  /**
   * Returns the score and the appropriate feedback string based on the current word count
   * for taxonomies (in WordPress) and collections (in Shopify).
   *
   * @param {number} wordCount	The amount of words to be checked against.
   * @returns {Object} The score and the feedback string.
   */
  calculateTaxonomyResult(wordCount) {
    if (wordCount >= this._config.recommendedMinimum) {
      return {
        score: this._config.scores.recommendedMinimum,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$d expands to the number of words / characters in the text,
        %2$s expands to a link on yoast.com, %3$s expands to the anchor end tag,
        %4$s expands to the word 'words' or 'characters'. */
        (0, _i18n.__)("%2$sText length%3$s: The text contains %1$d %4$s. Good job!", "wordpress-seo"), wordCount, this._config.urlTitle, "</a>", this._config.countTextIn.plural)
      };
    }
    if ((0, _lodash.inRange)(wordCount, this._config.slightlyBelowMinimum, this._config.recommendedMinimum)) {
      return {
        score: this._config.scores.slightlyBelowMinimum,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$d expands to the number of words / characters in the text,
        %2$s expands to a link on yoast.com, %3$s expands to a link on yoast.com,
        %4$s expands to the anchor end tag, %5$d expands to the recommended minimum of words / characters,
        %6$s expands to the word 'words' or 'characters'. */
        (0, _i18n.__)(
        // eslint-disable-next-line max-len
        "%2$sText length%4$s: The text contains %1$d %6$s. This is slightly below the recommended minimum of %5$d %6$s. %3$sAdd more content%4$s.", "wordpress-seo"), wordCount, this._config.urlTitle, this._config.urlCallToAction, "</a>", this._config.recommendedMinimum, this._config.countTextIn.plural)
      };
    }
    if ((0, _lodash.inRange)(wordCount, this._config.veryFarBelowMinimum, this._config.slightlyBelowMinimum)) {
      return {
        score: this._config.scores.belowMinimum,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$d expands to the number of words / characters in the text,
        		%2$s expands to a link on yoast.com, %3$s expands to a link on yoast.com,
        		%4$s expands to the anchor end tag, %5$d expands to the recommended minimum of words / characters,
        		%6$s expands to the word 'word' or 'character', %7$s expands to the word 'words' or 'characters'. */
        (0, _i18n._n)(
        // eslint-disable-next-line max-len
        "%2$sText length%4$s: The text contains %1$d %6$s. This is below the recommended minimum of %5$d %7$s. %3$sAdd more content%4$s.",
        // eslint-disable-next-line max-len
        "%2$sText length%4$s: The text contains %1$d %7$s. This is below the recommended minimum of %5$d %7$s. %3$sAdd more content%4$s.", wordCount, "wordpress-seo"), wordCount, this._config.urlTitle, this._config.urlCallToAction, "</a>", this._config.recommendedMinimum, this._config.countTextIn.singular, this._config.countTextIn.plural)
      };
    }
    return {
      score: this._config.scores.veryFarBelowMinimum,
      resultText: (0, _i18n.sprintf)(/* translators: %1$s expands to a link on yoast.com, %2$s expands to a link on yoast.com, %3$s expands to the anchor end tag. */
      (0, _i18n.__)("%1$sText length%3$s: %2$sPlease add some content%3$s.", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
    };
  }

  /**
   * Returns the score and the appropriate feedback string based on the current word count for every type of content.
   *
   * @param {number}  wordCount   The amount of words to be checked against.
   *
   * @returns {Object} The score and the feedback string.
   */
  calculateResult(wordCount) {
    const customContentTypes = ["taxonomyAssessor", "collectionSEOAssessor", "collectionCornerstoneSEOAssessor"];
    if (customContentTypes.includes(this._config.customContentType)) {
      return this.calculateTaxonomyResult(wordCount);
    }
    if (wordCount >= this._config.recommendedMinimum) {
      return {
        score: this._config.scores.recommendedMinimum,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$d expands to the number of words / characters in the text,
        %2$s expands to a link on yoast.com, %3$s expands to the anchor end tag,
        %4$s expands to the word 'words' or 'characters'. */
        (0, _i18n.__)("%2$sText length%3$s: The text contains %1$d %4$s. Good job!", "wordpress-seo"), wordCount, this._config.urlTitle, "</a>", this._config.countTextIn.plural)
      };
    }
    if ((0, _lodash.inRange)(wordCount, 0, this._config.belowMinimum)) {
      let badScore = this._config.scores.farBelowMinimum;
      if ((0, _lodash.inRange)(wordCount, 0, this._config.veryFarBelowMinimum)) {
        badScore = this._config.scores.veryFarBelowMinimum;
      }
      return {
        score: badScore,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$d expands to the number of words / characters in the text,
        %2$s expands to a link on yoast.com, %3$s expands to a link on yoast.com,
        %4$s expands to the anchor end tag, %5$d expands to the recommended minimum of words / characters,
        %6$s expands to the word 'word' or 'character', %7$s expands to the word 'words' or 'characters'. */
        (0, _i18n._n)("%2$sText length%4$s: The text contains %1$d %6$s. This is far below the recommended minimum of %5$d %7$s. %3$sAdd more content%4$s.", "%2$sText length%4$s: The text contains %1$d %7$s. This is far below the recommended minimum of %5$d %7$s. %3$sAdd more content%4$s.", wordCount, "wordpress-seo"), wordCount, this._config.urlTitle, this._config.urlCallToAction, "</a>", this._config.recommendedMinimum, this._config.countTextIn.singular, this._config.countTextIn.plural)
      };
    }
    if ((0, _lodash.inRange)(wordCount, this._config.slightlyBelowMinimum, this._config.recommendedMinimum)) {
      if (this._config.cornerstoneContent === false) {
        return {
          score: this._config.scores.slightlyBelowMinimum,
          resultText: (0, _i18n.sprintf)(
          /* translators: %1$d expands to the number of words / characters in the text,
          %2$s expands to a link on yoast.com, %3$s expands to a link on yoast.com,
          %4$s expands to the anchor end tag, %5$d expands to the recommended minimum of words / characters,
          %6$s expands to the word 'words' or 'characters'. */
          (0, _i18n.__)("%2$sText length%4$s: The text contains %1$d %6$s. This is slightly below the recommended minimum of %5$d %6$s. %3$sAdd a bit more copy%4$s.", "wordpress-seo"), wordCount, this._config.urlTitle, this._config.urlCallToAction, "</a>", this._config.recommendedMinimum, this._config.countTextIn.plural)
        };
      }
      return {
        score: this._config.scores.slightlyBelowMinimum,
        resultText: (0, _i18n.sprintf)(
        /* translators: %1$d expands to the number of words / characters in the text,
        	%2$s expands to a link on yoast.com, %3$s expands to a link on yoast.com,
        	%4$s expands to the anchor end tag, %5$d expands to the recommended minimum of words / characters,
        	%6$s expands to the word 'words' or 'characters'. */
        (0, _i18n.__)("%2$sText length%4$s: The text contains %1$d %6$s. This is below the recommended minimum of %5$d %6$s. %3$sAdd more content%4$s.", "wordpress-seo"), wordCount, this._config.urlTitle, this._config.urlCallToAction, "</a>", this._config.recommendedMinimum, this._config.countTextIn.plural)
      };
    }
    return {
      score: this._config.scores.belowMinimum,
      resultText: (0, _i18n.sprintf)(
      /* translators: %1$d expands to the number of words / characters in the text,
      		%2$s expands to a link on yoast.com, %3$s expands to a link on yoast.com,
      		%4$s expands to the anchor end tag, %5$d expands to the recommended minimum of words / characters,
      		%6$s expands to the word 'words' or 'characters'. */
      (0, _i18n.__)("%2$sText length%4$s: The text contains %1$d %6$s. This is below the recommended minimum of %5$d %6$s. %3$sAdd more content%4$s.", "wordpress-seo"), wordCount, this._config.urlTitle, this._config.urlCallToAction, "</a>", this._config.recommendedMinimum, this._config.countTextIn.plural)
    };
  }
}
exports["default"] = TextLengthAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/TextTitleAssessment.js":
/*!************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/TextTitleAssessment.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _helpers = __webpack_require__(/*! ../../../helpers */ "./node_modules/yoastseo/build/helpers/index.js");
var _unifyWhitespace = __webpack_require__(/*! ../../../languageProcessing/helpers/sanitize/unifyWhitespace */ "./node_modules/yoastseo/build/languageProcessing/helpers/sanitize/unifyWhitespace.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the assessment that checks whether a text has a title.
 */
class TextTitleAssessment extends _assessment.default {
  /**
   * Constructs a text title assessment.
   *
   * @param {object} config The config to use for the assessment.
   *
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      scores: {
        good: 9,
        bad: -10000
      },
      urlTitle: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/4nh"),
      urlCallToAction: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/4ni")
    };
    this.identifier = "textTitleAssessment";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Checks whether the paper has a text title.
   *
   * @param {Paper} 	paper		The paper to use for the assessment.
   *
   * @returns {boolean}	 Whether the paper has a text title.
   */
  getTextTitle(paper) {
    let textTitle = paper.getTextTitle();
    textTitle = (0, _unifyWhitespace.unifyAllSpaces)(textTitle);
    textTitle = textTitle.trim();
    return textTitle.length > 0;
  }

  /**
   * Gets the title from the Paper and based on this returns an assessment result with score.
   *
   * @param {Paper}      paper      The paper to use for the assessment.
   *
   * @returns {AssessmentResult} The assessment result.
   */
  getResult(paper) {
    const textTitleData = this.getTextTitle(paper);
    const calculatedResult = this.calculateResult(textTitleData);
    const assessmentResult = new _AssessmentResult.default();
    assessmentResult.setScore(calculatedResult.score);
    assessmentResult.setText(calculatedResult.resultText);
    return assessmentResult;
  }

  /**
   * Returns the result object based on whether the text has a title or not.
   *
   * @param {boolean} textTitleData Whether the text has a title.
   *
   * @returns {{resultText: string, score}} Result object with score and text.
   */
  calculateResult(textTitleData) {
    // GOOD result when the text has a title.
    if (textTitleData) {
      return {
        score: this._config.scores.good,
        resultText: (0, _i18n.sprintf)(/* translators: %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag. */
        (0, _i18n.__)("%1$sTitle%2$s: Your page has a title. Well done!", "wordpress-seo-premium"), this._config.urlTitle, "</a>")
      };
    }

    // BAD if the text is missing a title.
    return {
      score: this._config.scores.bad,
      resultText: (0, _i18n.sprintf)(
      /**
       * translators:
       * %1$s and %2$s expands to a link on yoast.com, %3$s expands to the anchor end tag.
       */
      (0, _i18n.__)("%1$sTitle%3$s: Your page does not have a title yet. %2$sAdd one%3$s!", "wordpress-seo-premium"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
    };
  }
}
exports["default"] = TextTitleAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessments/seo/UrlKeywordAssessment.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessments/seo/UrlKeywordAssessment.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.UrlKeywordAssessment = exports.SlugKeywordAssessment = void 0;
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _assessment = _interopRequireDefault(__webpack_require__(/*! ../assessment */ "./node_modules/yoastseo/build/scoring/assessments/assessment.js"));
var _shortlinker = __webpack_require__(/*! ../../../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Represents the Slug keyword assessment. This assessment checks if the keyword is present in the slug.
 */
class SlugKeywordAssessment extends _assessment.default {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} config   The configuration to use.
   * @returns {void}
   */
  constructor(config = {}) {
    super();
    const defaultConfig = {
      scores: {
        okay: 6,
        good: 9
      },
      urlTitle: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/33o"),
      urlCallToAction: (0, _shortlinker.createAnchorOpeningTag)("https://yoa.st/33p")
    };
    this.identifier = "slugKeyword";
    this._config = (0, _lodash.merge)(defaultConfig, config);
  }

  /**
   * Executes the Assessment and returns a result.
   *
   * @param {Paper}       paper       The Paper object to assess.
   * @param {Researcher}  researcher  The Researcher object containing all available researches.
   *
   * @returns {AssessmentResult} The result of the assessment, containing both a score and a descriptive text.
   */
  getResult(paper, researcher) {
    this._keywordInSlug = researcher.getResearch("keywordCountInSlug");
    const assessmentResult = new _AssessmentResult.default();
    const calculatedResult = this.calculateResult();
    assessmentResult.setScore(calculatedResult.score);
    assessmentResult.setText(calculatedResult.resultText);
    if (assessmentResult.getScore() < 9) {
      assessmentResult.setHasJumps(true);
      assessmentResult.setEditFieldName((0, _i18n.__)("slug", "wordpress-seo"));
    }
    return assessmentResult;
  }

  /**
   * Checks whether the paper has a keyword and a slug.
   *
   * @param {Paper}       paper       The paper to use for the assessment.
   * @param {Researcher}  researcher  The researcher object.
   *
   * @returns {boolean} True if the paper contains a keyword and a slug, and if the keywordCountInSlug research is available on the researcher.
   */
  isApplicable(paper, researcher) {
    return paper.hasKeyword() && paper.hasSlug() && researcher.hasResearch("keywordCountInSlug");
  }

  /**
   * Determines the score and the result text based on whether or not there's a keyword in the slug.
   *
   *
   * @returns {Object} The object with calculated score and resultText.
   */
  calculateResult() {
    if (this._keywordInSlug.keyphraseLength < 3) {
      if (this._keywordInSlug.percentWordMatches === 100) {
        return {
          score: this._config.scores.good,
          resultText: (0, _i18n.sprintf)(/* translators:  %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag */
          (0, _i18n.__)("%1$sKeyphrase in slug%2$s: Great work!", "wordpress-seo"), this._config.urlTitle, "</a>")
        };
      }
      return {
        score: this._config.scores.okay,
        resultText: (0, _i18n.sprintf)(/* translators:  %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sKeyphrase in slug%3$s: (Part of) your keyphrase does not appear in the slug. %2$sChange that%3$s!", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
      };
    }
    if (this._keywordInSlug.percentWordMatches > 50) {
      return {
        score: this._config.scores.good,
        resultText: (0, _i18n.sprintf)(/* translators:  %1$s expands to a link on yoast.com, %2$s expands to the anchor end tag */
        (0, _i18n.__)("%1$sKeyphrase in slug%2$s: More than half of your keyphrase appears in the slug. That's great!", "wordpress-seo"), this._config.urlTitle, "</a>")
      };
    }
    return {
      score: this._config.scores.okay,
      resultText: (0, _i18n.sprintf)(/* translators:  %1$s and %2$s expand to links on yoast.com, %3$s expands to the anchor end tag */
      (0, _i18n.__)("%1$sKeyphrase in slug%3$s: (Part of) your keyphrase does not appear in the slug. %2$sChange that%3$s!", "wordpress-seo"), this._config.urlTitle, this._config.urlCallToAction, "</a>")
    };
  }
}

/**
 * This assessment checks if the keyword is present in the slug.
 * UrlKeywordAssessment was the previous name for SlugKeywordAssessment (hence the name of this file).
 * We keep (and expose) this assessment for backwards compatibility.
 *
 * @deprecated Since version 18.8 Use SlugKeywordAssessment instead.
 */
exports.SlugKeywordAssessment = SlugKeywordAssessment;
class UrlKeywordAssessment extends SlugKeywordAssessment {
  /**
   * Sets the identifier and the config.
   *
   * @param {Object} config   The configuration to use.
   * @returns {void}
   */
  constructor(config = {}) {
    super(config);
    this.identifier = "urlKeyword";
    console.warn("This object is deprecated, use SlugKeywordAssessment instead.");
  }
}
exports.UrlKeywordAssessment = UrlKeywordAssessment;
var _default = exports["default"] = SlugKeywordAssessment;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/assessor.js":
/*!*********************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/assessor.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _missingArgument = _interopRequireDefault(__webpack_require__(/*! ../errors/missingArgument */ "./node_modules/yoastseo/build/errors/missingArgument.js"));
var _removeDuplicateMarks = _interopRequireDefault(__webpack_require__(/*! ../markers/removeDuplicateMarks */ "./node_modules/yoastseo/build/markers/removeDuplicateMarks.js"));
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../values/AssessmentResult.js */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _errors = __webpack_require__(/*! ../helpers/errors.js */ "./node_modules/yoastseo/build/helpers/errors.js");
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _LanguageProcessor = _interopRequireDefault(__webpack_require__(/*! ../parse/language/LanguageProcessor */ "./node_modules/yoastseo/build/parse/language/LanguageProcessor.js"));
var _build = __webpack_require__(/*! ../parse/build */ "./node_modules/yoastseo/build/parse/build/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
// The maximum score of individual assessment is 9. This is why we set the "score rating" here to 9.
const ScoreRating = 9;

/**
 * Creates the Assessor.
 *
 * @param {Researcher} researcher   The researcher to use in the assessor.
 * @param {Object?} options         The options for this assessor.
 * @param {Function} options.marker The marker to pass the list of marks to.
 *
 * @constructor
 */
const Assessor = function (researcher, options) {
  this.type = "assessor";
  this.setResearcher(researcher);
  this._assessments = [];
  this._options = options || {};
};

/**
 * Checks if the researcher is defined and sets it.
 *
 * @param   {Researcher} researcher The researcher to use in the assessor.
 *
 * @throws  {MissingArgument} Parameter needs to be a valid researcher object.
 * @returns {void}
 */
Assessor.prototype.setResearcher = function (researcher) {
  if ((0, _lodash.isUndefined)(researcher)) {
    throw new _missingArgument.default("The assessor requires a researcher.");
  }
  this._researcher = researcher;
};

/**
 * Gets all available assessments.
 * @returns {object} assessment
 */
Assessor.prototype.getAvailableAssessments = function () {
  return this._assessments;
};

/**
 * Checks whether the Assessment is applicable.
 *
 * @param {Object} assessment The Assessment object that needs to be checked.
 * @param {Paper} paper The Paper object to check against.
 * @param {Researcher} [researcher] The Researcher object containing additional information.
 * @returns {boolean} Whether or not the Assessment is applicable.
 */
Assessor.prototype.isApplicable = function (assessment, paper, researcher) {
  if (assessment.hasOwnProperty("isApplicable") || typeof assessment.isApplicable === "function") {
    return assessment.isApplicable(paper, researcher);
  }
  return true;
};

/**
 * Determines whether an assessment has a marker.
 *
 * @param {Object} assessment The assessment to check for.
 * @returns {boolean} Whether or not the assessment has a marker.
 */
Assessor.prototype.hasMarker = function (assessment) {
  return (0, _lodash.isFunction)(this._options.marker) && (assessment.hasOwnProperty("getMarks") || typeof assessment.getMarks === "function");
};

/**
 * Returns the specific marker for this assessor.
 *
 * @returns {Function} The specific marker for this assessor.
 */
Assessor.prototype.getSpecificMarker = function () {
  return this._options.marker;
};

/**
 * Returns the paper that was most recently assessed.
 *
 * @returns {Paper} The paper that was most recently assessed.
 */
Assessor.prototype.getPaper = function () {
  return this._lastPaper;
};

/**
 * Returns the marker for a given assessment, composes the specific marker with the assessment getMarks function.
 *
 * @param {Object} assessment The assessment for which we are retrieving the composed marker.
 * @param {Paper} paper The paper to retrieve the marker for.
 * @param {Researcher} researcher The researcher for the paper.
 * @returns {Function} A function that can mark the given paper according to the given assessment.
 */
Assessor.prototype.getMarker = function (assessment, paper, researcher) {
  const specificMarker = this._options.marker;
  return function () {
    let marks = assessment.getMarks(paper, researcher);
    marks = (0, _removeDuplicateMarks.default)(marks);
    specificMarker(paper, marks);
  };
};

/**
 * Runs the researches defined in the task list or the default researches.
 *
 * @param {Paper} paper The paper to run assessments on.
 * @returns {void}
 */
Assessor.prototype.assess = function (paper) {
  this._researcher.setPaper(paper);
  const languageProcessor = new _LanguageProcessor.default(this._researcher);
  const shortcodes = paper._attributes && paper._attributes.shortcodes;
  paper.setTree((0, _build.build)(paper, languageProcessor, shortcodes));
  let assessments = this.getAvailableAssessments();
  this.results = [];
  assessments = (0, _lodash.filter)(assessments, function (assessment) {
    return this.isApplicable(assessment, paper, this._researcher);
  }.bind(this));
  this.setHasMarkers(false);
  this.results = (0, _lodash.map)(assessments, this.executeAssessment.bind(this, paper, this._researcher));
  this._lastPaper = paper;
};

/**
 * Sets the value of has markers with a boolean to determine if there are markers.
 *
 * @param {boolean} hasMarkers True when there are markers, otherwise it is false.
 * @returns {void}
 */
Assessor.prototype.setHasMarkers = function (hasMarkers) {
  this._hasMarkers = hasMarkers;
};

/**
 * Returns true when there are markers.
 *
 * @returns {boolean} Are there markers
 */
Assessor.prototype.hasMarkers = function () {
  return this._hasMarkers;
};

/**
 * Executes an assessment and returns the AssessmentResult.
 *
 * @param {Paper} paper The paper to pass to the assessment.
 * @param {Researcher} researcher The researcher to pass to the assessment.
 * @param {Object} assessment The assessment to execute.
 * @returns {AssessmentResult} The result of the assessment.
 */
Assessor.prototype.executeAssessment = function (paper, researcher, assessment) {
  let result;
  try {
    result = assessment.getResult(paper, researcher);
    result.setIdentifier(assessment.identifier);
    if (result.hasMarks()) {
      result.marks = assessment.getMarks(paper, researcher);
      result.marks = (0, _removeDuplicateMarks.default)(result.marks);
    }
    if (result.hasMarks() && this.hasMarker(assessment)) {
      this.setHasMarkers(true);
      result.setMarker(this.getMarker(assessment, paper, researcher));
    }
  } catch (assessmentError) {
    (0, _errors.showTrace)(assessmentError);
    result = new _AssessmentResult.default();
    result.setScore(-1);
    result.setText((0, _i18n.sprintf)(/* translators: %1$s expands to the name of the assessment. */
    (0, _i18n.__)("An error occurred in the '%1$s' assessment", "wordpress-seo"), assessment.identifier, assessmentError));
  }
  return result;
};

/**
 * Filters out all assessment results that have no score and no text.
 *
 * @returns {Array<AssessmentResult>} The array with all the valid assessments.
 */
Assessor.prototype.getValidResults = function () {
  return (0, _lodash.filter)(this.results, function (result) {
    return this.isValidResult(result);
  }.bind(this));
};

/**
 * Returns if an assessmentResult is valid.
 *
 * @param {object} assessmentResult The assessmentResult to validate.
 * @returns {boolean} whether or not the result is valid.
 */
Assessor.prototype.isValidResult = function (assessmentResult) {
  return assessmentResult.hasScore() && assessmentResult.hasText();
};

/**
 * Returns the overall score. Calculates the total score by adding all scores and dividing these
 * by the number of results times the ScoreRating.
 *
 * @returns {number} The overall score.
 */
Assessor.prototype.calculateOverallScore = function () {
  const results = this.getValidResults();
  const totalScore = results.reduce((total, assessmentResult) => total + assessmentResult.getScore(), 0);
  return Math.round(totalScore / (results.length * ScoreRating) * 100) || 0;
};

/**
 * Register an assessment to add it to the internal assessments object.
 *
 * @param {string} name The name of the assessment.
 * @param {object} assessment The object containing function to run as an assessment and it's requirements.
 * @returns {boolean} Whether registering the assessment was successful.
 * @private
 */
Assessor.prototype.addAssessment = function (name, assessment) {
  if (!assessment.hasOwnProperty("identifier")) {
    assessment.identifier = name;
  }
  // If the assessor already has the same assessment, remove it and replace it with the new assessment with the same identifier.
  if (this.getAssessment(assessment.identifier)) {
    this.removeAssessment(assessment.identifier);
  }
  this._assessments.push(assessment);
  return true;
};

/**
 * Remove a specific Assessment from the list of Assessments.
 *
 * @param {string} name The Assessment to remove from the list of assessments.
 * @returns {void}
 */
Assessor.prototype.removeAssessment = function (name) {
  const toDelete = (0, _lodash.findIndex)(this._assessments, function (assessment) {
    return assessment.hasOwnProperty("identifier") && name === assessment.identifier;
  });
  if (-1 !== toDelete) {
    this._assessments.splice(toDelete, 1);
  }
};

/**
 * Returns an assessment by identifier
 *
 * @param {string} identifier The identifier of the assessment.
 * @returns {undefined|Assessment} The object if found, otherwise undefined.
 */
Assessor.prototype.getAssessment = function (identifier) {
  return (0, _lodash.find)(this._assessments, function (assessment) {
    return assessment.hasOwnProperty("identifier") && identifier === assessment.identifier;
  });
};

/**
 * Checks which of the available assessments are applicable and returns an array with applicable assessments.
 *
 * @returns {Array} The array with applicable assessments.
 */
Assessor.prototype.getApplicableAssessments = function () {
  const availableAssessments = this.getAvailableAssessments();
  return (0, _lodash.filter)(availableAssessments, function (availableAssessment) {
    return this.isApplicable(availableAssessment, this.getPaper(), this._researcher);
  }.bind(this));
};
var _default = exports["default"] = Assessor;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/contentAssessor.js":
/*!****************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/contentAssessor.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _assessor = _interopRequireDefault(__webpack_require__(/*! ./assessor.js */ "./node_modules/yoastseo/build/scoring/assessor.js"));
var _ParagraphTooLongAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/readability/ParagraphTooLongAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/readability/ParagraphTooLongAssessment.js"));
var _SentenceLengthInTextAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/readability/SentenceLengthInTextAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/readability/SentenceLengthInTextAssessment.js"));
var _SubheadingDistributionTooLongAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/readability/SubheadingDistributionTooLongAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/readability/SubheadingDistributionTooLongAssessment.js"));
var _TransitionWordsAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/readability/TransitionWordsAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/readability/TransitionWordsAssessment.js"));
var _PassiveVoiceAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/readability/PassiveVoiceAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/readability/PassiveVoiceAssessment.js"));
var _SentenceBeginningsAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/readability/SentenceBeginningsAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/readability/SentenceBeginningsAssessment.js"));
var _TextPresenceAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/readability/TextPresenceAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/readability/TextPresenceAssessment.js"));
var _scoreToRating = _interopRequireDefault(__webpack_require__(/*! ./interpreters/scoreToRating */ "./node_modules/yoastseo/build/scoring/interpreters/scoreToRating.js"));
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/*
	Temporarily disabled:
	var sentenceLengthInDescription = require( "./assessments/sentenceLengthInDescriptionAssessment.js" );
 */

/**
 * Creates the Assessor
 *
 * @param {object}  researcher      The researcher to use for the analysis.
 * @param {Object}  options         The options for this assessor.
 * @param {Object}  options.marker  The marker to pass the list of marks to.
 *
 * @constructor
 */
const ContentAssessor = function (researcher, options = {}) {
  _assessor.default.call(this, researcher, options);
  this.type = "contentAssessor";
  this._assessments = [new _SubheadingDistributionTooLongAssessment.default(), new _ParagraphTooLongAssessment.default(), new _SentenceLengthInTextAssessment.default(), new _TransitionWordsAssessment.default(), new _PassiveVoiceAssessment.default(), new _TextPresenceAssessment.default(), new _SentenceBeginningsAssessment.default()
  // Temporarily disabled: wordComplexity,
  ];
};
(__webpack_require__(/*! util */ "./node_modules/util/util.js").inherits)(ContentAssessor, _assessor.default);

/**
 * Calculates the weighted rating for languages that have all assessments based on a given rating.
 *
 * @param {number} rating The rating to be weighted.
 * @returns {number} The weighted rating.
 */
ContentAssessor.prototype.calculatePenaltyPointsFullSupport = function (rating) {
  switch (rating) {
    case "bad":
      return 3;
    case "ok":
      return 2;
    default:
    case "good":
      return 0;
  }
};

/**
 * Calculates the weighted rating for languages that don't have all assessments based on a given rating.
 *
 * @param {number} rating The rating to be weighted.
 * @returns {number} The weighted rating.
 */
ContentAssessor.prototype.calculatePenaltyPointsPartialSupport = function (rating) {
  switch (rating) {
    case "bad":
      return 4;
    case "ok":
      return 2;
    default:
    case "good":
      return 0;
  }
};

/**
 * Determines whether a language is fully supported. If a language supports 8 content assessments
 * it is fully supported
 *
 * @returns {boolean} True if fully supported.
 */
ContentAssessor.prototype._allAssessmentsSupported = function () {
  const numberOfAssessments = this._assessments.length;
  const applicableAssessments = this.getApplicableAssessments();
  return applicableAssessments.length === numberOfAssessments;
};

/**
 * Calculates the penalty points based on the assessment results.
 *
 * @returns {number} The total penalty points for the results.
 */
ContentAssessor.prototype.calculatePenaltyPoints = function () {
  const results = this.getValidResults();
  const penaltyPoints = (0, _lodash.map)(results, function (result) {
    const rating = (0, _scoreToRating.default)(result.getScore());
    if (this._allAssessmentsSupported()) {
      return this.calculatePenaltyPointsFullSupport(rating);
    }
    return this.calculatePenaltyPointsPartialSupport(rating);
  }.bind(this));
  return (0, _lodash.sum)(penaltyPoints);
};

/**
 * Rates the penalty points
 *
 * @param {number} totalPenaltyPoints The amount of penalty points.
 * @returns {number} The score based on the amount of penalty points.
 *
 * @private
 */
ContentAssessor.prototype._ratePenaltyPoints = function (totalPenaltyPoints) {
  if (this.getValidResults().length === 1) {
    // If we have only 1 result, we only have a "no content" result
    return 30;
  }
  if (this._allAssessmentsSupported()) {
    // Determine the total score based on the total penalty points.
    if (totalPenaltyPoints > 6) {
      // A red indicator.
      return 30;
    }
    if (totalPenaltyPoints > 4) {
      // An orange indicator.
      return 60;
    }
  } else {
    if (totalPenaltyPoints > 4) {
      // A red indicator.
      return 30;
    }
    if (totalPenaltyPoints > 2) {
      // An orange indicator.
      return 60;
    }
  }
  // A green indicator.
  return 90;
};

/**
 * Calculates the overall score based on the assessment results.
 *
 * @returns {number} The overall score.
 */
ContentAssessor.prototype.calculateOverallScore = function () {
  const results = this.getValidResults();

  // If you have no content, you have a red indicator.
  if (results.length === 0) {
    return 30;
  }
  const totalPenaltyPoints = this.calculatePenaltyPoints();
  return this._ratePenaltyPoints(totalPenaltyPoints);
};
var _default = exports["default"] = ContentAssessor;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/cornerstone/contentAssessor.js":
/*!****************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/cornerstone/contentAssessor.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _assessor = _interopRequireDefault(__webpack_require__(/*! ../assessor.js */ "./node_modules/yoastseo/build/scoring/assessor.js"));
var _contentAssessor = _interopRequireDefault(__webpack_require__(/*! ../contentAssessor */ "./node_modules/yoastseo/build/scoring/contentAssessor.js"));
var _ParagraphTooLongAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/readability/ParagraphTooLongAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/readability/ParagraphTooLongAssessment.js"));
var _SentenceLengthInTextAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/readability/SentenceLengthInTextAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/readability/SentenceLengthInTextAssessment.js"));
var _SubheadingDistributionTooLongAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/readability/SubheadingDistributionTooLongAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/readability/SubheadingDistributionTooLongAssessment.js"));
var _TransitionWordsAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/readability/TransitionWordsAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/readability/TransitionWordsAssessment.js"));
var _PassiveVoiceAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/readability/PassiveVoiceAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/readability/PassiveVoiceAssessment.js"));
var _SentenceBeginningsAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/readability/SentenceBeginningsAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/readability/SentenceBeginningsAssessment.js"));
var _TextPresenceAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/readability/TextPresenceAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/readability/TextPresenceAssessment.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/*
 Temporarily disabled:

 var sentenceLengthInDescription = require( "./assessments/readability/sentenceLengthInDescriptionAssessment.js" );
 */

/**
 * Creates the Assessor
 *
 * @param {object} researcher       The researcher used for the analysis.
 * @param {Object} options          The options for this assessor.
 * @param {Object} options.marker   The marker to pass the list of marks to.
 *
 * @constructor
 */
const CornerStoneContentAssessor = function (researcher, options = {}) {
  _assessor.default.call(this, researcher, options);
  this.type = "cornerstoneContentAssessor";
  this._assessments = [new _SubheadingDistributionTooLongAssessment.default({
    parameters: {
      slightlyTooMany: 250,
      farTooMany: 300,
      recommendedMaximumLength: 250
    },
    applicableIfTextLongerThan: 250,
    cornerstoneContent: true
  }), new _ParagraphTooLongAssessment.default(), new _SentenceLengthInTextAssessment.default({
    slightlyTooMany: 20,
    farTooMany: 25
  }, true), new _TransitionWordsAssessment.default(), new _PassiveVoiceAssessment.default(), new _TextPresenceAssessment.default(), new _SentenceBeginningsAssessment.default()
  // Temporarily disabled: wordComplexity,
  ];
};
(__webpack_require__(/*! util */ "./node_modules/util/util.js").inherits)(CornerStoneContentAssessor, _contentAssessor.default);
var _default = exports["default"] = CornerStoneContentAssessor;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/cornerstone/relatedKeywordAssessor.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/cornerstone/relatedKeywordAssessor.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _util = __webpack_require__(/*! util */ "./node_modules/util/util.js");
var _assessor = _interopRequireDefault(__webpack_require__(/*! ../assessor.js */ "./node_modules/yoastseo/build/scoring/assessor.js"));
var _IntroductionKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/IntroductionKeywordAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/seo/IntroductionKeywordAssessment.js"));
var _KeyphraseLengthAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/KeyphraseLengthAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseLengthAssessment.js"));
var _KeywordDensityAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/KeywordDensityAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeywordDensityAssessment.js"));
var _MetaDescriptionKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/MetaDescriptionKeywordAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/seo/MetaDescriptionKeywordAssessment.js"));
var _TextCompetingLinksAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/TextCompetingLinksAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/seo/TextCompetingLinksAssessment.js"));
var _FunctionWordsInKeyphraseAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/FunctionWordsInKeyphraseAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/FunctionWordsInKeyphraseAssessment.js"));
var _KeyphraseInImageTextAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/KeyphraseInImageTextAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseInImageTextAssessment.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Creates the Assessor
 *
 * @param {Researcher} researcher    The researcher used for the analysis.
 * @param {Object?} options          The options for this assessor.
 * @param {Function} options.marker  The marker to pass the list of marks to.
 *
 * @constructor
 */
const relatedKeywordAssessor = function (researcher, options) {
  _assessor.default.call(this, researcher, options);
  this.type = "cornerstoneRelatedKeywordAssessor";
  this._assessments = [new _IntroductionKeywordAssessment.default(), new _KeyphraseLengthAssessment.default({
    isRelatedKeyphrase: true
  }), new _KeywordDensityAssessment.default(), new _MetaDescriptionKeywordAssessment.default(), new _TextCompetingLinksAssessment.default(), new _FunctionWordsInKeyphraseAssessment.default(), new _KeyphraseInImageTextAssessment.default({
    scores: {
      withAltNonKeyword: 3,
      withAlt: 3,
      noAlt: 3
    }
  })];
};
(0, _util.inherits)(relatedKeywordAssessor, _assessor.default);
var _default = exports["default"] = relatedKeywordAssessor;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/cornerstone/seoAssessor.js":
/*!************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/cornerstone/seoAssessor.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _util = __webpack_require__(/*! util */ "./node_modules/util/util.js");
var _IntroductionKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/IntroductionKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/IntroductionKeywordAssessment.js"));
var _KeyphraseLengthAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/KeyphraseLengthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseLengthAssessment.js"));
var _KeywordDensityAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/KeywordDensityAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeywordDensityAssessment.js"));
var _MetaDescriptionKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/MetaDescriptionKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/MetaDescriptionKeywordAssessment.js"));
var _TextCompetingLinksAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/TextCompetingLinksAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/TextCompetingLinksAssessment.js"));
var _InternalLinksAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/InternalLinksAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/InternalLinksAssessment.js"));
var _KeyphraseInSEOTitleAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/KeyphraseInSEOTitleAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseInSEOTitleAssessment.js"));
var _UrlKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/UrlKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/UrlKeywordAssessment.js"));
var _assessor = _interopRequireDefault(__webpack_require__(/*! ../assessor */ "./node_modules/yoastseo/build/scoring/assessor.js"));
var _seoAssessor = _interopRequireDefault(__webpack_require__(/*! ../seoAssessor */ "./node_modules/yoastseo/build/scoring/seoAssessor.js"));
var _MetaDescriptionLengthAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/MetaDescriptionLengthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/MetaDescriptionLengthAssessment.js"));
var _SubHeadingsKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/SubHeadingsKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/SubHeadingsKeywordAssessment.js"));
var _KeyphraseInImageTextAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/KeyphraseInImageTextAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseInImageTextAssessment.js"));
var _ImageCountAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/ImageCountAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/ImageCountAssessment.js"));
var _TextLengthAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/TextLengthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/TextLengthAssessment.js"));
var _OutboundLinksAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/OutboundLinksAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/OutboundLinksAssessment.js"));
var _PageTitleWidthAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/PageTitleWidthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/PageTitleWidthAssessment.js"));
var _FunctionWordsInKeyphraseAssessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/FunctionWordsInKeyphraseAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/FunctionWordsInKeyphraseAssessment.js"));
var _SingleH1Assessment = _interopRequireDefault(__webpack_require__(/*! ../assessments/seo/SingleH1Assessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/SingleH1Assessment.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Creates the Assessor
 *
 * @param {Researcher} researcher    The researcher used for the analysis.
 * @param {Object?} options          The options for this assessor.
 * @param {Function} options.marker  The marker to pass the list of marks to.
 *
 * @constructor
 */
const CornerstoneSEOAssessor = function (researcher, options) {
  _assessor.default.call(this, researcher, options);
  this.type = "cornerstoneSEOAssessor";
  this._assessments = [new _IntroductionKeywordAssessment.default(), new _KeyphraseLengthAssessment.default(), new _KeywordDensityAssessment.default(), new _MetaDescriptionKeywordAssessment.default(), new _MetaDescriptionLengthAssessment.default({
    scores: {
      tooLong: 3,
      tooShort: 3
    }
  }), new _SubHeadingsKeywordAssessment.default(), new _TextCompetingLinksAssessment.default(), new _KeyphraseInImageTextAssessment.default({
    scores: {
      withAltNonKeyword: 3,
      withAlt: 3,
      noAlt: 3
    }
  }), new _ImageCountAssessment.default(), new _TextLengthAssessment.default({
    recommendedMinimum: 900,
    slightlyBelowMinimum: 400,
    belowMinimum: 300,
    scores: {
      belowMinimum: -20,
      farBelowMinimum: -20
    },
    cornerstoneContent: true
  }), new _OutboundLinksAssessment.default({
    scores: {
      noLinks: 3
    }
  }), new _KeyphraseInSEOTitleAssessment.default(), new _InternalLinksAssessment.default(), new _PageTitleWidthAssessment.default({
    scores: {
      widthTooShort: 9
    }
  }, true), new _UrlKeywordAssessment.default({
    scores: {
      okay: 3
    }
  }), new _FunctionWordsInKeyphraseAssessment.default(), new _SingleH1Assessment.default()];
};
(0, _util.inherits)(CornerstoneSEOAssessor, _seoAssessor.default);
var _default = exports["default"] = CornerstoneSEOAssessor;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/helpers/assessments/checkForTooLongSentences.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/helpers/assessments/checkForTooLongSentences.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Checks for too long sentences.
 * @param {array} sentences The array with objects containing sentences and their lengths.
 * @param {number} recommendedValue The recommended maximum length of sentence.
 * @returns {array} The array with objects containing too long sentences and their lengths.
 */
function _default(sentences, recommendedValue) {
  return (0, _lodash.filter)(sentences, function (sentence) {
    return sentence.sentenceLength > recommendedValue;
  });
}

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/helpers/assessments/inRange.js":
/*!****************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/helpers/assessments/inRange.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
exports.inRangeEndInclusive = exports.inRange = inRangeEndInclusive;
exports.inRangeStartEndInclusive = inRangeStartEndInclusive;
exports.inRangeStartInclusive = inRangeStartInclusive;
/**
 * Checks if `n` is between `start` and `end` but not including `start`.
 *
 * @param {number} number The number to check.
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
 */
function inRangeEndInclusive(number, start, end) {
  return number > start && number <= end;
}

/**
 * Checks if `n` is between `start` and up to, but not including, `end`.
 *
 * @param {number} number The number to check.
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
 */
function inRangeStartInclusive(number, start, end) {
  return number >= start && number < end;
}

/**
 * Checks if `n` is between `start` and `end`, including both.
 *
 * @param {number} number The number to check.
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
 */
function inRangeStartEndInclusive(number, start, end) {
  return number >= start && number <= end;
}
var _default = exports["default"] = {
  inRange: inRangeEndInclusive,
  inRangeStartInclusive: inRangeStartInclusive,
  inRangeEndInclusive: inRangeEndInclusive,
  inRangeStartEndInclusive: inRangeStartEndInclusive
};

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/helpers/assessments/keyphraseLengthFactor.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/helpers/assessments/keyphraseLengthFactor.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
/**
 * Calculates the keyphrase length weighting factor used to calculate the keyword density and the recommended keyword count.
 * Keyphrase length gets a base weight of 0.7, plus a specific weight for the keyphrase length (keyphraseLength / 3).
 *
 * @param {number} keyphraseLength The length of the keyphrase in words.
 * @returns {number} The keyphrase length weighting factor.
 */
function _default(keyphraseLength) {
  return 0.7 + keyphraseLength / 3;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/helpers/assessments/recommendedKeywordCount.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/helpers/assessments/recommendedKeywordCount.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
var _getAllWordsFromTree = _interopRequireDefault(__webpack_require__(/*! ../../../languageProcessing/helpers/word/getAllWordsFromTree */ "./node_modules/yoastseo/build/languageProcessing/helpers/word/getAllWordsFromTree.js"));
var _keyphraseLengthFactor = _interopRequireDefault(__webpack_require__(/*! ./keyphraseLengthFactor.js */ "./node_modules/yoastseo/build/scoring/helpers/assessments/keyphraseLengthFactor.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Calculates a recommended keyphrase count for a paper's text. The formula to calculate this number is based on the
 * keyphrase density formula.
 *
 * @param {Paper}	paper						The paper to analyze.
 * @param {number}	keyphraseLength				The length of the focus keyphrase in words.
 * @param {number}	recommendedKeyphraseDensity	The recommended keyphrase density (either maximum or minimum).
 * @param {string}	maxOrMin					Whether it's a maximum or minimum recommended keyphrase density.
 * @param {function} customGetWords				A helper to get words from the text for languages that don't use the default approach.
 *
 * @returns {number} The recommended keyphrase count.
 */
function _default(paper, keyphraseLength, recommendedKeyphraseDensity, maxOrMin, customGetWords) {
  const wordCount = customGetWords ? customGetWords(paper.getText()).length : (0, _getAllWordsFromTree.default)(paper).length;
  if (wordCount === 0) {
    return 0;
  }
  const lengthKeyphraseFactor = (0, _keyphraseLengthFactor.default)(keyphraseLength);
  const recommendedKeyphraseCount = recommendedKeyphraseDensity * wordCount / (100 * lengthKeyphraseFactor);

  /*
   * The recommended keyphrase count should always be at least 2,
   * regardless of the keyphrase density, the word count, or the keyphrase length.
   */
  if (recommendedKeyphraseCount < 2) {
    return 2;
  }
  switch (maxOrMin) {
    case "min":
      // Round up for the recommended minimum count.
      return Math.ceil(recommendedKeyphraseCount);
    default:
    case "max":
      // Round down for the recommended maximum count.
      return Math.floor(recommendedKeyphraseCount);
  }
}

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/inclusiveLanguageAssessor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/inclusiveLanguageAssessor.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _assessor = _interopRequireDefault(__webpack_require__(/*! ./assessor */ "./node_modules/yoastseo/build/scoring/assessor.js"));
var _configuration = _interopRequireDefault(__webpack_require__(/*! ./assessments/inclusiveLanguage/configuration */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/configuration/index.js"));
var _InclusiveLanguageAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/inclusiveLanguage/InclusiveLanguageAssessment */ "./node_modules/yoastseo/build/scoring/assessments/inclusiveLanguage/InclusiveLanguageAssessment.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Default options for the Inclusive language assessor.
 * The infoLinks object includes the shortlinks to be used in WordPress.
 *
 * @type {{infoLinks: {}}}
 */
const defaultOptions = {
  infoLinks: {}
};

/**
 * An assessor that assesses a paper for potentially non-inclusive language.
 */
class InclusiveLanguageAssessor extends _assessor.default {
  /**
   * Creates a new inclusive language assessor.
   *
   * @param {Researcher}  	researcher 		The researcher to use.
   * @param {Object}      	[options] 		The assessor options.
   */
  constructor(researcher, options = {}) {
    super(researcher, options);
    this.type = "inclusiveLanguageAssessor";
    // Assign the options, fall back to a default value for options that are not set.
    // The "options" object will be populated with shortlinks for Shopify in the Shopify repository.
    this._options = Object.assign({}, defaultOptions, options);
    const infoLinks = this._options.infoLinks;
    this._assessments = _configuration.default.map(config => {
      // The if statement is a safety check to assure that the infoLinks object includes keys for all assessments.
      // If the category keys match the config categories, the infoLinks shortlinks are saved as the learnMoreURL of the config.
      if (infoLinks[config.category]) {
        config.learnMoreUrl = infoLinks[config.category];
      }
      return new _InclusiveLanguageAssessment.default(config);
    });
  }

  /**
   * Calculates the overall score.
   *
   * @returns {number} The overall score.
   */
  calculateOverallScore() {
    const results = this.getValidResults();
    const improvementResults = results.filter(result => result.getScore() === 6);
    const problemResults = results.filter(result => result.getScore() === 3);
    if (problemResults.length >= 1) {
      return 30;
    } else if (improvementResults.length >= 1) {
      return 60;
    }
    return 90;
  }
}
var _default = exports["default"] = InclusiveLanguageAssessor;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/interpreters/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/interpreters/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "scoreToRating", ({
  enumerable: true,
  get: function () {
    return _scoreToRating.default;
  }
}));
var _scoreToRating = _interopRequireDefault(__webpack_require__(/*! ./scoreToRating */ "./node_modules/yoastseo/build/scoring/interpreters/scoreToRating.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/interpreters/scoreToRating.js":
/*!***************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/interpreters/scoreToRating.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Interpreters a score and gives it a particular rating.
 *
 * @param {Number} score The score to interpreter.
 * @returns {string} The rating, given based on the score.
 */
const ScoreToRating = function (score) {
  if (score === -1) {
    return "error";
  }
  if (score === 0) {
    return "feedback";
  }
  if (score <= 4) {
    return "bad";
  }
  if (score > 4 && score <= 7) {
    return "ok";
  }
  if (score > 7) {
    return "good";
  }
  return "";
};
var _default = exports["default"] = ScoreToRating;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/relatedKeywordAssessor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/relatedKeywordAssessor.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _util = __webpack_require__(/*! util */ "./node_modules/util/util.js");
var _assessor = _interopRequireDefault(__webpack_require__(/*! ./assessor.js */ "./node_modules/yoastseo/build/scoring/assessor.js"));
var _IntroductionKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/IntroductionKeywordAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/seo/IntroductionKeywordAssessment.js"));
var _KeyphraseLengthAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/KeyphraseLengthAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseLengthAssessment.js"));
var _KeywordDensityAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/KeywordDensityAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeywordDensityAssessment.js"));
var _MetaDescriptionKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/MetaDescriptionKeywordAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/seo/MetaDescriptionKeywordAssessment.js"));
var _KeyphraseInImageTextAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/KeyphraseInImageTextAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseInImageTextAssessment.js"));
var _TextCompetingLinksAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/TextCompetingLinksAssessment.js */ "./node_modules/yoastseo/build/scoring/assessments/seo/TextCompetingLinksAssessment.js"));
var _FunctionWordsInKeyphraseAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/FunctionWordsInKeyphraseAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/FunctionWordsInKeyphraseAssessment.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Creates the Assessor
 *
 * @param {Researcher} researcher      The researcher to use for the analysis.
 * @param {Object?}    options         The options for this assessor.
 * @param {Function}   options.marker  The marker to pass the list of marks to.
 *
 * @constructor
 */
const relatedKeywordAssessor = function (researcher, options) {
  _assessor.default.call(this, researcher, options);
  this.type = "relatedKeywordAssessor";
  this._assessments = [new _IntroductionKeywordAssessment.default(), new _KeyphraseLengthAssessment.default({
    isRelatedKeyphrase: true
  }), new _KeywordDensityAssessment.default(), new _MetaDescriptionKeywordAssessment.default(), new _TextCompetingLinksAssessment.default(), new _FunctionWordsInKeyphraseAssessment.default(), new _KeyphraseInImageTextAssessment.default()];
};
(0, _util.inherits)(relatedKeywordAssessor, _assessor.default);
var _default = exports["default"] = relatedKeywordAssessor;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/relatedKeywordTaxonomyAssessor.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/relatedKeywordTaxonomyAssessor.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _util = __webpack_require__(/*! util */ "./node_modules/util/util.js");
var _IntroductionKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/IntroductionKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/IntroductionKeywordAssessment.js"));
var _KeyphraseLengthAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/KeyphraseLengthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseLengthAssessment.js"));
var _KeywordDensityAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/KeywordDensityAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeywordDensityAssessment.js"));
var _MetaDescriptionKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/MetaDescriptionKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/MetaDescriptionKeywordAssessment.js"));
var _assessor = _interopRequireDefault(__webpack_require__(/*! ./assessor */ "./node_modules/yoastseo/build/scoring/assessor.js"));
var _FunctionWordsInKeyphraseAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/FunctionWordsInKeyphraseAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/FunctionWordsInKeyphraseAssessment.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Creates the Assessor used for taxonomy pages.
 *
 * @param {Researcher}  researcher  The researcher to use for the analysis.
 * @param {Object?}  options        The options for this assessor.
 *
 * @constructor
 */
const RelatedKeywordTaxonomyAssessor = function (researcher, options) {
  _assessor.default.call(this, researcher, options);
  this.type = "relatedKeywordsTaxonomyAssessor";
  this._assessments = [new _IntroductionKeywordAssessment.default(), new _KeyphraseLengthAssessment.default({
    isRelatedKeyphrase: true
  }), new _KeywordDensityAssessment.default(), new _MetaDescriptionKeywordAssessment.default(),
  // Text Images assessment here.
  new _FunctionWordsInKeyphraseAssessment.default()];
};
(0, _util.inherits)(RelatedKeywordTaxonomyAssessor, _assessor.default);
var _default = exports["default"] = RelatedKeywordTaxonomyAssessor;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/renderers/AssessorPresenter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/renderers/AssessorPresenter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _scoreToRating = _interopRequireDefault(__webpack_require__(/*! ../interpreters/scoreToRating.js */ "./node_modules/yoastseo/build/scoring/interpreters/scoreToRating.js"));
var _presenter = _interopRequireDefault(__webpack_require__(/*! ../../config/presenter.js */ "./node_modules/yoastseo/build/config/presenter.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Constructs the AssessorPresenter.
 *
 * @param {Object} args A list of arguments to use in the presenter.
 * @param {object} args.targets The HTML elements to render the output to.
 * @param {string} args.targets.output The HTML element to render the individual ratings out to.
 * @param {string} args.targets.overall The HTML element to render the overall rating out to.
 * @param {string} args.keyword The keyword to use for checking, when calculating the overall rating.
 * @param {SEOAssessor} args.assessor The Assessor object to retrieve assessment results from.
 *
 * @constructor
 */
var AssessorPresenter = function (args) {
  this.keyword = args.keyword;
  this.assessor = args.assessor;
  this.output = args.targets.output;
  this.overall = args.targets.overall || "overallScore";
  this.presenterConfig = (0, _presenter.default)();
  this._disableMarkerButtons = false;
  this._activeMarker = false;
};

/**
 * Sets the keyword.
 *
 * @param {string} keyword The keyword to use.
 * @returns {void}
 */
AssessorPresenter.prototype.setKeyword = function (keyword) {
  this.keyword = keyword;
};

/**
 * Checks whether a specific property exists in the presenter configuration.
 *
 * @param {string} property The property name to search for.
 * @returns {boolean} Whether or not the property exists.
 */
AssessorPresenter.prototype.configHasProperty = function (property) {
  return this.presenterConfig.hasOwnProperty(property);
};

/**
 * Gets a fully formatted indicator object that can be used.
 *
 * @param {string} rating The rating to use.
 * @returns {Object} An object containing the class, the screen reader text, and the full text.
 */
AssessorPresenter.prototype.getIndicator = function (rating) {
  return {
    className: this.getIndicatorColorClass(rating),
    screenReaderText: this.getIndicatorScreenReaderText(rating),
    fullText: this.getIndicatorFullText(rating),
    screenReaderReadabilityText: this.getIndicatorScreenReaderReadabilityText(rating)
  };
};

/**
 * Gets the indicator color class from the presenter configuration, if it exists.
 *
 * @param {string} rating The rating to check against the config.
 * @returns {string} String containing the CSS class to be used.
 */
AssessorPresenter.prototype.getIndicatorColorClass = function (rating) {
  if (!this.configHasProperty(rating)) {
    return "";
  }
  return this.presenterConfig[rating].className;
};

/**
 * Get the indicator screen reader text from the presenter configuration, if it exists.
 *
 * @param {string} rating The rating to check against the config.
 * @returns {string} Translated string containing the screen reader text to be used.
 */
AssessorPresenter.prototype.getIndicatorScreenReaderText = function (rating) {
  if (!this.configHasProperty(rating)) {
    return "";
  }
  return this.presenterConfig[rating].screenReaderText;
};

/**
 * Get the indicator screen reader readability text from the presenter configuration, if it exists.
 *
 * @param {string} rating The rating to check against the config.
 * @returns {string} Translated string containing the screen reader readability text to be used.
 */
AssessorPresenter.prototype.getIndicatorScreenReaderReadabilityText = function (rating) {
  if (!this.configHasProperty(rating)) {
    return "";
  }
  return this.presenterConfig[rating].screenReaderReadabilityText;
};

/**
 * Get the indicator full text from the presenter configuration, if it exists.
 *
 * @param {string} rating The rating to check against the config.
 * @returns {string} Translated string containing the full text to be used.
 */
AssessorPresenter.prototype.getIndicatorFullText = function (rating) {
  if (!this.configHasProperty(rating)) {
    return "";
  }
  return this.presenterConfig[rating].fullText;
};

/**
 * Adds a rating based on the numeric score.
 *
 * @param {Object} result Object based on the Assessment result. Requires a score property to work.
 * @returns {Object} The Assessment result object with the rating added.
 */
AssessorPresenter.prototype.resultToRating = function (result) {
  if (!(0, _lodash.isObject)(result)) {
    return "";
  }
  result.rating = (0, _scoreToRating.default)(result.score);
  return result;
};

/**
 * Takes the individual assessment results, sorts and rates them.
 *
 * @returns {Object} Object containing all the individual ratings.
 */
AssessorPresenter.prototype.getIndividualRatings = function () {
  var ratings = {};
  var validResults = this.sort(this.assessor.getValidResults());
  var mappedResults = validResults.map(this.resultToRating);
  (0, _lodash.forEach)(mappedResults, function (item, key) {
    ratings[key] = this.addRating(item);
  }.bind(this));
  return ratings;
};

/**
 * Excludes items from the results that are present in the exclude array.
 *
 * @param {Array} results Array containing the items to filter through.
 * @param {Array} exclude Array of results to exclude.
 * @returns {Array} Array containing items that remain after exclusion.
 */
AssessorPresenter.prototype.excludeFromResults = function (results, exclude) {
  return (0, _lodash.difference)(results, exclude);
};

/**
 * Sorts results based on their score property and always places items considered to be unsortable, at the top.
 *
 * @param {Array} results Array containing the results that need to be sorted.
 * @returns {Array} Array containing the sorted results.
 */
AssessorPresenter.prototype.sort = function (results) {
  var unsortables = this.getUndefinedScores(results);
  var sortables = this.excludeFromResults(results, unsortables);
  sortables.sort(function (a, b) {
    return a.score - b.score;
  });
  return unsortables.concat(sortables);
};

/**
 * Returns a subset of results that have an undefined score or a score set to zero.
 *
 * @param {Array} results The results to filter through.
 * @returns {Array} A subset of results containing items with an undefined score or where the score is zero.
 */
AssessorPresenter.prototype.getUndefinedScores = function (results) {
  return results.filter(function (result) {
    return (0, _lodash.isUndefined)(result.score) || result.score === 0;
  });
};

/**
 * Creates a rating object based on the item that is being passed.
 *
 * @param {AssessmentResult} item The item to check and create a rating object from.
 * @returns {Object} Object containing a parsed item, including a colored indicator.
 */
AssessorPresenter.prototype.addRating = function (item) {
  var indicator = this.getIndicator(item.rating);
  indicator.text = item.text;
  indicator.identifier = item.getIdentifier();
  if (item.hasMarker()) {
    indicator.marker = item.getMarker();
  }
  return indicator;
};

/**
 * Calculates the overall rating score based on the overall score.
 *
 * @param {Number} overallScore The overall score to use in the calculation.
 * @returns {Object} The rating based on the score.
 */
AssessorPresenter.prototype.getOverallRating = function (overallScore) {
  var rating = 0;
  if (this.keyword === "") {
    return this.resultToRating({
      score: rating
    });
  }
  if ((0, _lodash.isNumber)(overallScore)) {
    rating = overallScore / 10;
  }
  return this.resultToRating({
    score: rating
  });
};

/**
 * Mark with a given marker. This will set the active marker to the correct value.
 *
 * @param {string} identifier The identifier for the assessment/marker.
 * @param {Function} marker The marker function.
 * @returns {void}
 */
AssessorPresenter.prototype.markAssessment = function (identifier, marker) {
  if (this._activeMarker === identifier) {
    this.removeAllMarks();
    this._activeMarker = false;
  } else {
    marker();
    this._activeMarker = identifier;
  }
  this.render();
};

/**
 * Disables the currently active marker in the UI.
 *
 * @returns {void}
 */
AssessorPresenter.prototype.disableMarker = function () {
  this._activeMarker = false;
  this.render();
};

/**
 * Disables the marker buttons.
 *
 * @returns {void}
 */
AssessorPresenter.prototype.disableMarkerButtons = function () {
  this._disableMarkerButtons = true;
  this.render();
};

/**
 * Enables the marker buttons.
 *
 * @returns {void}
 */
AssessorPresenter.prototype.enableMarkerButtons = function () {
  this._disableMarkerButtons = false;
  this.render();
};

/**
 * Adds an event listener for the marker button
 *
 * @param {string} identifier The identifier for the assessment the marker belongs to.
 * @param {Function} marker The marker function that can mark the assessment in the text.
 * @returns {void}
 */
AssessorPresenter.prototype.addMarkerEventHandler = function (identifier, marker) {
  var container = document.getElementById(this.output);
  var markButton = container.getElementsByClassName("js-assessment-results__mark-" + identifier)[0];
  markButton.addEventListener("click", this.markAssessment.bind(this, identifier, marker));
};

/**
 * Renders out both the individual and the overall ratings.
 *
 * @returns {void}
 */
AssessorPresenter.prototype.render = function () {
  this.renderIndividualRatings();
  this.renderOverallRating();
};

/**
 * Adds event handlers to the mark buttons
 *
 * @param {Array} scores The list of rendered scores.
 *
 * @returns {void}
 */
AssessorPresenter.prototype.bindMarkButtons = function (scores) {
  // Make sure the button works for every score with a marker.
  (0, _lodash.forEach)(scores, function (score) {
    if (score.hasOwnProperty("marker")) {
      this.addMarkerEventHandler(score.identifier, score.marker);
    }
  }.bind(this));
};

/**
 * Removes all marks currently on the text
 *
 * @returns {void}
 */
AssessorPresenter.prototype.removeAllMarks = function () {
  var marker = this.assessor.getSpecificMarker();
  marker(this.assessor.getPaper(), []);
};

/**
 * Renders out the individual ratings.
 * Here, this method is set to noop. In `post-scraper.js` and `term-scraper.js` where this method is called, it is overridden with noop as well.
 *
 * @returns {void}
 */
AssessorPresenter.prototype.renderIndividualRatings = function () {};

/**
 * Renders out the overall rating.
 *
 * @returns {void}
 */
AssessorPresenter.prototype.renderOverallRating = function () {
  var overallRating = this.getOverallRating(this.assessor.calculateOverallScore());
  var overallRatingElement = document.getElementById(this.overall);
  if (!overallRatingElement) {
    return;
  }
  overallRatingElement.className = "overallScore " + this.getIndicatorColorClass(overallRating.rating);
};
var _default = exports["default"] = AssessorPresenter;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/scoreAggregators/ReadabilityScoreAggregator.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/scoreAggregators/ReadabilityScoreAggregator.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.READABILITY_SCORES = void 0;
var _getLanguage = _interopRequireDefault(__webpack_require__(/*! ../../languageProcessing/helpers/language/getLanguage */ "./node_modules/yoastseo/build/languageProcessing/helpers/language/getLanguage.js"));
var _interpreters = __webpack_require__(/*! ../interpreters */ "./node_modules/yoastseo/build/scoring/interpreters/index.js");
var _ScoreAggregator = _interopRequireDefault(__webpack_require__(/*! ./ScoreAggregator */ "./node_modules/yoastseo/build/scoring/scoreAggregators/ScoreAggregator.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/* Internal dependencies */

/**
 * Penalties that can be given on each assessment
 * when all assessments are currently supported
 * for the user's language.
 *
 * @type {{ok: number, bad: number, good: number}}
 * @const
 *
 * @memberOf module:parsedPaper/assess
 */
const PENALTY_MAPPING_FULL_SUPPORT = {
  bad: 3,
  ok: 2,
  good: 0
};

/**
 * Penalties that can be given on each assessment
 * when only a part of the assessments are currently supported
 * for the user's language.
 *
 * @type {{ok: number, bad: number, good: number}}
 * @const
 *
 * @memberOf module:parsedPaper/assess
 */
const PENALTY_MAPPING_PARTIAL_SUPPORT = {
  bad: 4,
  ok: 2,
  good: 0
};

/**
 * The scores that can be given on the readability analysis.
 *
 * @type {{GOOD: number, OKAY: number, NEEDS_IMPROVEMENT: number, NOT_AVAILABLE: number}}
 * @const
 *
 * @memberOf module:parsedPaper/assess
 */
const READABILITY_SCORES = exports.READABILITY_SCORES = {
  GOOD: 90,
  OKAY: 60,
  NEEDS_IMPROVEMENT: 30,
  NOT_AVAILABLE: 0
};

/**
 * A list of all the languages that have full support in the readability analysis.
 *
 * @type {string[]}
 * @const
 */
const FULLY_SUPPORTED_LANGUAGES = ["en", "nl", "de", "it", "ru", "fr", "es"];

/**
 * Aggregates the results of the readability analysis into a single score.
 *
 * @memberOf module:parsedPaper/assess
 */
class ReadabilityScoreAggregator extends _ScoreAggregator.default {
  /**
   * Determines whether a language is fully supported.
   *
   * @param {string} locale The locale for which the content is written, e.g. `sv-SE` for Sweden.
   *
   * @returns {boolean} `true` if fully supported.
   */
  isFullySupported(locale) {
    // Sanity check if this is actually a locale string.
    if (locale && locale.includes("_")) {
      const language = (0, _getLanguage.default)(locale);
      return FULLY_SUPPORTED_LANGUAGES.includes(language);
    }
    // Default to not fully supported.
    return false;
  }

  /**
   * Calculates the overall score (GOOD, OKAY or NEEDS IMPROVEMENT)
   * based on the penalty.
   *
   * @param {boolean} isFullySupported Whether this language is fully supported.
   * @param {number}  penalty          The total penalty.
   *
   * @returns {number} The overall score.
   */
  calculateScore(isFullySupported, penalty) {
    if (isFullySupported) {
      /*
       * If the language is fully supported, we are more lenient.
       * A higher penalty is needed to get lower scores.
       */
      if (penalty > 6) {
        return READABILITY_SCORES.NEEDS_IMPROVEMENT;
      }
      if (penalty > 4) {
        /*
         * A penalty between 4 and 6 means either:
         *  - One "ok" and one "bad" result (5).
         *  - Two "bad" results of 3 points each (6).
         *  - Three "ok" results of 2 points each (6).
         */
        return READABILITY_SCORES.OKAY;
      }
    } else {
      /*
       * If the language is NOT fully supported, we are more stringent.
       * The penalty threshold for getting lower scores is set lower.
       */
      if (penalty > 4) {
        return READABILITY_SCORES.NEEDS_IMPROVEMENT;
      }
      if (penalty > 2) {
        /*
         * A penalty of 3 or 4 means:
         *  - Two "ok" results of 2 points each (4).
         *  - One "bad" result of 4 points (4).
         */
        return READABILITY_SCORES.OKAY;
      }
    }
    return READABILITY_SCORES.GOOD;
  }

  /**
   * Calculates the total penalty based on the given assessment results.
   *
   * @param {AssessmentResult[]} results The valid results from which to calculate the total penalty.
   *
   * @returns {number} The total penalty for the results.
   */
  calculatePenalty(results) {
    return results.reduce((sum, result) => {
      // Compute the rating ("error", "feedback", "bad", "ok" or "good").
      const rating = (0, _interpreters.scoreToRating)(result.getScore());
      const penalty = this.isFullySupported(this.locale) ? PENALTY_MAPPING_FULL_SUPPORT[rating] : PENALTY_MAPPING_PARTIAL_SUPPORT[rating];

      // Add penalty when available.
      return penalty ? sum + penalty : sum;
    }, 0);
  }

  /**
   * Returns the list of valid results.
   * Valid results are all results that have a score and a text.
   *
   * @param {AssessmentResult[]} results The results to filter the valid results from.
   *
   * @returns {AssessmentResult[]} The list of valid results.
   */
  getValidResults(results) {
    return results.filter(result => result.hasScore() && result.hasText());
  }

  /**
   * Sets the locale of the content. We are more lenient on languages
   * that are fully supported in the analysis.
   *
   * @param {string} locale The locale of the content.
   *
   * @returns {void}
   */
  setLocale(locale) {
    this.locale = locale;
  }

  /**
   * Aggregates the given assessment results into a single analysis score.
   *
   * @param {AssessmentResult[]} results The assessment results.
   *
   * @returns {number} The aggregated score.
   */
  aggregate(results) {
    const validResults = this.getValidResults(results);

    /*
     * If you have no content, you have a gray indicator.
     * (Assume that one result always means the 'no content' assessment result).
     */
    if (validResults.length <= 1) {
      return READABILITY_SCORES.NOT_AVAILABLE;
    }
    const penalty = this.calculatePenalty(validResults);
    const isFullySupported = this.isFullySupported(this.locale);
    return this.calculateScore(isFullySupported, penalty);
  }
}
var _default = exports["default"] = ReadabilityScoreAggregator;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/scoreAggregators/SEOScoreAggregator.js":
/*!************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/scoreAggregators/SEOScoreAggregator.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _ScoreAggregator = _interopRequireDefault(__webpack_require__(/*! ./ScoreAggregator */ "./node_modules/yoastseo/build/scoring/scoreAggregators/ScoreAggregator.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * The number to scale the score to.
 *
 * Individual scores are from 1 to 9.
 * The total score should be multiplied by this number to scale up.
 *
 * @type {number}
 * @const
 *
 * @memberOf module:parsedPaper/assess
 */
const ScoreScale = 100;

/**
 * The factor to multiply the amount of results with.
 *
 * Individual scores are from 1 to 9.
 * The make the total score work in the 100 scale, the amount of results needs to get multiplied by this factor.
 *
 * @type {number}
 * @const
 *
 * @memberOf module:parsedPaper/assess
 */
const ScoreFactor = 9;

/**
 * Aggregates SEO assessment results into a single score.
 *
 * @memberOf module:parsedPaper/assess
 */
class SEOScoreAggregator extends _ScoreAggregator.default {
  /**
   * Aggregates the given assessment results into a single score.
   *
   * @param {AssessmentResult[]} results The assessment results.
   *
   * @returns {number} The aggregated score.
   */
  aggregate(results) {
    const score = results.reduce((sum, result) => sum + result.getScore(), 0);

    /*
     * Whenever the divide by part is 0 this can result in a `NaN` value. Then 0 should be returned as fallback.
     * This seemed better than the if check `results.length === 0`,
     * because it also protects against ScoreFactor being 0.
     */
    return Math.round(score * ScoreScale / (results.length * ScoreFactor)) || 0;
  }
}
var _default = exports["default"] = SEOScoreAggregator;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/scoreAggregators/ScoreAggregator.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/scoreAggregators/ScoreAggregator.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Aggregates assessment results into a single score.
 *
 * @memberOf module:parsedPaper/assess
 *
 * @abstract
 */
class ScoreAggregator {
  /**
   * Aggregates the given assessment results into a single score.
   *
   * @param {AssessmentResult[]} results The assessment results.
   *
   * @returns {number} The aggregated score.
   *
   * @abstract
   */
  aggregate(results) {
    // eslint-disable-line no-unused-vars
    console.warn("'aggregate' must be implemented by a child class of 'ScoreAggregator'");
  }
}
var _default = exports["default"] = ScoreAggregator;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/scoreAggregators/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/scoreAggregators/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "ReadabilityScoreAggregator", ({
  enumerable: true,
  get: function () {
    return _ReadabilityScoreAggregator.default;
  }
}));
Object.defineProperty(exports, "SEOScoreAggregator", ({
  enumerable: true,
  get: function () {
    return _SEOScoreAggregator.default;
  }
}));
Object.defineProperty(exports, "ScoreAggregator", ({
  enumerable: true,
  get: function () {
    return _ScoreAggregator.default;
  }
}));
var _ReadabilityScoreAggregator = _interopRequireDefault(__webpack_require__(/*! ./ReadabilityScoreAggregator */ "./node_modules/yoastseo/build/scoring/scoreAggregators/ReadabilityScoreAggregator.js"));
var _ScoreAggregator = _interopRequireDefault(__webpack_require__(/*! ./ScoreAggregator */ "./node_modules/yoastseo/build/scoring/scoreAggregators/ScoreAggregator.js"));
var _SEOScoreAggregator = _interopRequireDefault(__webpack_require__(/*! ./SEOScoreAggregator */ "./node_modules/yoastseo/build/scoring/scoreAggregators/SEOScoreAggregator.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/seoAssessor.js":
/*!************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/seoAssessor.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _util = __webpack_require__(/*! util */ "./node_modules/util/util.js");
var _IntroductionKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/IntroductionKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/IntroductionKeywordAssessment.js"));
var _KeyphraseLengthAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/KeyphraseLengthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseLengthAssessment.js"));
var _KeywordDensityAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/KeywordDensityAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeywordDensityAssessment.js"));
var _MetaDescriptionKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/MetaDescriptionKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/MetaDescriptionKeywordAssessment.js"));
var _TextCompetingLinksAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/TextCompetingLinksAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/TextCompetingLinksAssessment.js"));
var _InternalLinksAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/InternalLinksAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/InternalLinksAssessment.js"));
var _KeyphraseInSEOTitleAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/KeyphraseInSEOTitleAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseInSEOTitleAssessment.js"));
var _UrlKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/UrlKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/UrlKeywordAssessment.js"));
var _assessor = _interopRequireDefault(__webpack_require__(/*! ./assessor */ "./node_modules/yoastseo/build/scoring/assessor.js"));
var _MetaDescriptionLengthAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/MetaDescriptionLengthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/MetaDescriptionLengthAssessment.js"));
var _SubHeadingsKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/SubHeadingsKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/SubHeadingsKeywordAssessment.js"));
var _KeyphraseInImageTextAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/KeyphraseInImageTextAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseInImageTextAssessment.js"));
var _ImageCountAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/ImageCountAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/ImageCountAssessment.js"));
var _TextLengthAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/TextLengthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/TextLengthAssessment.js"));
var _OutboundLinksAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/OutboundLinksAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/OutboundLinksAssessment.js"));
var _PageTitleWidthAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/PageTitleWidthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/PageTitleWidthAssessment.js"));
var _FunctionWordsInKeyphraseAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/FunctionWordsInKeyphraseAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/FunctionWordsInKeyphraseAssessment.js"));
var _SingleH1Assessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/SingleH1Assessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/SingleH1Assessment.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Creates the Assessor
 *
 * @param {Researcher}  researcher      The researcher to use for the analysis.
 * @param {Object?}     options         The options for this assessor.
 * @param {Function}    options.marker  The marker to pass the list of marks to.
 *
 * @constructor
 */
const SEOAssessor = function (researcher, options) {
  _assessor.default.call(this, researcher, options);
  this.type = "SEOAssessor";
  this._assessments = [new _IntroductionKeywordAssessment.default(), new _KeyphraseLengthAssessment.default(), new _KeywordDensityAssessment.default(), new _MetaDescriptionKeywordAssessment.default(), new _MetaDescriptionLengthAssessment.default(), new _SubHeadingsKeywordAssessment.default(), new _TextCompetingLinksAssessment.default(), new _KeyphraseInImageTextAssessment.default(), new _ImageCountAssessment.default(), new _TextLengthAssessment.default(), new _OutboundLinksAssessment.default(), new _KeyphraseInSEOTitleAssessment.default(), new _InternalLinksAssessment.default(), new _PageTitleWidthAssessment.default({
    scores: {
      widthTooShort: 9
    }
  }, true), new _UrlKeywordAssessment.default(), new _FunctionWordsInKeyphraseAssessment.default(), new _SingleH1Assessment.default()];
};
(0, _util.inherits)(SEOAssessor, _assessor.default);
var _default = exports["default"] = SEOAssessor;

/***/ }),

/***/ "./node_modules/yoastseo/build/scoring/taxonomyAssessor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/yoastseo/build/scoring/taxonomyAssessor.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getTextLengthAssessment = exports["default"] = void 0;
var _util = __webpack_require__(/*! util */ "./node_modules/util/util.js");
var _IntroductionKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/IntroductionKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/IntroductionKeywordAssessment.js"));
var _KeyphraseLengthAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/KeyphraseLengthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseLengthAssessment.js"));
var _KeywordDensityAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/KeywordDensityAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeywordDensityAssessment.js"));
var _MetaDescriptionKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/MetaDescriptionKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/MetaDescriptionKeywordAssessment.js"));
var _KeyphraseInSEOTitleAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/KeyphraseInSEOTitleAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/KeyphraseInSEOTitleAssessment.js"));
var _UrlKeywordAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/UrlKeywordAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/UrlKeywordAssessment.js"));
var _assessor = _interopRequireDefault(__webpack_require__(/*! ./assessor */ "./node_modules/yoastseo/build/scoring/assessor.js"));
var _MetaDescriptionLengthAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/MetaDescriptionLengthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/MetaDescriptionLengthAssessment.js"));
var _TextLengthAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/TextLengthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/TextLengthAssessment.js"));
var _PageTitleWidthAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/PageTitleWidthAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/PageTitleWidthAssessment.js"));
var _FunctionWordsInKeyphraseAssessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/FunctionWordsInKeyphraseAssessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/FunctionWordsInKeyphraseAssessment.js"));
var _SingleH1Assessment = _interopRequireDefault(__webpack_require__(/*! ./assessments/seo/SingleH1Assessment */ "./node_modules/yoastseo/build/scoring/assessments/seo/SingleH1Assessment.js"));
var _helpers = __webpack_require__(/*! ../helpers */ "./node_modules/yoastseo/build/helpers/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Returns the text length assessment to use.
 *
 * @returns {TextLengthAssessment} The text length assessment (with taxonomy configuration) to use.
 */
const getTextLengthAssessment = function () {
  // Export so it can be used in tests.
  return new _TextLengthAssessment.default({
    recommendedMinimum: 30,
    slightlyBelowMinimum: 10,
    veryFarBelowMinimum: 1,
    urlTitle: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/34j"),
    urlCallToAction: (0, _helpers.createAnchorOpeningTag)("https://yoa.st/34k"),
    customContentType: "taxonomyAssessor"
  });
};

/**
 * Creates the Assessor used for taxonomy pages.
 *
 * @param {Researcher} researcher   The researcher used for the analysis.
 * @param {Object?} options         The options for this assessor.
 * @constructor
 */
exports.getTextLengthAssessment = getTextLengthAssessment;
const TaxonomyAssessor = function (researcher, options) {
  _assessor.default.call(this, researcher, options);
  this.type = "taxonomyAssessor";
  this._assessments = [new _IntroductionKeywordAssessment.default(), new _KeyphraseLengthAssessment.default(), new _KeywordDensityAssessment.default(), new _MetaDescriptionKeywordAssessment.default(), new _MetaDescriptionLengthAssessment.default(), getTextLengthAssessment(), new _KeyphraseInSEOTitleAssessment.default(), new _PageTitleWidthAssessment.default({
    scores: {
      widthTooShort: 9
    }
  }, true), new _UrlKeywordAssessment.default(), new _FunctionWordsInKeyphraseAssessment.default(), new _SingleH1Assessment.default()];
};
(0, _util.inherits)(TaxonomyAssessor, _assessor.default);
var _default = exports["default"] = TaxonomyAssessor;

/***/ }),

/***/ "./node_modules/yoastseo/build/values/AssessmentResult.js":
/*!****************************************************************!*\
  !*** ./node_modules/yoastseo/build/values/AssessmentResult.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _Mark = _interopRequireDefault(__webpack_require__(/*! ./Mark */ "./node_modules/yoastseo/build/values/Mark.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * A function that only returns an empty that can be used as an empty marker
 *
 * @returns {Array} A list of empty marks.
 */
var emptyMarker = function () {
  return [];
};

/**
 * Construct the AssessmentResult value object.
 *
 * @param {Object} [values] The values for this assessment result.
 *
 * @constructor
 */
var AssessmentResult = function (values) {
  this._hasScore = false;
  this._identifier = "";
  this._hasMarks = false;
  this._hasJumps = false;
  this._hasEditFieldName = false;
  this._marker = emptyMarker;
  this._hasBetaBadge = false;
  this.score = 0;
  this.text = "";
  this.marks = [];
  this.editFieldName = "";
  if ((0, _lodash.isUndefined)(values)) {
    values = {};
  }
  if (!(0, _lodash.isUndefined)(values.score)) {
    this.setScore(values.score);
  }
  if (!(0, _lodash.isUndefined)(values.text)) {
    this.setText(values.text);
  }
  if (!(0, _lodash.isUndefined)(values.marks)) {
    this.setMarks(values.marks);
  }
  if (!(0, _lodash.isUndefined)(values._hasBetaBadge)) {
    this.setHasBetaBadge(values._hasBetaBadge);
  }
  if (!(0, _lodash.isUndefined)(values._hasJumps)) {
    this.setHasJumps(values._hasJumps);
  }
  if (!(0, _lodash.isUndefined)(values.editFieldName)) {
    this.setEditFieldName(values.editFieldName);
  }
};

/**
 * Check if a score is available.
 * @returns {boolean} Whether or not a score is available.
 */
AssessmentResult.prototype.hasScore = function () {
  return this._hasScore;
};

/**
 * Get the available score
 * @returns {number} The score associated with the AssessmentResult.
 */
AssessmentResult.prototype.getScore = function () {
  return this.score;
};

/**
 * Set the score for the assessment.
 * @param {number} score The score to be used for the score property
 * @returns {void}
 */
AssessmentResult.prototype.setScore = function (score) {
  if ((0, _lodash.isNumber)(score)) {
    this.score = score;
    this._hasScore = true;
  }
};

/**
 * Check if a text is available.
 * @returns {boolean} Whether or not a text is available.
 */
AssessmentResult.prototype.hasText = function () {
  return this.text !== "";
};

/**
 * Get the available text
 * @returns {string} The text associated with the AssessmentResult.
 */
AssessmentResult.prototype.getText = function () {
  return this.text;
};

/**
 * Set the text for the assessment.
 * @param {string} text The text to be used for the text property
 * @returns {void}
 */
AssessmentResult.prototype.setText = function (text) {
  if ((0, _lodash.isUndefined)(text)) {
    text = "";
  }
  this.text = text;
};

/**
 * Gets the available marks.
 *
 * @returns {array} The marks associated with the AssessmentResult.
 */
AssessmentResult.prototype.getMarks = function () {
  return this.marks;
};

/**
 * Sets the marks for the assessment.
 *
 * @param {array} marks The marks to be used for the marks property
 *
 * @returns {void}
 */
AssessmentResult.prototype.setMarks = function (marks) {
  if ((0, _lodash.isArray)(marks)) {
    this.marks = marks;
    this._hasMarks = marks.length > 0;
  }
};

/**
 * Sets the identifier
 *
 * @param {string} identifier An alphanumeric identifier for this result.
 * @returns {void}
 */
AssessmentResult.prototype.setIdentifier = function (identifier) {
  this._identifier = identifier;
};

/**
 * Gets the identifier
 *
 * @returns {string} An alphanumeric identifier for this result.
 */
AssessmentResult.prototype.getIdentifier = function () {
  return this._identifier;
};

/**
 * Sets the marker, a pure function that can return the marks for a given Paper
 *
 * @param {Function} marker The marker to set.
 * @returns {void}
 */
AssessmentResult.prototype.setMarker = function (marker) {
  this._marker = marker;
};

/**
 * Returns whether or not this result has a marker that can be used to mark for a given Paper
 *
 * @returns {boolean} Whether or this result has a marker.
 */
AssessmentResult.prototype.hasMarker = function () {
  return this._hasMarks && this._marker !== this.emptyMarker;
};

/**
 * Gets the marker, a pure function that can return the marks for a given Paper
 *
 * @returns {Function} The marker.
 */
AssessmentResult.prototype.getMarker = function () {
  return this._marker;
};

/**
 * Sets the value of _hasMarks to determine if there is something to mark.
 *
 * @param {boolean} hasMarks Is there something to mark.
 * @returns {void}
 */
AssessmentResult.prototype.setHasMarks = function (hasMarks) {
  this._hasMarks = hasMarks;
};

/**
 * Returns the value of _hasMarks to determine if there is something to mark.
 *
 * @returns {boolean} Is there something to mark.
 */
AssessmentResult.prototype.hasMarks = function () {
  return this._hasMarks;
};

/**
 * Sets the value of _hasBetaBadge to determine if the result has a beta badge.
 *
 * @param {boolean} hasBetaBadge Whether this result has a beta badge.
 * @returns {void}
 */
AssessmentResult.prototype.setHasBetaBadge = function (hasBetaBadge) {
  this._hasBetaBadge = hasBetaBadge;
};

/**
 * Returns the value of _hasBetaBadge to determine if the result has a beta badge.
 *
 * @returns {bool} Whether this result has a beta badge.
 */
AssessmentResult.prototype.hasBetaBadge = function () {
  return this._hasBetaBadge;
};

/**
 * Sets the value of _hasJumps to determine whether it's needed to jump to a different field.
 *
 * @param {boolean} hasJumps Whether this result causes a jump to a different field.
 * @returns {void}
 */
AssessmentResult.prototype.setHasJumps = function (hasJumps) {
  this._hasJumps = hasJumps;
};

/**
 * Returns the value of _hasJumps to determine whether it's needed to jump to a different field.
 *
 * @returns {bool} Whether this result causes a jump to a different field.
 */
AssessmentResult.prototype.hasJumps = function () {
  return this._hasJumps;
};

/**
 * Check if an edit field name is available.
 * @returns {boolean} Whether or not an edit field name is available.
 */
AssessmentResult.prototype.hasEditFieldName = function () {
  return this._hasEditFieldName;
};

/**
 * Get the edit field name.
 * @returns {string} The edit field name associated with the AssessmentResult.
 */
AssessmentResult.prototype.getEditFieldName = function () {
  return this.editFieldName;
};

/**
 * Set the edit field name to be used to create the aria label for an edit button.
 * @param {string} editFieldName The string to be used for the string property
 * @returns {void}
 */
AssessmentResult.prototype.setEditFieldName = function (editFieldName) {
  if (editFieldName !== "") {
    this.editFieldName = editFieldName;
    this._hasEditFieldName = true;
  }
};

/**
 * Serializes the AssessmentResult instance to an object.
 *
 * @returns {Object} The serialized AssessmentResult.
 */
AssessmentResult.prototype.serialize = function () {
  return {
    _parseClass: "AssessmentResult",
    identifier: this._identifier,
    score: this.score,
    text: this.text,
    marks: this.marks.map(mark => mark.serialize()),
    _hasBetaBadge: this._hasBetaBadge,
    _hasJumps: this._hasJumps,
    editFieldName: this.editFieldName
  };
};

/**
 * Parses the object to an AssessmentResult.
 *
 * @param {Object} serialized The serialized object.
 *
 * @returns {AssessmentResult} The parsed AssessmentResult.
 */
AssessmentResult.parse = function (serialized) {
  const result = new AssessmentResult({
    text: serialized.text,
    score: serialized.score,
    marks: serialized.marks.map(mark => _Mark.default.parse(mark)),
    _hasBetaBadge: serialized._hasBetaBadge,
    _hasJumps: serialized._hasJumps,
    editFieldName: serialized.editFieldName
  });
  result.setIdentifier(serialized.identifier);
  return result;
};
var _default = exports["default"] = AssessmentResult;

/***/ }),

/***/ "./node_modules/yoastseo/build/values/Mark.js":
/*!****************************************************!*\
  !*** ./node_modules/yoastseo/build/values/Mark.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Represents a place where highlighting should be applied.
 * We allow both replacement-based highlighting (through providing `original`, `marked`, and potentially `fieldsToMark`) and
 * position-based highlighting (through providing a `position`).
 *
 * @param {Object}   properties                  The properties of this Mark.
 *
 * @param {string?}  properties.original         The original text that should be marked.
 * @param {string?}  properties.marked           The new text including marks.
 * @param {array?}   properties.fieldsToMark     The array that specifies which text section(s) to mark.
 *
 * @param {SourceCodeRange?} properties.position The position object: a range in the source code.
 *
 * @constructor
 */
function Mark(properties) {
  (0, _lodash.defaults)(properties, {
    original: "",
    marked: "",
    fieldsToMark: []
  });
  this._properties = properties;
  this.isValid();
}

/**
 * Returns the original text.
 *
 * @returns {string} The original text.
 */
Mark.prototype.getOriginal = function () {
  return this._properties.original;
};

/**
 * Returns the marked text.
 *
 * @returns {string} The replaced text.
 */
Mark.prototype.getMarked = function () {
  return this._properties.marked;
};

/**
 * Returns the fields to mark.
 *
 * @returns {array} The fields to mark.
 */
Mark.prototype.getFieldsToMark = function () {
  return this._properties.fieldsToMark;
};

/**
 * Returns the position information.
 *
 * @returns {number} The position information.
 */
Mark.prototype.getPosition = function () {
  return this._properties.position;
};

/**
 * Returns the start position.
 *
 * @returns {number} The start position.
 */
Mark.prototype.getPositionStart = function () {
  return this._properties.position && this._properties.position.startOffset;
};

/**
 * Returns the end position.
 *
 * @returns {number} The end position.
 */
Mark.prototype.getPositionEnd = function () {
  return this._properties.position && this._properties.position.endOffset;
};

/**
 * Sets the start position.
 *
 * @param {number} positionStart The new start position.
 *
 * @returns {void}
 */
Mark.prototype.setPositionStart = function (positionStart) {
  this._properties.position.startOffset = positionStart;
};

/**
 * Sets the end position.
 *
 * @param {number} positionEnd The new end position.
 *
 * @returns {void}
 */
Mark.prototype.setPositionEnd = function (positionEnd) {
  this._properties.position.endOffset = positionEnd;
};

/**
 * Returns the start position of a block.
 *
 * @param {number} startOffsetBlock The block start offset.
 *
 * @returns {number} The start position of a block.
 */
Mark.prototype.setBlockPositionStart = function (startOffsetBlock) {
  this._properties.position.startOffsetBlock = startOffsetBlock;
};

/**
 * Returns the end position of a block.
 *
 * @param {number} endOffsetBlock The block end offset.
 *
 * @returns {number} The end position of a block.
 */
Mark.prototype.setBlockPositionEnd = function (endOffsetBlock) {
  this._properties.position.endOffsetBlock = endOffsetBlock;
};

/**
 * Gets the block client id.
 *
 * @returns {string} The block client id.
 */
Mark.prototype.getBlockClientId = function () {
  return this._properties.position && this._properties.position.clientId;
};

/**
 * Gets the block attribute id.
 *
 * @returns {string} The block attribute id.
 */
Mark.prototype.getBlockAttributeId = function () {
  return this._properties.position && this._properties.position.attributeId;
};

/**
 * Checks if the mark object is intended for the first section of a Yoast sub-block.
 * This method will be used only for Yoast blocks where each block consists of sub-blocks
 * with two sections.
 *
 * @returns {boolean} Whether the mark object is intended for the first section of a Yoast sub-block.
 */
Mark.prototype.isMarkForFirstBlockSection = function () {
  return this._properties.position && this._properties.position.isFirstSection;
};

/**
 * Returns the start position inside block.
 *
 * @returns {number} The start position inside block if the mark position information, undefined otherwise.
 */
Mark.prototype.getBlockPositionStart = function () {
  return this._properties.position && this._properties.position.startOffsetBlock;
};

/**
 * Returns the end position inside block if the mark has position information, undefined otherwise.
 *
 * @returns {number} The end position inside block.
 */
Mark.prototype.getBlockPositionEnd = function () {
  return this._properties.position && this._properties.position.endOffsetBlock;
};

/**
 * Applies this mark to the given text with replacement-based highlighting.
 *
 * @param {string} text The original text without the mark applied.
 * @returns {string} A new text with the mark applied to it.
 */
Mark.prototype.applyWithReplace = function (text) {
  // (=^ ◡ ^=) Cute method to replace everything in a string without using regex.
  return text.split(this._properties.original).join(this._properties.marked);
};

/**
 * Applies this mark to the given text with position-based highlighting.
 *
 * @param {string} text The original text without the mark applied.
 * @returns {string} A new text with the mark applied to it.
 */
Mark.prototype.applyWithPosition = function (text) {
  const markStart = "<yoastmark class='yoast-text-mark'>";
  const markEnd = "</yoastmark>";
  const newPositionEnd = this.getPositionEnd() + markStart.length;
  text = text.substring(0, this.getPositionStart()) + markStart + text.substring(this.getPositionStart());
  text = text.substring(0, newPositionEnd) + markEnd + text.substring(newPositionEnd);
  return text;
};

/**
 * Serializes the Mark instance to an object.
 *
 * @returns {Object} The serialized Mark.
 */
Mark.prototype.serialize = function () {
  return {
    _parseClass: "Mark",
    ...this._properties
  };
};

/**
 * Checks if the mark object is valid for position-based highlighting.
 * @returns {void}
 */
// eslint-disable-next-line complexity
Mark.prototype.isValid = function () {
  if (!(0, _lodash.isUndefined)(this.getPositionStart()) && this.getPositionStart() < 0) {
    throw new RangeError("positionStart should be larger or equal than 0.");
  }
  if (!(0, _lodash.isUndefined)(this.getPositionEnd()) && this.getPositionEnd() <= 0) {
    throw new RangeError("positionEnd should be larger than 0.");
  }
  if (!(0, _lodash.isUndefined)(this.getPositionStart()) && !(0, _lodash.isUndefined)(this.getPositionEnd()) && this.getPositionStart() >= this.getPositionEnd()) {
    throw new RangeError("The positionStart should be smaller than the positionEnd.");
  }
  if ((0, _lodash.isUndefined)(this.getPositionStart()) && !(0, _lodash.isUndefined)(this.getPositionEnd()) || (0, _lodash.isUndefined)(this.getPositionEnd()) && !(0, _lodash.isUndefined)(this.getPositionStart())) {
    throw new Error("A mark object should either have start and end defined or start and end undefined.");
  }
};

/**
 * Checks if a mark has position information available.
 * @returns {boolean} Returns true if the Mark object has position information, false otherwise.
 */
Mark.prototype.hasPosition = function () {
  return !(0, _lodash.isUndefined)(this.getPositionStart());
};

/**
 * Checks if a mark has block position information available.
 * A block has position information if the block start offset is available.
 *
 * @returns {boolean} Returns true if the Mark object has block position information, false otherwise.
 */
Mark.prototype.hasBlockPosition = function () {
  return !(0, _lodash.isUndefined)(this.getBlockPositionStart());
};

/**
 * Parses the object to a Mark.
 *
 * @param {Object} serialized The serialized object.
 *
 * @returns {Mark} The parsed Mark.
 */
Mark.parse = function (serialized) {
  delete serialized._parseClass;
  return new Mark(serialized);
};
var _default = exports["default"] = Mark;

/***/ }),

/***/ "./node_modules/yoastseo/build/values/Paper.js":
/*!*****************************************************!*\
  !*** ./node_modules/yoastseo/build/values/Paper.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Default attributes to be used by the Paper if they are left undefined.
 * @type {{keyword: string, synonyms: string, description: string, title: string, titleWidth: number,
 * 		   slug: string, locale: string, permalink: string, date: string, customData: object, textTitle: string, writingDirection: "LTR" }}
 */
const defaultAttributes = {
  keyword: "",
  synonyms: "",
  description: "",
  title: "",
  titleWidth: 0,
  slug: "",
  locale: "en_US",
  permalink: "",
  date: "",
  customData: {},
  textTitle: "",
  writingDirection: "LTR"
};

/**
 * Constructs the Paper object and sets the keyword property.
 *
 * @param {string}  text                            The text to use in the analysis.
 * @param {object}  [attributes]                    The object containing all attributes.
 * @param {string}  [attributes.keyword]            The main keyword.
 * @param {string}  [attributes.synonyms]           The main keyword's synonyms.
 * @param {string}  [attributes.description]        The SEO description.
 * @param {string}  [attributes.title]              The SEO title.
 * @param {number}  [attributes.titleWidth]         The width of the title in pixels.
 * @param {string}  [attributes.slug]               The slug.
 * @param {string}  [attributes.locale]             The locale.
 * @param {string}  [attributes.permalink]          The base url + slug.
 * @param {string}  [attributes.date]               The date.
 * @param {Object}  [attributes.wpBlocks]           The text, encoded in WordPress block editor blocks.
 * @param {Object}  [attributes.customData]         Custom data.
 * @param {string}  [attributes.textTitle]          The title of the text.
 * @param {string}  [attributes.writingDirection]   The writing direction of the paper. Defaults to left to right (LTR).
 *
 * @constructor
 */
function Paper(text, attributes) {
  this._text = text || "";
  this._tree = null;
  attributes = attributes || {};
  (0, _lodash.defaults)(attributes, defaultAttributes);
  if (attributes.locale === "") {
    attributes.locale = defaultAttributes.locale;
  }
  if (attributes.hasOwnProperty("url")) {
    // The 'url' attribute has been deprecated since version 18.8, refer to hasUrl and getUrl below.
    console.warn("The 'url' attribute is deprecated, use 'slug' instead.");
    attributes.slug = attributes.url || attributes.slug;
  }
  const onlyLetters = attributes.keyword.replace(/[‘’“”"'.?!:;,¿¡«»&*@#±^%|~`[\](){}⟨⟩<>/\\–\-\u2014\u00d7\u002b\u0026\s]/g, "");
  if ((0, _lodash.isEmpty)(onlyLetters)) {
    attributes.keyword = defaultAttributes.keyword;
  }
  this._attributes = attributes;
}

/**
 * Checks whether a keyword is available.
 * @returns {boolean} Returns true if the Paper has a keyword.
 */
Paper.prototype.hasKeyword = function () {
  return this._attributes.keyword !== "";
};

/**
 * Returns the associated keyword or an empty string if no keyword is available.
 * @returns {string} Returns Keyword
 */
Paper.prototype.getKeyword = function () {
  return this._attributes.keyword;
};

/**
 * Checks whether synonyms are available.
 * @returns {boolean} Returns true if the Paper has synonyms.
 */
Paper.prototype.hasSynonyms = function () {
  return this._attributes.synonyms !== "";
};

/**
 * Returns the associated synonyms or an empty string if no synonyms is available.
 * @returns {string} Returns synonyms.
 */
Paper.prototype.getSynonyms = function () {
  return this._attributes.synonyms;
};

/**
 * Checks whether the text is available.
 * @returns {boolean} Returns true if the paper has a text.
 */
Paper.prototype.hasText = function () {
  return this._text !== "";
};

/**
 * Returns the associated text or am empty string if no text is available.
 * @returns {string} Returns text
 */
Paper.prototype.getText = function () {
  return this._text;
};

/**
 * Sets the tree.
 *
 * @param {Node} tree The tree to set.
 *
 * @returns {void}
 */
Paper.prototype.setTree = function (tree) {
  this._tree = tree;
};

/**
 * Returns the tree.
 *
 * @returns {Node} The tree.
 */
Paper.prototype.getTree = function () {
  return this._tree;
};

/**
 * Checks whether a description is available.
 * @returns {boolean} Returns true if the paper has a description.
 */
Paper.prototype.hasDescription = function () {
  return this._attributes.description !== "";
};

/**
 * Returns the description or an empty string if no description is available.
 * @returns {string} Returns the description.
 */
Paper.prototype.getDescription = function () {
  return this._attributes.description;
};

/**
 * Checks whether a title is available
 * @returns {boolean} Returns true if the Paper has a title.
 */
Paper.prototype.hasTitle = function () {
  return this._attributes.title !== "";
};

/**
 * Returns the title, or an empty string of no title is available.
 * @returns {string} Returns the title
 */
Paper.prototype.getTitle = function () {
  return this._attributes.title;
};

/**
 * Checks whether a title width in pixels is available
 * @returns {boolean} Returns true if the Paper has a title.
 */
Paper.prototype.hasTitleWidth = function () {
  return this._attributes.titleWidth !== 0;
};

/**
 * Returns the title width in pixels, or an empty string of no title width in pixels is available.
 * @returns {string} Returns the title
 */
Paper.prototype.getTitleWidth = function () {
  return this._attributes.titleWidth;
};

/**
 * Checks whether a slug is available
 * @returns {boolean} Returns true if the Paper has a slug.
 */
Paper.prototype.hasSlug = function () {
  return this._attributes.slug !== "";
};

/**
 * Returns the slug, or an empty string of no slug is available.
 * @returns {string} Returns the url
 */
Paper.prototype.getSlug = function () {
  return this._attributes.slug;
};

/**
 * Checks whether an url is available
 * @deprecated Since version 18.7. Use hasSlug instead.
 * @returns {boolean} Returns true if the Paper has a slug.
 */
Paper.prototype.hasUrl = function () {
  console.warn("This function is deprecated, use hasSlug instead");
  return this.hasSlug();
};

/**
 * Returns the url, or an empty string if no url is available.
 * @deprecated Since version 18.8. Use getSlug instead.
 * @returns {string} Returns the url
 */
Paper.prototype.getUrl = function () {
  console.warn("This function is deprecated, use getSlug instead");
  return this.getSlug();
};

/**
 * Checks whether a locale is available
 * @returns {boolean} Returns true if the paper has a locale
 */
Paper.prototype.hasLocale = function () {
  return this._attributes.locale !== "";
};

/**
 * Returns the locale or an empty string if no locale is available
 * @returns {string} Returns the locale
 */
Paper.prototype.getLocale = function () {
  return this._attributes.locale;
};

/**
 * Gets the information of the writing direction of the paper.
 * It returns "LTR" (left to right) if this attribute is not provided.
 *
 * @returns {string} Returns the information of the writing direction of the paper.
 */
Paper.prototype.getWritingDirection = function () {
  return this._attributes.writingDirection;
};

/**
 * Checks whether a permalink is available
 * @returns {boolean} Returns true if the Paper has a permalink.
 */
Paper.prototype.hasPermalink = function () {
  return this._attributes.permalink !== "";
};

/**
 * Returns the permalink, or an empty string if no permalink is available.
 * @returns {string} Returns the permalink.
 */
Paper.prototype.getPermalink = function () {
  return this._attributes.permalink;
};

/**
 * Checks whether a date is available.
 * @returns {boolean} Returns true if the Paper has a date.
 */
Paper.prototype.hasDate = function () {
  return this._attributes.date !== "";
};

/**
 * Returns the date, or an empty string if no date is available.
 * @returns {string} Returns the date.
 */
Paper.prototype.getDate = function () {
  return this._attributes.date;
};

/**
 * Checks whether custom data is available.
 * @returns {boolean} Returns true if the Paper has custom data.
 */
Paper.prototype.hasCustomData = function () {
  return !(0, _lodash.isEmpty)(this._attributes.customData);
};

/**
 * Returns the custom data, or an empty object if no data is available.
 * @returns {Object} Returns the custom data.
 */
Paper.prototype.getCustomData = function () {
  return this._attributes.customData;
};

/**
 * Checks whether a text title is available.
 * @returns {boolean} Returns true if the Paper has a text title.
 */
Paper.prototype.hasTextTitle = function () {
  return this._attributes.textTitle !== "" && !(0, _lodash.isNil)(this._attributes.textTitle);
};

/**
 * Returns the text title, or an empty string if no data is available.
 * @returns {string} Returns the text title.
 */
Paper.prototype.getTextTitle = function () {
  return this._attributes.textTitle;
};

/**
 * Serializes the Paper instance to an object.
 *
 * @returns {Object} The serialized Paper.
 */
Paper.prototype.serialize = function () {
  return {
    _parseClass: "Paper",
    text: this._text,
    ...this._attributes
  };
};

/**
 * Checks whether the given paper has the same properties as this instance.
 *
 * @param {Paper} paper The paper to compare to.
 *
 * @returns {boolean} Whether the given paper is identical or not.
 */
Paper.prototype.equals = function (paper) {
  return this._text === paper.getText() && (0, _lodash.isEqual)(this._attributes, paper._attributes);
};

/**
 * Parses the object to a Paper.
 *
 * @param {Object|Paper} serialized The serialized object or Paper instance.
 *
 * @returns {Paper} The parsed Paper.
 */
Paper.parse = function (serialized) {
  // For ease of use, check if it is not already a Paper instance.
  if (serialized instanceof Paper) {
    return serialized;
  }

  // _parseClass is taken here, so it doesn't end up in the attributes.
  // eslint-disable-next-line no-unused-vars
  const {
    text,
    _parseClass,
    ...attributes
  } = serialized;
  return new Paper(text, attributes);
};
var _default = exports["default"] = Paper;

/***/ }),

/***/ "./node_modules/yoastseo/build/values/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/yoastseo/build/values/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "AssessmentResult", ({
  enumerable: true,
  get: function () {
    return _AssessmentResult.default;
  }
}));
Object.defineProperty(exports, "Mark", ({
  enumerable: true,
  get: function () {
    return _Mark.default;
  }
}));
Object.defineProperty(exports, "Paper", ({
  enumerable: true,
  get: function () {
    return _Paper.default;
  }
}));
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ./AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _Mark = _interopRequireDefault(__webpack_require__(/*! ./Mark */ "./node_modules/yoastseo/build/values/Mark.js"));
var _Paper = _interopRequireDefault(__webpack_require__(/*! ./Paper */ "./node_modules/yoastseo/build/values/Paper.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/worker/AnalysisWebWorker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/yoastseo/build/worker/AnalysisWebWorker.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _featureFlag = __webpack_require__(/*! @yoast/feature-flag */ "./node_modules/@yoast/feature-flag/build/index.js");
var _i18n = __webpack_require__(/*! @wordpress/i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js");
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _loglevel = __webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js");
var _seoAssessor = _interopRequireDefault(__webpack_require__(/*! ../scoring/seoAssessor */ "./node_modules/yoastseo/build/scoring/seoAssessor.js"));
var _contentAssessor = _interopRequireDefault(__webpack_require__(/*! ../scoring/contentAssessor */ "./node_modules/yoastseo/build/scoring/contentAssessor.js"));
var _taxonomyAssessor = _interopRequireDefault(__webpack_require__(/*! ../scoring/taxonomyAssessor */ "./node_modules/yoastseo/build/scoring/taxonomyAssessor.js"));
var _Paper = _interopRequireDefault(__webpack_require__(/*! ../values/Paper */ "./node_modules/yoastseo/build/values/Paper.js"));
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _relatedKeywordAssessor = _interopRequireDefault(__webpack_require__(/*! ../scoring/relatedKeywordAssessor */ "./node_modules/yoastseo/build/scoring/relatedKeywordAssessor.js"));
var _inclusiveLanguageAssessor = _interopRequireDefault(__webpack_require__(/*! ../scoring/inclusiveLanguageAssessor */ "./node_modules/yoastseo/build/scoring/inclusiveLanguageAssessor.js"));
var _build = __webpack_require__(/*! ../parse/build */ "./node_modules/yoastseo/build/parse/build/index.js");
var _LanguageProcessor = _interopRequireDefault(__webpack_require__(/*! ../parse/language/LanguageProcessor */ "./node_modules/yoastseo/build/parse/language/LanguageProcessor.js"));
var _contentAssessor2 = _interopRequireDefault(__webpack_require__(/*! ../scoring/cornerstone/contentAssessor */ "./node_modules/yoastseo/build/scoring/cornerstone/contentAssessor.js"));
var _relatedKeywordAssessor2 = _interopRequireDefault(__webpack_require__(/*! ../scoring/cornerstone/relatedKeywordAssessor */ "./node_modules/yoastseo/build/scoring/cornerstone/relatedKeywordAssessor.js"));
var _seoAssessor2 = _interopRequireDefault(__webpack_require__(/*! ../scoring/cornerstone/seoAssessor */ "./node_modules/yoastseo/build/scoring/cornerstone/seoAssessor.js"));
var _invalidType = _interopRequireDefault(__webpack_require__(/*! ../errors/invalidType */ "./node_modules/yoastseo/build/errors/invalidType.js"));
var _missingArgument = _interopRequireDefault(__webpack_require__(/*! ../errors/missingArgument */ "./node_modules/yoastseo/build/errors/missingArgument.js"));
var _includesAny = _interopRequireDefault(__webpack_require__(/*! ../helpers/includesAny */ "./node_modules/yoastseo/build/helpers/includesAny.js"));
var _shortlinker = __webpack_require__(/*! ../helpers/shortlinker */ "./node_modules/yoastseo/build/helpers/shortlinker/index.js");
var _relatedKeywordTaxonomyAssessor = _interopRequireDefault(__webpack_require__(/*! ../scoring/relatedKeywordTaxonomyAssessor */ "./node_modules/yoastseo/build/scoring/relatedKeywordTaxonomyAssessor.js"));
var _scheduler = _interopRequireDefault(__webpack_require__(/*! ./scheduler */ "./node_modules/yoastseo/build/worker/scheduler/index.js"));
var _transporter = _interopRequireDefault(__webpack_require__(/*! ./transporter */ "./node_modules/yoastseo/build/worker/transporter/index.js"));
var _wrapTryCatchAroundAction = _interopRequireDefault(__webpack_require__(/*! ./wrapTryCatchAroundAction */ "./node_modules/yoastseo/build/worker/wrapTryCatchAroundAction.js"));
var _scoreAggregators = __webpack_require__(/*! ../scoring/scoreAggregators */ "./node_modules/yoastseo/build/scoring/scoreAggregators/index.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/* eslint-disable max-statements,complexity */
// External dependencies.

// YoastSEO.js dependencies.

// Internal dependencies.

// Tree assessor functionality.

const logger = (0, _loglevel.getLogger)("yoast-analysis-worker");
logger.setDefaultLevel("error");

/**
 * Analysis Web Worker.
 *
 * Worker API:     https://developer.mozilla.org/en-US/docs/Web/API/Worker
 * Webpack loader: https://github.com/webpack-contrib/worker-loader
 */
class AnalysisWebWorker {
  /* eslint-disable max-statements */
  /**
   * Initializes the AnalysisWebWorker class.
   *
   * @param {Object}      scope       The scope for the messaging. Expected to have the
   *                                  `onmessage` event and the `postMessage` function.
   * @param {Researcher}  researcher  The researcher to use.
   */
  constructor(scope, researcher) {
    this._scope = scope;
    this._configuration = {
      contentAnalysisActive: true,
      keywordAnalysisActive: true,
      inclusiveLanguageAnalysisActive: false,
      useCornerstone: false,
      useTaxonomy: false,
      // The locale used for language-specific configurations in Flesch-reading ease and Sentence length assessments.
      locale: "en_US",
      customAnalysisType: ""
    };
    this._scheduler = new _scheduler.default();
    this._paper = null;
    this._relatedKeywords = {};
    this._researcher = researcher;
    this._contentAssessor = null;
    this._seoAssessor = null;
    this._relatedKeywordAssessor = null;
    this.additionalAssessors = {};
    this._inclusiveLanguageOptions = {};

    /*
     * The cached analyses results.
     *
     * A single result has the following structure:
     * {AssessmentResult[]} 	readability.results An array of assessment results; in serialized format.
     * {number}             	readability.score   The overall score.
     *
     * The results have the following structure.
     * {Object} 				readability 		Content assessor results.
     * {Object} 				seo         		SEO assessor results, per keyword identifier or empty string for the main.
     * {Object} 				seo[ "" ]  			The result of the paper analysis for the main keyword.
     * {Object} 				seo[ key ]  		Same as above, but instead for a related keyword.
     * {Object} 				inclusiveLanguage 	Inclusive language assessor results.
     */
    this._results = {
      readability: {
        results: [],
        score: 0
      },
      seo: {
        "": {
          results: [],
          score: 0
        }
      },
      inclusiveLanguage: {
        results: [],
        score: 0
      }
    };
    this._registeredAssessments = [];
    this._registeredMessageHandlers = {};
    this._registeredParsers = [];

    // Set up everything for the analysis on the tree.
    this.setupTreeAnalysis();
    this.bindActions();
    this.assessRelatedKeywords = this.assessRelatedKeywords.bind(this);

    // Bind register functions to this scope.
    this.registerAssessment = this.registerAssessment.bind(this);
    this.registerMessageHandler = this.registerMessageHandler.bind(this);
    this.refreshAssessment = this.refreshAssessment.bind(this);
    this.setCustomContentAssessorClass = this.setCustomContentAssessorClass.bind(this);
    this.setCustomCornerstoneContentAssessorClass = this.setCustomCornerstoneContentAssessorClass.bind(this);
    this.setCustomSEOAssessorClass = this.setCustomSEOAssessorClass.bind(this);
    this.setCustomCornerstoneSEOAssessorClass = this.setCustomCornerstoneSEOAssessorClass.bind(this);
    this.setCustomRelatedKeywordAssessorClass = this.setCustomRelatedKeywordAssessorClass.bind(this);
    this.setCustomCornerstoneRelatedKeywordAssessorClass = this.setCustomCornerstoneRelatedKeywordAssessorClass.bind(this);
    this.registerAssessor = this.registerAssessor.bind(this);
    this.registerResearch = this.registerResearch.bind(this);
    this.registerHelper = this.registerHelper.bind(this);
    this.registerResearcherConfig = this.registerResearcherConfig.bind(this);
    this.setInclusiveLanguageOptions = this.setInclusiveLanguageOptions.bind(this);

    // Bind event handlers to this scope.
    this.handleMessage = this.handleMessage.bind(this);

    // Wrap try/catch around actions.
    this.analyzeRelatedKeywords = (0, _wrapTryCatchAroundAction.default)(logger, this.analyze, "An error occurred while running the related keywords analysis.");
    /*
     * Overwrite this.analyze after we use it in this.analyzeRelatedKeywords so that this.analyzeRelatedKeywords
     * doesn't use the overwritten version. Therefore, this order shouldn't be changed.
     */
    this.analyze = (0, _wrapTryCatchAroundAction.default)(logger, this.analyze, "An error occurred while running the analysis.");
    this.runResearch = (0, _wrapTryCatchAroundAction.default)(logger, this.runResearch, "An error occurred after running the '%%name%%' research.");
  }
  /* eslint-enable max-statements */

  /**
   * Binds actions to this scope.
   *
   * @returns {void}
   */
  bindActions() {
    // Bind actions to this scope.
    this.analyze = this.analyze.bind(this);
    this.analyzeDone = this.analyzeDone.bind(this);
    this.analyzeRelatedKeywordsDone = this.analyzeRelatedKeywordsDone.bind(this);
    this.loadScript = this.loadScript.bind(this);
    this.loadScriptDone = this.loadScriptDone.bind(this);
    this.customMessage = this.customMessage.bind(this);
    this.customMessageDone = this.customMessageDone.bind(this);
    this.clearCache = this.clearCache.bind(this);
    this.runResearch = this.runResearch.bind(this);
    this.runResearchDone = this.runResearchDone.bind(this);
  }

  /**
   * Sets a custom content assessor class.
   *
   * @param {Class}  ContentAssessorClass     A content assessor class.
   * @param {string} customAnalysisType       The type of analysis.
   * @param {Object} customAssessorOptions    The options to use.
   *
   * @returns {void}
   */
  setCustomContentAssessorClass(ContentAssessorClass, customAnalysisType, customAssessorOptions) {
    this._CustomContentAssessorClasses[customAnalysisType] = ContentAssessorClass;
    this._CustomContentAssessorOptions[customAnalysisType] = customAssessorOptions;
    this._contentAssessor = this.createContentAssessor();
  }

  /**
   * Sets a custom cornerstone content assessor class.
   *
   * @param {Class}  CornerstoneContentAssessorClass  A cornerstone content assessor class.
   * @param {string} customAnalysisType               The type of analysis.
   * @param {Object} customAssessorOptions            The options to use.
   *
   * @returns {void}
   */
  setCustomCornerstoneContentAssessorClass(CornerstoneContentAssessorClass, customAnalysisType, customAssessorOptions) {
    this._CustomCornerstoneContentAssessorClasses[customAnalysisType] = CornerstoneContentAssessorClass;
    this._CustomCornerstoneContentAssessorOptions[customAnalysisType] = customAssessorOptions;
    this._contentAssessor = this.createContentAssessor();
  }

  /**
   * Sets a custom SEO assessor class.
   *
   * @param {Class}   SEOAssessorClass         An SEO assessor class.
   * @param {string}  customAnalysisType       The type of analysis.
   * @param {Object}  customAssessorOptions    The options to use.
   *
   * @returns {void}
   */
  setCustomSEOAssessorClass(SEOAssessorClass, customAnalysisType, customAssessorOptions) {
    this._CustomSEOAssessorClasses[customAnalysisType] = SEOAssessorClass;
    this._CustomSEOAssessorOptions[customAnalysisType] = customAssessorOptions;
    this._seoAssessor = this.createSEOAssessor();
  }

  /**
   * Sets a custom cornerstone SEO assessor class.
   *
   * @param {Class}   CornerstoneSEOAssessorClass  A cornerstone SEO assessor class.
   * @param {string}  customAnalysisType           The type of analysis.
   * @param {Object}  customAssessorOptions        The options to use.
   *
   * @returns {void}
   */
  setCustomCornerstoneSEOAssessorClass(CornerstoneSEOAssessorClass, customAnalysisType, customAssessorOptions) {
    this._CustomCornerstoneSEOAssessorClasses[customAnalysisType] = CornerstoneSEOAssessorClass;
    this._CustomCornerstoneSEOAssessorOptions[customAnalysisType] = customAssessorOptions;
    this._seoAssessor = this.createSEOAssessor();
  }

  /**
   * Sets a custom related keyword assessor class.
   *
   * @param {Class}   RelatedKeywordAssessorClass A related keyword assessor class.
   * @param {string}  customAnalysisType          The type of analysis.
   * @param {Object}  customAssessorOptions       The options to use.
   *
   * @returns {void}
   */
  setCustomRelatedKeywordAssessorClass(RelatedKeywordAssessorClass, customAnalysisType, customAssessorOptions) {
    this._CustomRelatedKeywordAssessorClasses[customAnalysisType] = RelatedKeywordAssessorClass;
    this._CustomRelatedKeywordAssessorOptions[customAnalysisType] = customAssessorOptions;
    this._relatedKeywordAssessor = this.createRelatedKeywordsAssessor();
  }

  /**
   * Sets a custom cornerstone related keyword assessor class.
   *
   * @param {Class}   CornerstoneRelatedKeywordAssessorClass  A cornerstone related keyword assessor class.
   * @param {string}  customAnalysisType                      The type of analysis.
   * @param {Object}  customAssessorOptions                   The options to use.
   *
   * @returns {void}
   */
  setCustomCornerstoneRelatedKeywordAssessorClass(CornerstoneRelatedKeywordAssessorClass, customAnalysisType, customAssessorOptions) {
    this._CustomCornerstoneRelatedKeywordAssessorClasses[customAnalysisType] = CornerstoneRelatedKeywordAssessorClass;
    this._CustomCornerstoneRelatedKeywordAssessorOptions[customAnalysisType] = customAssessorOptions;
    this._relatedKeywordAssessor = this.createRelatedKeywordsAssessor();
  }

  /**
   * Sets the options to use for the Inclusive language analysis.
   *
   * @param {{infoLinks: {}}} options The options to use.
   *
   * @returns {void}
   */
  setInclusiveLanguageOptions(options) {
    this._inclusiveLanguageOptions = options;
  }

  /**
   * Sets up the web worker for running the tree readability and SEO analysis.
   *
   * @returns {void}
   */
  setupTreeAnalysis() {
    // Researcher
    /*
     * Disabled code:
     * this._treeResearcher = new TreeResearcher();
     */
    this._treeResearcher = null;

    // Assessors
    this._contentTreeAssessor = null;
    this._seoTreeAssessor = null;
    this._relatedKeywordTreeAssessor = null;

    // Custom assessor classes.
    this._CustomSEOAssessorClasses = {};
    this._CustomCornerstoneSEOAssessorClasses = {};
    this._CustomContentAssessorClasses = {};
    this._CustomCornerstoneContentAssessorClasses = {};
    this._CustomRelatedKeywordAssessorClasses = {};
    this._CustomCornerstoneRelatedKeywordAssessorClasses = {};

    // Custom assessor options.
    this._CustomSEOAssessorOptions = {};
    this._CustomCornerstoneSEOAssessorOptions = {};
    this._CustomContentAssessorOptions = {};
    this._CustomCornerstoneContentAssessorOptions = {};
    this._CustomRelatedKeywordAssessorOptions = {};
    this._CustomCornerstoneRelatedKeywordAssessorOptions = {};

    // Registered assessments
    this._registeredTreeAssessments = [];

    // Score aggregators
    this._seoScoreAggregator = new _scoreAggregators.SEOScoreAggregator();
    this._contentScoreAggregator = new _scoreAggregators.ReadabilityScoreAggregator();

    // Tree representation of text to analyze
    this._tree = null;

    // Tree builder.
    this._treeBuilder = null;
  }

  /**
   * Registers this web worker with the scope passed to it's constructor.
   *
   * @returns {void}
   */
  register() {
    this._scope.onmessage = this.handleMessage;
    this._scope.analysisWorker = this;
  }

  /**
   * Receives the post message and determines the action.
   *
   * See: https://developer.mozilla.org/en-US/docs/Web/API/Worker/onmessage
   *
   * @param {MessageEvent} event              The post message event.
   * @param {Object}       event.data         The data object.
   * @param {string}       event.data.type    The action type.
   * @param {string}       event.data.id      The request id.
   * @param {string}       event.data.payload The payload of the action.
   *
   * @returns {void}
   */
  handleMessage({
    data: {
      type,
      id,
      payload
    }
  }) {
    payload = _transporter.default.parse(payload);
    logger.debug("AnalysisWebWorker incoming:", type, id, payload);
    switch (type) {
      case "initialize":
        this.initialize(id, payload);
        this._scheduler.startPolling();
        break;
      case "analyze":
        this._scheduler.schedule({
          id,
          execute: this.analyze,
          done: this.analyzeDone,
          data: payload,
          type: type
        });
        break;
      case "analyzeRelatedKeywords":
        this._scheduler.schedule({
          id,
          execute: this.analyzeRelatedKeywords,
          done: this.analyzeRelatedKeywordsDone,
          data: payload,
          type: type
        });
        break;
      case "loadScript":
        this._scheduler.schedule({
          id,
          execute: this.loadScript,
          done: this.loadScriptDone,
          data: payload,
          type: type
        });
        break;
      case "runResearch":
        this._scheduler.schedule({
          id,
          execute: this.runResearch,
          done: this.runResearchDone,
          data: payload
        });
        break;
      case "customMessage":
        {
          const name = payload.name;
          if (name && this._registeredMessageHandlers[name]) {
            this._scheduler.schedule({
              id,
              execute: this.customMessage,
              done: this.customMessageDone,
              data: payload,
              type: type
            });
            break;
          }
          this.customMessageDone(id, {
            error: new Error("No message handler registered for messages with name: " + name)
          });
          break;
        }
      default:
        console.warn("AnalysisWebWorker unrecognized action:", type);
    }
  }

  /**
   * Initializes the appropriate content assessor.
   *
   * @returns {null|Assessor} The chosen content assessor.
   */
  createContentAssessor() {
    const {
      contentAnalysisActive,
      useCornerstone,
      customAnalysisType
    } = this._configuration;
    if (contentAnalysisActive === false) {
      return null;
    }
    let assessor;
    if (useCornerstone === true) {
      /*
       * Use a custom cornerstone content assessor if available,
       * otherwise set the default cornerstone content assessor.
       */
      assessor = this._CustomCornerstoneContentAssessorClasses[customAnalysisType] ? new this._CustomCornerstoneContentAssessorClasses[customAnalysisType](this._researcher, this._CustomCornerstoneContentAssessorOptions[customAnalysisType]) : new _contentAssessor2.default(this._researcher);

      // Add the readability assessment for cornerstone content to the cornerstone content assessor.
      this._registeredAssessments.forEach(({
        name,
        assessment,
        type
      }) => {
        if ((0, _lodash.isUndefined)(assessor.getAssessment(name)) && type === "cornerstoneReadability") {
          assessor.addAssessment(name, assessment);
        }
      });
    } else {
      /*
       * For non-cornerstone content, use a custom SEO assessor if available,
             * otherwise use the default SEO assessor.
       */
      assessor = this._CustomContentAssessorClasses[customAnalysisType] ? new this._CustomContentAssessorClasses[customAnalysisType](this._researcher, this._CustomContentAssessorOptions[customAnalysisType]) : new _contentAssessor.default(this._researcher);

      // Add the readability assessment for regular content to the regular content assessor.
      this._registeredAssessments.forEach(({
        name,
        assessment,
        type
      }) => {
        if ((0, _lodash.isUndefined)(assessor.getAssessment(name)) && type === "readability") {
          assessor.addAssessment(name, assessment);
        }
      });
    }
    return assessor;
  }

  /**
   * Initializes the appropriate SEO assessor.
   *
   * @returns {null|Assessor} The chosen SEO assessor.
   */
  createSEOAssessor() {
    const {
      keywordAnalysisActive,
      useCornerstone,
      useTaxonomy,
      customAnalysisType
    } = this._configuration;
    if (keywordAnalysisActive === false) {
      return null;
    }
    let assessor;
    if (useTaxonomy === true) {
      assessor = new _taxonomyAssessor.default(this._researcher);
    } else {
      // Set cornerstone SEO assessor for cornerstone content.
      if (useCornerstone === true) {
        // Use a custom cornerstone SEO assessor if available, otherwise set the default cornerstone SEO assessor.
        assessor = this._CustomCornerstoneSEOAssessorClasses[customAnalysisType] ? new this._CustomCornerstoneSEOAssessorClasses[customAnalysisType](this._researcher, this._CustomCornerstoneSEOAssessorOptions[customAnalysisType]) : new _seoAssessor2.default(this._researcher);
      } else {
        /*
         * For non-cornerstone content, use a custom SEO assessor if available,
         * otherwise use the default SEO assessor.
         */
        assessor = this._CustomSEOAssessorClasses[customAnalysisType] ? new this._CustomSEOAssessorClasses[customAnalysisType](this._researcher, this._CustomSEOAssessorOptions[customAnalysisType]) : new _seoAssessor.default(this._researcher);
      }
    }
    this._registeredAssessments.forEach(({
      name,
      assessment,
      type
    }) => {
      if ((0, _lodash.isUndefined)(assessor.getAssessment(name)) && type === "seo") {
        assessor.addAssessment(name, assessment);
      }
    });
    return assessor;
  }

  /**
   * Initializes the appropriate inclusive language assessor.
   *
   * @returns {null|Assessor} The chosen inclusive language assessor.
   */
  createInclusiveLanguageAssessor() {
    const {
      inclusiveLanguageAnalysisActive
    } = this._configuration;
    if (inclusiveLanguageAnalysisActive === false) {
      return null;
    }
    return new _inclusiveLanguageAssessor.default(this._researcher, this._inclusiveLanguageOptions);
  }

  /**
   * Initializes the appropriate SEO assessor for related keywords.
   *
   * @returns {null|Assessor} The chosen related keywords assessor.
   */
  createRelatedKeywordsAssessor() {
    const {
      keywordAnalysisActive,
      useCornerstone,
      useTaxonomy,
      customAnalysisType
    } = this._configuration;
    if (keywordAnalysisActive === false) {
      return null;
    }
    let assessor;
    if (useTaxonomy === true) {
      assessor = new _relatedKeywordTaxonomyAssessor.default(this._researcher);
    } else {
      // Set cornerstone related keyword assessor for cornerstone content.
      if (useCornerstone === true) {
        // Use a custom related keyword assessor if available, otherwise use the default related keyword assessor.
        assessor = this._CustomCornerstoneRelatedKeywordAssessorClasses[customAnalysisType] ? new this._CustomCornerstoneRelatedKeywordAssessorClasses[customAnalysisType](this._researcher, this._CustomCornerstoneRelatedKeywordAssessorOptions[customAnalysisType]) : new _relatedKeywordAssessor2.default(this._researcher);
      } else {
        /*
         * For non-cornerstone content, use a custom related keyword assessor if available,
         * otherwise use the default related keyword assessor.
         */
        assessor = this._CustomRelatedKeywordAssessorClasses[customAnalysisType] ? new this._CustomRelatedKeywordAssessorClasses[customAnalysisType](this._researcher, this._CustomRelatedKeywordAssessorOptions[customAnalysisType]) : new _relatedKeywordAssessor.default(this._researcher);
      }
    }
    this._registeredAssessments.forEach(({
      name,
      assessment,
      type
    }) => {
      if ((0, _lodash.isUndefined)(assessor.getAssessment(name)) && type === "relatedKeyphrase") {
        assessor.addAssessment(name, assessment);
      }
    });
    return assessor;
  }

  /**
   * Creates an SEO assessor for a tree, based on the given combination of cornerstone, taxonomy and related keyphrase flags.
   *
   * @param {Object}  assessorConfig                    The assessor configuration.
   * @param {boolean} [assessorConfig.relatedKeyphrase] If this assessor is for a related keyphrase, instead of the main one.
   * @param {boolean} [assessorConfig.taxonomy]         If this assessor is for a taxonomy page, instead of a regular page.
   * @param {boolean} [assessorConfig.cornerstone]      If this assessor is for cornerstone content.
   *
   * @returns {module:parsedPaper/assess.TreeAssessor} The created tree assessor.
   */

  /*
   * Disabled code:
   * createSEOTreeAssessor( assessorConfig ) {
   * 	 return constructSEOAssessor( this._treeResearcher, assessorConfig );
   * }
   */

  /**
   * Sends a message.
   *
   * @param {string} type      The message type.
   * @param {number} id        The request id.
   * @param {Object} [payload] The payload to deliver.
   *
   * @returns {void}
   */
  send(type, id, payload = {}) {
    logger.debug("AnalysisWebWorker outgoing:", type, id, payload);
    payload = _transporter.default.serialize(payload);
    this._scope.postMessage({
      type,
      id,
      payload
    });
  }

  /**
   * Checks which assessors should update giving a configuration.
   *
   * @param {Object}   configuration          The configuration to check.
   * @param {Assessor} [contentAssessor=null] The content assessor.
   * @param {Assessor} [seoAssessor=null]     The SEO assessor.
   * @param {Assessor} [inclusiveLanguageAssessor=null] The inclusive language assessor.
   *
   * @returns {Object} Containing seo, readability, and inclusiveLanguage with true or false.
   */
  static shouldAssessorsUpdate(configuration, contentAssessor = null, seoAssessor = null, inclusiveLanguageAssessor = null) {
    const readability = ["contentAnalysisActive", "useCornerstone", "locale", "translations", "customAnalysisType"];
    const seo = ["keywordAnalysisActive", "useCornerstone", "useTaxonomy", "locale", "translations", "researchData", "customAnalysisType"];
    const inclusiveLanguage = ["inclusiveLanguageAnalysisActive", "locale", "translations"];
    const configurationKeys = Object.keys(configuration);
    return {
      readability: (0, _lodash.isNull)(contentAssessor) || (0, _includesAny.default)(configurationKeys, readability),
      seo: (0, _lodash.isNull)(seoAssessor) || (0, _includesAny.default)(configurationKeys, seo),
      inclusiveLanguage: (0, _lodash.isNull)(inclusiveLanguageAssessor) || (0, _includesAny.default)(configurationKeys, inclusiveLanguage)
    };
  }

  /**
   * Configures the analysis worker.
   *
   * @param {number}   id                                     The request id.
   * @param {Object}   configuration                          The configuration object.
   * @param {boolean}  [configuration.contentAnalysisActive]  Whether the content analysis is active.
   * @param {boolean}  [configuration.keywordAnalysisActive]  Whether the keyword analysis is active.
   * @param {boolean}  [configuration.useCornerstone]         Whether the paper is cornerstone or not.
   * @param {boolean}  [configuration.useTaxonomy]            Whether the taxonomy assessor should be used.
   * @param {string}   [configuration.locale]                 The locale used in the seo assessor.
   * @param {Object}   [configuration.translations]           The translation strings.
   * @param {Object}   [configuration.researchData]           Extra research data.
   * @param {Object}   [configuration.defaultQueryParams]     The default query params for the Shortlinker.
   * @param {string}   [configuration.logLevel]               Log level, see: https://github.com/pimterry/loglevel#documentation
   * @param {string[]} [configuration.enabledFeatures]        A list of feature name flags of the experimental features to enable.
   *
   * @returns {void}
   */
  initialize(id, configuration) {
    const update = AnalysisWebWorker.shouldAssessorsUpdate(configuration, this._contentAssessor, this._seoAssessor, this._inclusiveLanguageAssessor);
    if ((0, _lodash.has)(configuration, "translations")) {
      Object.values(configuration.translations).forEach(translation => {
        // Don't proceed if translation object is null or otherwise falsy.
        if (translation) {
          const {
            domain,
            locale_data: localeData
          } = translation;
          (0, _i18n.setLocaleData)(localeData[domain], domain);
        }
      });
    }
    if ((0, _lodash.has)(configuration, "researchData")) {
      (0, _lodash.forEach)(configuration.researchData, (data, research) => {
        this._researcher.addResearchData(research, data);
      });
      delete configuration.researchData;
    }
    if ((0, _lodash.has)(configuration, "defaultQueryParams")) {
      (0, _shortlinker.configureShortlinker)({
        params: configuration.defaultQueryParams
      });
      delete configuration.defaultQueryParams;
    }
    if ((0, _lodash.has)(configuration, "logLevel")) {
      logger.setLevel(configuration.logLevel, false);
      delete configuration.logLevel;
    }
    if ((0, _lodash.has)(configuration, "enabledFeatures")) {
      // Make feature flags available inside of the web worker.
      (0, _featureFlag.enableFeatures)(configuration.enabledFeatures);
      delete configuration.enabledFeatures;
    }
    this._configuration = (0, _lodash.merge)(this._configuration, configuration);
    if (update.readability) {
      this._contentAssessor = this.createContentAssessor();
      /*
       * Disabled code:
       * this._contentTreeAssessor = constructReadabilityAssessor( this._treeResearcher, configuration.useCornerstone );
       */
      this._contentTreeAssessor = null;
    }
    if (update.seo) {
      this._seoAssessor = this.createSEOAssessor();
      this._relatedKeywordAssessor = this.createRelatedKeywordsAssessor();
      // Tree assessors
      /*
       * Disabled code:
       * const { useCornerstone, useTaxonomy } = this._configuration;
       * this._seoTreeAssessor = useTaxonomy
       * 	? this.createSEOTreeAssessor( { taxonomy: true } )
       * 	: this.createSEOTreeAssessor( { cornerstone: useCornerstone } );
       * this._relatedKeywordTreeAssessor = this.createSEOTreeAssessor( {
       * 	cornerstone: useCornerstone, relatedKeyphrase: true,
       * } );
       */
    }
    if (update.inclusiveLanguage) {
      this._inclusiveLanguageAssessor = this.createInclusiveLanguageAssessor();
    }

    // Reset the paper in order to not use the cached results on analyze.
    this.clearCache();
    this.send("initialize:done", id);
  }

  /**
   * Registers a custom assessor.
   *
   * @param {string} name The name of the assessor.
   * @param {Function} AssessorClass The assessor class to instantiate.
   * @param {Function} shouldUpdate Function that checks whether the assessor should update.
   *
   * @returns {void}
   */
  registerAssessor(name, AssessorClass, shouldUpdate) {
    const assessor = new AssessorClass(this._researcher);
    this.additionalAssessors[name] = {
      assessor,
      shouldUpdate
    };
  }

  /**
   * Register an assessment for a specific plugin.
   *
   * @param {string}   name       The name of the assessment.
   * @param {function} assessment The function to run as an assessment.
   * @param {string}   pluginName The name of the plugin associated with the assessment.
   * @param {string}   type       The type of the assessment. The default type is seo.
   *
   * @returns {boolean} Whether registering the assessment was successful.
   */
  registerAssessment(name, assessment, pluginName, type = "seo") {
    const {
      useCornerstone
    } = this._configuration;
    if (!(0, _lodash.isString)(name)) {
      throw new _invalidType.default("Failed to register assessment for plugin " + pluginName + ". Expected parameter `name` to be a string.");
    }
    if (!(0, _lodash.isObject)(assessment)) {
      throw new _invalidType.default("Failed to register assessment for plugin " + pluginName + ". Expected parameter `assessment` to be a function.");
    }
    if (!(0, _lodash.isString)(pluginName)) {
      throw new _invalidType.default("Failed to register assessment for plugin " + pluginName + ". Expected parameter `pluginName` to be a string.");
    }

    // Prefix the name with the pluginName so the test name is always unique.
    const combinedName = pluginName + "-" + name;
    if (this._seoAssessor !== null && type === "seo") {
      this._seoAssessor.addAssessment(combinedName, assessment);
    }
    if (this._contentAssessor !== null && type === "readability") {
      this._contentAssessor.addAssessment(combinedName, assessment);
    }
    if (this._contentAssessor !== null && type === "cornerstoneReadability" && useCornerstone) {
      this._contentAssessor.addAssessment(combinedName, assessment);
    }
    if (this._relatedKeywordAssessor !== null && type === "relatedKeyphrase") {
      this._relatedKeywordAssessor.addAssessment(combinedName, assessment);
    }
    this._registeredAssessments.push({
      combinedName,
      assessment,
      type
    });
    this.refreshAssessment(name, pluginName);
    return true;
  }

  /**
   * Register a message handler for a specific plugin.
   *
   * @param {string}   name       The name of the message handler.
   * @param {function} handler    The function to run as an message handler.
   * @param {string}   pluginName The name of the plugin associated with the message handler.
   *
   * @returns {boolean} Whether registering the message handler was successful.
   */
  registerMessageHandler(name, handler, pluginName) {
    if (!(0, _lodash.isString)(name)) {
      throw new _invalidType.default("Failed to register handler for plugin " + pluginName + ". Expected parameter `name` to be a string.");
    }
    if (!(0, _lodash.isObject)(handler)) {
      throw new _invalidType.default("Failed to register handler for plugin " + pluginName + ". Expected parameter `handler` to be a function.");
    }
    if (!(0, _lodash.isString)(pluginName)) {
      throw new _invalidType.default("Failed to register handler for plugin " + pluginName + ". Expected parameter `pluginName` to be a string.");
    }

    // Prefix the name with the pluginName so the test name is always unique.
    name = pluginName + "-" + name;
    this._registeredMessageHandlers[name] = handler;
  }

  /**
   * Refreshes an assessment in the analysis.
   *
   * Custom assessments can use this to mark their assessment as needing a
   * refresh.
   *
   * @param {string} name The name of the assessment.
   * @param {string} pluginName The name of the plugin associated with the assessment.
   *
   * @returns {boolean} Whether refreshing the assessment was successful.
   */
  refreshAssessment(name, pluginName) {
    if (!(0, _lodash.isString)(name)) {
      throw new _invalidType.default("Failed to refresh assessment for plugin " + pluginName + ". Expected parameter `name` to be a string.");
    }
    if (!(0, _lodash.isString)(pluginName)) {
      throw new _invalidType.default("Failed to refresh assessment for plugin " + pluginName + ". Expected parameter `pluginName` to be a string.");
    }
    this.clearCache();
  }

  /**
   * Register a parser that parses a formatted text
   * to a structured tree representation that can be further analyzed.
   *
   * @param {Object}   parser                              The parser to register.
   * @param {function(Paper): boolean} parser.isApplicable A method that checks whether this parser is applicable for a paper.
   * @param {function(Paper): module:parsedPaper/structure.Node } parser.parse A method that parses a paper to a structured tree representation.
   *
   * @returns {void}
   */
  registerParser(parser) {
    if (typeof parser.isApplicable !== "function") {
      throw new _invalidType.default("Failed to register the custom parser. Expected parameter 'parser' to have a method 'isApplicable'.");
    }
    if (typeof parser.parse !== "function") {
      throw new _invalidType.default("Failed to register the custom parser. Expected parameter 'parser' to have a method 'parse'.");
    }
    this._registeredParsers.push(parser);
  }

  /**
   * Clears the worker cache to force a new analysis.
   *
   * @returns {void}
   */
  clearCache() {
    this._paper = null;
  }

  /**
   * Changes the locale in the configuration.
   *
   * If the locale is different:
   * - Update the configuration locale.
   * - Create the content assessor.
   *
   * @param {string} locale The locale to set.
   *
   * @returns {void}
   */
  setLocale(locale) {
    if (this._configuration.locale === locale) {
      return;
    }
    this._configuration.locale = locale;
    this._contentAssessor = this.createContentAssessor();
  }

  /**
   * Checks if the paper contains changes that are used for readability.
   *
   * @param {Paper} paper The paper to check against the cached paper.
   *
   * @returns {boolean} True if there are changes detected.
   */
  shouldReadabilityUpdate(paper) {
    if (this._paper === null) {
      return true;
    }
    if (this._paper.getText() !== paper.getText()) {
      return true;
    }
    return this._paper.getLocale() !== paper.getLocale();
  }

  /**
   * Checks if the paper contains changes that are used for inclusive language analysis.
   *
   * @param {Paper} paper The paper to check against the cached paper.
   *
   * @returns {boolean} True if there are changes detected.
   */
  shouldInclusiveLanguageUpdate(paper) {
    if (this._paper === null) {
      return true;
    }
    if (this._paper.getText() !== paper.getText()) {
      return true;
    }
    if (this._paper.getTextTitle() !== paper.getTextTitle()) {
      return true;
    }
    return this._paper.getLocale() !== paper.getLocale();
  }

  /**
   * Updates the results for the inclusive language assessor.
   *
   * @param {boolean} shouldInclusiveLanguageUpdate Whether the results of the inclusive language assessor should be updated.
   * @returns {void}
   */
  updateInclusiveLanguageAssessor(shouldInclusiveLanguageUpdate) {
    if (this._configuration.inclusiveLanguageAnalysisActive && this._inclusiveLanguageAssessor && shouldInclusiveLanguageUpdate) {
      this._inclusiveLanguageAssessor.assess(this._paper);
      this._results.inclusiveLanguage = {
        results: this._inclusiveLanguageAssessor.results,
        score: this._inclusiveLanguageAssessor.calculateOverallScore()
      };
    }
  }

  /**
   * Checks if the related keyword contains changes that are used for seo.
   *
   * @param {string} key                     The identifier of the related keyword.
   * @param {Object} relatedKeyword          The related keyword object.
   * @param {string} relatedKeyword.keyword  The keyword.
   * @param {string} relatedKeyword.synonyms The synonyms.
   *
   * @returns {boolean} True if there are changes detected.
   */
  shouldSeoUpdate(key, {
    keyword,
    synonyms
  }) {
    if ((0, _lodash.isUndefined)(this._relatedKeywords[key])) {
      return true;
    }
    if (this._relatedKeywords[key].keyword !== keyword) {
      return true;
    }
    return this._relatedKeywords[key].synonyms !== synonyms;
  }

  /**
   * Checks whether the additional assessor should be updated.
   *
   * @param {Paper} paper The paper to check.
   * @returns {Object} An object containing the information whether each additional assessor needs to be updated.
   */
  shouldAdditionalAssessorsUpdate(paper) {
    const shouldCustomAssessorsUpdate = {};
    Object.keys(this.additionalAssessors).forEach(assessorName => {
      shouldCustomAssessorsUpdate[assessorName] = this.additionalAssessors[assessorName].shouldUpdate(this._paper, paper);
    });
    return shouldCustomAssessorsUpdate;
  }

  /**
   * Updates the results for the additional assessor.
   *
   * @param {boolean} shouldCustomAssessorsUpdate Whether the results of the additional assessor should be updated.
   * @returns {void}
   */
  updateAdditionalAssessors(shouldCustomAssessorsUpdate) {
    Object.keys(this.additionalAssessors).forEach(assessorName => {
      const {
        assessor
      } = this.additionalAssessors[assessorName];
      if (!this._results[assessorName] || shouldCustomAssessorsUpdate[assessorName]) {
        assessor.assess(this._paper);
        this._results[assessorName] = {
          results: assessor.results,
          score: assessor.calculateOverallScore()
        };
      }
    });
  }

  /**
   * Runs analyses on a paper.
   *
   * The paper includes the keyword and synonyms data. However, this is
   * possibly just one instance of these. From here we are going to split up
   * this data and keep track of the different sets of keyword-synonyms and
   * their results.
   *
   * @param {number} id                        The request id.
   * @param {Object} payload                   The payload object.
   * @param {Object} payload.paper             The paper to analyze.
   * @param {Object} [payload.relatedKeywords] The related keywords.
   *
   * @returns {Object} The result, may not contain readability or seo.
   */
  async analyze(id, {
    paper,
    relatedKeywords = {}
  }) {
    const paperHasChanges = this._paper === null || !this._paper.equals(paper);
    const shouldReadabilityUpdate = this.shouldReadabilityUpdate(paper);
    const shouldInclusiveLanguageUpdate = this.shouldInclusiveLanguageUpdate(paper);
    const shouldCustomAssessorsUpdate = this.shouldAdditionalAssessorsUpdate(paper);

    // Only set the paper and build the tree if the paper has any changes.
    if (paperHasChanges) {
      this._paper = paper;
      this._researcher.setPaper(this._paper);
      const languageProcessor = new _LanguageProcessor.default(this._researcher);
      const shortcodes = this._paper._attributes && this._paper._attributes.shortcodes;
      this._paper.setTree((0, _build.build)(this._paper, languageProcessor, shortcodes));

      // Update the configuration locale to the paper locale.
      this.setLocale(this._paper.getLocale());
    }
    if (this._configuration.keywordAnalysisActive && this._seoAssessor) {
      // Only assess the focus keyphrase if the paper has any changes.
      if (paperHasChanges) {
        // Assess the SEO of the content regarding the main keyphrase.
        this._results.seo[""] = await this.assess(this._paper, this._tree, {
          oldAssessor: this._seoAssessor,
          treeAssessor: this._seoTreeAssessor,
          scoreAggregator: this._seoScoreAggregator
        });
      }

      // Only assess the related keyphrases when they have been given.
      if (!(0, _lodash.isEmpty)(relatedKeywords)) {
        // Get the related keyphrase keys (one for each keyphrase).
        const requestedRelatedKeywordKeys = Object.keys(relatedKeywords);

        // Analyze the SEO for each related keyphrase and wait for the results.
        const relatedKeyphraseResults = await this.assessRelatedKeywords(paper, this._tree, relatedKeywords);

        // Put the related keyphrase results on the SEO results, under the right key.
        relatedKeyphraseResults.forEach(result => {
          this._results.seo[result.key] = result.results;
        });

        // Clear the results of unrequested related keyphrases, but only if there are requested related keyphrases.
        if (requestedRelatedKeywordKeys.length > 1) {
          this._results.seo = (0, _lodash.pickBy)(this._results.seo, (relatedKeyword, key) => (0, _lodash.includes)(requestedRelatedKeywordKeys, key) || key === "");
        }
      }
    }
    if (this._configuration.contentAnalysisActive && this._contentAssessor && shouldReadabilityUpdate) {
      const analysisCombination = {
        oldAssessor: this._contentAssessor,
        treeAssessor: this._contentTreeAssessor,
        scoreAggregator: this._contentScoreAggregator
      };
      // Set the locale (we are more lenient for languages that have full analysis support).
      analysisCombination.scoreAggregator.setLocale(this._configuration.locale);
      this._results.readability = await this.assess(this._paper, this._tree, analysisCombination);
    }
    this.updateInclusiveLanguageAssessor(shouldInclusiveLanguageUpdate);
    this.updateAdditionalAssessors(shouldCustomAssessorsUpdate);
    return this._results;
  }

  /**
   * Assesses a given paper and tree combination
   * using an original Assessor (that works on a string representation of the text)
   * and a new Tree Assessor (that works on a tree representation).
   *
   * The results of both analyses are combined using the given score aggregator.
   *
   * @param {Paper}                      paper The paper to analyze.
   * @param {module:parsedPaper/structure.Node} tree  The tree to analyze.
   *
   * @param {Object}                             analysisCombination                 Which assessors and score aggregator to use.
   * @param {Assessor}                           analysisCombination.oldAssessor     The original assessor.
   * @param {module:parsedPaper/assess.TreeAssessor}    analysisCombination.treeAssessor    The new assessor.
   * @param {module:parsedPaper/assess.ScoreAggregator} analysisCombination.scoreAggregator The score aggregator to use.
   *
   * @returns {Promise<{score: number, results: AssessmentResult[]}>} The analysis results.
   */
  async assess(paper, tree, analysisCombination) {
    // Disabled code: The variable `treeAssessor` is removed from here.
    const {
      oldAssessor,
      scoreAggregator
    } = analysisCombination;
    /*
     * Assess the paper and the tree
     * using the original assessor and the tree assessor.
     */
    oldAssessor.assess(paper);
    const oldAssessmentResults = oldAssessor.results;
    const treeAssessmentResults = [];

    /*
     * Disable code:
     * // Only assess tree if it has been built.
     * if ( tree ) {
     * const treeAssessorResult = await treeAssessor.assess( paper, tree );
     * treeAssessmentResults = treeAssessorResult.results;
     * } else {
     * // Cannot assess the tree, generate errors on the assessments that use the tree assessor.
     * const treeAssessments = treeAssessor.getAssessments();
     * treeAssessmentResults = treeAssessments.map( assessment => this.generateAssessmentError( assessment ) );
     * }
     */

    // Combine the results of the tree assessor and old assessor.
    const results = [...treeAssessmentResults, ...oldAssessmentResults];

    // Aggregate the results.
    const score = scoreAggregator.aggregate(results);
    return {
      results: results,
      score: score
    };
  }

  /**
   * Generates an error message ("grey bullet") for the given assessment.
   *
   * @param {module:parsedPaper/assess.Assessment} assessment The assessment to generate an error message for.
   *
   * @returns {AssessmentResult} The generated assessment result.
   */
  generateAssessmentError(assessment) {
    const result = new _AssessmentResult.default();
    result.setScore(-1);
    result.setText((0, _i18n.sprintf)(/* translators: %1$s expands to the name of the assessment. */
    (0, _i18n.__)("An error occurred in the '%1$s' assessment", "wordpress-seo"), assessment.name));
    return result;
  }

  /**
   * Assesses the SEO of a paper and tree combination on the given related keyphrases and their synonyms.
   *
   * The old assessor as well as the new tree assessor are used and their results are combined.
   *
   * @param {Paper}                 paper           The paper to analyze.
   * @param {module:parsedPaper/structure} tree            The tree to analyze.
   * @param {Object}                relatedKeywords The related keyphrases to use in the analysis.
   *
   * @returns {Promise<[{results: {score: number, results: AssessmentResult[]}, key: string}]>} The results, one for each keyphrase.
   */
  async assessRelatedKeywords(paper, tree, relatedKeywords) {
    const keywordKeys = Object.keys(relatedKeywords);
    return await Promise.all(keywordKeys.map(key => {
      this._relatedKeywords[key] = relatedKeywords[key];
      const relatedPaper = _Paper.default.parse({
        ...paper.serialize(),
        keyword: this._relatedKeywords[key].keyword,
        synonyms: this._relatedKeywords[key].synonyms
      });

      // Which combination of (tree) assessors and score aggregator to use.
      const analysisCombination = {
        oldAssessor: this._relatedKeywordAssessor,
        treeAssessor: this._relatedKeywordTreeAssessor,
        scoreAggregator: this._seoScoreAggregator
      };

      // We need to remember the key, since the SEO results are stored in an object, not an array.
      return this.assess(relatedPaper, tree, analysisCombination).then(results => ({
        key: key,
        results: results
      }));
    }));
  }

  /**
   * Loads a new script from an external source.
   *
   * @param {number} id  The request id.
   * @param {string} url The url of the script to load;
   *
   * @returns {Object} An object containing whether or not the url was loaded, the url and possibly an error message.
   */
  loadScript(id, {
    url
  }) {
    if ((0, _lodash.isUndefined)(url)) {
      return {
        loaded: false,
        url,
        message: "Load Script was called without an URL."
      };
    }
    try {
      this._scope.importScripts(url);
    } catch (error) {
      return {
        loaded: false,
        url,
        message: error.message
      };
    }
    return {
      loaded: true,
      url
    };
  }

  /**
   * Sends the load script result back.
   *
   * @param {number} id     The request id.
   * @param {Object} result The result.
   *
   * @returns {void}
   */
  loadScriptDone(id, result) {
    if (!result.loaded) {
      this.send("loadScript:failed", id, result);
      return;
    }
    this.send("loadScript:done", id, result);
  }

  /**
   * Sends the analyze result back.
   *
   * @param {number} id     The request id.
   * @param {Object} result The result.
   *
   * @returns {void}
   */
  analyzeDone(id, result) {
    if (result.error) {
      this.send("analyze:failed", id, result);
      return;
    }
    this.send("analyze:done", id, result);
  }

  /**
   * Sends the analyze related keywords result back.
   *
   * @param {number} id     The request id.
   * @param {Object} result The result.
   *
   * @returns {void}
   */
  analyzeRelatedKeywordsDone(id, result) {
    if (result.error) {
      this.send("analyzeRelatedKeywords:failed", id, result);
      return;
    }
    this.send("analyzeRelatedKeywords:done", id, result);
  }

  /**
   * Handle a custom message using the registered handler.
   *
   * @param {number} id   The request id.
   * @param {string} name The name of the message.
   * @param {Object} data The data of the message.
   *
   * @returns {Object} An object containing either success and data or an error.
   */
  customMessage(id, {
    name,
    data
  }) {
    try {
      return {
        success: true,
        data: this._registeredMessageHandlers[name](data)
      };
    } catch (error) {
      return {
        error
      };
    }
  }

  /**
   * Send the result of a custom message back.
   *
   * @param {number} id     The request id.
   * @param {Object} result The result.
   *
   * @returns {void}
   */
  customMessageDone(id, result) {
    if (result.success) {
      this.send("customMessage:done", id, result.data);
      return;
    }
    this.send("customMessage:failed", result.error);
  }

  /**
   * Registers custom research to the researcher.
   *
   * @param {string} name         The name of the research.
   * @param {function} research   The research function to add.
   *
   * @returns {void}
   */
  registerResearch(name, research) {
    if (!(0, _lodash.isString)(name)) {
      throw new _invalidType.default("Failed to register the custom research. Expected parameter `name` to be a string.");
    }
    if (!(0, _lodash.isObject)(research)) {
      throw new _invalidType.default("Failed to register the custom research. Expected parameter `research` to be a function.");
    }
    const researcher = this._researcher;
    if (!researcher.hasResearch(name)) {
      researcher.addResearch(name, research);
    }
  }

  /**
   * Runs the specified research in the worker. Optionally pass a paper.
   *
   * @param {number} id     The request id.
   * @param {string} name   The name of the research to run.
   * @param {Paper} [paper] The paper to run the research on if it shouldn't
   *                        be run on the latest paper.
   *
   * @returns {Object} The result of the research.
   */
  runResearch(id, {
    name,
    paper = null
  }) {
    // Save morphology data if it is available in the current researcher.
    const morphologyData = this._researcher.getData("morphology");
    const researcher = this._researcher;
    // When a specific paper is passed we create a temporary new researcher.
    if (paper !== null) {
      researcher.setPaper(paper);
      researcher.addResearchData("morphology", morphologyData);

      // Build and set the tree if it's not been set before.
      if (paper.getTree() === null) {
        const languageProcessor = new _LanguageProcessor.default(researcher);
        const shortcodes = paper._attributes && paper._attributes.shortcodes;
        paper.setTree((0, _build.build)(paper, languageProcessor, shortcodes));
      }
    }
    return researcher.getResearch(name);
  }

  /**
   * Send the result of a custom message back.
   *
   * @param {number} id     The request id.
   * @param {Object} result The result.
   *
   * @returns {void}
   */
  runResearchDone(id, result) {
    if (result.error) {
      this.send("runResearch:failed", id, result);
      return;
    }
    this.send("runResearch:done", id, result);
  }

  /**
   * Registers a custom helper to the researcher.
   *
   * @param {string} name       The name of the helper.
   * @param {function} helper   The helper function to add.
   *
   * @returns {void}
   */
  registerHelper(name, helper) {
    if (!(0, _lodash.isString)(name)) {
      throw new _invalidType.default("Failed to register the custom helper. Expected parameter `name` to be a string.");
    }
    if (!(0, _lodash.isObject)(helper)) {
      throw new _invalidType.default("Failed to register the custom helper. Expected parameter `helper` to be a function.");
    }
    const researcher = this._researcher;
    if (!researcher.hasHelper(name)) {
      researcher.addHelper(name, helper);
    }
  }

  /**
   * Registers a configuration to the researcher.
   *
   * @param {string}  name                The name of the researcher configuration.
   * @param {*}       researcherConfig    The researcher configuration to add.
   *
   * @returns {void}
   */
  registerResearcherConfig(name, researcherConfig) {
    if (!(0, _lodash.isString)(name)) {
      throw new _invalidType.default("Failed to register the custom researcher config. Expected parameter `name` to be a string.");
    }
    if ((0, _lodash.isUndefined)(researcherConfig) || (0, _lodash.isEmpty)(researcherConfig)) {
      throw new _missingArgument.default("Failed to register the custom researcher config. Expected parameter `researcherConfig` to be defined.");
    }
    const researcher = this._researcher;
    if (!researcher.hasConfig(name)) {
      researcher.addConfig(name, researcherConfig);
    }
  }
}
exports["default"] = AnalysisWebWorker;

/***/ }),

/***/ "./node_modules/yoastseo/build/worker/AnalysisWorkerWrapper.js":
/*!*********************************************************************!*\
  !*** ./node_modules/yoastseo/build/worker/AnalysisWorkerWrapper.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _request = _interopRequireDefault(__webpack_require__(/*! ./request */ "./node_modules/yoastseo/build/worker/request/index.js"));
var _transporter = _interopRequireDefault(__webpack_require__(/*! ./transporter */ "./node_modules/yoastseo/build/worker/transporter/index.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
// Internal dependencies.

/**
 * Analysis worker is an API around the Web Worker.
 */
class AnalysisWorkerWrapper {
  /**
   * Initializes the AnalysisWorkerWrapper class.
   *
   * @param {Worker} worker The worker to wrap.
   *
   * @constructor
   */
  constructor(worker) {
    // Initialize instance variables.
    this._worker = worker;
    this._requests = {};
    this._autoIncrementedRequestId = -1;

    // Bind actions to this scope.
    this.initialize = this.initialize.bind(this);
    this.analyze = this.analyze.bind(this);
    this.analyzeRelatedKeywords = this.analyzeRelatedKeywords.bind(this);
    this.loadScript = this.loadScript.bind(this);
    this.sendMessage = this.sendMessage.bind(this);
    this.runResearch = this.runResearch.bind(this);

    // Bind event handlers to this scope.
    this.handleMessage = this.handleMessage.bind(this);
    this.handleMessageError = this.handleMessageError.bind(this);
    this.handleError = this.handleError.bind(this);

    // Initialize the worker event handlers.
    this._worker.onmessage = this.handleMessage;
    this._worker.onmessageerror = this.handleMessageError;
    this._worker.onerror = this.handleError;
  }

  /**
   * Receives the messages and determines the action.
   *
   * See: https://developer.mozilla.org/en-US/docs/Web/API/Worker/onmessage
   *
   * @param {MessageEvent} event              The post message event.
   * @param {Object}       event.data         The data object.
   * @param {string}       event.data.type    The action type.
   * @param {number}       event.data.id      The request id.
   * @param {string}       event.data.payload The payload of the action.
   *
   * @returns {void}
   */
  handleMessage({
    data: {
      type,
      id,
      payload
    }
  }) {
    const request = this._requests[id];
    if (!request) {
      console.warn("AnalysisWebWorker unmatched response:", payload);
      return;
    }
    payload = _transporter.default.parse(payload);
    switch (type) {
      case "initialize:done":
      case "loadScript:done":
      case "customMessage:done":
      case "runResearch:done":
      case "analyzeRelatedKeywords:done":
      case "analyze:done":
        request.resolve(payload);
        break;
      case "analyze:failed":
      case "loadScript:failed":
      case "customMessage:failed":
      case "runResearch:failed":
      case "analyzeRelatedKeywords:failed":
        request.reject(payload);
        break;
      default:
        console.warn("AnalysisWebWorker unrecognized action:", type);
    }

    // Remove the handled request from our queue.
    delete this._requests[id];
  }

  /**
   * Receives the message errors.
   *
   * See: https://developer.mozilla.org/en-US/docs/Web/Events/messageerror
   *
   * @param {MessageEvent} event The message event for the error that
   *                             occurred.
   *
   * @returns {void}
   */
  handleMessageError(event) {
    console.warn("AnalysisWebWorker message error:", event);
  }

  /**
   * Receives the errors.
   *
   * See:
   * https://developer.mozilla.org/en-US/docs/Web/API/AbstractWorker/onerror
   *
   * @param {Error} event The error event.
   *
   * @returns {void}
   */
  handleError(event) {
    /*
     * Try to get the last request. This might not perfectly match the request error.
     * However, that is not as bad as not being able to reject it like this.
     *
     * This is not the _autoIncrementedRequestId because that might be a
     * request that is handled already. Instead the last object key is used.
     */
    const requestKeys = Object.keys(this._requests);
    const lastRequestId = requestKeys[requestKeys.length - 1];
    const lastRequest = this._requests[lastRequestId];
    if (!lastRequest) {
      console.error("AnalysisWebWorker error:", event);
      return;
    }
    lastRequest.reject(event);
  }

  /**
   * Increments the request id.
   *
   * @returns {number} The incremented id.
   */
  createRequestId() {
    this._autoIncrementedRequestId++;
    return this._autoIncrementedRequestId;
  }

  /**
   * Creates a new request inside a Promise.
   *
   * @param {number} id     The request id.
   * @param {Object} [data] Optional extra data.
   *
   * @returns {Promise} The callback promise.
   */
  createRequestPromise(id, data = {}) {
    return new Promise((resolve, reject) => {
      this._requests[id] = new _request.default(resolve, reject, data);
    });
  }

  /**
   * Sends a request to the worker and returns a promise that will resolve or reject once the worker finishes.
   *
   * @param {string} action  The action of the request.
   * @param {Object} payload The payload of the request.
   * @param {Object} [data]  Optional extra data.
   *
   * @returns {Promise} A promise that will resolve or reject once the worker finishes.
   */
  sendRequest(action, payload, data = {}) {
    const id = this.createRequestId();
    const promise = this.createRequestPromise(id, data);
    this.send(action, id, payload);
    return promise;
  }

  /**
   * Sends a message to the worker.
   *
   * @param {string} type      The message type.
   * @param {number} id        The request id.
   * @param {Object} [payload] The payload to deliver.
   *
   * @returns {void}
   */
  send(type, id, payload = {}) {
    payload = _transporter.default.serialize(payload);
    this._worker.postMessage({
      type,
      id,
      payload
    });
  }

  /**
   * Initializes the worker with a configuration.
   *
   * @param {Object} configuration The configuration to initialize the worker
   *                               with.
   *
   * @returns {Promise} The promise of initialization.
   */
  initialize(configuration) {
    return this.sendRequest("initialize", configuration);
  }

  /**
   * Analyzes the paper.
   *
   * @param {Object} paper           The paper to analyze.
   * @param {Object} relatedKeywords The related keywords.
   *
   * @returns {Promise} The promise of analyses.
   */
  analyzeRelatedKeywords(paper, relatedKeywords = {}) {
    return this.sendRequest("analyzeRelatedKeywords", {
      paper,
      relatedKeywords
    });
  }

  /**
   * Analyzes the paper.
   *
   * @param {Object} paper           The paper to analyze.
   *
   * @returns {Promise} The promise of analyses.
   */
  analyze(paper) {
    return this.sendRequest("analyze", {
      paper
    });
  }

  /**
   * Imports a script to the worker.
   *
   * @param {string} url The relative url to the script to be loaded.
   *
   * @returns {Promise} The promise of the script import.
   */
  loadScript(url) {
    return this.sendRequest("loadScript", {
      url
    });
  }

  /**
   * Sends a custom message to the worker.
   *
   * @param {string} name       The name of the message.
   * @param {string} data       The data of the message.
   * @param {string} pluginName The plugin that registered this type of message.
   *
   * @returns {Promise} The promise of the custom message.
   */
  sendMessage(name, data, pluginName) {
    name = pluginName + "-" + name;
    return this.sendRequest("customMessage", {
      name,
      data
    }, data);
  }

  /**
   * Runs the specified research in the worker. Optionally pass a paper.
   *
   * @param {string} name    The name of the research to run.
   * @param {Paper} [paper] The paper to run the research on if it shouldn't
   *                         be run on the latest paper.
   *
   * @returns {Promise} The promise of the research.
   */
  runResearch(name, paper = null) {
    return this.sendRequest("runResearch", {
      name,
      paper
    });
  }
}
var _default = exports["default"] = AnalysisWorkerWrapper;

/***/ }),

/***/ "./node_modules/yoastseo/build/worker/createWorker.js":
/*!************************************************************!*\
  !*** ./node_modules/yoastseo/build/worker/createWorker.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createBlobScript = createBlobScript;
exports.createBlobURL = createBlobURL;
exports.createExceptionHandler = createExceptionHandler;
exports.createWorker = createWorker;
exports.createWorkerFallback = createWorkerFallback;
exports["default"] = void 0;
exports.isSameOrigin = isSameOrigin;
/**
 * Creates a try catch for a web worker around a script.
 *
 * @param 		{string} originalScript 	The script to put a try-catch around.
 * @returns 	{string} 					The new script including a try-catch.
 */
function createExceptionHandler(originalScript) {
  return `
		try {
			${originalScript}
		} catch ( error ) {
			console.log( "Error occurred during worker initialization:" );
			console.log( error );
		}
	`;
}

/**
 * Creates the script to run inside the fallback web worker.
 *
 * @param 		{string} url 				The URL for which to create a script.
 * @returns 	{string} 					A script that can be run inside a worker as a blob.
 */
function createBlobScript(url) {
  return `
		self.yoastOriginalUrl = '${url}';
		importScripts('${url}');
	`;
}

/**
 * Determines whether or not two URLs have the same origin.
 *
 * @param 		{string} urlA 				First URL to test.
 * @param 		{string} urlB 				Second URL to test.
 *
 * @returns {boolean} Whether the URLs have the same origin.
 */
function isSameOrigin(urlA, urlB) {
  const url1 = new URL(urlA, window.location.origin);
  const url2 = new URL(urlB, window.location.origin);
  return url1.hostname === url2.hostname && url1.port === url2.port && url1.protocol === url2.protocol;
}

/**
 * Creates a URL to a blob. This blob imports a script for use in a web worker (using `importScripts`).
 *
 * @param 		{string} url 				The URL to the script that has to be loaded.
 * @returns 	{string} 					The URL to the blob.
 */
function createBlobURL(url) {
  const URL = window.URL || window.webkitURL;
  const BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
  const blobScript = createExceptionHandler(createBlobScript(url));
  let blob;
  try {
    blob = new Blob([blobScript], {
      type: "application/javascript"
    });
  } catch (e1) {
    const blobBuilder = new BlobBuilder();
    blobBuilder.append(blobScript);
    blob = blobBuilder.getBlob("application/javascript");
  }
  return URL.createObjectURL(blob);
}

/**
 * Creates a worker fallback using the blob URL method.
 *
 * @param 		{string} url 				The URL to create a worker for.
 * @returns 	{Worker} 					The web worker.
 */
function createWorkerFallback(url) {
  const blobUrl = createBlobURL(url);
  return new Worker(blobUrl);
}

/**
 * Creates a WebWorker using the given url.
 *
 * @param 		{string} url 				The url of the worker.
 * @returns 	{Worker} 					The worker.
 */
function createWorker(url) {
  // If we are not on the same domain, or we are editing a post in the Web Stories plug-in integration, we require a fallback worker.
  if (!isSameOrigin(window.location, url) || window.wpseoAdminL10n && window.wpseoAdminL10n.isWebStoriesIntegrationActive === "1") {
    return createWorkerFallback(url);
  }
  let worker = null;
  try {
    worker = new Worker(url);
  } catch (e) {
    // This will either: succeed and provide a worker, or throw an error.
    worker = createWorkerFallback(url);
  }
  return worker;
}
var _default = exports["default"] = createWorker;

/***/ }),

/***/ "./node_modules/yoastseo/build/worker/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/yoastseo/build/worker/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "AnalysisWebWorker", ({
  enumerable: true,
  get: function () {
    return _AnalysisWebWorker.default;
  }
}));
Object.defineProperty(exports, "AnalysisWorkerWrapper", ({
  enumerable: true,
  get: function () {
    return _AnalysisWorkerWrapper.default;
  }
}));
Object.defineProperty(exports, "createWorker", ({
  enumerable: true,
  get: function () {
    return _createWorker.default;
  }
}));
var _AnalysisWebWorker = _interopRequireDefault(__webpack_require__(/*! ./AnalysisWebWorker */ "./node_modules/yoastseo/build/worker/AnalysisWebWorker.js"));
var _AnalysisWorkerWrapper = _interopRequireDefault(__webpack_require__(/*! ./AnalysisWorkerWrapper */ "./node_modules/yoastseo/build/worker/AnalysisWorkerWrapper.js"));
var _createWorker = _interopRequireDefault(__webpack_require__(/*! ./createWorker */ "./node_modules/yoastseo/build/worker/createWorker.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/build/worker/request/Request.js":
/*!***************************************************************!*\
  !*** ./node_modules/yoastseo/build/worker/request/Request.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _Result = _interopRequireDefault(__webpack_require__(/*! ./Result */ "./node_modules/yoastseo/build/worker/request/Result.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Request serves as helper for the AnalysisWorkerWrapper.
 *
 * It holds the resolve and reject functions that it needs to fulfill the
 * promise. Any optional data will get included in the Result it can generate.
 */
class Request {
  /**
   * Initializes a request.
   *
   * @param {Function} resolve The resolve function.
   * @param {Function} reject  The reject function.
   * @param {Object}  [data]   Optional extra data.
   */
  constructor(resolve, reject, data = {}) {
    this._resolve = resolve;
    this._reject = reject;
    this._data = data;
  }

  /**
   * Resolves the request with a result.
   *
   * @param {Object} [payload] Optional payload.
   *
   * @returns {void}
   */
  resolve(payload = {}) {
    const result = new _Result.default(payload, this._data);
    this._resolve(result);
  }

  /**
   * Rejects the request with a result.
   *
   * @param {Object} [payload] Optional payload.
   *
   * @returns {void}
   */
  reject(payload = {}) {
    const result = new _Result.default(payload, this._data);
    this._reject(result);
  }
}
exports["default"] = Request;

/***/ }),

/***/ "./node_modules/yoastseo/build/worker/request/Result.js":
/*!**************************************************************!*\
  !*** ./node_modules/yoastseo/build/worker/request/Result.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
/**
 * Result serves as data structure for the AnalysisWorkerWrapper request result.
 */
class Result {
  /**
   * Initializes a result.
   *
   * @param {Object} result The result.
   * @param {Object} [data] Optional extra data.
   */
  constructor(result, data = {}) {
    this.result = result;
    this.data = data;
  }
}
exports["default"] = Result;

/***/ }),

/***/ "./node_modules/yoastseo/build/worker/request/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/yoastseo/build/worker/request/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _Request = _interopRequireDefault(__webpack_require__(/*! ./Request */ "./node_modules/yoastseo/build/worker/request/Request.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _default = exports["default"] = _Request.default;

/***/ }),

/***/ "./node_modules/yoastseo/build/worker/scheduler/Scheduler.js":
/*!*******************************************************************!*\
  !*** ./node_modules/yoastseo/build/worker/scheduler/Scheduler.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _Task = _interopRequireDefault(__webpack_require__(/*! ./Task */ "./node_modules/yoastseo/build/worker/scheduler/Task.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
// External dependencies.

// Internal dependencies.

const DEFAULT_CONFIGURATION = {
  pollTime: 50
};

/**
 * The scheduler is used in the analysis web worker to schedule tasks.
 *
 * Tasks have priorities based on their type.
 * When a task is executed, the task id and data are its arguments.
 * When a task is done, the task id and the execute result are its arguments.
 *
 * Start polling runs tick.
 * 1. Tick tries to run the next task.
 * 2. After the task is run, a timeout is set (configuration.pollTime).
 * 3. On the timeout execution, tick is called again (back to step 1).
 */
class Scheduler {
  /**
   * Initializes a Scheduler.
   *
   * @param {Object}  [configuration]             The configuration.
   * @param {number}  [configuration.pollTime]    The time in between each task
   *                                              poll in milliseconds,
   *                                              defaults to 50.
   */
  constructor(configuration = {}) {
    this._configuration = (0, _lodash.merge)(DEFAULT_CONFIGURATION, configuration);
    this._tasks = {
      standard: [],
      extensions: [],
      analyze: [],
      analyzeRelatedKeywords: []
    };
    this._pollHandle = null;
    this._started = false;

    // Bind functions to this scope.
    this.startPolling = this.startPolling.bind(this);
    this.stopPolling = this.stopPolling.bind(this);
    this.tick = this.tick.bind(this);
  }

  /**
   * Initialize polling.
   *
   * @returns {void}
   */
  startPolling() {
    if (this._started) {
      return;
    }
    this._started = true;
    this.tick();
  }

  /**
   * Do a tick and execute a task.
   *
   * @returns {void}
   */
  tick() {
    this.executeNextTask().then(() => {
      this._pollHandle = setTimeout(this.tick, this._configuration.pollTime);
    });
  }

  /**
   * Stop polling.
   *
   * @returns {void}
   */
  stopPolling() {
    clearTimeout(this._pollHandle);
    this._pollHandle = null;
    this._started = false;
  }

  /**
   * Schedule a task.
   *
   * @param {Object}   task         The task object.
   * @param {number}   task.id      The task id.
   * @param {function} task.execute The function to run for task execution.
   * @param {function} task.done    The function to run when the task is done.
   * @param {Object}   task.data    The data object to execute with.
   * @param {string}   task.type    The type of the task.
   *
   * @returns {void}
   */
  schedule({
    id,
    execute,
    done,
    data,
    type
  }) {
    const task = new _Task.default(id, execute, done, data, type);
    switch (type) {
      case "customMessage":
      case "loadScript":
        this._tasks.extensions.push(task);
        break;
      case "analyze":
        this._tasks.analyze = [task];
        break;
      case "analyzeRelatedKeywords":
        this._tasks.analyzeRelatedKeywords = [task];
        break;
      default:
        this._tasks.standard.push(task);
    }
  }

  /**
   * Retrieves the next task from the queue. Queues are sorted from lowest to highest priority.
   *
   * @returns {Task|null} The next task or null if none are available.
   */
  getNextTask() {
    if (this._tasks.extensions.length > 0) {
      return this._tasks.extensions.shift();
    }
    if (this._tasks.analyze.length > 0) {
      return this._tasks.analyze.shift();
    }
    if (this._tasks.analyzeRelatedKeywords.length > 0) {
      return this._tasks.analyzeRelatedKeywords.shift();
    }
    if (this._tasks.standard.length > 0) {
      return this._tasks.standard.shift();
    }
    return null;
  }

  /**
   * Executes the next task.
   *
   * @returns {Promise} Resolves once the task is done, with the result of the task.
   */
  executeNextTask() {
    const task = this.getNextTask();
    if (task === null) {
      return Promise.resolve(null);
    }
    return Promise.resolve().then(() => {
      return task.execute(task.id, task.data);
    }).then(result => {
      task.done(task.id, result);
      return result;
    });
  }
}
exports["default"] = Scheduler;

/***/ }),

/***/ "./node_modules/yoastseo/build/worker/scheduler/Task.js":
/*!**************************************************************!*\
  !*** ./node_modules/yoastseo/build/worker/scheduler/Task.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Represents a scheduler task.
 */
class Task {
  /**
   * Initializes a task.
   *
   * @param {number}   id      The task identifier.
   * @param {Function} execute Executes the job with the data.
   * @param {Function} done    Callback for the scheduler.
   * @param {Object}   [data]  Optional data for when executing the task.
   * @param {string}   type    The type of the task (analyze, analyzeRelatedKeywords, loadScript or customMessage)
   */
  constructor(id, execute, done, data = {}, type = "analyze") {
    if (!(0, _lodash.isNumber)(id)) {
      throw new Error("Task.id should be a number.");
    }
    if (!(0, _lodash.isFunction)(execute)) {
      throw new Error("Task.execute should be a function.");
    }
    if (!(0, _lodash.isFunction)(done)) {
      throw new Error("Task.done should be a function.");
    }
    if (!(0, _lodash.isObject)(data)) {
      throw new Error("Task.data should be an object.");
    }
    this.id = id;
    this.execute = execute;
    this.done = done;
    this.data = data;
    this.type = type;
  }
}
exports["default"] = Task;

/***/ }),

/***/ "./node_modules/yoastseo/build/worker/scheduler/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/yoastseo/build/worker/scheduler/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _Scheduler = _interopRequireDefault(__webpack_require__(/*! ./Scheduler */ "./node_modules/yoastseo/build/worker/scheduler/Scheduler.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _default = exports["default"] = _Scheduler.default;

/***/ }),

/***/ "./node_modules/yoastseo/build/worker/transporter/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/yoastseo/build/worker/transporter/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _parse = _interopRequireDefault(__webpack_require__(/*! ./parse */ "./node_modules/yoastseo/build/worker/transporter/parse.js"));
var _serialize = _interopRequireDefault(__webpack_require__(/*! ./serialize */ "./node_modules/yoastseo/build/worker/transporter/serialize.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
var _default = exports["default"] = {
  parse: _parse.default,
  serialize: _serialize.default
};

/***/ }),

/***/ "./node_modules/yoastseo/build/worker/transporter/parse.js":
/*!*****************************************************************!*\
  !*** ./node_modules/yoastseo/build/worker/transporter/parse.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = parse;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
var _AssessmentResult = _interopRequireDefault(__webpack_require__(/*! ../../values/AssessmentResult */ "./node_modules/yoastseo/build/values/AssessmentResult.js"));
var _Mark = _interopRequireDefault(__webpack_require__(/*! ../../values/Mark */ "./node_modules/yoastseo/build/values/Mark.js"));
var _Paper = _interopRequireDefault(__webpack_require__(/*! ../../values/Paper */ "./node_modules/yoastseo/build/values/Paper.js"));
var _Sentence = _interopRequireDefault(__webpack_require__(/*! ../../languageProcessing/values/Sentence */ "./node_modules/yoastseo/build/languageProcessing/values/Sentence.js"));
var _Clause = _interopRequireDefault(__webpack_require__(/*! ../../languageProcessing/values/Clause */ "./node_modules/yoastseo/build/languageProcessing/values/Clause.js"));
var _ProminentWord = _interopRequireDefault(__webpack_require__(/*! ../../languageProcessing/values/ProminentWord */ "./node_modules/yoastseo/build/languageProcessing/values/ProminentWord.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const PARSE_CLASSES = {
  AssessmentResult: _AssessmentResult.default,
  Mark: _Mark.default,
  Paper: _Paper.default,
  Sentence: _Sentence.default,
  Clause: _Clause.default,
  ProminentWord: _ProminentWord.default
};

/**
 * Parses a data structure that has previously been serialized.
 *
 * @param {*} thing The data structure to parse.
 *
 * @returns {*} The parsed data structure.
 */
function parse(thing) {
  if ((0, _lodash.isArray)(thing)) {
    return thing.map(parse);
  }
  const thingIsObject = (0, _lodash.isObject)(thing);
  if (thingIsObject && thing._parseClass && PARSE_CLASSES[thing._parseClass]) {
    return thing._parseClass === "Sentence" || thing._parseClass === "Clause" ? PARSE_CLASSES[thing._parseClass].prototype.parse(thing) : PARSE_CLASSES[thing._parseClass].parse(thing);
  }
  if (thingIsObject) {
    return (0, _lodash.mapValues)(thing, value => parse(value));
  }
  return thing;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/worker/transporter/serialize.js":
/*!*********************************************************************!*\
  !*** ./node_modules/yoastseo/build/worker/transporter/serialize.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = serialize;
var _lodash = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/**
 * Serializes a data structure to transfer it over a web worker message.
 *
 * @param {*} thing The data structure to serialize.
 *
 * @returns {*} The serialized data structure.
 */
function serialize(thing) {
  if ((0, _lodash.isArray)(thing)) {
    return thing.map(serialize);
  }
  const thingIsObject = (0, _lodash.isObject)(thing);
  if (thingIsObject && thing.serialize) {
    return thing.serialize();
  }
  if (thingIsObject) {
    return (0, _lodash.mapValues)(thing, value => serialize(value));
  }
  return thing;
}

/***/ }),

/***/ "./node_modules/yoastseo/build/worker/wrapTryCatchAroundAction.js":
/*!************************************************************************!*\
  !*** ./node_modules/yoastseo/build/worker/wrapTryCatchAroundAction.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = wrapTryCatchAroundAction;
var _formatString = _interopRequireDefault(__webpack_require__(/*! ../helpers/formatString */ "./node_modules/yoastseo/build/helpers/formatString.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
/**
 * Logs and formats the error message to send back to the plugin
 * when an analysis web worker action fails.
 *
 * @param {Logger}	logger					The logger instance to log with.
 * @param {Error} 	error					The error to log.
 * @param {Object}	payload					The action payload.
 * @param {string} 	[errorMessagePrefix=""]	The prefix of the error message.
 *
 * @returns {string} the error message to send back.
 */
const handleError = function (logger, error, payload, errorMessagePrefix = "") {
  // Try to format the string with payload parameters, if there are any.
  if (payload) {
    errorMessagePrefix = (0, _formatString.default)(errorMessagePrefix, payload);
  }
  let errorMessage = errorMessagePrefix ? [errorMessagePrefix] : [];
  if (error.name && error.message) {
    if (error.stack) {
      logger.debug(error.stack);
    }
    // Standard JavaScript error (e.g. when calling `throw new Error( message )`).
    errorMessage.push(`${error.name}: ${error.message}`);
  }
  errorMessage = errorMessage.join("\n\t");
  logger.error(errorMessage);
  return errorMessage;
};

/**
 * Wraps the given action in a try-catch that logs the error message.
 *
 * @param {Logger}   logger                  The logger instance to log with.
 * @param {Function} action                  The action to safely run.
 * @param {string}   [errorMessagePrefix=""] The prefix of the error message.
 *
 * @returns {Function} The wrapped action.
 */
function wrapTryCatchAroundAction(logger, action, errorMessagePrefix = "") {
  return async (...args) => {
    try {
      return await action(...args);
    } catch (error) {
      const errorMessage = handleError(logger, error, args[1], errorMessagePrefix);
      return {
        error: errorMessage
      };
    }
  };
}

/***/ }),

/***/ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createAddHook.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createAddHook.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validateNamespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validateNamespace.js */ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/validateNamespace.js");
/* harmony import */ var _validateHookName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./validateHookName.js */ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/validateHookName.js");
/**
 * Internal dependencies
 */



/**
 * @callback AddHook
 *
 * Adds the hook to the appropriate hooks container.
 *
 * @param {string}               hookName      Name of hook to add
 * @param {string}               namespace     The unique namespace identifying the callback in the form `vendor/plugin/function`.
 * @param {import('.').Callback} callback      Function to call when the hook is run
 * @param {number}               [priority=10] Priority of this hook
 */

/**
 * Returns a function which, when invoked, will add a hook.
 *
 * @param {import('.').Hooks}    hooks    Hooks instance.
 * @param {import('.').StoreKey} storeKey
 *
 * @return {AddHook} Function that adds a new hook.
 */
function createAddHook(hooks, storeKey) {
  return function addHook(hookName, namespace, callback, priority = 10) {
    const hooksStore = hooks[storeKey];
    if (!(0,_validateHookName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(hookName)) {
      return;
    }
    if (!(0,_validateNamespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(namespace)) {
      return;
    }
    if ('function' !== typeof callback) {
      // eslint-disable-next-line no-console
      console.error('The hook callback must be a function.');
      return;
    }

    // Validate numeric priority
    if ('number' !== typeof priority) {
      // eslint-disable-next-line no-console
      console.error('If specified, the hook priority must be a number.');
      return;
    }
    const handler = {
      callback,
      priority,
      namespace
    };
    if (hooksStore[hookName]) {
      // Find the correct insert index of the new hook.
      const handlers = hooksStore[hookName].handlers;

      /** @type {number} */
      let i;
      for (i = handlers.length; i > 0; i--) {
        if (priority >= handlers[i - 1].priority) {
          break;
        }
      }
      if (i === handlers.length) {
        // If append, operate via direct assignment.
        handlers[i] = handler;
      } else {
        // Otherwise, insert before index via splice.
        handlers.splice(i, 0, handler);
      }

      // We may also be currently executing this hook.  If the callback
      // we're adding would come after the current callback, there's no
      // problem; otherwise we need to increase the execution index of
      // any other runs by 1 to account for the added element.
      hooksStore.__current.forEach(hookInfo => {
        if (hookInfo.name === hookName && hookInfo.currentIndex >= i) {
          hookInfo.currentIndex++;
        }
      });
    } else {
      // This is the first hook of its type.
      hooksStore[hookName] = {
        handlers: [handler],
        runs: 0
      };
    }
    if (hookName !== 'hookAdded') {
      hooks.doAction('hookAdded', hookName, namespace, callback, priority);
    }
  };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createAddHook);

/***/ }),

/***/ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createCurrentHook.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createCurrentHook.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Returns a function which, when invoked, will return the name of the
 * currently running hook, or `null` if no hook of the given type is currently
 * running.
 *
 * @param {import('.').Hooks}    hooks    Hooks instance.
 * @param {import('.').StoreKey} storeKey
 *
 * @return {() => string | null} Function that returns the current hook name or null.
 */
function createCurrentHook(hooks, storeKey) {
  return function currentHook() {
    var _hooksStore$__current2;
    var _hooksStore$__current;
    const hooksStore = hooks[storeKey];
    return (_hooksStore$__current = (_hooksStore$__current2 = hooksStore.__current[hooksStore.__current.length - 1]) === null || _hooksStore$__current2 === void 0 ? void 0 : _hooksStore$__current2.name) !== null && _hooksStore$__current !== void 0 ? _hooksStore$__current : null;
  };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createCurrentHook);

/***/ }),

/***/ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createDidHook.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createDidHook.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validateHookName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validateHookName.js */ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/validateHookName.js");
/**
 * Internal dependencies
 */


/**
 * @callback DidHook
 *
 * Returns the number of times an action has been fired.
 *
 * @param {string} hookName The hook name to check.
 *
 * @return {number | undefined} The number of times the hook has run.
 */

/**
 * Returns a function which, when invoked, will return the number of times a
 * hook has been called.
 *
 * @param {import('.').Hooks}    hooks    Hooks instance.
 * @param {import('.').StoreKey} storeKey
 *
 * @return {DidHook} Function that returns a hook's call count.
 */
function createDidHook(hooks, storeKey) {
  return function didHook(hookName) {
    const hooksStore = hooks[storeKey];
    if (!(0,_validateHookName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(hookName)) {
      return;
    }
    return hooksStore[hookName] && hooksStore[hookName].runs ? hooksStore[hookName].runs : 0;
  };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createDidHook);

/***/ }),

/***/ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createDoingHook.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createDoingHook.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @callback DoingHook
 * Returns whether a hook is currently being executed.
 *
 * @param {string} [hookName] The name of the hook to check for.  If
 *                            omitted, will check for any hook being executed.
 *
 * @return {boolean} Whether the hook is being executed.
 */

/**
 * Returns a function which, when invoked, will return whether a hook is
 * currently being executed.
 *
 * @param {import('.').Hooks}    hooks    Hooks instance.
 * @param {import('.').StoreKey} storeKey
 *
 * @return {DoingHook} Function that returns whether a hook is currently
 *                     being executed.
 */
function createDoingHook(hooks, storeKey) {
  return function doingHook(hookName) {
    const hooksStore = hooks[storeKey];

    // If the hookName was not passed, check for any current hook.
    if ('undefined' === typeof hookName) {
      return 'undefined' !== typeof hooksStore.__current[0];
    }

    // Return the __current hook.
    return hooksStore.__current[0] ? hookName === hooksStore.__current[0].name : false;
  };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createDoingHook);

/***/ }),

/***/ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createHasHook.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createHasHook.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @callback HasHook
 *
 * Returns whether any handlers are attached for the given hookName and optional namespace.
 *
 * @param {string} hookName    The name of the hook to check for.
 * @param {string} [namespace] Optional. The unique namespace identifying the callback
 *                             in the form `vendor/plugin/function`.
 *
 * @return {boolean} Whether there are handlers that are attached to the given hook.
 */
/**
 * Returns a function which, when invoked, will return whether any handlers are
 * attached to a particular hook.
 *
 * @param {import('.').Hooks}    hooks    Hooks instance.
 * @param {import('.').StoreKey} storeKey
 *
 * @return {HasHook} Function that returns whether any handlers are
 *                   attached to a particular hook and optional namespace.
 */
function createHasHook(hooks, storeKey) {
  return function hasHook(hookName, namespace) {
    const hooksStore = hooks[storeKey];

    // Use the namespace if provided.
    if ('undefined' !== typeof namespace) {
      return hookName in hooksStore && hooksStore[hookName].handlers.some(hook => hook.namespace === namespace);
    }
    return hookName in hooksStore;
  };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createHasHook);

/***/ }),

/***/ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createHooks.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createHooks.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _Hooks: () => (/* binding */ _Hooks),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createAddHook__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createAddHook */ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createAddHook.js");
/* harmony import */ var _createRemoveHook__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createRemoveHook */ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createRemoveHook.js");
/* harmony import */ var _createHasHook__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createHasHook */ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createHasHook.js");
/* harmony import */ var _createRunHook__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createRunHook */ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createRunHook.js");
/* harmony import */ var _createCurrentHook__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createCurrentHook */ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createCurrentHook.js");
/* harmony import */ var _createDoingHook__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createDoingHook */ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createDoingHook.js");
/* harmony import */ var _createDidHook__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./createDidHook */ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createDidHook.js");
/**
 * Internal dependencies
 */








/**
 * Internal class for constructing hooks. Use `createHooks()` function
 *
 * Note, it is necessary to expose this class to make its type public.
 *
 * @private
 */
class _Hooks {
  constructor() {
    /** @type {import('.').Store} actions */
    this.actions = Object.create(null);
    this.actions.__current = [];

    /** @type {import('.').Store} filters */
    this.filters = Object.create(null);
    this.filters.__current = [];
    this.addAction = (0,_createAddHook__WEBPACK_IMPORTED_MODULE_0__["default"])(this, 'actions');
    this.addFilter = (0,_createAddHook__WEBPACK_IMPORTED_MODULE_0__["default"])(this, 'filters');
    this.removeAction = (0,_createRemoveHook__WEBPACK_IMPORTED_MODULE_1__["default"])(this, 'actions');
    this.removeFilter = (0,_createRemoveHook__WEBPACK_IMPORTED_MODULE_1__["default"])(this, 'filters');
    this.hasAction = (0,_createHasHook__WEBPACK_IMPORTED_MODULE_2__["default"])(this, 'actions');
    this.hasFilter = (0,_createHasHook__WEBPACK_IMPORTED_MODULE_2__["default"])(this, 'filters');
    this.removeAllActions = (0,_createRemoveHook__WEBPACK_IMPORTED_MODULE_1__["default"])(this, 'actions', true);
    this.removeAllFilters = (0,_createRemoveHook__WEBPACK_IMPORTED_MODULE_1__["default"])(this, 'filters', true);
    this.doAction = (0,_createRunHook__WEBPACK_IMPORTED_MODULE_3__["default"])(this, 'actions');
    this.applyFilters = (0,_createRunHook__WEBPACK_IMPORTED_MODULE_3__["default"])(this, 'filters', true);
    this.currentAction = (0,_createCurrentHook__WEBPACK_IMPORTED_MODULE_4__["default"])(this, 'actions');
    this.currentFilter = (0,_createCurrentHook__WEBPACK_IMPORTED_MODULE_4__["default"])(this, 'filters');
    this.doingAction = (0,_createDoingHook__WEBPACK_IMPORTED_MODULE_5__["default"])(this, 'actions');
    this.doingFilter = (0,_createDoingHook__WEBPACK_IMPORTED_MODULE_5__["default"])(this, 'filters');
    this.didAction = (0,_createDidHook__WEBPACK_IMPORTED_MODULE_6__["default"])(this, 'actions');
    this.didFilter = (0,_createDidHook__WEBPACK_IMPORTED_MODULE_6__["default"])(this, 'filters');
  }
}

/** @typedef {_Hooks} Hooks */

/**
 * Returns an instance of the hooks object.
 *
 * @return {Hooks} A Hooks instance.
 */
function createHooks() {
  return new _Hooks();
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createHooks);

/***/ }),

/***/ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createRemoveHook.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createRemoveHook.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validateNamespace_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validateNamespace.js */ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/validateNamespace.js");
/* harmony import */ var _validateHookName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./validateHookName.js */ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/validateHookName.js");
/**
 * Internal dependencies
 */



/**
 * @callback RemoveHook
 * Removes the specified callback (or all callbacks) from the hook with a given hookName
 * and namespace.
 *
 * @param {string} hookName  The name of the hook to modify.
 * @param {string} namespace The unique namespace identifying the callback in the
 *                           form `vendor/plugin/function`.
 *
 * @return {number | undefined} The number of callbacks removed.
 */

/**
 * Returns a function which, when invoked, will remove a specified hook or all
 * hooks by the given name.
 *
 * @param {import('.').Hooks}    hooks             Hooks instance.
 * @param {import('.').StoreKey} storeKey
 * @param {boolean}              [removeAll=false] Whether to remove all callbacks for a hookName,
 *                                                 without regard to namespace. Used to create
 *                                                 `removeAll*` functions.
 *
 * @return {RemoveHook} Function that removes hooks.
 */
function createRemoveHook(hooks, storeKey, removeAll = false) {
  return function removeHook(hookName, namespace) {
    const hooksStore = hooks[storeKey];
    if (!(0,_validateHookName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(hookName)) {
      return;
    }
    if (!removeAll && !(0,_validateNamespace_js__WEBPACK_IMPORTED_MODULE_0__["default"])(namespace)) {
      return;
    }

    // Bail if no hooks exist by this name.
    if (!hooksStore[hookName]) {
      return 0;
    }
    let handlersRemoved = 0;
    if (removeAll) {
      handlersRemoved = hooksStore[hookName].handlers.length;
      hooksStore[hookName] = {
        runs: hooksStore[hookName].runs,
        handlers: []
      };
    } else {
      // Try to find the specified callback to remove.
      const handlers = hooksStore[hookName].handlers;
      for (let i = handlers.length - 1; i >= 0; i--) {
        if (handlers[i].namespace === namespace) {
          handlers.splice(i, 1);
          handlersRemoved++;
          // This callback may also be part of a hook that is
          // currently executing.  If the callback we're removing
          // comes after the current callback, there's no problem;
          // otherwise we need to decrease the execution index of any
          // other runs by 1 to account for the removed element.
          hooksStore.__current.forEach(hookInfo => {
            if (hookInfo.name === hookName && hookInfo.currentIndex >= i) {
              hookInfo.currentIndex--;
            }
          });
        }
      }
    }
    if (hookName !== 'hookRemoved') {
      hooks.doAction('hookRemoved', hookName, namespace);
    }
    return handlersRemoved;
  };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createRemoveHook);

/***/ }),

/***/ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createRunHook.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createRunHook.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Returns a function which, when invoked, will execute all callbacks
 * registered to a hook of the specified type, optionally returning the final
 * value of the call chain.
 *
 * @param {import('.').Hooks}    hooks                  Hooks instance.
 * @param {import('.').StoreKey} storeKey
 * @param {boolean}              [returnFirstArg=false] Whether each hook callback is expected to
 *                                                      return its first argument.
 *
 * @return {(hookName:string, ...args: unknown[]) => undefined|unknown} Function that runs hook callbacks.
 */
function createRunHook(hooks, storeKey, returnFirstArg = false) {
  return function runHooks(hookName, ...args) {
    const hooksStore = hooks[storeKey];
    if (!hooksStore[hookName]) {
      hooksStore[hookName] = {
        handlers: [],
        runs: 0
      };
    }
    hooksStore[hookName].runs++;
    const handlers = hooksStore[hookName].handlers;

    // The following code is stripped from production builds.
    if (true) {
      // Handle any 'all' hooks registered.
      if ('hookAdded' !== hookName && hooksStore.all) {
        handlers.push(...hooksStore.all.handlers);
      }
    }
    if (!handlers || !handlers.length) {
      return returnFirstArg ? args[0] : undefined;
    }
    const hookInfo = {
      name: hookName,
      currentIndex: 0
    };
    hooksStore.__current.push(hookInfo);
    while (hookInfo.currentIndex < handlers.length) {
      const handler = handlers[hookInfo.currentIndex];
      const result = handler.callback.apply(null, args);
      if (returnFirstArg) {
        args[0] = result;
      }
      hookInfo.currentIndex++;
    }
    hooksStore.__current.pop();
    if (returnFirstArg) {
      return args[0];
    }
    return undefined;
  };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createRunHook);

/***/ }),

/***/ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   actions: () => (/* binding */ actions),
/* harmony export */   addAction: () => (/* binding */ addAction),
/* harmony export */   addFilter: () => (/* binding */ addFilter),
/* harmony export */   applyFilters: () => (/* binding */ applyFilters),
/* harmony export */   createHooks: () => (/* reexport safe */ _createHooks__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   currentAction: () => (/* binding */ currentAction),
/* harmony export */   currentFilter: () => (/* binding */ currentFilter),
/* harmony export */   defaultHooks: () => (/* binding */ defaultHooks),
/* harmony export */   didAction: () => (/* binding */ didAction),
/* harmony export */   didFilter: () => (/* binding */ didFilter),
/* harmony export */   doAction: () => (/* binding */ doAction),
/* harmony export */   doingAction: () => (/* binding */ doingAction),
/* harmony export */   doingFilter: () => (/* binding */ doingFilter),
/* harmony export */   filters: () => (/* binding */ filters),
/* harmony export */   hasAction: () => (/* binding */ hasAction),
/* harmony export */   hasFilter: () => (/* binding */ hasFilter),
/* harmony export */   removeAction: () => (/* binding */ removeAction),
/* harmony export */   removeAllActions: () => (/* binding */ removeAllActions),
/* harmony export */   removeAllFilters: () => (/* binding */ removeAllFilters),
/* harmony export */   removeFilter: () => (/* binding */ removeFilter)
/* harmony export */ });
/* harmony import */ var _createHooks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createHooks */ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/createHooks.js");
/**
 * Internal dependencies
 */


/** @typedef {(...args: any[])=>any} Callback */

/**
 * @typedef Handler
 * @property {Callback} callback  The callback
 * @property {string}   namespace The namespace
 * @property {number}   priority  The namespace
 */

/**
 * @typedef Hook
 * @property {Handler[]} handlers Array of handlers
 * @property {number}    runs     Run counter
 */

/**
 * @typedef Current
 * @property {string} name         Hook name
 * @property {number} currentIndex The index
 */

/**
 * @typedef {Record<string, Hook> & {__current: Current[]}} Store
 */

/**
 * @typedef {'actions' | 'filters'} StoreKey
 */

/**
 * @typedef {import('./createHooks').Hooks} Hooks
 */

const defaultHooks = (0,_createHooks__WEBPACK_IMPORTED_MODULE_0__["default"])();
const {
  addAction,
  addFilter,
  removeAction,
  removeFilter,
  hasAction,
  hasFilter,
  removeAllActions,
  removeAllFilters,
  doAction,
  applyFilters,
  currentAction,
  currentFilter,
  doingAction,
  doingFilter,
  didAction,
  didFilter,
  actions,
  filters
} = defaultHooks;


/***/ }),

/***/ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/validateHookName.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/validateHookName.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Validate a hookName string.
 *
 * @param {string} hookName The hook name to validate. Should be a non empty string containing
 *                          only numbers, letters, dashes, periods and underscores. Also,
 *                          the hook name cannot begin with `__`.
 *
 * @return {boolean} Whether the hook name is valid.
 */
function validateHookName(hookName) {
  if ('string' !== typeof hookName || '' === hookName) {
    // eslint-disable-next-line no-console
    console.error('The hook name must be a non-empty string.');
    return false;
  }
  if (/^__/.test(hookName)) {
    // eslint-disable-next-line no-console
    console.error('The hook name cannot begin with `__`.');
    return false;
  }
  if (!/^[a-zA-Z][a-zA-Z0-9_.-]*$/.test(hookName)) {
    // eslint-disable-next-line no-console
    console.error('The hook name can only contain numbers, letters, dashes, periods and underscores.');
    return false;
  }
  return true;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validateHookName);

/***/ }),

/***/ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/validateNamespace.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/validateNamespace.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Validate a namespace string.
 *
 * @param {string} namespace The namespace to validate - should take the form
 *                           `vendor/plugin/function`.
 *
 * @return {boolean} Whether the namespace is valid.
 */
function validateNamespace(namespace) {
  if ('string' !== typeof namespace || '' === namespace) {
    // eslint-disable-next-line no-console
    console.error('The namespace must be a non-empty string.');
    return false;
  }
  if (!/^[a-zA-Z][a-zA-Z0-9_.\-\/]*$/.test(namespace)) {
    // eslint-disable-next-line no-console
    console.error('The namespace can only contain numbers, letters, dashes, periods, underscores and slashes.');
    return false;
  }
  return true;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validateNamespace);

/***/ }),

/***/ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/create-i18n.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/create-i18n.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createI18n: () => (/* binding */ createI18n)
/* harmony export */ });
/* harmony import */ var tannin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tannin */ "./node_modules/tannin/index.js");
/**
 * External dependencies
 */


/**
 * @typedef {Record<string,any>} LocaleData
 */

/**
 * Default locale data to use for Tannin domain when not otherwise provided.
 * Assumes an English plural forms expression.
 *
 * @type {LocaleData}
 */
const DEFAULT_LOCALE_DATA = {
  '': {
    /** @param {number} n */
    plural_forms(n) {
      return n === 1 ? 0 : 1;
    }
  }
};

/*
 * Regular expression that matches i18n hooks like `i18n.gettext`, `i18n.ngettext`,
 * `i18n.gettext_domain` or `i18n.ngettext_with_context` or `i18n.has_translation`.
 */
const I18N_HOOK_REGEXP = /^i18n\.(n?gettext|has_translation)(_|$)/;

/**
 * @typedef {(domain?: string) => LocaleData} GetLocaleData
 *
 * Returns locale data by domain in a
 * Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 */
/**
 * @typedef {(data?: LocaleData, domain?: string) => void} SetLocaleData
 *
 * Merges locale data into the Tannin instance by domain. Note that this
 * function will overwrite the domain configuration. Accepts data in a
 * Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 */
/**
 * @typedef {(data?: LocaleData, domain?: string) => void} AddLocaleData
 *
 * Merges locale data into the Tannin instance by domain. Note that this
 * function will also merge the domain configuration. Accepts data in a
 * Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 */
/**
 * @typedef {(data?: LocaleData, domain?: string) => void} ResetLocaleData
 *
 * Resets all current Tannin instance locale data and sets the specified
 * locale data for the domain. Accepts data in a Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 */
/** @typedef {() => void} SubscribeCallback */
/** @typedef {() => void} UnsubscribeCallback */
/**
 * @typedef {(callback: SubscribeCallback) => UnsubscribeCallback} Subscribe
 *
 * Subscribes to changes of locale data
 */
/**
 * @typedef {(domain?: string) => string} GetFilterDomain
 * Retrieve the domain to use when calling domain-specific filters.
 */
/**
 * @typedef {(text: string, domain?: string) => string} __
 *
 * Retrieve the translation of text.
 *
 * @see https://developer.wordpress.org/reference/functions/__/
 */
/**
 * @typedef {(text: string, context: string, domain?: string) => string} _x
 *
 * Retrieve translated string with gettext context.
 *
 * @see https://developer.wordpress.org/reference/functions/_x/
 */
/**
 * @typedef {(single: string, plural: string, number: number, domain?: string) => string} _n
 *
 * Translates and retrieves the singular or plural form based on the supplied
 * number.
 *
 * @see https://developer.wordpress.org/reference/functions/_n/
 */
/**
 * @typedef {(single: string, plural: string, number: number, context: string, domain?: string) => string} _nx
 *
 * Translates and retrieves the singular or plural form based on the supplied
 * number, with gettext context.
 *
 * @see https://developer.wordpress.org/reference/functions/_nx/
 */
/**
 * @typedef {() => boolean} IsRtl
 *
 * Check if current locale is RTL.
 *
 * **RTL (Right To Left)** is a locale property indicating that text is written from right to left.
 * For example, the `he` locale (for Hebrew) specifies right-to-left. Arabic (ar) is another common
 * language written RTL. The opposite of RTL, LTR (Left To Right) is used in other languages,
 * including English (`en`, `en-US`, `en-GB`, etc.), Spanish (`es`), and French (`fr`).
 */
/**
 * @typedef {(single: string, context?: string, domain?: string) => boolean} HasTranslation
 *
 * Check if there is a translation for a given string in singular form.
 */
/** @typedef {import('@wordpress/hooks').Hooks} Hooks */

/**
 * An i18n instance
 *
 * @typedef I18n
 * @property {GetLocaleData}   getLocaleData   Returns locale data by domain in a Jed-formatted JSON object shape.
 * @property {SetLocaleData}   setLocaleData   Merges locale data into the Tannin instance by domain. Note that this
 *                                             function will overwrite the domain configuration. Accepts data in a
 *                                             Jed-formatted JSON object shape.
 * @property {AddLocaleData}   addLocaleData   Merges locale data into the Tannin instance by domain. Note that this
 *                                             function will also merge the domain configuration. Accepts data in a
 *                                             Jed-formatted JSON object shape.
 * @property {ResetLocaleData} resetLocaleData Resets all current Tannin instance locale data and sets the specified
 *                                             locale data for the domain. Accepts data in a Jed-formatted JSON object shape.
 * @property {Subscribe}       subscribe       Subscribes to changes of Tannin locale data.
 * @property {__}              __              Retrieve the translation of text.
 * @property {_x}              _x              Retrieve translated string with gettext context.
 * @property {_n}              _n              Translates and retrieves the singular or plural form based on the supplied
 *                                             number.
 * @property {_nx}             _nx             Translates and retrieves the singular or plural form based on the supplied
 *                                             number, with gettext context.
 * @property {IsRtl}           isRTL           Check if current locale is RTL.
 * @property {HasTranslation}  hasTranslation  Check if there is a translation for a given string.
 */

/**
 * Create an i18n instance
 *
 * @param {LocaleData} [initialData]   Locale data configuration.
 * @param {string}     [initialDomain] Domain for which configuration applies.
 * @param {Hooks}      [hooks]         Hooks implementation.
 *
 * @return {I18n} I18n instance.
 */
const createI18n = (initialData, initialDomain, hooks) => {
  /**
   * The underlying instance of Tannin to which exported functions interface.
   *
   * @type {Tannin}
   */
  const tannin = new tannin__WEBPACK_IMPORTED_MODULE_0__["default"]({});
  const listeners = new Set();
  const notifyListeners = () => {
    listeners.forEach(listener => listener());
  };

  /**
   * Subscribe to changes of locale data.
   *
   * @param {SubscribeCallback} callback Subscription callback.
   * @return {UnsubscribeCallback} Unsubscribe callback.
   */
  const subscribe = callback => {
    listeners.add(callback);
    return () => listeners.delete(callback);
  };

  /** @type {GetLocaleData} */
  const getLocaleData = (domain = 'default') => tannin.data[domain];

  /**
   * @param {LocaleData} [data]
   * @param {string}     [domain]
   */
  const doSetLocaleData = (data, domain = 'default') => {
    var _tannin$data$domain;
    tannin.data[domain] = {
      ...tannin.data[domain],
      ...data
    };

    // Populate default domain configuration (supported locale date which omits
    // a plural forms expression).
    tannin.data[domain][''] = {
      ...DEFAULT_LOCALE_DATA[''],
      ...((_tannin$data$domain = tannin.data[domain]) === null || _tannin$data$domain === void 0 ? void 0 : _tannin$data$domain[''])
    };

    // Clean up cached plural forms functions cache as it might be updated.
    delete tannin.pluralForms[domain];
  };

  /** @type {SetLocaleData} */
  const setLocaleData = (data, domain) => {
    doSetLocaleData(data, domain);
    notifyListeners();
  };

  /** @type {AddLocaleData} */
  const addLocaleData = (data, domain = 'default') => {
    var _tannin$data$domain2;
    tannin.data[domain] = {
      ...tannin.data[domain],
      ...data,
      // Populate default domain configuration (supported locale date which omits
      // a plural forms expression).
      '': {
        ...DEFAULT_LOCALE_DATA[''],
        ...((_tannin$data$domain2 = tannin.data[domain]) === null || _tannin$data$domain2 === void 0 ? void 0 : _tannin$data$domain2['']),
        ...(data === null || data === void 0 ? void 0 : data[''])
      }
    };

    // Clean up cached plural forms functions cache as it might be updated.
    delete tannin.pluralForms[domain];
    notifyListeners();
  };

  /** @type {ResetLocaleData} */
  const resetLocaleData = (data, domain) => {
    // Reset all current Tannin locale data.
    tannin.data = {};

    // Reset cached plural forms functions cache.
    tannin.pluralForms = {};
    setLocaleData(data, domain);
  };

  /**
   * Wrapper for Tannin's `dcnpgettext`. Populates default locale data if not
   * otherwise previously assigned.
   *
   * @param {string|undefined} domain   Domain to retrieve the translated text.
   * @param {string|undefined} context  Context information for the translators.
   * @param {string}           single   Text to translate if non-plural. Used as
   *                                    fallback return value on a caught error.
   * @param {string}           [plural] The text to be used if the number is
   *                                    plural.
   * @param {number}           [number] The number to compare against to use
   *                                    either the singular or plural form.
   *
   * @return {string} The translated string.
   */
  const dcnpgettext = (domain = 'default', context, single, plural, number) => {
    if (!tannin.data[domain]) {
      // Use `doSetLocaleData` to set silently, without notifying listeners.
      doSetLocaleData(undefined, domain);
    }
    return tannin.dcnpgettext(domain, context, single, plural, number);
  };

  /** @type {GetFilterDomain} */
  const getFilterDomain = (domain = 'default') => domain;

  /** @type {__} */
  const __ = (text, domain) => {
    let translation = dcnpgettext(domain, undefined, text);
    if (!hooks) {
      return translation;
    }

    /**
     * Filters text with its translation.
     *
     * @param {string} translation Translated text.
     * @param {string} text        Text to translate.
     * @param {string} domain      Text domain. Unique identifier for retrieving translated strings.
     */
    translation = /** @type {string} */
    /** @type {*} */hooks.applyFilters('i18n.gettext', translation, text, domain);
    return /** @type {string} */ /** @type {*} */hooks.applyFilters('i18n.gettext_' + getFilterDomain(domain), translation, text, domain);
  };

  /** @type {_x} */
  const _x = (text, context, domain) => {
    let translation = dcnpgettext(domain, context, text);
    if (!hooks) {
      return translation;
    }

    /**
     * Filters text with its translation based on context information.
     *
     * @param {string} translation Translated text.
     * @param {string} text        Text to translate.
     * @param {string} context     Context information for the translators.
     * @param {string} domain      Text domain. Unique identifier for retrieving translated strings.
     */
    translation = /** @type {string} */
    /** @type {*} */hooks.applyFilters('i18n.gettext_with_context', translation, text, context, domain);
    return /** @type {string} */ /** @type {*} */hooks.applyFilters('i18n.gettext_with_context_' + getFilterDomain(domain), translation, text, context, domain);
  };

  /** @type {_n} */
  const _n = (single, plural, number, domain) => {
    let translation = dcnpgettext(domain, undefined, single, plural, number);
    if (!hooks) {
      return translation;
    }

    /**
     * Filters the singular or plural form of a string.
     *
     * @param {string} translation Translated text.
     * @param {string} single      The text to be used if the number is singular.
     * @param {string} plural      The text to be used if the number is plural.
     * @param {string} number      The number to compare against to use either the singular or plural form.
     * @param {string} domain      Text domain. Unique identifier for retrieving translated strings.
     */
    translation = /** @type {string} */
    /** @type {*} */hooks.applyFilters('i18n.ngettext', translation, single, plural, number, domain);
    return /** @type {string} */ /** @type {*} */hooks.applyFilters('i18n.ngettext_' + getFilterDomain(domain), translation, single, plural, number, domain);
  };

  /** @type {_nx} */
  const _nx = (single, plural, number, context, domain) => {
    let translation = dcnpgettext(domain, context, single, plural, number);
    if (!hooks) {
      return translation;
    }

    /**
     * Filters the singular or plural form of a string with gettext context.
     *
     * @param {string} translation Translated text.
     * @param {string} single      The text to be used if the number is singular.
     * @param {string} plural      The text to be used if the number is plural.
     * @param {string} number      The number to compare against to use either the singular or plural form.
     * @param {string} context     Context information for the translators.
     * @param {string} domain      Text domain. Unique identifier for retrieving translated strings.
     */
    translation = /** @type {string} */
    /** @type {*} */hooks.applyFilters('i18n.ngettext_with_context', translation, single, plural, number, context, domain);
    return /** @type {string} */ /** @type {*} */hooks.applyFilters('i18n.ngettext_with_context_' + getFilterDomain(domain), translation, single, plural, number, context, domain);
  };

  /** @type {IsRtl} */
  const isRTL = () => {
    return 'rtl' === _x('ltr', 'text direction');
  };

  /** @type {HasTranslation} */
  const hasTranslation = (single, context, domain) => {
    var _tannin$data, _tannin$data2;
    const key = context ? context + '\u0004' + single : single;
    let result = !!((_tannin$data = tannin.data) !== null && _tannin$data !== void 0 && (_tannin$data2 = _tannin$data[domain !== null && domain !== void 0 ? domain : 'default']) !== null && _tannin$data2 !== void 0 && _tannin$data2[key]);
    if (hooks) {
      /**
       * Filters the presence of a translation in the locale data.
       *
       * @param {boolean} hasTranslation Whether the translation is present or not..
       * @param {string}  single         The singular form of the translated text (used as key in locale data)
       * @param {string}  context        Context information for the translators.
       * @param {string}  domain         Text domain. Unique identifier for retrieving translated strings.
       */
      result = /** @type { boolean } */
      /** @type {*} */hooks.applyFilters('i18n.has_translation', result, single, context, domain);
      result = /** @type { boolean } */
      /** @type {*} */hooks.applyFilters('i18n.has_translation_' + getFilterDomain(domain), result, single, context, domain);
    }
    return result;
  };
  if (initialData) {
    setLocaleData(initialData, initialDomain);
  }
  if (hooks) {
    /**
     * @param {string} hookName
     */
    const onHookAddedOrRemoved = hookName => {
      if (I18N_HOOK_REGEXP.test(hookName)) {
        notifyListeners();
      }
    };
    hooks.addAction('hookAdded', 'core/i18n', onHookAddedOrRemoved);
    hooks.addAction('hookRemoved', 'core/i18n', onHookAddedOrRemoved);
  }
  return {
    getLocaleData,
    setLocaleData,
    addLocaleData,
    resetLocaleData,
    subscribe,
    __,
    _x,
    _n,
    _nx,
    isRTL,
    hasTranslation
  };
};

/***/ }),

/***/ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/default-i18n.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/default-i18n.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __: () => (/* binding */ __),
/* harmony export */   _n: () => (/* binding */ _n),
/* harmony export */   _nx: () => (/* binding */ _nx),
/* harmony export */   _x: () => (/* binding */ _x),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getLocaleData: () => (/* binding */ getLocaleData),
/* harmony export */   hasTranslation: () => (/* binding */ hasTranslation),
/* harmony export */   isRTL: () => (/* binding */ isRTL),
/* harmony export */   resetLocaleData: () => (/* binding */ resetLocaleData),
/* harmony export */   setLocaleData: () => (/* binding */ setLocaleData),
/* harmony export */   subscribe: () => (/* binding */ subscribe)
/* harmony export */ });
/* harmony import */ var _create_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create-i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/create-i18n.js");
/* harmony import */ var _wordpress_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wordpress/hooks */ "./node_modules/yoastseo/node_modules/@wordpress/hooks/build-module/index.js");
/**
 * Internal dependencies
 */


/**
 * WordPress dependencies
 */

const i18n = (0,_create_i18n__WEBPACK_IMPORTED_MODULE_0__.createI18n)(undefined, undefined, _wordpress_hooks__WEBPACK_IMPORTED_MODULE_1__.defaultHooks);

/**
 * Default, singleton instance of `I18n`.
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (i18n);

/*
 * Comments in this file are duplicated from ./i18n due to
 * https://github.com/WordPress/gutenberg/pull/20318#issuecomment-590837722
 */

/**
 * @typedef {import('./create-i18n').LocaleData} LocaleData
 * @typedef {import('./create-i18n').SubscribeCallback} SubscribeCallback
 * @typedef {import('./create-i18n').UnsubscribeCallback} UnsubscribeCallback
 */

/**
 * Returns locale data by domain in a Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 *
 * @param {string} [domain] Domain for which to get the data.
 * @return {LocaleData} Locale data.
 */
const getLocaleData = i18n.getLocaleData.bind(i18n);

/**
 * Merges locale data into the Tannin instance by domain. Accepts data in a
 * Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 *
 * @param {LocaleData} [data]   Locale data configuration.
 * @param {string}     [domain] Domain for which configuration applies.
 */
const setLocaleData = i18n.setLocaleData.bind(i18n);

/**
 * Resets all current Tannin instance locale data and sets the specified
 * locale data for the domain. Accepts data in a Jed-formatted JSON object shape.
 *
 * @see http://messageformat.github.io/Jed/
 *
 * @param {LocaleData} [data]   Locale data configuration.
 * @param {string}     [domain] Domain for which configuration applies.
 */
const resetLocaleData = i18n.resetLocaleData.bind(i18n);

/**
 * Subscribes to changes of locale data
 *
 * @param {SubscribeCallback} callback Subscription callback
 * @return {UnsubscribeCallback} Unsubscribe callback
 */
const subscribe = i18n.subscribe.bind(i18n);

/**
 * Retrieve the translation of text.
 *
 * @see https://developer.wordpress.org/reference/functions/__/
 *
 * @param {string} text     Text to translate.
 * @param {string} [domain] Domain to retrieve the translated text.
 *
 * @return {string} Translated text.
 */
const __ = i18n.__.bind(i18n);

/**
 * Retrieve translated string with gettext context.
 *
 * @see https://developer.wordpress.org/reference/functions/_x/
 *
 * @param {string} text     Text to translate.
 * @param {string} context  Context information for the translators.
 * @param {string} [domain] Domain to retrieve the translated text.
 *
 * @return {string} Translated context string without pipe.
 */
const _x = i18n._x.bind(i18n);

/**
 * Translates and retrieves the singular or plural form based on the supplied
 * number.
 *
 * @see https://developer.wordpress.org/reference/functions/_n/
 *
 * @param {string} single   The text to be used if the number is singular.
 * @param {string} plural   The text to be used if the number is plural.
 * @param {number} number   The number to compare against to use either the
 *                          singular or plural form.
 * @param {string} [domain] Domain to retrieve the translated text.
 *
 * @return {string} The translated singular or plural form.
 */
const _n = i18n._n.bind(i18n);

/**
 * Translates and retrieves the singular or plural form based on the supplied
 * number, with gettext context.
 *
 * @see https://developer.wordpress.org/reference/functions/_nx/
 *
 * @param {string} single   The text to be used if the number is singular.
 * @param {string} plural   The text to be used if the number is plural.
 * @param {number} number   The number to compare against to use either the
 *                          singular or plural form.
 * @param {string} context  Context information for the translators.
 * @param {string} [domain] Domain to retrieve the translated text.
 *
 * @return {string} The translated singular or plural form.
 */
const _nx = i18n._nx.bind(i18n);

/**
 * Check if current locale is RTL.
 *
 * **RTL (Right To Left)** is a locale property indicating that text is written from right to left.
 * For example, the `he` locale (for Hebrew) specifies right-to-left. Arabic (ar) is another common
 * language written RTL. The opposite of RTL, LTR (Left To Right) is used in other languages,
 * including English (`en`, `en-US`, `en-GB`, etc.), Spanish (`es`), and French (`fr`).
 *
 * @return {boolean} Whether locale is RTL.
 */
const isRTL = i18n.isRTL.bind(i18n);

/**
 * Check if there is a translation for a given string (in singular form).
 *
 * @param {string} single    Singular form of the string to look up.
 * @param {string} [context] Context information for the translators.
 * @param {string} [domain]  Domain to retrieve the translated text.
 * @return {boolean} Whether the translation exists or not.
 */
const hasTranslation = i18n.hasTranslation.bind(i18n);

/***/ }),

/***/ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __: () => (/* reexport safe */ _default_i18n__WEBPACK_IMPORTED_MODULE_2__.__),
/* harmony export */   _n: () => (/* reexport safe */ _default_i18n__WEBPACK_IMPORTED_MODULE_2__._n),
/* harmony export */   _nx: () => (/* reexport safe */ _default_i18n__WEBPACK_IMPORTED_MODULE_2__._nx),
/* harmony export */   _x: () => (/* reexport safe */ _default_i18n__WEBPACK_IMPORTED_MODULE_2__._x),
/* harmony export */   createI18n: () => (/* reexport safe */ _create_i18n__WEBPACK_IMPORTED_MODULE_1__.createI18n),
/* harmony export */   defaultI18n: () => (/* reexport safe */ _default_i18n__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   getLocaleData: () => (/* reexport safe */ _default_i18n__WEBPACK_IMPORTED_MODULE_2__.getLocaleData),
/* harmony export */   hasTranslation: () => (/* reexport safe */ _default_i18n__WEBPACK_IMPORTED_MODULE_2__.hasTranslation),
/* harmony export */   isRTL: () => (/* reexport safe */ _default_i18n__WEBPACK_IMPORTED_MODULE_2__.isRTL),
/* harmony export */   resetLocaleData: () => (/* reexport safe */ _default_i18n__WEBPACK_IMPORTED_MODULE_2__.resetLocaleData),
/* harmony export */   setLocaleData: () => (/* reexport safe */ _default_i18n__WEBPACK_IMPORTED_MODULE_2__.setLocaleData),
/* harmony export */   sprintf: () => (/* reexport safe */ _sprintf__WEBPACK_IMPORTED_MODULE_0__.sprintf),
/* harmony export */   subscribe: () => (/* reexport safe */ _default_i18n__WEBPACK_IMPORTED_MODULE_2__.subscribe)
/* harmony export */ });
/* harmony import */ var _sprintf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sprintf */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/sprintf.js");
/* harmony import */ var _create_i18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./create-i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/create-i18n.js");
/* harmony import */ var _default_i18n__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./default-i18n */ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/default-i18n.js");




/***/ }),

/***/ "./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/sprintf.js":
/*!************************************************************************************!*\
  !*** ./node_modules/yoastseo/node_modules/@wordpress/i18n/build-module/sprintf.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sprintf: () => (/* binding */ sprintf)
/* harmony export */ });
/* harmony import */ var memize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! memize */ "./node_modules/yoastseo/node_modules/memize/dist/index.js");
/* harmony import */ var sprintf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sprintf-js */ "./node_modules/sprintf-js/src/sprintf.js");
/* harmony import */ var sprintf_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(sprintf_js__WEBPACK_IMPORTED_MODULE_1__);
/**
 * External dependencies
 */



/**
 * Log to console, once per message; or more precisely, per referentially equal
 * argument set. Because Jed throws errors, we log these to the console instead
 * to avoid crashing the application.
 *
 * @param {...*} args Arguments to pass to `console.error`
 */
const logErrorOnce = (0,memize__WEBPACK_IMPORTED_MODULE_0__["default"])(console.error); // eslint-disable-line no-console

/**
 * Returns a formatted string. If an error occurs in applying the format, the
 * original format string is returned.
 *
 * @param {string} format The format of the string to generate.
 * @param {...*}   args   Arguments to apply to the format.
 *
 * @see https://www.npmjs.com/package/sprintf-js
 *
 * @return {string} The formatted string.
 */
function sprintf(format, ...args) {
  try {
    return sprintf_js__WEBPACK_IMPORTED_MODULE_1___default().sprintf(format, ...args);
  } catch (error) {
    if (error instanceof Error) {
      logErrorOnce('sprintf error: \n\n' + error.toString());
    }
    return format;
  }
}

/***/ }),

/***/ "?13bc":
/*!*********************************!*\
  !*** readable-stream (ignored) ***!
  \*********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4f7e":
/*!********************************!*\
  !*** ./util.inspect (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/available-typed-arrays/index.js":
/*!******************************************************!*\
  !*** ./node_modules/available-typed-arrays/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var possibleNames = __webpack_require__(/*! possible-typed-array-names */ "./node_modules/possible-typed-array-names/index.js");
var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;

/** @type {import('.')} */
module.exports = function availableTypedArrays() {
  var /** @type {ReturnType<typeof availableTypedArrays>} */out = [];
  for (var i = 0; i < possibleNames.length; i++) {
    if (typeof g[possibleNames[i]] === 'function') {
      // @ts-expect-error
      out[out.length] = possibleNames[i];
    }
  }
  return out;
};

/***/ }),

/***/ "./node_modules/parse5/dist/cjs/common/doctype.js":
/*!********************************************************!*\
  !*** ./node_modules/parse5/dist/cjs/common/doctype.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isConforming = isConforming;
exports.getDocumentMode = getDocumentMode;
const html_js_1 = __webpack_require__(/*! ./html.js */ "./node_modules/parse5/dist/cjs/common/html.js");
//Const
const VALID_DOCTYPE_NAME = 'html';
const VALID_SYSTEM_ID = 'about:legacy-compat';
const QUIRKS_MODE_SYSTEM_ID = 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd';
const QUIRKS_MODE_PUBLIC_ID_PREFIXES = ['+//silmaril//dtd html pro v0r11 19970101//', '-//as//dtd html 3.0 aswedit + extensions//', '-//advasoft ltd//dtd html 3.0 aswedit + extensions//', '-//ietf//dtd html 2.0 level 1//', '-//ietf//dtd html 2.0 level 2//', '-//ietf//dtd html 2.0 strict level 1//', '-//ietf//dtd html 2.0 strict level 2//', '-//ietf//dtd html 2.0 strict//', '-//ietf//dtd html 2.0//', '-//ietf//dtd html 2.1e//', '-//ietf//dtd html 3.0//', '-//ietf//dtd html 3.2 final//', '-//ietf//dtd html 3.2//', '-//ietf//dtd html 3//', '-//ietf//dtd html level 0//', '-//ietf//dtd html level 1//', '-//ietf//dtd html level 2//', '-//ietf//dtd html level 3//', '-//ietf//dtd html strict level 0//', '-//ietf//dtd html strict level 1//', '-//ietf//dtd html strict level 2//', '-//ietf//dtd html strict level 3//', '-//ietf//dtd html strict//', '-//ietf//dtd html//', '-//metrius//dtd metrius presentational//', '-//microsoft//dtd internet explorer 2.0 html strict//', '-//microsoft//dtd internet explorer 2.0 html//', '-//microsoft//dtd internet explorer 2.0 tables//', '-//microsoft//dtd internet explorer 3.0 html strict//', '-//microsoft//dtd internet explorer 3.0 html//', '-//microsoft//dtd internet explorer 3.0 tables//', '-//netscape comm. corp.//dtd html//', '-//netscape comm. corp.//dtd strict html//', "-//o'reilly and associates//dtd html 2.0//", "-//o'reilly and associates//dtd html extended 1.0//", "-//o'reilly and associates//dtd html extended relaxed 1.0//", '-//sq//dtd html 2.0 hotmetal + extensions//', '-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//', '-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//', '-//spyglass//dtd html 2.0 extended//', '-//sun microsystems corp.//dtd hotjava html//', '-//sun microsystems corp.//dtd hotjava strict html//', '-//w3c//dtd html 3 1995-03-24//', '-//w3c//dtd html 3.2 draft//', '-//w3c//dtd html 3.2 final//', '-//w3c//dtd html 3.2//', '-//w3c//dtd html 3.2s draft//', '-//w3c//dtd html 4.0 frameset//', '-//w3c//dtd html 4.0 transitional//', '-//w3c//dtd html experimental 19960712//', '-//w3c//dtd html experimental 970421//', '-//w3c//dtd w3 html//', '-//w3o//dtd w3 html 3.0//', '-//webtechs//dtd mozilla html 2.0//', '-//webtechs//dtd mozilla html//'];
const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [...QUIRKS_MODE_PUBLIC_ID_PREFIXES, '-//w3c//dtd html 4.01 frameset//', '-//w3c//dtd html 4.01 transitional//'];
const QUIRKS_MODE_PUBLIC_IDS = new Set(['-//w3o//dtd w3 html strict 3.0//en//', '-/w3c/dtd html 4.0 transitional/en', 'html']);
const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ['-//w3c//dtd xhtml 1.0 frameset//', '-//w3c//dtd xhtml 1.0 transitional//'];
const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES, '-//w3c//dtd html 4.01 frameset//', '-//w3c//dtd html 4.01 transitional//'];
//Utils
function hasPrefix(publicId, prefixes) {
  return prefixes.some(prefix => publicId.startsWith(prefix));
}
//API
function isConforming(token) {
  return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
}
function getDocumentMode(token) {
  if (token.name !== VALID_DOCTYPE_NAME) {
    return html_js_1.DOCUMENT_MODE.QUIRKS;
  }
  const {
    systemId
  } = token;
  if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
    return html_js_1.DOCUMENT_MODE.QUIRKS;
  }
  let {
    publicId
  } = token;
  if (publicId !== null) {
    publicId = publicId.toLowerCase();
    if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) {
      return html_js_1.DOCUMENT_MODE.QUIRKS;
    }
    let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return html_js_1.DOCUMENT_MODE.QUIRKS;
    }
    prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return html_js_1.DOCUMENT_MODE.LIMITED_QUIRKS;
    }
  }
  return html_js_1.DOCUMENT_MODE.NO_QUIRKS;
}

/***/ }),

/***/ "./node_modules/parse5/dist/cjs/common/error-codes.js":
/*!************************************************************!*\
  !*** ./node_modules/parse5/dist/cjs/common/error-codes.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ERR = void 0;
var ERR;
(function (ERR) {
  ERR["controlCharacterInInputStream"] = "control-character-in-input-stream";
  ERR["noncharacterInInputStream"] = "noncharacter-in-input-stream";
  ERR["surrogateInInputStream"] = "surrogate-in-input-stream";
  ERR["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
  ERR["endTagWithAttributes"] = "end-tag-with-attributes";
  ERR["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
  ERR["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
  ERR["unexpectedNullCharacter"] = "unexpected-null-character";
  ERR["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
  ERR["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
  ERR["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
  ERR["missingEndTagName"] = "missing-end-tag-name";
  ERR["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
  ERR["unknownNamedCharacterReference"] = "unknown-named-character-reference";
  ERR["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
  ERR["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
  ERR["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
  ERR["eofBeforeTagName"] = "eof-before-tag-name";
  ERR["eofInTag"] = "eof-in-tag";
  ERR["missingAttributeValue"] = "missing-attribute-value";
  ERR["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
  ERR["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
  ERR["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
  ERR["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
  ERR["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
  ERR["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
  ERR["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
  ERR["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
  ERR["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
  ERR["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
  ERR["cdataInHtmlContent"] = "cdata-in-html-content";
  ERR["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
  ERR["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
  ERR["eofInDoctype"] = "eof-in-doctype";
  ERR["nestedComment"] = "nested-comment";
  ERR["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
  ERR["eofInComment"] = "eof-in-comment";
  ERR["incorrectlyClosedComment"] = "incorrectly-closed-comment";
  ERR["eofInCdata"] = "eof-in-cdata";
  ERR["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
  ERR["nullCharacterReference"] = "null-character-reference";
  ERR["surrogateCharacterReference"] = "surrogate-character-reference";
  ERR["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
  ERR["controlCharacterReference"] = "control-character-reference";
  ERR["noncharacterCharacterReference"] = "noncharacter-character-reference";
  ERR["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
  ERR["missingDoctypeName"] = "missing-doctype-name";
  ERR["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
  ERR["duplicateAttribute"] = "duplicate-attribute";
  ERR["nonConformingDoctype"] = "non-conforming-doctype";
  ERR["missingDoctype"] = "missing-doctype";
  ERR["misplacedDoctype"] = "misplaced-doctype";
  ERR["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
  ERR["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
  ERR["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
  ERR["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
  ERR["abandonedHeadElementChild"] = "abandoned-head-element-child";
  ERR["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
  ERR["nestedNoscriptInHead"] = "nested-noscript-in-head";
  ERR["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
})(ERR || (exports.ERR = ERR = {}));

/***/ }),

/***/ "./node_modules/parse5/dist/cjs/common/foreign-content.js":
/*!****************************************************************!*\
  !*** ./node_modules/parse5/dist/cjs/common/foreign-content.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SVG_TAG_NAMES_ADJUSTMENT_MAP = void 0;
exports.causesExit = causesExit;
exports.adjustTokenMathMLAttrs = adjustTokenMathMLAttrs;
exports.adjustTokenSVGAttrs = adjustTokenSVGAttrs;
exports.adjustTokenXMLAttrs = adjustTokenXMLAttrs;
exports.adjustTokenSVGTagName = adjustTokenSVGTagName;
exports.isIntegrationPoint = isIntegrationPoint;
const html_js_1 = __webpack_require__(/*! ./html.js */ "./node_modules/parse5/dist/cjs/common/html.js");
//MIME types
const MIME_TYPES = {
  TEXT_HTML: 'text/html',
  APPLICATION_XML: 'application/xhtml+xml'
};
//Attributes
const DEFINITION_URL_ATTR = 'definitionurl';
const ADJUSTED_DEFINITION_URL_ATTR = 'definitionURL';
const SVG_ATTRS_ADJUSTMENT_MAP = new Map(['attributeName', 'attributeType', 'baseFrequency', 'baseProfile', 'calcMode', 'clipPathUnits', 'diffuseConstant', 'edgeMode', 'filterUnits', 'glyphRef', 'gradientTransform', 'gradientUnits', 'kernelMatrix', 'kernelUnitLength', 'keyPoints', 'keySplines', 'keyTimes', 'lengthAdjust', 'limitingConeAngle', 'markerHeight', 'markerUnits', 'markerWidth', 'maskContentUnits', 'maskUnits', 'numOctaves', 'pathLength', 'patternContentUnits', 'patternTransform', 'patternUnits', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'preserveAlpha', 'preserveAspectRatio', 'primitiveUnits', 'refX', 'refY', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'specularConstant', 'specularExponent', 'spreadMethod', 'startOffset', 'stdDeviation', 'stitchTiles', 'surfaceScale', 'systemLanguage', 'tableValues', 'targetX', 'targetY', 'textLength', 'viewBox', 'viewTarget', 'xChannelSelector', 'yChannelSelector', 'zoomAndPan'].map(attr => [attr.toLowerCase(), attr]));
const XML_ATTRS_ADJUSTMENT_MAP = new Map([['xlink:actuate', {
  prefix: 'xlink',
  name: 'actuate',
  namespace: html_js_1.NS.XLINK
}], ['xlink:arcrole', {
  prefix: 'xlink',
  name: 'arcrole',
  namespace: html_js_1.NS.XLINK
}], ['xlink:href', {
  prefix: 'xlink',
  name: 'href',
  namespace: html_js_1.NS.XLINK
}], ['xlink:role', {
  prefix: 'xlink',
  name: 'role',
  namespace: html_js_1.NS.XLINK
}], ['xlink:show', {
  prefix: 'xlink',
  name: 'show',
  namespace: html_js_1.NS.XLINK
}], ['xlink:title', {
  prefix: 'xlink',
  name: 'title',
  namespace: html_js_1.NS.XLINK
}], ['xlink:type', {
  prefix: 'xlink',
  name: 'type',
  namespace: html_js_1.NS.XLINK
}], ['xml:lang', {
  prefix: 'xml',
  name: 'lang',
  namespace: html_js_1.NS.XML
}], ['xml:space', {
  prefix: 'xml',
  name: 'space',
  namespace: html_js_1.NS.XML
}], ['xmlns', {
  prefix: '',
  name: 'xmlns',
  namespace: html_js_1.NS.XMLNS
}], ['xmlns:xlink', {
  prefix: 'xmlns',
  name: 'xlink',
  namespace: html_js_1.NS.XMLNS
}]]);
//SVG tag names adjustment map
exports.SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map(['altGlyph', 'altGlyphDef', 'altGlyphItem', 'animateColor', 'animateMotion', 'animateTransform', 'clipPath', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'foreignObject', 'glyphRef', 'linearGradient', 'radialGradient', 'textPath'].map(tn => [tn.toLowerCase(), tn]));
//Tags that causes exit from foreign content
const EXITS_FOREIGN_CONTENT = new Set([html_js_1.TAG_ID.B, html_js_1.TAG_ID.BIG, html_js_1.TAG_ID.BLOCKQUOTE, html_js_1.TAG_ID.BODY, html_js_1.TAG_ID.BR, html_js_1.TAG_ID.CENTER, html_js_1.TAG_ID.CODE, html_js_1.TAG_ID.DD, html_js_1.TAG_ID.DIV, html_js_1.TAG_ID.DL, html_js_1.TAG_ID.DT, html_js_1.TAG_ID.EM, html_js_1.TAG_ID.EMBED, html_js_1.TAG_ID.H1, html_js_1.TAG_ID.H2, html_js_1.TAG_ID.H3, html_js_1.TAG_ID.H4, html_js_1.TAG_ID.H5, html_js_1.TAG_ID.H6, html_js_1.TAG_ID.HEAD, html_js_1.TAG_ID.HR, html_js_1.TAG_ID.I, html_js_1.TAG_ID.IMG, html_js_1.TAG_ID.LI, html_js_1.TAG_ID.LISTING, html_js_1.TAG_ID.MENU, html_js_1.TAG_ID.META, html_js_1.TAG_ID.NOBR, html_js_1.TAG_ID.OL, html_js_1.TAG_ID.P, html_js_1.TAG_ID.PRE, html_js_1.TAG_ID.RUBY, html_js_1.TAG_ID.S, html_js_1.TAG_ID.SMALL, html_js_1.TAG_ID.SPAN, html_js_1.TAG_ID.STRONG, html_js_1.TAG_ID.STRIKE, html_js_1.TAG_ID.SUB, html_js_1.TAG_ID.SUP, html_js_1.TAG_ID.TABLE, html_js_1.TAG_ID.TT, html_js_1.TAG_ID.U, html_js_1.TAG_ID.UL, html_js_1.TAG_ID.VAR]);
//Check exit from foreign content
function causesExit(startTagToken) {
  const tn = startTagToken.tagID;
  const isFontWithAttrs = tn === html_js_1.TAG_ID.FONT && startTagToken.attrs.some(({
    name
  }) => name === html_js_1.ATTRS.COLOR || name === html_js_1.ATTRS.SIZE || name === html_js_1.ATTRS.FACE);
  return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn);
}
//Token adjustments
function adjustTokenMathMLAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    if (token.attrs[i].name === DEFINITION_URL_ATTR) {
      token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
      break;
    }
  }
}
function adjustTokenSVGAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
    if (adjustedAttrName != null) {
      token.attrs[i].name = adjustedAttrName;
    }
  }
}
function adjustTokenXMLAttrs(token) {
  for (let i = 0; i < token.attrs.length; i++) {
    const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
    if (adjustedAttrEntry) {
      token.attrs[i].prefix = adjustedAttrEntry.prefix;
      token.attrs[i].name = adjustedAttrEntry.name;
      token.attrs[i].namespace = adjustedAttrEntry.namespace;
    }
  }
}
function adjustTokenSVGTagName(token) {
  const adjustedTagName = exports.SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token.tagName);
  if (adjustedTagName != null) {
    token.tagName = adjustedTagName;
    token.tagID = (0, html_js_1.getTagID)(token.tagName);
  }
}
//Integration points
function isMathMLTextIntegrationPoint(tn, ns) {
  return ns === html_js_1.NS.MATHML && (tn === html_js_1.TAG_ID.MI || tn === html_js_1.TAG_ID.MO || tn === html_js_1.TAG_ID.MN || tn === html_js_1.TAG_ID.MS || tn === html_js_1.TAG_ID.MTEXT);
}
function isHtmlIntegrationPoint(tn, ns, attrs) {
  if (ns === html_js_1.NS.MATHML && tn === html_js_1.TAG_ID.ANNOTATION_XML) {
    for (let i = 0; i < attrs.length; i++) {
      if (attrs[i].name === html_js_1.ATTRS.ENCODING) {
        const value = attrs[i].value.toLowerCase();
        return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
      }
    }
  }
  return ns === html_js_1.NS.SVG && (tn === html_js_1.TAG_ID.FOREIGN_OBJECT || tn === html_js_1.TAG_ID.DESC || tn === html_js_1.TAG_ID.TITLE);
}
function isIntegrationPoint(tn, ns, attrs, foreignNS) {
  return (!foreignNS || foreignNS === html_js_1.NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs) || (!foreignNS || foreignNS === html_js_1.NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns);
}

/***/ }),

/***/ "./node_modules/parse5/dist/cjs/common/html.js":
/*!*****************************************************!*\
  !*** ./node_modules/parse5/dist/cjs/common/html.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NUMBERED_HEADERS = exports.SPECIAL_ELEMENTS = exports.TAG_ID = exports.TAG_NAMES = exports.DOCUMENT_MODE = exports.ATTRS = exports.NS = void 0;
exports.getTagID = getTagID;
exports.hasUnescapedText = hasUnescapedText;
/** All valid namespaces in HTML. */
var NS;
(function (NS) {
  NS["HTML"] = "http://www.w3.org/1999/xhtml";
  NS["MATHML"] = "http://www.w3.org/1998/Math/MathML";
  NS["SVG"] = "http://www.w3.org/2000/svg";
  NS["XLINK"] = "http://www.w3.org/1999/xlink";
  NS["XML"] = "http://www.w3.org/XML/1998/namespace";
  NS["XMLNS"] = "http://www.w3.org/2000/xmlns/";
})(NS || (exports.NS = NS = {}));
var ATTRS;
(function (ATTRS) {
  ATTRS["TYPE"] = "type";
  ATTRS["ACTION"] = "action";
  ATTRS["ENCODING"] = "encoding";
  ATTRS["PROMPT"] = "prompt";
  ATTRS["NAME"] = "name";
  ATTRS["COLOR"] = "color";
  ATTRS["FACE"] = "face";
  ATTRS["SIZE"] = "size";
})(ATTRS || (exports.ATTRS = ATTRS = {}));
/**
 * The mode of the document.
 *
 * @see {@link https://dom.spec.whatwg.org/#concept-document-limited-quirks}
 */
var DOCUMENT_MODE;
(function (DOCUMENT_MODE) {
  DOCUMENT_MODE["NO_QUIRKS"] = "no-quirks";
  DOCUMENT_MODE["QUIRKS"] = "quirks";
  DOCUMENT_MODE["LIMITED_QUIRKS"] = "limited-quirks";
})(DOCUMENT_MODE || (exports.DOCUMENT_MODE = DOCUMENT_MODE = {}));
var TAG_NAMES;
(function (TAG_NAMES) {
  TAG_NAMES["A"] = "a";
  TAG_NAMES["ADDRESS"] = "address";
  TAG_NAMES["ANNOTATION_XML"] = "annotation-xml";
  TAG_NAMES["APPLET"] = "applet";
  TAG_NAMES["AREA"] = "area";
  TAG_NAMES["ARTICLE"] = "article";
  TAG_NAMES["ASIDE"] = "aside";
  TAG_NAMES["B"] = "b";
  TAG_NAMES["BASE"] = "base";
  TAG_NAMES["BASEFONT"] = "basefont";
  TAG_NAMES["BGSOUND"] = "bgsound";
  TAG_NAMES["BIG"] = "big";
  TAG_NAMES["BLOCKQUOTE"] = "blockquote";
  TAG_NAMES["BODY"] = "body";
  TAG_NAMES["BR"] = "br";
  TAG_NAMES["BUTTON"] = "button";
  TAG_NAMES["CAPTION"] = "caption";
  TAG_NAMES["CENTER"] = "center";
  TAG_NAMES["CODE"] = "code";
  TAG_NAMES["COL"] = "col";
  TAG_NAMES["COLGROUP"] = "colgroup";
  TAG_NAMES["DD"] = "dd";
  TAG_NAMES["DESC"] = "desc";
  TAG_NAMES["DETAILS"] = "details";
  TAG_NAMES["DIALOG"] = "dialog";
  TAG_NAMES["DIR"] = "dir";
  TAG_NAMES["DIV"] = "div";
  TAG_NAMES["DL"] = "dl";
  TAG_NAMES["DT"] = "dt";
  TAG_NAMES["EM"] = "em";
  TAG_NAMES["EMBED"] = "embed";
  TAG_NAMES["FIELDSET"] = "fieldset";
  TAG_NAMES["FIGCAPTION"] = "figcaption";
  TAG_NAMES["FIGURE"] = "figure";
  TAG_NAMES["FONT"] = "font";
  TAG_NAMES["FOOTER"] = "footer";
  TAG_NAMES["FOREIGN_OBJECT"] = "foreignObject";
  TAG_NAMES["FORM"] = "form";
  TAG_NAMES["FRAME"] = "frame";
  TAG_NAMES["FRAMESET"] = "frameset";
  TAG_NAMES["H1"] = "h1";
  TAG_NAMES["H2"] = "h2";
  TAG_NAMES["H3"] = "h3";
  TAG_NAMES["H4"] = "h4";
  TAG_NAMES["H5"] = "h5";
  TAG_NAMES["H6"] = "h6";
  TAG_NAMES["HEAD"] = "head";
  TAG_NAMES["HEADER"] = "header";
  TAG_NAMES["HGROUP"] = "hgroup";
  TAG_NAMES["HR"] = "hr";
  TAG_NAMES["HTML"] = "html";
  TAG_NAMES["I"] = "i";
  TAG_NAMES["IMG"] = "img";
  TAG_NAMES["IMAGE"] = "image";
  TAG_NAMES["INPUT"] = "input";
  TAG_NAMES["IFRAME"] = "iframe";
  TAG_NAMES["KEYGEN"] = "keygen";
  TAG_NAMES["LABEL"] = "label";
  TAG_NAMES["LI"] = "li";
  TAG_NAMES["LINK"] = "link";
  TAG_NAMES["LISTING"] = "listing";
  TAG_NAMES["MAIN"] = "main";
  TAG_NAMES["MALIGNMARK"] = "malignmark";
  TAG_NAMES["MARQUEE"] = "marquee";
  TAG_NAMES["MATH"] = "math";
  TAG_NAMES["MENU"] = "menu";
  TAG_NAMES["META"] = "meta";
  TAG_NAMES["MGLYPH"] = "mglyph";
  TAG_NAMES["MI"] = "mi";
  TAG_NAMES["MO"] = "mo";
  TAG_NAMES["MN"] = "mn";
  TAG_NAMES["MS"] = "ms";
  TAG_NAMES["MTEXT"] = "mtext";
  TAG_NAMES["NAV"] = "nav";
  TAG_NAMES["NOBR"] = "nobr";
  TAG_NAMES["NOFRAMES"] = "noframes";
  TAG_NAMES["NOEMBED"] = "noembed";
  TAG_NAMES["NOSCRIPT"] = "noscript";
  TAG_NAMES["OBJECT"] = "object";
  TAG_NAMES["OL"] = "ol";
  TAG_NAMES["OPTGROUP"] = "optgroup";
  TAG_NAMES["OPTION"] = "option";
  TAG_NAMES["P"] = "p";
  TAG_NAMES["PARAM"] = "param";
  TAG_NAMES["PLAINTEXT"] = "plaintext";
  TAG_NAMES["PRE"] = "pre";
  TAG_NAMES["RB"] = "rb";
  TAG_NAMES["RP"] = "rp";
  TAG_NAMES["RT"] = "rt";
  TAG_NAMES["RTC"] = "rtc";
  TAG_NAMES["RUBY"] = "ruby";
  TAG_NAMES["S"] = "s";
  TAG_NAMES["SCRIPT"] = "script";
  TAG_NAMES["SEARCH"] = "search";
  TAG_NAMES["SECTION"] = "section";
  TAG_NAMES["SELECT"] = "select";
  TAG_NAMES["SOURCE"] = "source";
  TAG_NAMES["SMALL"] = "small";
  TAG_NAMES["SPAN"] = "span";
  TAG_NAMES["STRIKE"] = "strike";
  TAG_NAMES["STRONG"] = "strong";
  TAG_NAMES["STYLE"] = "style";
  TAG_NAMES["SUB"] = "sub";
  TAG_NAMES["SUMMARY"] = "summary";
  TAG_NAMES["SUP"] = "sup";
  TAG_NAMES["TABLE"] = "table";
  TAG_NAMES["TBODY"] = "tbody";
  TAG_NAMES["TEMPLATE"] = "template";
  TAG_NAMES["TEXTAREA"] = "textarea";
  TAG_NAMES["TFOOT"] = "tfoot";
  TAG_NAMES["TD"] = "td";
  TAG_NAMES["TH"] = "th";
  TAG_NAMES["THEAD"] = "thead";
  TAG_NAMES["TITLE"] = "title";
  TAG_NAMES["TR"] = "tr";
  TAG_NAMES["TRACK"] = "track";
  TAG_NAMES["TT"] = "tt";
  TAG_NAMES["U"] = "u";
  TAG_NAMES["UL"] = "ul";
  TAG_NAMES["SVG"] = "svg";
  TAG_NAMES["VAR"] = "var";
  TAG_NAMES["WBR"] = "wbr";
  TAG_NAMES["XMP"] = "xmp";
})(TAG_NAMES || (exports.TAG_NAMES = TAG_NAMES = {}));
/**
 * Tag IDs are numeric IDs for known tag names.
 *
 * We use tag IDs to improve the performance of tag name comparisons.
 */
var TAG_ID;
(function (TAG_ID) {
  TAG_ID[TAG_ID["UNKNOWN"] = 0] = "UNKNOWN";
  TAG_ID[TAG_ID["A"] = 1] = "A";
  TAG_ID[TAG_ID["ADDRESS"] = 2] = "ADDRESS";
  TAG_ID[TAG_ID["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
  TAG_ID[TAG_ID["APPLET"] = 4] = "APPLET";
  TAG_ID[TAG_ID["AREA"] = 5] = "AREA";
  TAG_ID[TAG_ID["ARTICLE"] = 6] = "ARTICLE";
  TAG_ID[TAG_ID["ASIDE"] = 7] = "ASIDE";
  TAG_ID[TAG_ID["B"] = 8] = "B";
  TAG_ID[TAG_ID["BASE"] = 9] = "BASE";
  TAG_ID[TAG_ID["BASEFONT"] = 10] = "BASEFONT";
  TAG_ID[TAG_ID["BGSOUND"] = 11] = "BGSOUND";
  TAG_ID[TAG_ID["BIG"] = 12] = "BIG";
  TAG_ID[TAG_ID["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
  TAG_ID[TAG_ID["BODY"] = 14] = "BODY";
  TAG_ID[TAG_ID["BR"] = 15] = "BR";
  TAG_ID[TAG_ID["BUTTON"] = 16] = "BUTTON";
  TAG_ID[TAG_ID["CAPTION"] = 17] = "CAPTION";
  TAG_ID[TAG_ID["CENTER"] = 18] = "CENTER";
  TAG_ID[TAG_ID["CODE"] = 19] = "CODE";
  TAG_ID[TAG_ID["COL"] = 20] = "COL";
  TAG_ID[TAG_ID["COLGROUP"] = 21] = "COLGROUP";
  TAG_ID[TAG_ID["DD"] = 22] = "DD";
  TAG_ID[TAG_ID["DESC"] = 23] = "DESC";
  TAG_ID[TAG_ID["DETAILS"] = 24] = "DETAILS";
  TAG_ID[TAG_ID["DIALOG"] = 25] = "DIALOG";
  TAG_ID[TAG_ID["DIR"] = 26] = "DIR";
  TAG_ID[TAG_ID["DIV"] = 27] = "DIV";
  TAG_ID[TAG_ID["DL"] = 28] = "DL";
  TAG_ID[TAG_ID["DT"] = 29] = "DT";
  TAG_ID[TAG_ID["EM"] = 30] = "EM";
  TAG_ID[TAG_ID["EMBED"] = 31] = "EMBED";
  TAG_ID[TAG_ID["FIELDSET"] = 32] = "FIELDSET";
  TAG_ID[TAG_ID["FIGCAPTION"] = 33] = "FIGCAPTION";
  TAG_ID[TAG_ID["FIGURE"] = 34] = "FIGURE";
  TAG_ID[TAG_ID["FONT"] = 35] = "FONT";
  TAG_ID[TAG_ID["FOOTER"] = 36] = "FOOTER";
  TAG_ID[TAG_ID["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
  TAG_ID[TAG_ID["FORM"] = 38] = "FORM";
  TAG_ID[TAG_ID["FRAME"] = 39] = "FRAME";
  TAG_ID[TAG_ID["FRAMESET"] = 40] = "FRAMESET";
  TAG_ID[TAG_ID["H1"] = 41] = "H1";
  TAG_ID[TAG_ID["H2"] = 42] = "H2";
  TAG_ID[TAG_ID["H3"] = 43] = "H3";
  TAG_ID[TAG_ID["H4"] = 44] = "H4";
  TAG_ID[TAG_ID["H5"] = 45] = "H5";
  TAG_ID[TAG_ID["H6"] = 46] = "H6";
  TAG_ID[TAG_ID["HEAD"] = 47] = "HEAD";
  TAG_ID[TAG_ID["HEADER"] = 48] = "HEADER";
  TAG_ID[TAG_ID["HGROUP"] = 49] = "HGROUP";
  TAG_ID[TAG_ID["HR"] = 50] = "HR";
  TAG_ID[TAG_ID["HTML"] = 51] = "HTML";
  TAG_ID[TAG_ID["I"] = 52] = "I";
  TAG_ID[TAG_ID["IMG"] = 53] = "IMG";
  TAG_ID[TAG_ID["IMAGE"] = 54] = "IMAGE";
  TAG_ID[TAG_ID["INPUT"] = 55] = "INPUT";
  TAG_ID[TAG_ID["IFRAME"] = 56] = "IFRAME";
  TAG_ID[TAG_ID["KEYGEN"] = 57] = "KEYGEN";
  TAG_ID[TAG_ID["LABEL"] = 58] = "LABEL";
  TAG_ID[TAG_ID["LI"] = 59] = "LI";
  TAG_ID[TAG_ID["LINK"] = 60] = "LINK";
  TAG_ID[TAG_ID["LISTING"] = 61] = "LISTING";
  TAG_ID[TAG_ID["MAIN"] = 62] = "MAIN";
  TAG_ID[TAG_ID["MALIGNMARK"] = 63] = "MALIGNMARK";
  TAG_ID[TAG_ID["MARQUEE"] = 64] = "MARQUEE";
  TAG_ID[TAG_ID["MATH"] = 65] = "MATH";
  TAG_ID[TAG_ID["MENU"] = 66] = "MENU";
  TAG_ID[TAG_ID["META"] = 67] = "META";
  TAG_ID[TAG_ID["MGLYPH"] = 68] = "MGLYPH";
  TAG_ID[TAG_ID["MI"] = 69] = "MI";
  TAG_ID[TAG_ID["MO"] = 70] = "MO";
  TAG_ID[TAG_ID["MN"] = 71] = "MN";
  TAG_ID[TAG_ID["MS"] = 72] = "MS";
  TAG_ID[TAG_ID["MTEXT"] = 73] = "MTEXT";
  TAG_ID[TAG_ID["NAV"] = 74] = "NAV";
  TAG_ID[TAG_ID["NOBR"] = 75] = "NOBR";
  TAG_ID[TAG_ID["NOFRAMES"] = 76] = "NOFRAMES";
  TAG_ID[TAG_ID["NOEMBED"] = 77] = "NOEMBED";
  TAG_ID[TAG_ID["NOSCRIPT"] = 78] = "NOSCRIPT";
  TAG_ID[TAG_ID["OBJECT"] = 79] = "OBJECT";
  TAG_ID[TAG_ID["OL"] = 80] = "OL";
  TAG_ID[TAG_ID["OPTGROUP"] = 81] = "OPTGROUP";
  TAG_ID[TAG_ID["OPTION"] = 82] = "OPTION";
  TAG_ID[TAG_ID["P"] = 83] = "P";
  TAG_ID[TAG_ID["PARAM"] = 84] = "PARAM";
  TAG_ID[TAG_ID["PLAINTEXT"] = 85] = "PLAINTEXT";
  TAG_ID[TAG_ID["PRE"] = 86] = "PRE";
  TAG_ID[TAG_ID["RB"] = 87] = "RB";
  TAG_ID[TAG_ID["RP"] = 88] = "RP";
  TAG_ID[TAG_ID["RT"] = 89] = "RT";
  TAG_ID[TAG_ID["RTC"] = 90] = "RTC";
  TAG_ID[TAG_ID["RUBY"] = 91] = "RUBY";
  TAG_ID[TAG_ID["S"] = 92] = "S";
  TAG_ID[TAG_ID["SCRIPT"] = 93] = "SCRIPT";
  TAG_ID[TAG_ID["SEARCH"] = 94] = "SEARCH";
  TAG_ID[TAG_ID["SECTION"] = 95] = "SECTION";
  TAG_ID[TAG_ID["SELECT"] = 96] = "SELECT";
  TAG_ID[TAG_ID["SOURCE"] = 97] = "SOURCE";
  TAG_ID[TAG_ID["SMALL"] = 98] = "SMALL";
  TAG_ID[TAG_ID["SPAN"] = 99] = "SPAN";
  TAG_ID[TAG_ID["STRIKE"] = 100] = "STRIKE";
  TAG_ID[TAG_ID["STRONG"] = 101] = "STRONG";
  TAG_ID[TAG_ID["STYLE"] = 102] = "STYLE";
  TAG_ID[TAG_ID["SUB"] = 103] = "SUB";
  TAG_ID[TAG_ID["SUMMARY"] = 104] = "SUMMARY";
  TAG_ID[TAG_ID["SUP"] = 105] = "SUP";
  TAG_ID[TAG_ID["TABLE"] = 106] = "TABLE";
  TAG_ID[TAG_ID["TBODY"] = 107] = "TBODY";
  TAG_ID[TAG_ID["TEMPLATE"] = 108] = "TEMPLATE";
  TAG_ID[TAG_ID["TEXTAREA"] = 109] = "TEXTAREA";
  TAG_ID[TAG_ID["TFOOT"] = 110] = "TFOOT";
  TAG_ID[TAG_ID["TD"] = 111] = "TD";
  TAG_ID[TAG_ID["TH"] = 112] = "TH";
  TAG_ID[TAG_ID["THEAD"] = 113] = "THEAD";
  TAG_ID[TAG_ID["TITLE"] = 114] = "TITLE";
  TAG_ID[TAG_ID["TR"] = 115] = "TR";
  TAG_ID[TAG_ID["TRACK"] = 116] = "TRACK";
  TAG_ID[TAG_ID["TT"] = 117] = "TT";
  TAG_ID[TAG_ID["U"] = 118] = "U";
  TAG_ID[TAG_ID["UL"] = 119] = "UL";
  TAG_ID[TAG_ID["SVG"] = 120] = "SVG";
  TAG_ID[TAG_ID["VAR"] = 121] = "VAR";
  TAG_ID[TAG_ID["WBR"] = 122] = "WBR";
  TAG_ID[TAG_ID["XMP"] = 123] = "XMP";
})(TAG_ID || (exports.TAG_ID = TAG_ID = {}));
const TAG_NAME_TO_ID = new Map([[TAG_NAMES.A, TAG_ID.A], [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS], [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML], [TAG_NAMES.APPLET, TAG_ID.APPLET], [TAG_NAMES.AREA, TAG_ID.AREA], [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE], [TAG_NAMES.ASIDE, TAG_ID.ASIDE], [TAG_NAMES.B, TAG_ID.B], [TAG_NAMES.BASE, TAG_ID.BASE], [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT], [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND], [TAG_NAMES.BIG, TAG_ID.BIG], [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE], [TAG_NAMES.BODY, TAG_ID.BODY], [TAG_NAMES.BR, TAG_ID.BR], [TAG_NAMES.BUTTON, TAG_ID.BUTTON], [TAG_NAMES.CAPTION, TAG_ID.CAPTION], [TAG_NAMES.CENTER, TAG_ID.CENTER], [TAG_NAMES.CODE, TAG_ID.CODE], [TAG_NAMES.COL, TAG_ID.COL], [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP], [TAG_NAMES.DD, TAG_ID.DD], [TAG_NAMES.DESC, TAG_ID.DESC], [TAG_NAMES.DETAILS, TAG_ID.DETAILS], [TAG_NAMES.DIALOG, TAG_ID.DIALOG], [TAG_NAMES.DIR, TAG_ID.DIR], [TAG_NAMES.DIV, TAG_ID.DIV], [TAG_NAMES.DL, TAG_ID.DL], [TAG_NAMES.DT, TAG_ID.DT], [TAG_NAMES.EM, TAG_ID.EM], [TAG_NAMES.EMBED, TAG_ID.EMBED], [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET], [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION], [TAG_NAMES.FIGURE, TAG_ID.FIGURE], [TAG_NAMES.FONT, TAG_ID.FONT], [TAG_NAMES.FOOTER, TAG_ID.FOOTER], [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT], [TAG_NAMES.FORM, TAG_ID.FORM], [TAG_NAMES.FRAME, TAG_ID.FRAME], [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET], [TAG_NAMES.H1, TAG_ID.H1], [TAG_NAMES.H2, TAG_ID.H2], [TAG_NAMES.H3, TAG_ID.H3], [TAG_NAMES.H4, TAG_ID.H4], [TAG_NAMES.H5, TAG_ID.H5], [TAG_NAMES.H6, TAG_ID.H6], [TAG_NAMES.HEAD, TAG_ID.HEAD], [TAG_NAMES.HEADER, TAG_ID.HEADER], [TAG_NAMES.HGROUP, TAG_ID.HGROUP], [TAG_NAMES.HR, TAG_ID.HR], [TAG_NAMES.HTML, TAG_ID.HTML], [TAG_NAMES.I, TAG_ID.I], [TAG_NAMES.IMG, TAG_ID.IMG], [TAG_NAMES.IMAGE, TAG_ID.IMAGE], [TAG_NAMES.INPUT, TAG_ID.INPUT], [TAG_NAMES.IFRAME, TAG_ID.IFRAME], [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN], [TAG_NAMES.LABEL, TAG_ID.LABEL], [TAG_NAMES.LI, TAG_ID.LI], [TAG_NAMES.LINK, TAG_ID.LINK], [TAG_NAMES.LISTING, TAG_ID.LISTING], [TAG_NAMES.MAIN, TAG_ID.MAIN], [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK], [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE], [TAG_NAMES.MATH, TAG_ID.MATH], [TAG_NAMES.MENU, TAG_ID.MENU], [TAG_NAMES.META, TAG_ID.META], [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH], [TAG_NAMES.MI, TAG_ID.MI], [TAG_NAMES.MO, TAG_ID.MO], [TAG_NAMES.MN, TAG_ID.MN], [TAG_NAMES.MS, TAG_ID.MS], [TAG_NAMES.MTEXT, TAG_ID.MTEXT], [TAG_NAMES.NAV, TAG_ID.NAV], [TAG_NAMES.NOBR, TAG_ID.NOBR], [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES], [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED], [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT], [TAG_NAMES.OBJECT, TAG_ID.OBJECT], [TAG_NAMES.OL, TAG_ID.OL], [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP], [TAG_NAMES.OPTION, TAG_ID.OPTION], [TAG_NAMES.P, TAG_ID.P], [TAG_NAMES.PARAM, TAG_ID.PARAM], [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT], [TAG_NAMES.PRE, TAG_ID.PRE], [TAG_NAMES.RB, TAG_ID.RB], [TAG_NAMES.RP, TAG_ID.RP], [TAG_NAMES.RT, TAG_ID.RT], [TAG_NAMES.RTC, TAG_ID.RTC], [TAG_NAMES.RUBY, TAG_ID.RUBY], [TAG_NAMES.S, TAG_ID.S], [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT], [TAG_NAMES.SEARCH, TAG_ID.SEARCH], [TAG_NAMES.SECTION, TAG_ID.SECTION], [TAG_NAMES.SELECT, TAG_ID.SELECT], [TAG_NAMES.SOURCE, TAG_ID.SOURCE], [TAG_NAMES.SMALL, TAG_ID.SMALL], [TAG_NAMES.SPAN, TAG_ID.SPAN], [TAG_NAMES.STRIKE, TAG_ID.STRIKE], [TAG_NAMES.STRONG, TAG_ID.STRONG], [TAG_NAMES.STYLE, TAG_ID.STYLE], [TAG_NAMES.SUB, TAG_ID.SUB], [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY], [TAG_NAMES.SUP, TAG_ID.SUP], [TAG_NAMES.TABLE, TAG_ID.TABLE], [TAG_NAMES.TBODY, TAG_ID.TBODY], [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE], [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA], [TAG_NAMES.TFOOT, TAG_ID.TFOOT], [TAG_NAMES.TD, TAG_ID.TD], [TAG_NAMES.TH, TAG_ID.TH], [TAG_NAMES.THEAD, TAG_ID.THEAD], [TAG_NAMES.TITLE, TAG_ID.TITLE], [TAG_NAMES.TR, TAG_ID.TR], [TAG_NAMES.TRACK, TAG_ID.TRACK], [TAG_NAMES.TT, TAG_ID.TT], [TAG_NAMES.U, TAG_ID.U], [TAG_NAMES.UL, TAG_ID.UL], [TAG_NAMES.SVG, TAG_ID.SVG], [TAG_NAMES.VAR, TAG_ID.VAR], [TAG_NAMES.WBR, TAG_ID.WBR], [TAG_NAMES.XMP, TAG_ID.XMP]]);
function getTagID(tagName) {
  var _a;
  return (_a = TAG_NAME_TO_ID.get(tagName)) !== null && _a !== void 0 ? _a : TAG_ID.UNKNOWN;
}
const $ = TAG_ID;
exports.SPECIAL_ELEMENTS = {
  [NS.HTML]: new Set([$.ADDRESS, $.APPLET, $.AREA, $.ARTICLE, $.ASIDE, $.BASE, $.BASEFONT, $.BGSOUND, $.BLOCKQUOTE, $.BODY, $.BR, $.BUTTON, $.CAPTION, $.CENTER, $.COL, $.COLGROUP, $.DD, $.DETAILS, $.DIR, $.DIV, $.DL, $.DT, $.EMBED, $.FIELDSET, $.FIGCAPTION, $.FIGURE, $.FOOTER, $.FORM, $.FRAME, $.FRAMESET, $.H1, $.H2, $.H3, $.H4, $.H5, $.H6, $.HEAD, $.HEADER, $.HGROUP, $.HR, $.HTML, $.IFRAME, $.IMG, $.INPUT, $.LI, $.LINK, $.LISTING, $.MAIN, $.MARQUEE, $.MENU, $.META, $.NAV, $.NOEMBED, $.NOFRAMES, $.NOSCRIPT, $.OBJECT, $.OL, $.P, $.PARAM, $.PLAINTEXT, $.PRE, $.SCRIPT, $.SECTION, $.SELECT, $.SOURCE, $.STYLE, $.SUMMARY, $.TABLE, $.TBODY, $.TD, $.TEMPLATE, $.TEXTAREA, $.TFOOT, $.TH, $.THEAD, $.TITLE, $.TR, $.TRACK, $.UL, $.WBR, $.XMP]),
  [NS.MATHML]: new Set([$.MI, $.MO, $.MN, $.MS, $.MTEXT, $.ANNOTATION_XML]),
  [NS.SVG]: new Set([$.TITLE, $.FOREIGN_OBJECT, $.DESC]),
  [NS.XLINK]: new Set(),
  [NS.XML]: new Set(),
  [NS.XMLNS]: new Set()
};
exports.NUMBERED_HEADERS = new Set([$.H1, $.H2, $.H3, $.H4, $.H5, $.H6]);
const UNESCAPED_TEXT = new Set([TAG_NAMES.STYLE, TAG_NAMES.SCRIPT, TAG_NAMES.XMP, TAG_NAMES.IFRAME, TAG_NAMES.NOEMBED, TAG_NAMES.NOFRAMES, TAG_NAMES.PLAINTEXT]);
function hasUnescapedText(tn, scriptingEnabled) {
  return UNESCAPED_TEXT.has(tn) || scriptingEnabled && tn === TAG_NAMES.NOSCRIPT;
}

/***/ }),

/***/ "./node_modules/parse5/dist/cjs/common/token.js":
/*!******************************************************!*\
  !*** ./node_modules/parse5/dist/cjs/common/token.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TokenType = void 0;
exports.getTokenAttr = getTokenAttr;
var TokenType;
(function (TokenType) {
  TokenType[TokenType["CHARACTER"] = 0] = "CHARACTER";
  TokenType[TokenType["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
  TokenType[TokenType["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
  TokenType[TokenType["START_TAG"] = 3] = "START_TAG";
  TokenType[TokenType["END_TAG"] = 4] = "END_TAG";
  TokenType[TokenType["COMMENT"] = 5] = "COMMENT";
  TokenType[TokenType["DOCTYPE"] = 6] = "DOCTYPE";
  TokenType[TokenType["EOF"] = 7] = "EOF";
  TokenType[TokenType["HIBERNATION"] = 8] = "HIBERNATION";
})(TokenType || (exports.TokenType = TokenType = {}));
function getTokenAttr(token, attrName) {
  for (let i = token.attrs.length - 1; i >= 0; i--) {
    if (token.attrs[i].name === attrName) {
      return token.attrs[i].value;
    }
  }
  return null;
}

/***/ }),

/***/ "./node_modules/parse5/dist/cjs/common/unicode.js":
/*!********************************************************!*\
  !*** ./node_modules/parse5/dist/cjs/common/unicode.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SEQUENCES = exports.CODE_POINTS = exports.REPLACEMENT_CHARACTER = void 0;
exports.isSurrogate = isSurrogate;
exports.isSurrogatePair = isSurrogatePair;
exports.getSurrogatePairCodePoint = getSurrogatePairCodePoint;
exports.isControlCodePoint = isControlCodePoint;
exports.isUndefinedCodePoint = isUndefinedCodePoint;
const UNDEFINED_CODE_POINTS = new Set([65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111]);
exports.REPLACEMENT_CHARACTER = '\uFFFD';
var CODE_POINTS;
(function (CODE_POINTS) {
  CODE_POINTS[CODE_POINTS["EOF"] = -1] = "EOF";
  CODE_POINTS[CODE_POINTS["NULL"] = 0] = "NULL";
  CODE_POINTS[CODE_POINTS["TABULATION"] = 9] = "TABULATION";
  CODE_POINTS[CODE_POINTS["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
  CODE_POINTS[CODE_POINTS["LINE_FEED"] = 10] = "LINE_FEED";
  CODE_POINTS[CODE_POINTS["FORM_FEED"] = 12] = "FORM_FEED";
  CODE_POINTS[CODE_POINTS["SPACE"] = 32] = "SPACE";
  CODE_POINTS[CODE_POINTS["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
  CODE_POINTS[CODE_POINTS["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
  CODE_POINTS[CODE_POINTS["AMPERSAND"] = 38] = "AMPERSAND";
  CODE_POINTS[CODE_POINTS["APOSTROPHE"] = 39] = "APOSTROPHE";
  CODE_POINTS[CODE_POINTS["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
  CODE_POINTS[CODE_POINTS["SOLIDUS"] = 47] = "SOLIDUS";
  CODE_POINTS[CODE_POINTS["DIGIT_0"] = 48] = "DIGIT_0";
  CODE_POINTS[CODE_POINTS["DIGIT_9"] = 57] = "DIGIT_9";
  CODE_POINTS[CODE_POINTS["SEMICOLON"] = 59] = "SEMICOLON";
  CODE_POINTS[CODE_POINTS["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
  CODE_POINTS[CODE_POINTS["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
  CODE_POINTS[CODE_POINTS["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
  CODE_POINTS[CODE_POINTS["QUESTION_MARK"] = 63] = "QUESTION_MARK";
  CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
  CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
  CODE_POINTS[CODE_POINTS["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
  CODE_POINTS[CODE_POINTS["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
  CODE_POINTS[CODE_POINTS["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
  CODE_POINTS[CODE_POINTS["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
})(CODE_POINTS || (exports.CODE_POINTS = CODE_POINTS = {}));
exports.SEQUENCES = {
  DASH_DASH: '--',
  CDATA_START: '[CDATA[',
  DOCTYPE: 'doctype',
  SCRIPT: 'script',
  PUBLIC: 'public',
  SYSTEM: 'system'
};
//Surrogates
function isSurrogate(cp) {
  return cp >= 55296 && cp <= 57343;
}
function isSurrogatePair(cp) {
  return cp >= 56320 && cp <= 57343;
}
function getSurrogatePairCodePoint(cp1, cp2) {
  return (cp1 - 55296) * 1024 + 9216 + cp2;
}
//NOTE: excluding NULL and ASCII whitespace
function isControlCodePoint(cp) {
  return cp !== 0x20 && cp !== 0x0a && cp !== 0x0d && cp !== 0x09 && cp !== 0x0c && cp >= 0x01 && cp <= 0x1f || cp >= 0x7f && cp <= 0x9f;
}
function isUndefinedCodePoint(cp) {
  return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.has(cp);
}

/***/ }),

/***/ "./node_modules/parse5/dist/cjs/index.js":
/*!***********************************************!*\
  !*** ./node_modules/parse5/dist/cjs/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TokenizerMode = exports.Tokenizer = exports.Token = exports.html = exports.foreignContent = exports.ErrorCodes = exports.serializeOuter = exports.serialize = exports.Parser = exports.defaultTreeAdapter = void 0;
exports.parse = parse;
exports.parseFragment = parseFragment;
const index_js_1 = __webpack_require__(/*! ./parser/index.js */ "./node_modules/parse5/dist/cjs/parser/index.js");
var default_js_1 = __webpack_require__(/*! ./tree-adapters/default.js */ "./node_modules/parse5/dist/cjs/tree-adapters/default.js");
Object.defineProperty(exports, "defaultTreeAdapter", ({
  enumerable: true,
  get: function () {
    return default_js_1.defaultTreeAdapter;
  }
}));
var index_js_2 = __webpack_require__(/*! ./parser/index.js */ "./node_modules/parse5/dist/cjs/parser/index.js");
Object.defineProperty(exports, "Parser", ({
  enumerable: true,
  get: function () {
    return index_js_2.Parser;
  }
}));
var index_js_3 = __webpack_require__(/*! ./serializer/index.js */ "./node_modules/parse5/dist/cjs/serializer/index.js");
Object.defineProperty(exports, "serialize", ({
  enumerable: true,
  get: function () {
    return index_js_3.serialize;
  }
}));
Object.defineProperty(exports, "serializeOuter", ({
  enumerable: true,
  get: function () {
    return index_js_3.serializeOuter;
  }
}));
var error_codes_js_1 = __webpack_require__(/*! ./common/error-codes.js */ "./node_modules/parse5/dist/cjs/common/error-codes.js");
Object.defineProperty(exports, "ErrorCodes", ({
  enumerable: true,
  get: function () {
    return error_codes_js_1.ERR;
  }
}));
/** @internal */
exports.foreignContent = __webpack_require__(/*! ./common/foreign-content.js */ "./node_modules/parse5/dist/cjs/common/foreign-content.js");
exports.html = __webpack_require__(/*! ./common/html.js */ "./node_modules/parse5/dist/cjs/common/html.js");
exports.Token = __webpack_require__(/*! ./common/token.js */ "./node_modules/parse5/dist/cjs/common/token.js");
/** @internal */
var index_js_4 = __webpack_require__(/*! ./tokenizer/index.js */ "./node_modules/parse5/dist/cjs/tokenizer/index.js");
Object.defineProperty(exports, "Tokenizer", ({
  enumerable: true,
  get: function () {
    return index_js_4.Tokenizer;
  }
}));
Object.defineProperty(exports, "TokenizerMode", ({
  enumerable: true,
  get: function () {
    return index_js_4.TokenizerMode;
  }
}));
// Shorthands
/**
 * Parses an HTML string.
 *
 * @param html Input HTML string.
 * @param options Parsing options.
 * @returns Document
 *
 * @example
 *
 * ```js
 * const parse5 = require('parse5');
 *
 * const document = parse5.parse('<!DOCTYPE html><html><head></head><body>Hi there!</body></html>');
 *
 * console.log(document.childNodes[1].tagName); //> 'html'
 *```
 */
function parse(html, options) {
  return index_js_1.Parser.parse(html, options);
}
function parseFragment(fragmentContext, html, options) {
  if (typeof fragmentContext === 'string') {
    options = html;
    html = fragmentContext;
    fragmentContext = null;
  }
  const parser = index_js_1.Parser.getFragmentParser(fragmentContext, options);
  parser.tokenizer.write(html, true);
  return parser.getFragment();
}

/***/ }),

/***/ "./node_modules/parse5/dist/cjs/parser/formatting-element-list.js":
/*!************************************************************************!*\
  !*** ./node_modules/parse5/dist/cjs/parser/formatting-element-list.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FormattingElementList = exports.EntryType = void 0;
//Const
const NOAH_ARK_CAPACITY = 3;
var EntryType;
(function (EntryType) {
  EntryType[EntryType["Marker"] = 0] = "Marker";
  EntryType[EntryType["Element"] = 1] = "Element";
})(EntryType || (exports.EntryType = EntryType = {}));
const MARKER = {
  type: EntryType.Marker
};
//List of formatting elements
class FormattingElementList {
  constructor(treeAdapter) {
    this.treeAdapter = treeAdapter;
    this.entries = [];
    this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(newElement, neAttrs) {
    const candidates = [];
    const neAttrsLength = neAttrs.length;
    const neTagName = this.treeAdapter.getTagName(newElement);
    const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
    for (let i = 0; i < this.entries.length; i++) {
      const entry = this.entries[i];
      if (entry.type === EntryType.Marker) {
        break;
      }
      const {
        element
      } = entry;
      if (this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {
        const elementAttrs = this.treeAdapter.getAttrList(element);
        if (elementAttrs.length === neAttrsLength) {
          candidates.push({
            idx: i,
            attrs: elementAttrs
          });
        }
      }
    }
    return candidates;
  }
  _ensureNoahArkCondition(newElement) {
    if (this.entries.length < NOAH_ARK_CAPACITY) return;
    const neAttrs = this.treeAdapter.getAttrList(newElement);
    const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
    if (candidates.length < NOAH_ARK_CAPACITY) return;
    //NOTE: build attrs map for the new element, so we can perform fast lookups
    const neAttrsMap = new Map(neAttrs.map(neAttr => [neAttr.name, neAttr.value]));
    let validCandidates = 0;
    //NOTE: remove bottommost candidates, until Noah's Ark condition will not be met
    for (let i = 0; i < candidates.length; i++) {
      const candidate = candidates[i];
      // We know that `candidate.attrs.length === neAttrs.length`
      if (candidate.attrs.every(cAttr => neAttrsMap.get(cAttr.name) === cAttr.value)) {
        validCandidates += 1;
        if (validCandidates >= NOAH_ARK_CAPACITY) {
          this.entries.splice(candidate.idx, 1);
        }
      }
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(MARKER);
  }
  pushElement(element, token) {
    this._ensureNoahArkCondition(element);
    this.entries.unshift({
      type: EntryType.Element,
      element,
      token
    });
  }
  insertElementAfterBookmark(element, token) {
    const bookmarkIdx = this.entries.indexOf(this.bookmark);
    this.entries.splice(bookmarkIdx, 0, {
      type: EntryType.Element,
      element,
      token
    });
  }
  removeEntry(entry) {
    const entryIndex = this.entries.indexOf(entry);
    if (entryIndex >= 0) {
      this.entries.splice(entryIndex, 1);
    }
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const markerIdx = this.entries.indexOf(MARKER);
    if (markerIdx >= 0) {
      this.entries.splice(0, markerIdx + 1);
    } else {
      this.entries.length = 0;
    }
  }
  //Search
  getElementEntryInScopeWithTagName(tagName) {
    const entry = this.entries.find(entry => entry.type === EntryType.Marker || this.treeAdapter.getTagName(entry.element) === tagName);
    return entry && entry.type === EntryType.Element ? entry : null;
  }
  getElementEntry(element) {
    return this.entries.find(entry => entry.type === EntryType.Element && entry.element === element);
  }
}
exports.FormattingElementList = FormattingElementList;

/***/ }),

/***/ "./node_modules/parse5/dist/cjs/parser/index.js":
/*!******************************************************!*\
  !*** ./node_modules/parse5/dist/cjs/parser/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Parser = void 0;
const index_js_1 = __webpack_require__(/*! ../tokenizer/index.js */ "./node_modules/parse5/dist/cjs/tokenizer/index.js");
const open_element_stack_js_1 = __webpack_require__(/*! ./open-element-stack.js */ "./node_modules/parse5/dist/cjs/parser/open-element-stack.js");
const formatting_element_list_js_1 = __webpack_require__(/*! ./formatting-element-list.js */ "./node_modules/parse5/dist/cjs/parser/formatting-element-list.js");
const default_js_1 = __webpack_require__(/*! ../tree-adapters/default.js */ "./node_modules/parse5/dist/cjs/tree-adapters/default.js");
const doctype = __webpack_require__(/*! ../common/doctype.js */ "./node_modules/parse5/dist/cjs/common/doctype.js");
const foreignContent = __webpack_require__(/*! ../common/foreign-content.js */ "./node_modules/parse5/dist/cjs/common/foreign-content.js");
const error_codes_js_1 = __webpack_require__(/*! ../common/error-codes.js */ "./node_modules/parse5/dist/cjs/common/error-codes.js");
const unicode = __webpack_require__(/*! ../common/unicode.js */ "./node_modules/parse5/dist/cjs/common/unicode.js");
const html_js_1 = __webpack_require__(/*! ../common/html.js */ "./node_modules/parse5/dist/cjs/common/html.js");
const token_js_1 = __webpack_require__(/*! ../common/token.js */ "./node_modules/parse5/dist/cjs/common/token.js");
//Misc constants
const HIDDEN_INPUT_TYPE = 'hidden';
//Adoption agency loops iteration count
const AA_OUTER_LOOP_ITER = 8;
const AA_INNER_LOOP_ITER = 3;
//Insertion modes
var InsertionMode;
(function (InsertionMode) {
  InsertionMode[InsertionMode["INITIAL"] = 0] = "INITIAL";
  InsertionMode[InsertionMode["BEFORE_HTML"] = 1] = "BEFORE_HTML";
  InsertionMode[InsertionMode["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
  InsertionMode[InsertionMode["IN_HEAD"] = 3] = "IN_HEAD";
  InsertionMode[InsertionMode["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
  InsertionMode[InsertionMode["AFTER_HEAD"] = 5] = "AFTER_HEAD";
  InsertionMode[InsertionMode["IN_BODY"] = 6] = "IN_BODY";
  InsertionMode[InsertionMode["TEXT"] = 7] = "TEXT";
  InsertionMode[InsertionMode["IN_TABLE"] = 8] = "IN_TABLE";
  InsertionMode[InsertionMode["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
  InsertionMode[InsertionMode["IN_CAPTION"] = 10] = "IN_CAPTION";
  InsertionMode[InsertionMode["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
  InsertionMode[InsertionMode["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
  InsertionMode[InsertionMode["IN_ROW"] = 13] = "IN_ROW";
  InsertionMode[InsertionMode["IN_CELL"] = 14] = "IN_CELL";
  InsertionMode[InsertionMode["IN_SELECT"] = 15] = "IN_SELECT";
  InsertionMode[InsertionMode["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
  InsertionMode[InsertionMode["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
  InsertionMode[InsertionMode["AFTER_BODY"] = 18] = "AFTER_BODY";
  InsertionMode[InsertionMode["IN_FRAMESET"] = 19] = "IN_FRAMESET";
  InsertionMode[InsertionMode["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
  InsertionMode[InsertionMode["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
  InsertionMode[InsertionMode["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
})(InsertionMode || (InsertionMode = {}));
const BASE_LOC = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
};
const TABLE_STRUCTURE_TAGS = new Set([html_js_1.TAG_ID.TABLE, html_js_1.TAG_ID.TBODY, html_js_1.TAG_ID.TFOOT, html_js_1.TAG_ID.THEAD, html_js_1.TAG_ID.TR]);
const defaultParserOptions = {
  scriptingEnabled: true,
  sourceCodeLocationInfo: false,
  treeAdapter: default_js_1.defaultTreeAdapter,
  onParseError: null
};
//Parser
class Parser {
  constructor(options, document, /** @internal */
  fragmentContext = null, /** @internal */
  scriptHandler = null) {
    this.fragmentContext = fragmentContext;
    this.scriptHandler = scriptHandler;
    this.currentToken = null;
    this.stopped = false;
    /** @internal */
    this.insertionMode = InsertionMode.INITIAL;
    /** @internal */
    this.originalInsertionMode = InsertionMode.INITIAL;
    /** @internal */
    this.headElement = null;
    /** @internal */
    this.formElement = null;
    /** Indicates that the current node is not an element in the HTML namespace */
    this.currentNotInHTML = false;
    /**
     * The template insertion mode stack is maintained from the left.
     * Ie. the topmost element will always have index 0.
     *
     * @internal
     */
    this.tmplInsertionModeStack = [];
    /** @internal */
    this.pendingCharacterTokens = [];
    /** @internal */
    this.hasNonWhitespacePendingCharacterToken = false;
    /** @internal */
    this.framesetOk = true;
    /** @internal */
    this.skipNextNewLine = false;
    /** @internal */
    this.fosterParentingEnabled = false;
    this.options = Object.assign(Object.assign({}, defaultParserOptions), options);
    this.treeAdapter = this.options.treeAdapter;
    this.onParseError = this.options.onParseError;
    // Always enable location info if we report parse errors.
    if (this.onParseError) {
      this.options.sourceCodeLocationInfo = true;
    }
    this.document = document !== null && document !== void 0 ? document : this.treeAdapter.createDocument();
    this.tokenizer = new index_js_1.Tokenizer(this.options, this);
    this.activeFormattingElements = new formatting_element_list_js_1.FormattingElementList(this.treeAdapter);
    this.fragmentContextID = fragmentContext ? (0, html_js_1.getTagID)(this.treeAdapter.getTagName(fragmentContext)) : html_js_1.TAG_ID.UNKNOWN;
    this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
    this.openElements = new open_element_stack_js_1.OpenElementStack(this.document, this.treeAdapter, this);
  }
  // API
  static parse(html, options) {
    const parser = new this(options);
    parser.tokenizer.write(html, true);
    return parser.document;
  }
  static getFragmentParser(fragmentContext, options) {
    const opts = Object.assign(Object.assign({}, defaultParserOptions), options);
    //NOTE: use a <template> element as the fragment context if no context element was provided,
    //so we will parse in a "forgiving" manner
    fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : fragmentContext = opts.treeAdapter.createElement(html_js_1.TAG_NAMES.TEMPLATE, html_js_1.NS.HTML, []);
    //NOTE: create a fake element which will be used as the `document` for fragment parsing.
    //This is important for jsdom, where a new `document` cannot be created. This led to
    //fragment parsing messing with the main `document`.
    const documentMock = opts.treeAdapter.createElement('documentmock', html_js_1.NS.HTML, []);
    const parser = new this(opts, documentMock, fragmentContext);
    if (parser.fragmentContextID === html_js_1.TAG_ID.TEMPLATE) {
      parser.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
    }
    parser._initTokenizerForFragmentParsing();
    parser._insertFakeRootElement();
    parser._resetInsertionMode();
    parser._findFormInFragmentContext();
    return parser;
  }
  getFragment() {
    const rootElement = this.treeAdapter.getFirstChild(this.document);
    const fragment = this.treeAdapter.createDocumentFragment();
    this._adoptNodes(rootElement, fragment);
    return fragment;
  }
  //Errors
  /** @internal */
  _err(token, code, beforeToken) {
    var _a;
    if (!this.onParseError) return;
    const loc = (_a = token.location) !== null && _a !== void 0 ? _a : BASE_LOC;
    const err = {
      code,
      startLine: loc.startLine,
      startCol: loc.startCol,
      startOffset: loc.startOffset,
      endLine: beforeToken ? loc.startLine : loc.endLine,
      endCol: beforeToken ? loc.startCol : loc.endCol,
      endOffset: beforeToken ? loc.startOffset : loc.endOffset
    };
    this.onParseError(err);
  }
  //Stack events
  /** @internal */
  onItemPush(node, tid, isTop) {
    var _a, _b;
    (_b = (_a = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a, node);
    if (isTop && this.openElements.stackTop > 0) this._setContextModes(node, tid);
  }
  /** @internal */
  onItemPop(node, isTop) {
    var _a, _b;
    if (this.options.sourceCodeLocationInfo) {
      this._setEndLocation(node, this.currentToken);
    }
    (_b = (_a = this.treeAdapter).onItemPop) === null || _b === void 0 ? void 0 : _b.call(_a, node, this.openElements.current);
    if (isTop) {
      let current;
      let currentTagId;
      if (this.openElements.stackTop === 0 && this.fragmentContext) {
        current = this.fragmentContext;
        currentTagId = this.fragmentContextID;
      } else {
        ({
          current,
          currentTagId
        } = this.openElements);
      }
      this._setContextModes(current, currentTagId);
    }
  }
  _setContextModes(current, tid) {
    const isHTML = current === this.document || this.treeAdapter.getNamespaceURI(current) === html_js_1.NS.HTML;
    this.currentNotInHTML = !isHTML;
    this.tokenizer.inForeignNode = !isHTML && !this._isIntegrationPoint(tid, current);
  }
  /** @protected */
  _switchToTextParsing(currentToken, nextTokenizerState) {
    this._insertElement(currentToken, html_js_1.NS.HTML);
    this.tokenizer.state = nextTokenizerState;
    this.originalInsertionMode = this.insertionMode;
    this.insertionMode = InsertionMode.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = InsertionMode.TEXT;
    this.originalInsertionMode = InsertionMode.IN_BODY;
    this.tokenizer.state = index_js_1.TokenizerMode.PLAINTEXT;
  }
  //Fragment parsing
  /** @protected */
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  /** @protected */
  _findFormInFragmentContext() {
    let node = this.fragmentContext;
    while (node) {
      if (this.treeAdapter.getTagName(node) === html_js_1.TAG_NAMES.FORM) {
        this.formElement = node;
        break;
      }
      node = this.treeAdapter.getParentNode(node);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== html_js_1.NS.HTML) {
      return;
    }
    switch (this.fragmentContextID) {
      case html_js_1.TAG_ID.TITLE:
      case html_js_1.TAG_ID.TEXTAREA:
        {
          this.tokenizer.state = index_js_1.TokenizerMode.RCDATA;
          break;
        }
      case html_js_1.TAG_ID.STYLE:
      case html_js_1.TAG_ID.XMP:
      case html_js_1.TAG_ID.IFRAME:
      case html_js_1.TAG_ID.NOEMBED:
      case html_js_1.TAG_ID.NOFRAMES:
      case html_js_1.TAG_ID.NOSCRIPT:
        {
          this.tokenizer.state = index_js_1.TokenizerMode.RAWTEXT;
          break;
        }
      case html_js_1.TAG_ID.SCRIPT:
        {
          this.tokenizer.state = index_js_1.TokenizerMode.SCRIPT_DATA;
          break;
        }
      case html_js_1.TAG_ID.PLAINTEXT:
        {
          this.tokenizer.state = index_js_1.TokenizerMode.PLAINTEXT;
          break;
        }
      default:
      // Do nothing
    }
  }
  //Tree mutation
  /** @protected */
  _setDocumentType(token) {
    const name = token.name || '';
    const publicId = token.publicId || '';
    const systemId = token.systemId || '';
    this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
    if (token.location) {
      const documentChildren = this.treeAdapter.getChildNodes(this.document);
      const docTypeNode = documentChildren.find(node => this.treeAdapter.isDocumentTypeNode(node));
      if (docTypeNode) {
        this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
      }
    }
  }
  /** @protected */
  _attachElementToTree(element, location) {
    if (this.options.sourceCodeLocationInfo) {
      const loc = location && Object.assign(Object.assign({}, location), {
        startTag: location
      });
      this.treeAdapter.setNodeSourceCodeLocation(element, loc);
    }
    if (this._shouldFosterParentOnInsertion()) {
      this._fosterParentElement(element);
    } else {
      const parent = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(parent, element);
    }
  }
  /**
   * For self-closing tags. Add an element to the tree, but skip adding it
   * to the stack.
   */
  /** @protected */
  _appendElement(token, namespaceURI) {
    const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element, token.location);
  }
  /** @protected */
  _insertElement(token, namespaceURI) {
    const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element, token.location);
    this.openElements.push(element, token.tagID);
  }
  /** @protected */
  _insertFakeElement(tagName, tagID) {
    const element = this.treeAdapter.createElement(tagName, html_js_1.NS.HTML, []);
    this._attachElementToTree(element, null);
    this.openElements.push(element, tagID);
  }
  /** @protected */
  _insertTemplate(token) {
    const tmpl = this.treeAdapter.createElement(token.tagName, html_js_1.NS.HTML, token.attrs);
    const content = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(tmpl, content);
    this._attachElementToTree(tmpl, token.location);
    this.openElements.push(tmpl, token.tagID);
    if (this.options.sourceCodeLocationInfo) this.treeAdapter.setNodeSourceCodeLocation(content, null);
  }
  /** @protected */
  _insertFakeRootElement() {
    const element = this.treeAdapter.createElement(html_js_1.TAG_NAMES.HTML, html_js_1.NS.HTML, []);
    if (this.options.sourceCodeLocationInfo) this.treeAdapter.setNodeSourceCodeLocation(element, null);
    this.treeAdapter.appendChild(this.openElements.current, element);
    this.openElements.push(element, html_js_1.TAG_ID.HTML);
  }
  /** @protected */
  _appendCommentNode(token, parent) {
    const commentNode = this.treeAdapter.createCommentNode(token.data);
    this.treeAdapter.appendChild(parent, commentNode);
    if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
    }
  }
  /** @protected */
  _insertCharacters(token) {
    let parent;
    let beforeElement;
    if (this._shouldFosterParentOnInsertion()) {
      ({
        parent,
        beforeElement
      } = this._findFosterParentingLocation());
      if (beforeElement) {
        this.treeAdapter.insertTextBefore(parent, token.chars, beforeElement);
      } else {
        this.treeAdapter.insertText(parent, token.chars);
      }
    } else {
      parent = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.insertText(parent, token.chars);
    }
    if (!token.location) return;
    const siblings = this.treeAdapter.getChildNodes(parent);
    const textNodeIdx = beforeElement ? siblings.lastIndexOf(beforeElement) : siblings.length;
    const textNode = siblings[textNodeIdx - 1];
    //NOTE: if we have a location assigned by another token, then just update the end position
    const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
    if (tnLoc) {
      const {
        endLine,
        endCol,
        endOffset
      } = token.location;
      this.treeAdapter.updateNodeSourceCodeLocation(textNode, {
        endLine,
        endCol,
        endOffset
      });
    } else if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
    }
  }
  /** @protected */
  _adoptNodes(donor, recipient) {
    for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
      this.treeAdapter.detachNode(child);
      this.treeAdapter.appendChild(recipient, child);
    }
  }
  /** @protected */
  _setEndLocation(element, closingToken) {
    if (this.treeAdapter.getNodeSourceCodeLocation(element) && closingToken.location) {
      const ctLoc = closingToken.location;
      const tn = this.treeAdapter.getTagName(element);
      const endLoc =
      // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
      // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
      closingToken.type === token_js_1.TokenType.END_TAG && tn === closingToken.tagName ? {
        endTag: Object.assign({}, ctLoc),
        endLine: ctLoc.endLine,
        endCol: ctLoc.endCol,
        endOffset: ctLoc.endOffset
      } : {
        endLine: ctLoc.startLine,
        endCol: ctLoc.startCol,
        endOffset: ctLoc.startOffset
      };
      this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(token) {
    // Check that neither current === document, or ns === NS.HTML
    if (!this.currentNotInHTML) return false;
    let current;
    let currentTagId;
    if (this.openElements.stackTop === 0 && this.fragmentContext) {
      current = this.fragmentContext;
      currentTagId = this.fragmentContextID;
    } else {
      ({
        current,
        currentTagId
      } = this.openElements);
    }
    if (token.tagID === html_js_1.TAG_ID.SVG && this.treeAdapter.getTagName(current) === html_js_1.TAG_NAMES.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(current) === html_js_1.NS.MATHML) {
      return false;
    }
    return (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode ||
      // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (token.tagID === html_js_1.TAG_ID.MGLYPH || token.tagID === html_js_1.TAG_ID.MALIGNMARK) && !this._isIntegrationPoint(currentTagId, current, html_js_1.NS.HTML)
    );
  }
  /** @protected */
  _processToken(token) {
    switch (token.type) {
      case token_js_1.TokenType.CHARACTER:
        {
          this.onCharacter(token);
          break;
        }
      case token_js_1.TokenType.NULL_CHARACTER:
        {
          this.onNullCharacter(token);
          break;
        }
      case token_js_1.TokenType.COMMENT:
        {
          this.onComment(token);
          break;
        }
      case token_js_1.TokenType.DOCTYPE:
        {
          this.onDoctype(token);
          break;
        }
      case token_js_1.TokenType.START_TAG:
        {
          this._processStartTag(token);
          break;
        }
      case token_js_1.TokenType.END_TAG:
        {
          this.onEndTag(token);
          break;
        }
      case token_js_1.TokenType.EOF:
        {
          this.onEof(token);
          break;
        }
      case token_js_1.TokenType.WHITESPACE_CHARACTER:
        {
          this.onWhitespaceCharacter(token);
          break;
        }
    }
  }
  //Integration points
  /** @protected */
  _isIntegrationPoint(tid, element, foreignNS) {
    const ns = this.treeAdapter.getNamespaceURI(element);
    const attrs = this.treeAdapter.getAttrList(element);
    return foreignContent.isIntegrationPoint(tid, ns, attrs, foreignNS);
  }
  //Active formatting elements reconstruction
  /** @protected */
  _reconstructActiveFormattingElements() {
    const listLength = this.activeFormattingElements.entries.length;
    if (listLength) {
      const endIndex = this.activeFormattingElements.entries.findIndex(entry => entry.type === formatting_element_list_js_1.EntryType.Marker || this.openElements.contains(entry.element));
      const unopenIdx = endIndex < 0 ? listLength - 1 : endIndex - 1;
      for (let i = unopenIdx; i >= 0; i--) {
        const entry = this.activeFormattingElements.entries[i];
        this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
        entry.element = this.openElements.current;
      }
    }
  }
  //Close elements
  /** @protected */
  _closeTableCell() {
    this.openElements.generateImpliedEndTags();
    this.openElements.popUntilTableCellPopped();
    this.activeFormattingElements.clearToLastMarker();
    this.insertionMode = InsertionMode.IN_ROW;
  }
  /** @protected */
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(html_js_1.TAG_ID.P);
    this.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.P);
  }
  //Insertion modes
  /** @protected */
  _resetInsertionMode() {
    for (let i = this.openElements.stackTop; i >= 0; i--) {
      //Insertion mode reset map
      switch (i === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i]) {
        case html_js_1.TAG_ID.TR:
          {
            this.insertionMode = InsertionMode.IN_ROW;
            return;
          }
        case html_js_1.TAG_ID.TBODY:
        case html_js_1.TAG_ID.THEAD:
        case html_js_1.TAG_ID.TFOOT:
          {
            this.insertionMode = InsertionMode.IN_TABLE_BODY;
            return;
          }
        case html_js_1.TAG_ID.CAPTION:
          {
            this.insertionMode = InsertionMode.IN_CAPTION;
            return;
          }
        case html_js_1.TAG_ID.COLGROUP:
          {
            this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
            return;
          }
        case html_js_1.TAG_ID.TABLE:
          {
            this.insertionMode = InsertionMode.IN_TABLE;
            return;
          }
        case html_js_1.TAG_ID.BODY:
          {
            this.insertionMode = InsertionMode.IN_BODY;
            return;
          }
        case html_js_1.TAG_ID.FRAMESET:
          {
            this.insertionMode = InsertionMode.IN_FRAMESET;
            return;
          }
        case html_js_1.TAG_ID.SELECT:
          {
            this._resetInsertionModeForSelect(i);
            return;
          }
        case html_js_1.TAG_ID.TEMPLATE:
          {
            this.insertionMode = this.tmplInsertionModeStack[0];
            return;
          }
        case html_js_1.TAG_ID.HTML:
          {
            this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
            return;
          }
        case html_js_1.TAG_ID.TD:
        case html_js_1.TAG_ID.TH:
          {
            if (i > 0) {
              this.insertionMode = InsertionMode.IN_CELL;
              return;
            }
            break;
          }
        case html_js_1.TAG_ID.HEAD:
          {
            if (i > 0) {
              this.insertionMode = InsertionMode.IN_HEAD;
              return;
            }
            break;
          }
      }
    }
    this.insertionMode = InsertionMode.IN_BODY;
  }
  /** @protected */
  _resetInsertionModeForSelect(selectIdx) {
    if (selectIdx > 0) {
      for (let i = selectIdx - 1; i > 0; i--) {
        const tn = this.openElements.tagIDs[i];
        if (tn === html_js_1.TAG_ID.TEMPLATE) {
          break;
        } else if (tn === html_js_1.TAG_ID.TABLE) {
          this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
          return;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_SELECT;
  }
  //Foster parenting
  /** @protected */
  _isElementCausesFosterParenting(tn) {
    return TABLE_STRUCTURE_TAGS.has(tn);
  }
  /** @protected */
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  /** @protected */
  _findFosterParentingLocation() {
    for (let i = this.openElements.stackTop; i >= 0; i--) {
      const openElement = this.openElements.items[i];
      switch (this.openElements.tagIDs[i]) {
        case html_js_1.TAG_ID.TEMPLATE:
          {
            if (this.treeAdapter.getNamespaceURI(openElement) === html_js_1.NS.HTML) {
              return {
                parent: this.treeAdapter.getTemplateContent(openElement),
                beforeElement: null
              };
            }
            break;
          }
        case html_js_1.TAG_ID.TABLE:
          {
            const parent = this.treeAdapter.getParentNode(openElement);
            if (parent) {
              return {
                parent,
                beforeElement: openElement
              };
            }
            return {
              parent: this.openElements.items[i - 1],
              beforeElement: null
            };
          }
        default:
        // Do nothing
      }
    }
    return {
      parent: this.openElements.items[0],
      beforeElement: null
    };
  }
  /** @protected */
  _fosterParentElement(element) {
    const location = this._findFosterParentingLocation();
    if (location.beforeElement) {
      this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);
    } else {
      this.treeAdapter.appendChild(location.parent, element);
    }
  }
  //Special elements
  /** @protected */
  _isSpecialElement(element, id) {
    const ns = this.treeAdapter.getNamespaceURI(element);
    return html_js_1.SPECIAL_ELEMENTS[ns].has(id);
  }
  /** @internal */
  onCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      characterInForeignContent(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
        {
          tokenInInitialMode(this, token);
          break;
        }
      case InsertionMode.BEFORE_HTML:
        {
          tokenBeforeHtml(this, token);
          break;
        }
      case InsertionMode.BEFORE_HEAD:
        {
          tokenBeforeHead(this, token);
          break;
        }
      case InsertionMode.IN_HEAD:
        {
          tokenInHead(this, token);
          break;
        }
      case InsertionMode.IN_HEAD_NO_SCRIPT:
        {
          tokenInHeadNoScript(this, token);
          break;
        }
      case InsertionMode.AFTER_HEAD:
        {
          tokenAfterHead(this, token);
          break;
        }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE:
        {
          characterInBody(this, token);
          break;
        }
      case InsertionMode.TEXT:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
        {
          this._insertCharacters(token);
          break;
        }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
        {
          characterInTable(this, token);
          break;
        }
      case InsertionMode.IN_TABLE_TEXT:
        {
          characterInTableText(this, token);
          break;
        }
      case InsertionMode.IN_COLUMN_GROUP:
        {
          tokenInColumnGroup(this, token);
          break;
        }
      case InsertionMode.AFTER_BODY:
        {
          tokenAfterBody(this, token);
          break;
        }
      case InsertionMode.AFTER_AFTER_BODY:
        {
          tokenAfterAfterBody(this, token);
          break;
        }
      default:
      // Do nothing
    }
  }
  /** @internal */
  onNullCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      nullCharacterInForeignContent(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
        {
          tokenInInitialMode(this, token);
          break;
        }
      case InsertionMode.BEFORE_HTML:
        {
          tokenBeforeHtml(this, token);
          break;
        }
      case InsertionMode.BEFORE_HEAD:
        {
          tokenBeforeHead(this, token);
          break;
        }
      case InsertionMode.IN_HEAD:
        {
          tokenInHead(this, token);
          break;
        }
      case InsertionMode.IN_HEAD_NO_SCRIPT:
        {
          tokenInHeadNoScript(this, token);
          break;
        }
      case InsertionMode.AFTER_HEAD:
        {
          tokenAfterHead(this, token);
          break;
        }
      case InsertionMode.TEXT:
        {
          this._insertCharacters(token);
          break;
        }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
        {
          characterInTable(this, token);
          break;
        }
      case InsertionMode.IN_COLUMN_GROUP:
        {
          tokenInColumnGroup(this, token);
          break;
        }
      case InsertionMode.AFTER_BODY:
        {
          tokenAfterBody(this, token);
          break;
        }
      case InsertionMode.AFTER_AFTER_BODY:
        {
          tokenAfterAfterBody(this, token);
          break;
        }
      default:
      // Do nothing
    }
  }
  /** @internal */
  onComment(token) {
    this.skipNextNewLine = false;
    if (this.currentNotInHTML) {
      appendComment(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
      case InsertionMode.BEFORE_HTML:
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET:
        {
          appendComment(this, token);
          break;
        }
      case InsertionMode.IN_TABLE_TEXT:
        {
          tokenInTableText(this, token);
          break;
        }
      case InsertionMode.AFTER_BODY:
        {
          appendCommentToRootHtmlElement(this, token);
          break;
        }
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET:
        {
          appendCommentToDocument(this, token);
          break;
        }
      default:
      // Do nothing
    }
  }
  /** @internal */
  onDoctype(token) {
    this.skipNextNewLine = false;
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
        {
          doctypeInInitialMode(this, token);
          break;
        }
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
        {
          this._err(token, error_codes_js_1.ERR.misplacedDoctype);
          break;
        }
      case InsertionMode.IN_TABLE_TEXT:
        {
          tokenInTableText(this, token);
          break;
        }
      default:
      // Do nothing
    }
  }
  /** @internal */
  onStartTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    this._processStartTag(token);
    if (token.selfClosing && !token.ackSelfClosing) {
      this._err(token, error_codes_js_1.ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
    }
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   * @protected
   */
  _processStartTag(token) {
    if (this.shouldProcessStartTagTokenInForeignContent(token)) {
      startTagInForeignContent(this, token);
    } else {
      this._startTagOutsideForeignContent(token);
    }
  }
  /** @protected */
  _startTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
        {
          tokenInInitialMode(this, token);
          break;
        }
      case InsertionMode.BEFORE_HTML:
        {
          startTagBeforeHtml(this, token);
          break;
        }
      case InsertionMode.BEFORE_HEAD:
        {
          startTagBeforeHead(this, token);
          break;
        }
      case InsertionMode.IN_HEAD:
        {
          startTagInHead(this, token);
          break;
        }
      case InsertionMode.IN_HEAD_NO_SCRIPT:
        {
          startTagInHeadNoScript(this, token);
          break;
        }
      case InsertionMode.AFTER_HEAD:
        {
          startTagAfterHead(this, token);
          break;
        }
      case InsertionMode.IN_BODY:
        {
          startTagInBody(this, token);
          break;
        }
      case InsertionMode.IN_TABLE:
        {
          startTagInTable(this, token);
          break;
        }
      case InsertionMode.IN_TABLE_TEXT:
        {
          tokenInTableText(this, token);
          break;
        }
      case InsertionMode.IN_CAPTION:
        {
          startTagInCaption(this, token);
          break;
        }
      case InsertionMode.IN_COLUMN_GROUP:
        {
          startTagInColumnGroup(this, token);
          break;
        }
      case InsertionMode.IN_TABLE_BODY:
        {
          startTagInTableBody(this, token);
          break;
        }
      case InsertionMode.IN_ROW:
        {
          startTagInRow(this, token);
          break;
        }
      case InsertionMode.IN_CELL:
        {
          startTagInCell(this, token);
          break;
        }
      case InsertionMode.IN_SELECT:
        {
          startTagInSelect(this, token);
          break;
        }
      case InsertionMode.IN_SELECT_IN_TABLE:
        {
          startTagInSelectInTable(this, token);
          break;
        }
      case InsertionMode.IN_TEMPLATE:
        {
          startTagInTemplate(this, token);
          break;
        }
      case InsertionMode.AFTER_BODY:
        {
          startTagAfterBody(this, token);
          break;
        }
      case InsertionMode.IN_FRAMESET:
        {
          startTagInFrameset(this, token);
          break;
        }
      case InsertionMode.AFTER_FRAMESET:
        {
          startTagAfterFrameset(this, token);
          break;
        }
      case InsertionMode.AFTER_AFTER_BODY:
        {
          startTagAfterAfterBody(this, token);
          break;
        }
      case InsertionMode.AFTER_AFTER_FRAMESET:
        {
          startTagAfterAfterFrameset(this, token);
          break;
        }
      default:
      // Do nothing
    }
  }
  /** @internal */
  onEndTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    if (this.currentNotInHTML) {
      endTagInForeignContent(this, token);
    } else {
      this._endTagOutsideForeignContent(token);
    }
  }
  /** @protected */
  _endTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
        {
          tokenInInitialMode(this, token);
          break;
        }
      case InsertionMode.BEFORE_HTML:
        {
          endTagBeforeHtml(this, token);
          break;
        }
      case InsertionMode.BEFORE_HEAD:
        {
          endTagBeforeHead(this, token);
          break;
        }
      case InsertionMode.IN_HEAD:
        {
          endTagInHead(this, token);
          break;
        }
      case InsertionMode.IN_HEAD_NO_SCRIPT:
        {
          endTagInHeadNoScript(this, token);
          break;
        }
      case InsertionMode.AFTER_HEAD:
        {
          endTagAfterHead(this, token);
          break;
        }
      case InsertionMode.IN_BODY:
        {
          endTagInBody(this, token);
          break;
        }
      case InsertionMode.TEXT:
        {
          endTagInText(this, token);
          break;
        }
      case InsertionMode.IN_TABLE:
        {
          endTagInTable(this, token);
          break;
        }
      case InsertionMode.IN_TABLE_TEXT:
        {
          tokenInTableText(this, token);
          break;
        }
      case InsertionMode.IN_CAPTION:
        {
          endTagInCaption(this, token);
          break;
        }
      case InsertionMode.IN_COLUMN_GROUP:
        {
          endTagInColumnGroup(this, token);
          break;
        }
      case InsertionMode.IN_TABLE_BODY:
        {
          endTagInTableBody(this, token);
          break;
        }
      case InsertionMode.IN_ROW:
        {
          endTagInRow(this, token);
          break;
        }
      case InsertionMode.IN_CELL:
        {
          endTagInCell(this, token);
          break;
        }
      case InsertionMode.IN_SELECT:
        {
          endTagInSelect(this, token);
          break;
        }
      case InsertionMode.IN_SELECT_IN_TABLE:
        {
          endTagInSelectInTable(this, token);
          break;
        }
      case InsertionMode.IN_TEMPLATE:
        {
          endTagInTemplate(this, token);
          break;
        }
      case InsertionMode.AFTER_BODY:
        {
          endTagAfterBody(this, token);
          break;
        }
      case InsertionMode.IN_FRAMESET:
        {
          endTagInFrameset(this, token);
          break;
        }
      case InsertionMode.AFTER_FRAMESET:
        {
          endTagAfterFrameset(this, token);
          break;
        }
      case InsertionMode.AFTER_AFTER_BODY:
        {
          tokenAfterAfterBody(this, token);
          break;
        }
      default:
      // Do nothing
    }
  }
  /** @internal */
  onEof(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
        {
          tokenInInitialMode(this, token);
          break;
        }
      case InsertionMode.BEFORE_HTML:
        {
          tokenBeforeHtml(this, token);
          break;
        }
      case InsertionMode.BEFORE_HEAD:
        {
          tokenBeforeHead(this, token);
          break;
        }
      case InsertionMode.IN_HEAD:
        {
          tokenInHead(this, token);
          break;
        }
      case InsertionMode.IN_HEAD_NO_SCRIPT:
        {
          tokenInHeadNoScript(this, token);
          break;
        }
      case InsertionMode.AFTER_HEAD:
        {
          tokenAfterHead(this, token);
          break;
        }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
        {
          eofInBody(this, token);
          break;
        }
      case InsertionMode.TEXT:
        {
          eofInText(this, token);
          break;
        }
      case InsertionMode.IN_TABLE_TEXT:
        {
          tokenInTableText(this, token);
          break;
        }
      case InsertionMode.IN_TEMPLATE:
        {
          eofInTemplate(this, token);
          break;
        }
      case InsertionMode.AFTER_BODY:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET:
        {
          stopParsing(this, token);
          break;
        }
      default:
      // Do nothing
    }
  }
  /** @internal */
  onWhitespaceCharacter(token) {
    if (this.skipNextNewLine) {
      this.skipNextNewLine = false;
      if (token.chars.charCodeAt(0) === unicode.CODE_POINTS.LINE_FEED) {
        if (token.chars.length === 1) {
          return;
        }
        token.chars = token.chars.substr(1);
      }
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.TEXT:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET:
        {
          this._insertCharacters(token);
          break;
        }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.AFTER_BODY:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET:
        {
          whitespaceCharacterInBody(this, token);
          break;
        }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
        {
          characterInTable(this, token);
          break;
        }
      case InsertionMode.IN_TABLE_TEXT:
        {
          whitespaceCharacterInTableText(this, token);
          break;
        }
      default:
      // Do nothing
    }
  }
}
exports.Parser = Parser;
//Adoption agency algorithm
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adoptionAgency)
//------------------------------------------------------------------
//Steps 5-8 of the algorithm
function aaObtainFormattingElementEntry(p, token) {
  let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
  if (formattingElementEntry) {
    if (!p.openElements.contains(formattingElementEntry.element)) {
      p.activeFormattingElements.removeEntry(formattingElementEntry);
      formattingElementEntry = null;
    } else if (!p.openElements.hasInScope(token.tagID)) {
      formattingElementEntry = null;
    }
  } else {
    genericEndTagInBody(p, token);
  }
  return formattingElementEntry;
}
//Steps 9 and 10 of the algorithm
function aaObtainFurthestBlock(p, formattingElementEntry) {
  let furthestBlock = null;
  let idx = p.openElements.stackTop;
  for (; idx >= 0; idx--) {
    const element = p.openElements.items[idx];
    if (element === formattingElementEntry.element) {
      break;
    }
    if (p._isSpecialElement(element, p.openElements.tagIDs[idx])) {
      furthestBlock = element;
    }
  }
  if (!furthestBlock) {
    p.openElements.shortenToLength(idx < 0 ? 0 : idx);
    p.activeFormattingElements.removeEntry(formattingElementEntry);
  }
  return furthestBlock;
}
//Step 13 of the algorithm
function aaInnerLoop(p, furthestBlock, formattingElement) {
  let lastElement = furthestBlock;
  let nextElement = p.openElements.getCommonAncestor(furthestBlock);
  for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
    //NOTE: store the next element for the next loop iteration (it may be deleted from the stack by step 9.5)
    nextElement = p.openElements.getCommonAncestor(element);
    const elementEntry = p.activeFormattingElements.getElementEntry(element);
    const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
    const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
    if (shouldRemoveFromOpenElements) {
      if (counterOverflow) {
        p.activeFormattingElements.removeEntry(elementEntry);
      }
      p.openElements.remove(element);
    } else {
      element = aaRecreateElementFromEntry(p, elementEntry);
      if (lastElement === furthestBlock) {
        p.activeFormattingElements.bookmark = elementEntry;
      }
      p.treeAdapter.detachNode(lastElement);
      p.treeAdapter.appendChild(element, lastElement);
      lastElement = element;
    }
  }
  return lastElement;
}
//Step 13.7 of the algorithm
function aaRecreateElementFromEntry(p, elementEntry) {
  const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
  const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
  p.openElements.replace(elementEntry.element, newElement);
  elementEntry.element = newElement;
  return newElement;
}
//Step 14 of the algorithm
function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
  const tn = p.treeAdapter.getTagName(commonAncestor);
  const tid = (0, html_js_1.getTagID)(tn);
  if (p._isElementCausesFosterParenting(tid)) {
    p._fosterParentElement(lastElement);
  } else {
    const ns = p.treeAdapter.getNamespaceURI(commonAncestor);
    if (tid === html_js_1.TAG_ID.TEMPLATE && ns === html_js_1.NS.HTML) {
      commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
    }
    p.treeAdapter.appendChild(commonAncestor, lastElement);
  }
}
//Steps 15-19 of the algorithm
function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
  const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
  const {
    token
  } = formattingElementEntry;
  const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);
  p._adoptNodes(furthestBlock, newElement);
  p.treeAdapter.appendChild(furthestBlock, newElement);
  p.activeFormattingElements.insertElementAfterBookmark(newElement, token);
  p.activeFormattingElements.removeEntry(formattingElementEntry);
  p.openElements.remove(formattingElementEntry.element);
  p.openElements.insertAfter(furthestBlock, newElement, token.tagID);
}
//Algorithm entry point
function callAdoptionAgency(p, token) {
  for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
    const formattingElementEntry = aaObtainFormattingElementEntry(p, token);
    if (!formattingElementEntry) {
      break;
    }
    const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);
    if (!furthestBlock) {
      break;
    }
    p.activeFormattingElements.bookmark = formattingElementEntry;
    const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);
    const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);
    p.treeAdapter.detachNode(lastElement);
    if (commonAncestor) aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
    aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
  }
}
//Generic token handlers
//------------------------------------------------------------------
function appendComment(p, token) {
  p._appendCommentNode(token, p.openElements.currentTmplContentOrNode);
}
function appendCommentToRootHtmlElement(p, token) {
  p._appendCommentNode(token, p.openElements.items[0]);
}
function appendCommentToDocument(p, token) {
  p._appendCommentNode(token, p.document);
}
function stopParsing(p, token) {
  p.stopped = true;
  // NOTE: Set end locations for elements that remain on the open element stack.
  if (token.location) {
    // NOTE: If we are not in a fragment, `html` and `body` will stay on the stack.
    // This is a problem, as we might overwrite their end position here.
    const target = p.fragmentContext ? 0 : 2;
    for (let i = p.openElements.stackTop; i >= target; i--) {
      p._setEndLocation(p.openElements.items[i], token);
    }
    // Handle `html` and `body`
    if (!p.fragmentContext && p.openElements.stackTop >= 0) {
      const htmlElement = p.openElements.items[0];
      const htmlLocation = p.treeAdapter.getNodeSourceCodeLocation(htmlElement);
      if (htmlLocation && !htmlLocation.endTag) {
        p._setEndLocation(htmlElement, token);
        if (p.openElements.stackTop >= 1) {
          const bodyElement = p.openElements.items[1];
          const bodyLocation = p.treeAdapter.getNodeSourceCodeLocation(bodyElement);
          if (bodyLocation && !bodyLocation.endTag) {
            p._setEndLocation(bodyElement, token);
          }
        }
      }
    }
  }
}
// The "initial" insertion mode
//------------------------------------------------------------------
function doctypeInInitialMode(p, token) {
  p._setDocumentType(token);
  const mode = token.forceQuirks ? html_js_1.DOCUMENT_MODE.QUIRKS : doctype.getDocumentMode(token);
  if (!doctype.isConforming(token)) {
    p._err(token, error_codes_js_1.ERR.nonConformingDoctype);
  }
  p.treeAdapter.setDocumentMode(p.document, mode);
  p.insertionMode = InsertionMode.BEFORE_HTML;
}
function tokenInInitialMode(p, token) {
  p._err(token, error_codes_js_1.ERR.missingDoctype, true);
  p.treeAdapter.setDocumentMode(p.document, html_js_1.DOCUMENT_MODE.QUIRKS);
  p.insertionMode = InsertionMode.BEFORE_HTML;
  p._processToken(token);
}
// The "before html" insertion mode
//------------------------------------------------------------------
function startTagBeforeHtml(p, token) {
  if (token.tagID === html_js_1.TAG_ID.HTML) {
    p._insertElement(token, html_js_1.NS.HTML);
    p.insertionMode = InsertionMode.BEFORE_HEAD;
  } else {
    tokenBeforeHtml(p, token);
  }
}
function endTagBeforeHtml(p, token) {
  const tn = token.tagID;
  if (tn === html_js_1.TAG_ID.HTML || tn === html_js_1.TAG_ID.HEAD || tn === html_js_1.TAG_ID.BODY || tn === html_js_1.TAG_ID.BR) {
    tokenBeforeHtml(p, token);
  }
}
function tokenBeforeHtml(p, token) {
  p._insertFakeRootElement();
  p.insertionMode = InsertionMode.BEFORE_HEAD;
  p._processToken(token);
}
// The "before head" insertion mode
//------------------------------------------------------------------
function startTagBeforeHead(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.HTML:
      {
        startTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.HEAD:
      {
        p._insertElement(token, html_js_1.NS.HTML);
        p.headElement = p.openElements.current;
        p.insertionMode = InsertionMode.IN_HEAD;
        break;
      }
    default:
      {
        tokenBeforeHead(p, token);
      }
  }
}
function endTagBeforeHead(p, token) {
  const tn = token.tagID;
  if (tn === html_js_1.TAG_ID.HEAD || tn === html_js_1.TAG_ID.BODY || tn === html_js_1.TAG_ID.HTML || tn === html_js_1.TAG_ID.BR) {
    tokenBeforeHead(p, token);
  } else {
    p._err(token, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenBeforeHead(p, token) {
  p._insertFakeElement(html_js_1.TAG_NAMES.HEAD, html_js_1.TAG_ID.HEAD);
  p.headElement = p.openElements.current;
  p.insertionMode = InsertionMode.IN_HEAD;
  p._processToken(token);
}
// The "in head" insertion mode
//------------------------------------------------------------------
function startTagInHead(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.HTML:
      {
        startTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.BASE:
    case html_js_1.TAG_ID.BASEFONT:
    case html_js_1.TAG_ID.BGSOUND:
    case html_js_1.TAG_ID.LINK:
    case html_js_1.TAG_ID.META:
      {
        p._appendElement(token, html_js_1.NS.HTML);
        token.ackSelfClosing = true;
        break;
      }
    case html_js_1.TAG_ID.TITLE:
      {
        p._switchToTextParsing(token, index_js_1.TokenizerMode.RCDATA);
        break;
      }
    case html_js_1.TAG_ID.NOSCRIPT:
      {
        if (p.options.scriptingEnabled) {
          p._switchToTextParsing(token, index_js_1.TokenizerMode.RAWTEXT);
        } else {
          p._insertElement(token, html_js_1.NS.HTML);
          p.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
        }
        break;
      }
    case html_js_1.TAG_ID.NOFRAMES:
    case html_js_1.TAG_ID.STYLE:
      {
        p._switchToTextParsing(token, index_js_1.TokenizerMode.RAWTEXT);
        break;
      }
    case html_js_1.TAG_ID.SCRIPT:
      {
        p._switchToTextParsing(token, index_js_1.TokenizerMode.SCRIPT_DATA);
        break;
      }
    case html_js_1.TAG_ID.TEMPLATE:
      {
        p._insertTemplate(token);
        p.activeFormattingElements.insertMarker();
        p.framesetOk = false;
        p.insertionMode = InsertionMode.IN_TEMPLATE;
        p.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
        break;
      }
    case html_js_1.TAG_ID.HEAD:
      {
        p._err(token, error_codes_js_1.ERR.misplacedStartTagForHeadElement);
        break;
      }
    default:
      {
        tokenInHead(p, token);
      }
  }
}
function endTagInHead(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.HEAD:
      {
        p.openElements.pop();
        p.insertionMode = InsertionMode.AFTER_HEAD;
        break;
      }
    case html_js_1.TAG_ID.BODY:
    case html_js_1.TAG_ID.BR:
    case html_js_1.TAG_ID.HTML:
      {
        tokenInHead(p, token);
        break;
      }
    case html_js_1.TAG_ID.TEMPLATE:
      {
        templateEndTagInHead(p, token);
        break;
      }
    default:
      {
        p._err(token, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
      }
  }
}
function templateEndTagInHead(p, token) {
  if (p.openElements.tmplCount > 0) {
    p.openElements.generateImpliedEndTagsThoroughly();
    if (p.openElements.currentTagId !== html_js_1.TAG_ID.TEMPLATE) {
      p._err(token, error_codes_js_1.ERR.closingOfElementWithOpenChildElements);
    }
    p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p.tmplInsertionModeStack.shift();
    p._resetInsertionMode();
  } else {
    p._err(token, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenInHead(p, token) {
  p.openElements.pop();
  p.insertionMode = InsertionMode.AFTER_HEAD;
  p._processToken(token);
}
// The "in head no script" insertion mode
//------------------------------------------------------------------
function startTagInHeadNoScript(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.HTML:
      {
        startTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.BASEFONT:
    case html_js_1.TAG_ID.BGSOUND:
    case html_js_1.TAG_ID.HEAD:
    case html_js_1.TAG_ID.LINK:
    case html_js_1.TAG_ID.META:
    case html_js_1.TAG_ID.NOFRAMES:
    case html_js_1.TAG_ID.STYLE:
      {
        startTagInHead(p, token);
        break;
      }
    case html_js_1.TAG_ID.NOSCRIPT:
      {
        p._err(token, error_codes_js_1.ERR.nestedNoscriptInHead);
        break;
      }
    default:
      {
        tokenInHeadNoScript(p, token);
      }
  }
}
function endTagInHeadNoScript(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.NOSCRIPT:
      {
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_HEAD;
        break;
      }
    case html_js_1.TAG_ID.BR:
      {
        tokenInHeadNoScript(p, token);
        break;
      }
    default:
      {
        p._err(token, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
      }
  }
}
function tokenInHeadNoScript(p, token) {
  const errCode = token.type === token_js_1.TokenType.EOF ? error_codes_js_1.ERR.openElementsLeftAfterEof : error_codes_js_1.ERR.disallowedContentInNoscriptInHead;
  p._err(token, errCode);
  p.openElements.pop();
  p.insertionMode = InsertionMode.IN_HEAD;
  p._processToken(token);
}
// The "after head" insertion mode
//------------------------------------------------------------------
function startTagAfterHead(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.HTML:
      {
        startTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.BODY:
      {
        p._insertElement(token, html_js_1.NS.HTML);
        p.framesetOk = false;
        p.insertionMode = InsertionMode.IN_BODY;
        break;
      }
    case html_js_1.TAG_ID.FRAMESET:
      {
        p._insertElement(token, html_js_1.NS.HTML);
        p.insertionMode = InsertionMode.IN_FRAMESET;
        break;
      }
    case html_js_1.TAG_ID.BASE:
    case html_js_1.TAG_ID.BASEFONT:
    case html_js_1.TAG_ID.BGSOUND:
    case html_js_1.TAG_ID.LINK:
    case html_js_1.TAG_ID.META:
    case html_js_1.TAG_ID.NOFRAMES:
    case html_js_1.TAG_ID.SCRIPT:
    case html_js_1.TAG_ID.STYLE:
    case html_js_1.TAG_ID.TEMPLATE:
    case html_js_1.TAG_ID.TITLE:
      {
        p._err(token, error_codes_js_1.ERR.abandonedHeadElementChild);
        p.openElements.push(p.headElement, html_js_1.TAG_ID.HEAD);
        startTagInHead(p, token);
        p.openElements.remove(p.headElement);
        break;
      }
    case html_js_1.TAG_ID.HEAD:
      {
        p._err(token, error_codes_js_1.ERR.misplacedStartTagForHeadElement);
        break;
      }
    default:
      {
        tokenAfterHead(p, token);
      }
  }
}
function endTagAfterHead(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.BODY:
    case html_js_1.TAG_ID.HTML:
    case html_js_1.TAG_ID.BR:
      {
        tokenAfterHead(p, token);
        break;
      }
    case html_js_1.TAG_ID.TEMPLATE:
      {
        templateEndTagInHead(p, token);
        break;
      }
    default:
      {
        p._err(token, error_codes_js_1.ERR.endTagWithoutMatchingOpenElement);
      }
  }
}
function tokenAfterHead(p, token) {
  p._insertFakeElement(html_js_1.TAG_NAMES.BODY, html_js_1.TAG_ID.BODY);
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
// The "in body" insertion mode
//------------------------------------------------------------------
function modeInBody(p, token) {
  switch (token.type) {
    case token_js_1.TokenType.CHARACTER:
      {
        characterInBody(p, token);
        break;
      }
    case token_js_1.TokenType.WHITESPACE_CHARACTER:
      {
        whitespaceCharacterInBody(p, token);
        break;
      }
    case token_js_1.TokenType.COMMENT:
      {
        appendComment(p, token);
        break;
      }
    case token_js_1.TokenType.START_TAG:
      {
        startTagInBody(p, token);
        break;
      }
    case token_js_1.TokenType.END_TAG:
      {
        endTagInBody(p, token);
        break;
      }
    case token_js_1.TokenType.EOF:
      {
        eofInBody(p, token);
        break;
      }
    default:
    // Do nothing
  }
}
function whitespaceCharacterInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
}
function characterInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
  p.framesetOk = false;
}
function htmlStartTagInBody(p, token) {
  if (p.openElements.tmplCount === 0) {
    p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
  }
}
function bodyStartTagInBody(p, token) {
  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (bodyElement && p.openElements.tmplCount === 0) {
    p.framesetOk = false;
    p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
  }
}
function framesetStartTagInBody(p, token) {
  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (p.framesetOk && bodyElement) {
    p.treeAdapter.detachNode(bodyElement);
    p.openElements.popAllUpToHtmlElement();
    p._insertElement(token, html_js_1.NS.HTML);
    p.insertionMode = InsertionMode.IN_FRAMESET;
  }
}
function addressStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, html_js_1.NS.HTML);
}
function numberedHeaderStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
    p._closePElement();
  }
  if (html_js_1.NUMBERED_HEADERS.has(p.openElements.currentTagId)) {
    p.openElements.pop();
  }
  p._insertElement(token, html_js_1.NS.HTML);
}
function preStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, html_js_1.NS.HTML);
  //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
  //on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)
  p.skipNextNewLine = true;
  p.framesetOk = false;
}
function formStartTagInBody(p, token) {
  const inTemplate = p.openElements.tmplCount > 0;
  if (!p.formElement || inTemplate) {
    if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
      p._closePElement();
    }
    p._insertElement(token, html_js_1.NS.HTML);
    if (!inTemplate) {
      p.formElement = p.openElements.current;
    }
  }
}
function listItemStartTagInBody(p, token) {
  p.framesetOk = false;
  const tn = token.tagID;
  for (let i = p.openElements.stackTop; i >= 0; i--) {
    const elementId = p.openElements.tagIDs[i];
    if (tn === html_js_1.TAG_ID.LI && elementId === html_js_1.TAG_ID.LI || (tn === html_js_1.TAG_ID.DD || tn === html_js_1.TAG_ID.DT) && (elementId === html_js_1.TAG_ID.DD || elementId === html_js_1.TAG_ID.DT)) {
      p.openElements.generateImpliedEndTagsWithExclusion(elementId);
      p.openElements.popUntilTagNamePopped(elementId);
      break;
    }
    if (elementId !== html_js_1.TAG_ID.ADDRESS && elementId !== html_js_1.TAG_ID.DIV && elementId !== html_js_1.TAG_ID.P && p._isSpecialElement(p.openElements.items[i], elementId)) {
      break;
    }
  }
  if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, html_js_1.NS.HTML);
}
function plaintextStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, html_js_1.NS.HTML);
  p.tokenizer.state = index_js_1.TokenizerMode.PLAINTEXT;
}
function buttonStartTagInBody(p, token) {
  if (p.openElements.hasInScope(html_js_1.TAG_ID.BUTTON)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.BUTTON);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, html_js_1.NS.HTML);
  p.framesetOk = false;
}
function aStartTagInBody(p, token) {
  const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(html_js_1.TAG_NAMES.A);
  if (activeElementEntry) {
    callAdoptionAgency(p, token);
    p.openElements.remove(activeElementEntry.element);
    p.activeFormattingElements.removeEntry(activeElementEntry);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, html_js_1.NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function bStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, html_js_1.NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function nobrStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  if (p.openElements.hasInScope(html_js_1.TAG_ID.NOBR)) {
    callAdoptionAgency(p, token);
    p._reconstructActiveFormattingElements();
  }
  p._insertElement(token, html_js_1.NS.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function appletStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, html_js_1.NS.HTML);
  p.activeFormattingElements.insertMarker();
  p.framesetOk = false;
}
function tableStartTagInBody(p, token) {
  if (p.treeAdapter.getDocumentMode(p.document) !== html_js_1.DOCUMENT_MODE.QUIRKS && p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, html_js_1.NS.HTML);
  p.framesetOk = false;
  p.insertionMode = InsertionMode.IN_TABLE;
}
function areaStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, html_js_1.NS.HTML);
  p.framesetOk = false;
  token.ackSelfClosing = true;
}
function isHiddenInput(token) {
  const inputType = (0, token_js_1.getTokenAttr)(token, html_js_1.ATTRS.TYPE);
  return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
}
function inputStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, html_js_1.NS.HTML);
  if (!isHiddenInput(token)) {
    p.framesetOk = false;
  }
  token.ackSelfClosing = true;
}
function paramStartTagInBody(p, token) {
  p._appendElement(token, html_js_1.NS.HTML);
  token.ackSelfClosing = true;
}
function hrStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
    p._closePElement();
  }
  p._appendElement(token, html_js_1.NS.HTML);
  p.framesetOk = false;
  token.ackSelfClosing = true;
}
function imageStartTagInBody(p, token) {
  token.tagName = html_js_1.TAG_NAMES.IMG;
  token.tagID = html_js_1.TAG_ID.IMG;
  areaStartTagInBody(p, token);
}
function textareaStartTagInBody(p, token) {
  p._insertElement(token, html_js_1.NS.HTML);
  //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
  //on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
  p.skipNextNewLine = true;
  p.tokenizer.state = index_js_1.TokenizerMode.RCDATA;
  p.originalInsertionMode = p.insertionMode;
  p.framesetOk = false;
  p.insertionMode = InsertionMode.TEXT;
}
function xmpStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
    p._closePElement();
  }
  p._reconstructActiveFormattingElements();
  p.framesetOk = false;
  p._switchToTextParsing(token, index_js_1.TokenizerMode.RAWTEXT);
}
function iframeStartTagInBody(p, token) {
  p.framesetOk = false;
  p._switchToTextParsing(token, index_js_1.TokenizerMode.RAWTEXT);
}
//NOTE: here we assume that we always act as a user agent with enabled plugins/frames, so we parse
//<noembed>/<noframes> as rawtext.
function rawTextStartTagInBody(p, token) {
  p._switchToTextParsing(token, index_js_1.TokenizerMode.RAWTEXT);
}
function selectStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, html_js_1.NS.HTML);
  p.framesetOk = false;
  p.insertionMode = p.insertionMode === InsertionMode.IN_TABLE || p.insertionMode === InsertionMode.IN_CAPTION || p.insertionMode === InsertionMode.IN_TABLE_BODY || p.insertionMode === InsertionMode.IN_ROW || p.insertionMode === InsertionMode.IN_CELL ? InsertionMode.IN_SELECT_IN_TABLE : InsertionMode.IN_SELECT;
}
function optgroupStartTagInBody(p, token) {
  if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTION) {
    p.openElements.pop();
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, html_js_1.NS.HTML);
}
function rbStartTagInBody(p, token) {
  if (p.openElements.hasInScope(html_js_1.TAG_ID.RUBY)) {
    p.openElements.generateImpliedEndTags();
  }
  p._insertElement(token, html_js_1.NS.HTML);
}
function rtStartTagInBody(p, token) {
  if (p.openElements.hasInScope(html_js_1.TAG_ID.RUBY)) {
    p.openElements.generateImpliedEndTagsWithExclusion(html_js_1.TAG_ID.RTC);
  }
  p._insertElement(token, html_js_1.NS.HTML);
}
function mathStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  foreignContent.adjustTokenMathMLAttrs(token);
  foreignContent.adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p._appendElement(token, html_js_1.NS.MATHML);
  } else {
    p._insertElement(token, html_js_1.NS.MATHML);
  }
  token.ackSelfClosing = true;
}
function svgStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  foreignContent.adjustTokenSVGAttrs(token);
  foreignContent.adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p._appendElement(token, html_js_1.NS.SVG);
  } else {
    p._insertElement(token, html_js_1.NS.SVG);
  }
  token.ackSelfClosing = true;
}
function genericStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, html_js_1.NS.HTML);
}
function startTagInBody(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.I:
    case html_js_1.TAG_ID.S:
    case html_js_1.TAG_ID.B:
    case html_js_1.TAG_ID.U:
    case html_js_1.TAG_ID.EM:
    case html_js_1.TAG_ID.TT:
    case html_js_1.TAG_ID.BIG:
    case html_js_1.TAG_ID.CODE:
    case html_js_1.TAG_ID.FONT:
    case html_js_1.TAG_ID.SMALL:
    case html_js_1.TAG_ID.STRIKE:
    case html_js_1.TAG_ID.STRONG:
      {
        bStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.A:
      {
        aStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.H1:
    case html_js_1.TAG_ID.H2:
    case html_js_1.TAG_ID.H3:
    case html_js_1.TAG_ID.H4:
    case html_js_1.TAG_ID.H5:
    case html_js_1.TAG_ID.H6:
      {
        numberedHeaderStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.P:
    case html_js_1.TAG_ID.DL:
    case html_js_1.TAG_ID.OL:
    case html_js_1.TAG_ID.UL:
    case html_js_1.TAG_ID.DIV:
    case html_js_1.TAG_ID.DIR:
    case html_js_1.TAG_ID.NAV:
    case html_js_1.TAG_ID.MAIN:
    case html_js_1.TAG_ID.MENU:
    case html_js_1.TAG_ID.ASIDE:
    case html_js_1.TAG_ID.CENTER:
    case html_js_1.TAG_ID.FIGURE:
    case html_js_1.TAG_ID.FOOTER:
    case html_js_1.TAG_ID.HEADER:
    case html_js_1.TAG_ID.HGROUP:
    case html_js_1.TAG_ID.DIALOG:
    case html_js_1.TAG_ID.DETAILS:
    case html_js_1.TAG_ID.ADDRESS:
    case html_js_1.TAG_ID.ARTICLE:
    case html_js_1.TAG_ID.SEARCH:
    case html_js_1.TAG_ID.SECTION:
    case html_js_1.TAG_ID.SUMMARY:
    case html_js_1.TAG_ID.FIELDSET:
    case html_js_1.TAG_ID.BLOCKQUOTE:
    case html_js_1.TAG_ID.FIGCAPTION:
      {
        addressStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.LI:
    case html_js_1.TAG_ID.DD:
    case html_js_1.TAG_ID.DT:
      {
        listItemStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.BR:
    case html_js_1.TAG_ID.IMG:
    case html_js_1.TAG_ID.WBR:
    case html_js_1.TAG_ID.AREA:
    case html_js_1.TAG_ID.EMBED:
    case html_js_1.TAG_ID.KEYGEN:
      {
        areaStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.HR:
      {
        hrStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.RB:
    case html_js_1.TAG_ID.RTC:
      {
        rbStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.RT:
    case html_js_1.TAG_ID.RP:
      {
        rtStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.PRE:
    case html_js_1.TAG_ID.LISTING:
      {
        preStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.XMP:
      {
        xmpStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.SVG:
      {
        svgStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.HTML:
      {
        htmlStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.BASE:
    case html_js_1.TAG_ID.LINK:
    case html_js_1.TAG_ID.META:
    case html_js_1.TAG_ID.STYLE:
    case html_js_1.TAG_ID.TITLE:
    case html_js_1.TAG_ID.SCRIPT:
    case html_js_1.TAG_ID.BGSOUND:
    case html_js_1.TAG_ID.BASEFONT:
    case html_js_1.TAG_ID.TEMPLATE:
      {
        startTagInHead(p, token);
        break;
      }
    case html_js_1.TAG_ID.BODY:
      {
        bodyStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.FORM:
      {
        formStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.NOBR:
      {
        nobrStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.MATH:
      {
        mathStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.TABLE:
      {
        tableStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.INPUT:
      {
        inputStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.PARAM:
    case html_js_1.TAG_ID.TRACK:
    case html_js_1.TAG_ID.SOURCE:
      {
        paramStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.IMAGE:
      {
        imageStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.BUTTON:
      {
        buttonStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.APPLET:
    case html_js_1.TAG_ID.OBJECT:
    case html_js_1.TAG_ID.MARQUEE:
      {
        appletStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.IFRAME:
      {
        iframeStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.SELECT:
      {
        selectStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.OPTION:
    case html_js_1.TAG_ID.OPTGROUP:
      {
        optgroupStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.NOEMBED:
    case html_js_1.TAG_ID.NOFRAMES:
      {
        rawTextStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.FRAMESET:
      {
        framesetStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.TEXTAREA:
      {
        textareaStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.NOSCRIPT:
      {
        if (p.options.scriptingEnabled) {
          rawTextStartTagInBody(p, token);
        } else {
          genericStartTagInBody(p, token);
        }
        break;
      }
    case html_js_1.TAG_ID.PLAINTEXT:
      {
        plaintextStartTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.COL:
    case html_js_1.TAG_ID.TH:
    case html_js_1.TAG_ID.TD:
    case html_js_1.TAG_ID.TR:
    case html_js_1.TAG_ID.HEAD:
    case html_js_1.TAG_ID.FRAME:
    case html_js_1.TAG_ID.TBODY:
    case html_js_1.TAG_ID.TFOOT:
    case html_js_1.TAG_ID.THEAD:
    case html_js_1.TAG_ID.CAPTION:
    case html_js_1.TAG_ID.COLGROUP:
      {
        // Ignore token
        break;
      }
    default:
      {
        genericStartTagInBody(p, token);
      }
  }
}
function bodyEndTagInBody(p, token) {
  if (p.openElements.hasInScope(html_js_1.TAG_ID.BODY)) {
    p.insertionMode = InsertionMode.AFTER_BODY;
    //NOTE: <body> is never popped from the stack, so we need to updated
    //the end location explicitly.
    if (p.options.sourceCodeLocationInfo) {
      const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
      if (bodyElement) {
        p._setEndLocation(bodyElement, token);
      }
    }
  }
}
function htmlEndTagInBody(p, token) {
  if (p.openElements.hasInScope(html_js_1.TAG_ID.BODY)) {
    p.insertionMode = InsertionMode.AFTER_BODY;
    endTagAfterBody(p, token);
  }
}
function addressEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function formEndTagInBody(p) {
  const inTemplate = p.openElements.tmplCount > 0;
  const {
    formElement
  } = p;
  if (!inTemplate) {
    p.formElement = null;
  }
  if ((formElement || inTemplate) && p.openElements.hasInScope(html_js_1.TAG_ID.FORM)) {
    p.openElements.generateImpliedEndTags();
    if (inTemplate) {
      p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.FORM);
    } else if (formElement) {
      p.openElements.remove(formElement);
    }
  }
}
function pEndTagInBody(p) {
  if (!p.openElements.hasInButtonScope(html_js_1.TAG_ID.P)) {
    p._insertFakeElement(html_js_1.TAG_NAMES.P, html_js_1.TAG_ID.P);
  }
  p._closePElement();
}
function liEndTagInBody(p) {
  if (p.openElements.hasInListItemScope(html_js_1.TAG_ID.LI)) {
    p.openElements.generateImpliedEndTagsWithExclusion(html_js_1.TAG_ID.LI);
    p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.LI);
  }
}
function ddEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTagsWithExclusion(tn);
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function numberedHeaderEndTagInBody(p) {
  if (p.openElements.hasNumberedHeaderInScope()) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilNumberedHeaderPopped();
  }
}
function appletEndTagInBody(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
    p.activeFormattingElements.clearToLastMarker();
  }
}
function brEndTagInBody(p) {
  p._reconstructActiveFormattingElements();
  p._insertFakeElement(html_js_1.TAG_NAMES.BR, html_js_1.TAG_ID.BR);
  p.openElements.pop();
  p.framesetOk = false;
}
function genericEndTagInBody(p, token) {
  const tn = token.tagName;
  const tid = token.tagID;
  for (let i = p.openElements.stackTop; i > 0; i--) {
    const element = p.openElements.items[i];
    const elementId = p.openElements.tagIDs[i];
    // Compare the tag name here, as the tag might not be a known tag with an ID.
    if (tid === elementId && (tid !== html_js_1.TAG_ID.UNKNOWN || p.treeAdapter.getTagName(element) === tn)) {
      p.openElements.generateImpliedEndTagsWithExclusion(tid);
      if (p.openElements.stackTop >= i) p.openElements.shortenToLength(i);
      break;
    }
    if (p._isSpecialElement(element, elementId)) {
      break;
    }
  }
}
function endTagInBody(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.A:
    case html_js_1.TAG_ID.B:
    case html_js_1.TAG_ID.I:
    case html_js_1.TAG_ID.S:
    case html_js_1.TAG_ID.U:
    case html_js_1.TAG_ID.EM:
    case html_js_1.TAG_ID.TT:
    case html_js_1.TAG_ID.BIG:
    case html_js_1.TAG_ID.CODE:
    case html_js_1.TAG_ID.FONT:
    case html_js_1.TAG_ID.NOBR:
    case html_js_1.TAG_ID.SMALL:
    case html_js_1.TAG_ID.STRIKE:
    case html_js_1.TAG_ID.STRONG:
      {
        callAdoptionAgency(p, token);
        break;
      }
    case html_js_1.TAG_ID.P:
      {
        pEndTagInBody(p);
        break;
      }
    case html_js_1.TAG_ID.DL:
    case html_js_1.TAG_ID.UL:
    case html_js_1.TAG_ID.OL:
    case html_js_1.TAG_ID.DIR:
    case html_js_1.TAG_ID.DIV:
    case html_js_1.TAG_ID.NAV:
    case html_js_1.TAG_ID.PRE:
    case html_js_1.TAG_ID.MAIN:
    case html_js_1.TAG_ID.MENU:
    case html_js_1.TAG_ID.ASIDE:
    case html_js_1.TAG_ID.BUTTON:
    case html_js_1.TAG_ID.CENTER:
    case html_js_1.TAG_ID.FIGURE:
    case html_js_1.TAG_ID.FOOTER:
    case html_js_1.TAG_ID.HEADER:
    case html_js_1.TAG_ID.HGROUP:
    case html_js_1.TAG_ID.DIALOG:
    case html_js_1.TAG_ID.ADDRESS:
    case html_js_1.TAG_ID.ARTICLE:
    case html_js_1.TAG_ID.DETAILS:
    case html_js_1.TAG_ID.SEARCH:
    case html_js_1.TAG_ID.SECTION:
    case html_js_1.TAG_ID.SUMMARY:
    case html_js_1.TAG_ID.LISTING:
    case html_js_1.TAG_ID.FIELDSET:
    case html_js_1.TAG_ID.BLOCKQUOTE:
    case html_js_1.TAG_ID.FIGCAPTION:
      {
        addressEndTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.LI:
      {
        liEndTagInBody(p);
        break;
      }
    case html_js_1.TAG_ID.DD:
    case html_js_1.TAG_ID.DT:
      {
        ddEndTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.H1:
    case html_js_1.TAG_ID.H2:
    case html_js_1.TAG_ID.H3:
    case html_js_1.TAG_ID.H4:
    case html_js_1.TAG_ID.H5:
    case html_js_1.TAG_ID.H6:
      {
        numberedHeaderEndTagInBody(p);
        break;
      }
    case html_js_1.TAG_ID.BR:
      {
        brEndTagInBody(p);
        break;
      }
    case html_js_1.TAG_ID.BODY:
      {
        bodyEndTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.HTML:
      {
        htmlEndTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.FORM:
      {
        formEndTagInBody(p);
        break;
      }
    case html_js_1.TAG_ID.APPLET:
    case html_js_1.TAG_ID.OBJECT:
    case html_js_1.TAG_ID.MARQUEE:
      {
        appletEndTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.TEMPLATE:
      {
        templateEndTagInHead(p, token);
        break;
      }
    default:
      {
        genericEndTagInBody(p, token);
      }
  }
}
function eofInBody(p, token) {
  if (p.tmplInsertionModeStack.length > 0) {
    eofInTemplate(p, token);
  } else {
    stopParsing(p, token);
  }
}
// The "text" insertion mode
//------------------------------------------------------------------
function endTagInText(p, token) {
  var _a;
  if (token.tagID === html_js_1.TAG_ID.SCRIPT) {
    (_a = p.scriptHandler) === null || _a === void 0 ? void 0 : _a.call(p, p.openElements.current);
  }
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
}
function eofInText(p, token) {
  p._err(token, error_codes_js_1.ERR.eofInElementThatCanContainOnlyText);
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
  p.onEof(token);
}
// The "in table" insertion mode
//------------------------------------------------------------------
function characterInTable(p, token) {
  if (TABLE_STRUCTURE_TAGS.has(p.openElements.currentTagId)) {
    p.pendingCharacterTokens.length = 0;
    p.hasNonWhitespacePendingCharacterToken = false;
    p.originalInsertionMode = p.insertionMode;
    p.insertionMode = InsertionMode.IN_TABLE_TEXT;
    switch (token.type) {
      case token_js_1.TokenType.CHARACTER:
        {
          characterInTableText(p, token);
          break;
        }
      case token_js_1.TokenType.WHITESPACE_CHARACTER:
        {
          whitespaceCharacterInTableText(p, token);
          break;
        }
      // Ignore null
    }
  } else {
    tokenInTable(p, token);
  }
}
function captionStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p.activeFormattingElements.insertMarker();
  p._insertElement(token, html_js_1.NS.HTML);
  p.insertionMode = InsertionMode.IN_CAPTION;
}
function colgroupStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, html_js_1.NS.HTML);
  p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
}
function colStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement(html_js_1.TAG_NAMES.COLGROUP, html_js_1.TAG_ID.COLGROUP);
  p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
  startTagInColumnGroup(p, token);
}
function tbodyStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, html_js_1.NS.HTML);
  p.insertionMode = InsertionMode.IN_TABLE_BODY;
}
function tdStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement(html_js_1.TAG_NAMES.TBODY, html_js_1.TAG_ID.TBODY);
  p.insertionMode = InsertionMode.IN_TABLE_BODY;
  startTagInTableBody(p, token);
}
function tableStartTagInTable(p, token) {
  if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TABLE)) {
    p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.TABLE);
    p._resetInsertionMode();
    p._processStartTag(token);
  }
}
function inputStartTagInTable(p, token) {
  if (isHiddenInput(token)) {
    p._appendElement(token, html_js_1.NS.HTML);
  } else {
    tokenInTable(p, token);
  }
  token.ackSelfClosing = true;
}
function formStartTagInTable(p, token) {
  if (!p.formElement && p.openElements.tmplCount === 0) {
    p._insertElement(token, html_js_1.NS.HTML);
    p.formElement = p.openElements.current;
    p.openElements.pop();
  }
}
function startTagInTable(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.TD:
    case html_js_1.TAG_ID.TH:
    case html_js_1.TAG_ID.TR:
      {
        tdStartTagInTable(p, token);
        break;
      }
    case html_js_1.TAG_ID.STYLE:
    case html_js_1.TAG_ID.SCRIPT:
    case html_js_1.TAG_ID.TEMPLATE:
      {
        startTagInHead(p, token);
        break;
      }
    case html_js_1.TAG_ID.COL:
      {
        colStartTagInTable(p, token);
        break;
      }
    case html_js_1.TAG_ID.FORM:
      {
        formStartTagInTable(p, token);
        break;
      }
    case html_js_1.TAG_ID.TABLE:
      {
        tableStartTagInTable(p, token);
        break;
      }
    case html_js_1.TAG_ID.TBODY:
    case html_js_1.TAG_ID.TFOOT:
    case html_js_1.TAG_ID.THEAD:
      {
        tbodyStartTagInTable(p, token);
        break;
      }
    case html_js_1.TAG_ID.INPUT:
      {
        inputStartTagInTable(p, token);
        break;
      }
    case html_js_1.TAG_ID.CAPTION:
      {
        captionStartTagInTable(p, token);
        break;
      }
    case html_js_1.TAG_ID.COLGROUP:
      {
        colgroupStartTagInTable(p, token);
        break;
      }
    default:
      {
        tokenInTable(p, token);
      }
  }
}
function endTagInTable(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.TABLE:
      {
        if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TABLE)) {
          p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.TABLE);
          p._resetInsertionMode();
        }
        break;
      }
    case html_js_1.TAG_ID.TEMPLATE:
      {
        templateEndTagInHead(p, token);
        break;
      }
    case html_js_1.TAG_ID.BODY:
    case html_js_1.TAG_ID.CAPTION:
    case html_js_1.TAG_ID.COL:
    case html_js_1.TAG_ID.COLGROUP:
    case html_js_1.TAG_ID.HTML:
    case html_js_1.TAG_ID.TBODY:
    case html_js_1.TAG_ID.TD:
    case html_js_1.TAG_ID.TFOOT:
    case html_js_1.TAG_ID.TH:
    case html_js_1.TAG_ID.THEAD:
    case html_js_1.TAG_ID.TR:
      {
        // Ignore token
        break;
      }
    default:
      {
        tokenInTable(p, token);
      }
  }
}
function tokenInTable(p, token) {
  const savedFosterParentingState = p.fosterParentingEnabled;
  p.fosterParentingEnabled = true;
  // Process token in `In Body` mode
  modeInBody(p, token);
  p.fosterParentingEnabled = savedFosterParentingState;
}
// The "in table text" insertion mode
//------------------------------------------------------------------
function whitespaceCharacterInTableText(p, token) {
  p.pendingCharacterTokens.push(token);
}
function characterInTableText(p, token) {
  p.pendingCharacterTokens.push(token);
  p.hasNonWhitespacePendingCharacterToken = true;
}
function tokenInTableText(p, token) {
  let i = 0;
  if (p.hasNonWhitespacePendingCharacterToken) {
    for (; i < p.pendingCharacterTokens.length; i++) {
      tokenInTable(p, p.pendingCharacterTokens[i]);
    }
  } else {
    for (; i < p.pendingCharacterTokens.length; i++) {
      p._insertCharacters(p.pendingCharacterTokens[i]);
    }
  }
  p.insertionMode = p.originalInsertionMode;
  p._processToken(token);
}
// The "in caption" insertion mode
//------------------------------------------------------------------
const TABLE_VOID_ELEMENTS = new Set([html_js_1.TAG_ID.CAPTION, html_js_1.TAG_ID.COL, html_js_1.TAG_ID.COLGROUP, html_js_1.TAG_ID.TBODY, html_js_1.TAG_ID.TD, html_js_1.TAG_ID.TFOOT, html_js_1.TAG_ID.TH, html_js_1.TAG_ID.THEAD, html_js_1.TAG_ID.TR]);
function startTagInCaption(p, token) {
  const tn = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p.openElements.hasInTableScope(html_js_1.TAG_ID.CAPTION)) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.CAPTION);
      p.activeFormattingElements.clearToLastMarker();
      p.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p, token);
    }
  } else {
    startTagInBody(p, token);
  }
}
function endTagInCaption(p, token) {
  const tn = token.tagID;
  switch (tn) {
    case html_js_1.TAG_ID.CAPTION:
    case html_js_1.TAG_ID.TABLE:
      {
        if (p.openElements.hasInTableScope(html_js_1.TAG_ID.CAPTION)) {
          p.openElements.generateImpliedEndTags();
          p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.CAPTION);
          p.activeFormattingElements.clearToLastMarker();
          p.insertionMode = InsertionMode.IN_TABLE;
          if (tn === html_js_1.TAG_ID.TABLE) {
            endTagInTable(p, token);
          }
        }
        break;
      }
    case html_js_1.TAG_ID.BODY:
    case html_js_1.TAG_ID.COL:
    case html_js_1.TAG_ID.COLGROUP:
    case html_js_1.TAG_ID.HTML:
    case html_js_1.TAG_ID.TBODY:
    case html_js_1.TAG_ID.TD:
    case html_js_1.TAG_ID.TFOOT:
    case html_js_1.TAG_ID.TH:
    case html_js_1.TAG_ID.THEAD:
    case html_js_1.TAG_ID.TR:
      {
        // Ignore token
        break;
      }
    default:
      {
        endTagInBody(p, token);
      }
  }
}
// The "in column group" insertion mode
//------------------------------------------------------------------
function startTagInColumnGroup(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.HTML:
      {
        startTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.COL:
      {
        p._appendElement(token, html_js_1.NS.HTML);
        token.ackSelfClosing = true;
        break;
      }
    case html_js_1.TAG_ID.TEMPLATE:
      {
        startTagInHead(p, token);
        break;
      }
    default:
      {
        tokenInColumnGroup(p, token);
      }
  }
}
function endTagInColumnGroup(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.COLGROUP:
      {
        if (p.openElements.currentTagId === html_js_1.TAG_ID.COLGROUP) {
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE;
        }
        break;
      }
    case html_js_1.TAG_ID.TEMPLATE:
      {
        templateEndTagInHead(p, token);
        break;
      }
    case html_js_1.TAG_ID.COL:
      {
        // Ignore token
        break;
      }
    default:
      {
        tokenInColumnGroup(p, token);
      }
  }
}
function tokenInColumnGroup(p, token) {
  if (p.openElements.currentTagId === html_js_1.TAG_ID.COLGROUP) {
    p.openElements.pop();
    p.insertionMode = InsertionMode.IN_TABLE;
    p._processToken(token);
  }
}
// The "in table body" insertion mode
//------------------------------------------------------------------
function startTagInTableBody(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.TR:
      {
        p.openElements.clearBackToTableBodyContext();
        p._insertElement(token, html_js_1.NS.HTML);
        p.insertionMode = InsertionMode.IN_ROW;
        break;
      }
    case html_js_1.TAG_ID.TH:
    case html_js_1.TAG_ID.TD:
      {
        p.openElements.clearBackToTableBodyContext();
        p._insertFakeElement(html_js_1.TAG_NAMES.TR, html_js_1.TAG_ID.TR);
        p.insertionMode = InsertionMode.IN_ROW;
        startTagInRow(p, token);
        break;
      }
    case html_js_1.TAG_ID.CAPTION:
    case html_js_1.TAG_ID.COL:
    case html_js_1.TAG_ID.COLGROUP:
    case html_js_1.TAG_ID.TBODY:
    case html_js_1.TAG_ID.TFOOT:
    case html_js_1.TAG_ID.THEAD:
      {
        if (p.openElements.hasTableBodyContextInTableScope()) {
          p.openElements.clearBackToTableBodyContext();
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE;
          startTagInTable(p, token);
        }
        break;
      }
    default:
      {
        startTagInTable(p, token);
      }
  }
}
function endTagInTableBody(p, token) {
  const tn = token.tagID;
  switch (token.tagID) {
    case html_js_1.TAG_ID.TBODY:
    case html_js_1.TAG_ID.TFOOT:
    case html_js_1.TAG_ID.THEAD:
      {
        if (p.openElements.hasInTableScope(tn)) {
          p.openElements.clearBackToTableBodyContext();
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE;
        }
        break;
      }
    case html_js_1.TAG_ID.TABLE:
      {
        if (p.openElements.hasTableBodyContextInTableScope()) {
          p.openElements.clearBackToTableBodyContext();
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE;
          endTagInTable(p, token);
        }
        break;
      }
    case html_js_1.TAG_ID.BODY:
    case html_js_1.TAG_ID.CAPTION:
    case html_js_1.TAG_ID.COL:
    case html_js_1.TAG_ID.COLGROUP:
    case html_js_1.TAG_ID.HTML:
    case html_js_1.TAG_ID.TD:
    case html_js_1.TAG_ID.TH:
    case html_js_1.TAG_ID.TR:
      {
        // Ignore token
        break;
      }
    default:
      {
        endTagInTable(p, token);
      }
  }
}
// The "in row" insertion mode
//------------------------------------------------------------------
function startTagInRow(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.TH:
    case html_js_1.TAG_ID.TD:
      {
        p.openElements.clearBackToTableRowContext();
        p._insertElement(token, html_js_1.NS.HTML);
        p.insertionMode = InsertionMode.IN_CELL;
        p.activeFormattingElements.insertMarker();
        break;
      }
    case html_js_1.TAG_ID.CAPTION:
    case html_js_1.TAG_ID.COL:
    case html_js_1.TAG_ID.COLGROUP:
    case html_js_1.TAG_ID.TBODY:
    case html_js_1.TAG_ID.TFOOT:
    case html_js_1.TAG_ID.THEAD:
    case html_js_1.TAG_ID.TR:
      {
        if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TR)) {
          p.openElements.clearBackToTableRowContext();
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE_BODY;
          startTagInTableBody(p, token);
        }
        break;
      }
    default:
      {
        startTagInTable(p, token);
      }
  }
}
function endTagInRow(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.TR:
      {
        if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TR)) {
          p.openElements.clearBackToTableRowContext();
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE_BODY;
        }
        break;
      }
    case html_js_1.TAG_ID.TABLE:
      {
        if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TR)) {
          p.openElements.clearBackToTableRowContext();
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE_BODY;
          endTagInTableBody(p, token);
        }
        break;
      }
    case html_js_1.TAG_ID.TBODY:
    case html_js_1.TAG_ID.TFOOT:
    case html_js_1.TAG_ID.THEAD:
      {
        if (p.openElements.hasInTableScope(token.tagID) || p.openElements.hasInTableScope(html_js_1.TAG_ID.TR)) {
          p.openElements.clearBackToTableRowContext();
          p.openElements.pop();
          p.insertionMode = InsertionMode.IN_TABLE_BODY;
          endTagInTableBody(p, token);
        }
        break;
      }
    case html_js_1.TAG_ID.BODY:
    case html_js_1.TAG_ID.CAPTION:
    case html_js_1.TAG_ID.COL:
    case html_js_1.TAG_ID.COLGROUP:
    case html_js_1.TAG_ID.HTML:
    case html_js_1.TAG_ID.TD:
    case html_js_1.TAG_ID.TH:
      {
        // Ignore end tag
        break;
      }
    default:
      {
        endTagInTable(p, token);
      }
  }
}
// The "in cell" insertion mode
//------------------------------------------------------------------
function startTagInCell(p, token) {
  const tn = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p.openElements.hasInTableScope(html_js_1.TAG_ID.TD) || p.openElements.hasInTableScope(html_js_1.TAG_ID.TH)) {
      p._closeTableCell();
      startTagInRow(p, token);
    }
  } else {
    startTagInBody(p, token);
  }
}
function endTagInCell(p, token) {
  const tn = token.tagID;
  switch (tn) {
    case html_js_1.TAG_ID.TD:
    case html_js_1.TAG_ID.TH:
      {
        if (p.openElements.hasInTableScope(tn)) {
          p.openElements.generateImpliedEndTags();
          p.openElements.popUntilTagNamePopped(tn);
          p.activeFormattingElements.clearToLastMarker();
          p.insertionMode = InsertionMode.IN_ROW;
        }
        break;
      }
    case html_js_1.TAG_ID.TABLE:
    case html_js_1.TAG_ID.TBODY:
    case html_js_1.TAG_ID.TFOOT:
    case html_js_1.TAG_ID.THEAD:
    case html_js_1.TAG_ID.TR:
      {
        if (p.openElements.hasInTableScope(tn)) {
          p._closeTableCell();
          endTagInRow(p, token);
        }
        break;
      }
    case html_js_1.TAG_ID.BODY:
    case html_js_1.TAG_ID.CAPTION:
    case html_js_1.TAG_ID.COL:
    case html_js_1.TAG_ID.COLGROUP:
    case html_js_1.TAG_ID.HTML:
      {
        // Ignore token
        break;
      }
    default:
      {
        endTagInBody(p, token);
      }
  }
}
// The "in select" insertion mode
//------------------------------------------------------------------
function startTagInSelect(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.HTML:
      {
        startTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.OPTION:
      {
        if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTION) {
          p.openElements.pop();
        }
        p._insertElement(token, html_js_1.NS.HTML);
        break;
      }
    case html_js_1.TAG_ID.OPTGROUP:
      {
        if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTION) {
          p.openElements.pop();
        }
        if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTGROUP) {
          p.openElements.pop();
        }
        p._insertElement(token, html_js_1.NS.HTML);
        break;
      }
    case html_js_1.TAG_ID.HR:
      {
        if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTION) {
          p.openElements.pop();
        }
        if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTGROUP) {
          p.openElements.pop();
        }
        p._appendElement(token, html_js_1.NS.HTML);
        token.ackSelfClosing = true;
        break;
      }
    case html_js_1.TAG_ID.INPUT:
    case html_js_1.TAG_ID.KEYGEN:
    case html_js_1.TAG_ID.TEXTAREA:
    case html_js_1.TAG_ID.SELECT:
      {
        if (p.openElements.hasInSelectScope(html_js_1.TAG_ID.SELECT)) {
          p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.SELECT);
          p._resetInsertionMode();
          if (token.tagID !== html_js_1.TAG_ID.SELECT) {
            p._processStartTag(token);
          }
        }
        break;
      }
    case html_js_1.TAG_ID.SCRIPT:
    case html_js_1.TAG_ID.TEMPLATE:
      {
        startTagInHead(p, token);
        break;
      }
    default:
    // Do nothing
  }
}
function endTagInSelect(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.OPTGROUP:
      {
        if (p.openElements.stackTop > 0 && p.openElements.currentTagId === html_js_1.TAG_ID.OPTION && p.openElements.tagIDs[p.openElements.stackTop - 1] === html_js_1.TAG_ID.OPTGROUP) {
          p.openElements.pop();
        }
        if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTGROUP) {
          p.openElements.pop();
        }
        break;
      }
    case html_js_1.TAG_ID.OPTION:
      {
        if (p.openElements.currentTagId === html_js_1.TAG_ID.OPTION) {
          p.openElements.pop();
        }
        break;
      }
    case html_js_1.TAG_ID.SELECT:
      {
        if (p.openElements.hasInSelectScope(html_js_1.TAG_ID.SELECT)) {
          p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.SELECT);
          p._resetInsertionMode();
        }
        break;
      }
    case html_js_1.TAG_ID.TEMPLATE:
      {
        templateEndTagInHead(p, token);
        break;
      }
    default:
    // Do nothing
  }
}
// The "in select in table" insertion mode
//------------------------------------------------------------------
function startTagInSelectInTable(p, token) {
  const tn = token.tagID;
  if (tn === html_js_1.TAG_ID.CAPTION || tn === html_js_1.TAG_ID.TABLE || tn === html_js_1.TAG_ID.TBODY || tn === html_js_1.TAG_ID.TFOOT || tn === html_js_1.TAG_ID.THEAD || tn === html_js_1.TAG_ID.TR || tn === html_js_1.TAG_ID.TD || tn === html_js_1.TAG_ID.TH) {
    p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.SELECT);
    p._resetInsertionMode();
    p._processStartTag(token);
  } else {
    startTagInSelect(p, token);
  }
}
function endTagInSelectInTable(p, token) {
  const tn = token.tagID;
  if (tn === html_js_1.TAG_ID.CAPTION || tn === html_js_1.TAG_ID.TABLE || tn === html_js_1.TAG_ID.TBODY || tn === html_js_1.TAG_ID.TFOOT || tn === html_js_1.TAG_ID.THEAD || tn === html_js_1.TAG_ID.TR || tn === html_js_1.TAG_ID.TD || tn === html_js_1.TAG_ID.TH) {
    if (p.openElements.hasInTableScope(tn)) {
      p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.SELECT);
      p._resetInsertionMode();
      p.onEndTag(token);
    }
  } else {
    endTagInSelect(p, token);
  }
}
// The "in template" insertion mode
//------------------------------------------------------------------
function startTagInTemplate(p, token) {
  switch (token.tagID) {
    // First, handle tags that can start without a mode change
    case html_js_1.TAG_ID.BASE:
    case html_js_1.TAG_ID.BASEFONT:
    case html_js_1.TAG_ID.BGSOUND:
    case html_js_1.TAG_ID.LINK:
    case html_js_1.TAG_ID.META:
    case html_js_1.TAG_ID.NOFRAMES:
    case html_js_1.TAG_ID.SCRIPT:
    case html_js_1.TAG_ID.STYLE:
    case html_js_1.TAG_ID.TEMPLATE:
    case html_js_1.TAG_ID.TITLE:
      {
        startTagInHead(p, token);
        break;
      }
    // Re-process the token in the appropriate mode
    case html_js_1.TAG_ID.CAPTION:
    case html_js_1.TAG_ID.COLGROUP:
    case html_js_1.TAG_ID.TBODY:
    case html_js_1.TAG_ID.TFOOT:
    case html_js_1.TAG_ID.THEAD:
      {
        p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
        p.insertionMode = InsertionMode.IN_TABLE;
        startTagInTable(p, token);
        break;
      }
    case html_js_1.TAG_ID.COL:
      {
        p.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
        p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
        startTagInColumnGroup(p, token);
        break;
      }
    case html_js_1.TAG_ID.TR:
      {
        p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        startTagInTableBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.TD:
    case html_js_1.TAG_ID.TH:
      {
        p.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
        p.insertionMode = InsertionMode.IN_ROW;
        startTagInRow(p, token);
        break;
      }
    default:
      {
        p.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
        p.insertionMode = InsertionMode.IN_BODY;
        startTagInBody(p, token);
      }
  }
}
function endTagInTemplate(p, token) {
  if (token.tagID === html_js_1.TAG_ID.TEMPLATE) {
    templateEndTagInHead(p, token);
  }
}
function eofInTemplate(p, token) {
  if (p.openElements.tmplCount > 0) {
    p.openElements.popUntilTagNamePopped(html_js_1.TAG_ID.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p.tmplInsertionModeStack.shift();
    p._resetInsertionMode();
    p.onEof(token);
  } else {
    stopParsing(p, token);
  }
}
// The "after body" insertion mode
//------------------------------------------------------------------
function startTagAfterBody(p, token) {
  if (token.tagID === html_js_1.TAG_ID.HTML) {
    startTagInBody(p, token);
  } else {
    tokenAfterBody(p, token);
  }
}
function endTagAfterBody(p, token) {
  var _a;
  if (token.tagID === html_js_1.TAG_ID.HTML) {
    if (!p.fragmentContext) {
      p.insertionMode = InsertionMode.AFTER_AFTER_BODY;
    }
    //NOTE: <html> is never popped from the stack, so we need to updated
    //the end location explicitly.
    if (p.options.sourceCodeLocationInfo && p.openElements.tagIDs[0] === html_js_1.TAG_ID.HTML) {
      p._setEndLocation(p.openElements.items[0], token);
      // Update the body element, if it doesn't have an end tag
      const bodyElement = p.openElements.items[1];
      if (bodyElement && !((_a = p.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a === void 0 ? void 0 : _a.endTag)) {
        p._setEndLocation(bodyElement, token);
      }
    }
  } else {
    tokenAfterBody(p, token);
  }
}
function tokenAfterBody(p, token) {
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
// The "in frameset" insertion mode
//------------------------------------------------------------------
function startTagInFrameset(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.HTML:
      {
        startTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.FRAMESET:
      {
        p._insertElement(token, html_js_1.NS.HTML);
        break;
      }
    case html_js_1.TAG_ID.FRAME:
      {
        p._appendElement(token, html_js_1.NS.HTML);
        token.ackSelfClosing = true;
        break;
      }
    case html_js_1.TAG_ID.NOFRAMES:
      {
        startTagInHead(p, token);
        break;
      }
    default:
    // Do nothing
  }
}
function endTagInFrameset(p, token) {
  if (token.tagID === html_js_1.TAG_ID.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
    p.openElements.pop();
    if (!p.fragmentContext && p.openElements.currentTagId !== html_js_1.TAG_ID.FRAMESET) {
      p.insertionMode = InsertionMode.AFTER_FRAMESET;
    }
  }
}
// The "after frameset" insertion mode
//------------------------------------------------------------------
function startTagAfterFrameset(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.HTML:
      {
        startTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.NOFRAMES:
      {
        startTagInHead(p, token);
        break;
      }
    default:
    // Do nothing
  }
}
function endTagAfterFrameset(p, token) {
  if (token.tagID === html_js_1.TAG_ID.HTML) {
    p.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
  }
}
// The "after after body" insertion mode
//------------------------------------------------------------------
function startTagAfterAfterBody(p, token) {
  if (token.tagID === html_js_1.TAG_ID.HTML) {
    startTagInBody(p, token);
  } else {
    tokenAfterAfterBody(p, token);
  }
}
function tokenAfterAfterBody(p, token) {
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
// The "after after frameset" insertion mode
//------------------------------------------------------------------
function startTagAfterAfterFrameset(p, token) {
  switch (token.tagID) {
    case html_js_1.TAG_ID.HTML:
      {
        startTagInBody(p, token);
        break;
      }
    case html_js_1.TAG_ID.NOFRAMES:
      {
        startTagInHead(p, token);
        break;
      }
    default:
    // Do nothing
  }
}
// The rules for parsing tokens in foreign content
//------------------------------------------------------------------
function nullCharacterInForeignContent(p, token) {
  token.chars = unicode.REPLACEMENT_CHARACTER;
  p._insertCharacters(token);
}
function characterInForeignContent(p, token) {
  p._insertCharacters(token);
  p.framesetOk = false;
}
function popUntilHtmlOrIntegrationPoint(p) {
  while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== html_js_1.NS.HTML && !p._isIntegrationPoint(p.openElements.currentTagId, p.openElements.current)) {
    p.openElements.pop();
  }
}
function startTagInForeignContent(p, token) {
  if (foreignContent.causesExit(token)) {
    popUntilHtmlOrIntegrationPoint(p);
    p._startTagOutsideForeignContent(token);
  } else {
    const current = p._getAdjustedCurrentElement();
    const currentNs = p.treeAdapter.getNamespaceURI(current);
    if (currentNs === html_js_1.NS.MATHML) {
      foreignContent.adjustTokenMathMLAttrs(token);
    } else if (currentNs === html_js_1.NS.SVG) {
      foreignContent.adjustTokenSVGTagName(token);
      foreignContent.adjustTokenSVGAttrs(token);
    }
    foreignContent.adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p._appendElement(token, currentNs);
    } else {
      p._insertElement(token, currentNs);
    }
    token.ackSelfClosing = true;
  }
}
function endTagInForeignContent(p, token) {
  if (token.tagID === html_js_1.TAG_ID.P || token.tagID === html_js_1.TAG_ID.BR) {
    popUntilHtmlOrIntegrationPoint(p);
    p._endTagOutsideForeignContent(token);
    return;
  }
  for (let i = p.openElements.stackTop; i > 0; i--) {
    const element = p.openElements.items[i];
    if (p.treeAdapter.getNamespaceURI(element) === html_js_1.NS.HTML) {
      p._endTagOutsideForeignContent(token);
      break;
    }
    const tagName = p.treeAdapter.getTagName(element);
    if (tagName.toLowerCase() === token.tagName) {
      //NOTE: update the token tag name for `_setEndLocation`.
      token.tagName = tagName;
      p.openElements.shortenToLength(i);
      break;
    }
  }
}

/***/ }),

/***/ "./node_modules/parse5/dist/cjs/parser/open-element-stack.js":
/*!*******************************************************************!*\
  !*** ./node_modules/parse5/dist/cjs/parser/open-element-stack.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OpenElementStack = void 0;
const html_js_1 = __webpack_require__(/*! ../common/html.js */ "./node_modules/parse5/dist/cjs/common/html.js");
//Element utils
const IMPLICIT_END_TAG_REQUIRED = new Set([html_js_1.TAG_ID.DD, html_js_1.TAG_ID.DT, html_js_1.TAG_ID.LI, html_js_1.TAG_ID.OPTGROUP, html_js_1.TAG_ID.OPTION, html_js_1.TAG_ID.P, html_js_1.TAG_ID.RB, html_js_1.TAG_ID.RP, html_js_1.TAG_ID.RT, html_js_1.TAG_ID.RTC]);
const IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = new Set([...IMPLICIT_END_TAG_REQUIRED, html_js_1.TAG_ID.CAPTION, html_js_1.TAG_ID.COLGROUP, html_js_1.TAG_ID.TBODY, html_js_1.TAG_ID.TD, html_js_1.TAG_ID.TFOOT, html_js_1.TAG_ID.TH, html_js_1.TAG_ID.THEAD, html_js_1.TAG_ID.TR]);
const SCOPING_ELEMENTS_HTML = new Set([html_js_1.TAG_ID.APPLET, html_js_1.TAG_ID.CAPTION, html_js_1.TAG_ID.HTML, html_js_1.TAG_ID.MARQUEE, html_js_1.TAG_ID.OBJECT, html_js_1.TAG_ID.TABLE, html_js_1.TAG_ID.TD, html_js_1.TAG_ID.TEMPLATE, html_js_1.TAG_ID.TH]);
const SCOPING_ELEMENTS_HTML_LIST = new Set([...SCOPING_ELEMENTS_HTML, html_js_1.TAG_ID.OL, html_js_1.TAG_ID.UL]);
const SCOPING_ELEMENTS_HTML_BUTTON = new Set([...SCOPING_ELEMENTS_HTML, html_js_1.TAG_ID.BUTTON]);
const SCOPING_ELEMENTS_MATHML = new Set([html_js_1.TAG_ID.ANNOTATION_XML, html_js_1.TAG_ID.MI, html_js_1.TAG_ID.MN, html_js_1.TAG_ID.MO, html_js_1.TAG_ID.MS, html_js_1.TAG_ID.MTEXT]);
const SCOPING_ELEMENTS_SVG = new Set([html_js_1.TAG_ID.DESC, html_js_1.TAG_ID.FOREIGN_OBJECT, html_js_1.TAG_ID.TITLE]);
const TABLE_ROW_CONTEXT = new Set([html_js_1.TAG_ID.TR, html_js_1.TAG_ID.TEMPLATE, html_js_1.TAG_ID.HTML]);
const TABLE_BODY_CONTEXT = new Set([html_js_1.TAG_ID.TBODY, html_js_1.TAG_ID.TFOOT, html_js_1.TAG_ID.THEAD, html_js_1.TAG_ID.TEMPLATE, html_js_1.TAG_ID.HTML]);
const TABLE_CONTEXT = new Set([html_js_1.TAG_ID.TABLE, html_js_1.TAG_ID.TEMPLATE, html_js_1.TAG_ID.HTML]);
const TABLE_CELLS = new Set([html_js_1.TAG_ID.TD, html_js_1.TAG_ID.TH]);
//Stack of open elements
class OpenElementStack {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(document, treeAdapter, handler) {
    this.treeAdapter = treeAdapter;
    this.handler = handler;
    this.items = [];
    this.tagIDs = [];
    this.stackTop = -1;
    this.tmplCount = 0;
    this.currentTagId = html_js_1.TAG_ID.UNKNOWN;
    this.current = document;
  }
  //Index of element
  _indexOf(element) {
    return this.items.lastIndexOf(element, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === html_js_1.TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === html_js_1.NS.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop];
    this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(element, tagID) {
    this.stackTop++;
    this.items[this.stackTop] = element;
    this.current = element;
    this.tagIDs[this.stackTop] = tagID;
    this.currentTagId = tagID;
    if (this._isInTemplate()) {
      this.tmplCount++;
    }
    this.handler.onItemPush(element, tagID, true);
  }
  pop() {
    const popped = this.current;
    if (this.tmplCount > 0 && this._isInTemplate()) {
      this.tmplCount--;
    }
    this.stackTop--;
    this._updateCurrentElement();
    this.handler.onItemPop(popped, true);
  }
  replace(oldElement, newElement) {
    const idx = this._indexOf(oldElement);
    this.items[idx] = newElement;
    if (idx === this.stackTop) {
      this.current = newElement;
    }
  }
  insertAfter(referenceElement, newElement, newElementID) {
    const insertionIdx = this._indexOf(referenceElement) + 1;
    this.items.splice(insertionIdx, 0, newElement);
    this.tagIDs.splice(insertionIdx, 0, newElementID);
    this.stackTop++;
    if (insertionIdx === this.stackTop) {
      this._updateCurrentElement();
    }
    this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
  }
  popUntilTagNamePopped(tagName) {
    let targetIdx = this.stackTop + 1;
    do {
      targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
    } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== html_js_1.NS.HTML);
    this.shortenToLength(targetIdx < 0 ? 0 : targetIdx);
  }
  shortenToLength(idx) {
    while (this.stackTop >= idx) {
      const popped = this.current;
      if (this.tmplCount > 0 && this._isInTemplate()) {
        this.tmplCount -= 1;
      }
      this.stackTop--;
      this._updateCurrentElement();
      this.handler.onItemPop(popped, this.stackTop < idx);
    }
  }
  popUntilElementPopped(element) {
    const idx = this._indexOf(element);
    this.shortenToLength(idx < 0 ? 0 : idx);
  }
  popUntilPopped(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx < 0 ? 0 : idx);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(html_js_1.NUMBERED_HEADERS, html_js_1.NS.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(TABLE_CELLS, html_js_1.NS.HTML);
  }
  popAllUpToHtmlElement() {
    //NOTE: here we assume that the root <html> element is always first in the open element stack, so
    //we perform this fast stack clean up.
    this.tmplCount = 0;
    this.shortenToLength(1);
  }
  _indexOfTagNames(tagNames, namespace) {
    for (let i = this.stackTop; i >= 0; i--) {
      if (tagNames.has(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === namespace) {
        return i;
      }
    }
    return -1;
  }
  clearBackTo(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(TABLE_CONTEXT, html_js_1.NS.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(TABLE_BODY_CONTEXT, html_js_1.NS.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(TABLE_ROW_CONTEXT, html_js_1.NS.HTML);
  }
  remove(element) {
    const idx = this._indexOf(element);
    if (idx >= 0) {
      if (idx === this.stackTop) {
        this.pop();
      } else {
        this.items.splice(idx, 1);
        this.tagIDs.splice(idx, 1);
        this.stackTop--;
        this._updateCurrentElement();
        this.handler.onItemPop(element, false);
      }
    }
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    //Properly nested <body> element (should be second element in stack).
    return this.stackTop >= 1 && this.tagIDs[1] === html_js_1.TAG_ID.BODY ? this.items[1] : null;
  }
  contains(element) {
    return this._indexOf(element) > -1;
  }
  getCommonAncestor(element) {
    const elementIdx = this._indexOf(element) - 1;
    return elementIdx >= 0 ? this.items[elementIdx] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === html_js_1.TAG_ID.HTML;
  }
  //Element in scope
  hasInDynamicScope(tagName, htmlScope) {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      switch (this.treeAdapter.getNamespaceURI(this.items[i])) {
        case html_js_1.NS.HTML:
          {
            if (tn === tagName) return true;
            if (htmlScope.has(tn)) return false;
            break;
          }
        case html_js_1.NS.SVG:
          {
            if (SCOPING_ELEMENTS_SVG.has(tn)) return false;
            break;
          }
        case html_js_1.NS.MATHML:
          {
            if (SCOPING_ELEMENTS_MATHML.has(tn)) return false;
            break;
          }
      }
    }
    return true;
  }
  hasInScope(tagName) {
    return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML);
  }
  hasInListItemScope(tagName) {
    return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_LIST);
  }
  hasInButtonScope(tagName) {
    return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_BUTTON);
  }
  hasNumberedHeaderInScope() {
    for (let i = this.stackTop; i >= 0; i--) {
      const tn = this.tagIDs[i];
      switch (this.treeAdapter.getNamespaceURI(this.items[i])) {
        case html_js_1.NS.HTML:
          {
            if (html_js_1.NUMBERED_HEADERS.has(tn)) return true;
            if (SCOPING_ELEMENTS_HTML.has(tn)) return false;
            break;
          }
        case html_js_1.NS.SVG:
          {
            if (SCOPING_ELEMENTS_SVG.has(tn)) return false;
            break;
          }
        case html_js_1.NS.MATHML:
          {
            if (SCOPING_ELEMENTS_MATHML.has(tn)) return false;
            break;
          }
      }
    }
    return true;
  }
  hasInTableScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      if (this.treeAdapter.getNamespaceURI(this.items[i]) !== html_js_1.NS.HTML) {
        continue;
      }
      switch (this.tagIDs[i]) {
        case tagName:
          {
            return true;
          }
        case html_js_1.TAG_ID.TABLE:
        case html_js_1.TAG_ID.HTML:
          {
            return false;
          }
      }
    }
    return true;
  }
  hasTableBodyContextInTableScope() {
    for (let i = this.stackTop; i >= 0; i--) {
      if (this.treeAdapter.getNamespaceURI(this.items[i]) !== html_js_1.NS.HTML) {
        continue;
      }
      switch (this.tagIDs[i]) {
        case html_js_1.TAG_ID.TBODY:
        case html_js_1.TAG_ID.THEAD:
        case html_js_1.TAG_ID.TFOOT:
          {
            return true;
          }
        case html_js_1.TAG_ID.TABLE:
        case html_js_1.TAG_ID.HTML:
          {
            return false;
          }
      }
    }
    return true;
  }
  hasInSelectScope(tagName) {
    for (let i = this.stackTop; i >= 0; i--) {
      if (this.treeAdapter.getNamespaceURI(this.items[i]) !== html_js_1.NS.HTML) {
        continue;
      }
      switch (this.tagIDs[i]) {
        case tagName:
          {
            return true;
          }
        case html_js_1.TAG_ID.OPTION:
        case html_js_1.TAG_ID.OPTGROUP:
          {
            break;
          }
        default:
          {
            return false;
          }
      }
    }
    return true;
  }
  //Implied end tags
  generateImpliedEndTags() {
    while (IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsThoroughly() {
    while (IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsWithExclusion(exclusionId) {
    while (this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
}
exports.OpenElementStack = OpenElementStack;

/***/ }),

/***/ "./node_modules/parse5/dist/cjs/serializer/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/parse5/dist/cjs/serializer/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.serialize = serialize;
exports.serializeOuter = serializeOuter;
const html_js_1 = __webpack_require__(/*! ../common/html.js */ "./node_modules/parse5/dist/cjs/common/html.js");
const escape_js_1 = __webpack_require__(/*! entities/lib/escape.js */ "./node_modules/entities/lib/escape.js");
const default_js_1 = __webpack_require__(/*! ../tree-adapters/default.js */ "./node_modules/parse5/dist/cjs/tree-adapters/default.js");
// Sets
const VOID_ELEMENTS = new Set([html_js_1.TAG_NAMES.AREA, html_js_1.TAG_NAMES.BASE, html_js_1.TAG_NAMES.BASEFONT, html_js_1.TAG_NAMES.BGSOUND, html_js_1.TAG_NAMES.BR, html_js_1.TAG_NAMES.COL, html_js_1.TAG_NAMES.EMBED, html_js_1.TAG_NAMES.FRAME, html_js_1.TAG_NAMES.HR, html_js_1.TAG_NAMES.IMG, html_js_1.TAG_NAMES.INPUT, html_js_1.TAG_NAMES.KEYGEN, html_js_1.TAG_NAMES.LINK, html_js_1.TAG_NAMES.META, html_js_1.TAG_NAMES.PARAM, html_js_1.TAG_NAMES.SOURCE, html_js_1.TAG_NAMES.TRACK, html_js_1.TAG_NAMES.WBR]);
function isVoidElement(node, options) {
  return options.treeAdapter.isElementNode(node) && options.treeAdapter.getNamespaceURI(node) === html_js_1.NS.HTML && VOID_ELEMENTS.has(options.treeAdapter.getTagName(node));
}
const defaultOpts = {
  treeAdapter: default_js_1.defaultTreeAdapter,
  scriptingEnabled: true
};
/**
 * Serializes an AST node to an HTML string.
 *
 * @example
 *
 * ```js
 * const parse5 = require('parse5');
 *
 * const document = parse5.parse('<!DOCTYPE html><html><head></head><body>Hi there!</body></html>');
 *
 * // Serializes a document.
 * const html = parse5.serialize(document);
 *
 * // Serializes the <html> element content.
 * const str = parse5.serialize(document.childNodes[1]);
 *
 * console.log(str); //> '<head></head><body>Hi there!</body>'
 * ```
 *
 * @param node Node to serialize.
 * @param options Serialization options.
 */
function serialize(node, options) {
  const opts = Object.assign(Object.assign({}, defaultOpts), options);
  if (isVoidElement(node, opts)) {
    return '';
  }
  return serializeChildNodes(node, opts);
}
/**
 * Serializes an AST element node to an HTML string, including the element node.
 *
 * @example
 *
 * ```js
 * const parse5 = require('parse5');
 *
 * const document = parse5.parseFragment('<div>Hello, <b>world</b>!</div>');
 *
 * // Serializes the <div> element.
 * const str = parse5.serializeOuter(document.childNodes[0]);
 *
 * console.log(str); //> '<div>Hello, <b>world</b>!</div>'
 * ```
 *
 * @param node Node to serialize.
 * @param options Serialization options.
 */
function serializeOuter(node, options) {
  const opts = Object.assign(Object.assign({}, defaultOpts), options);
  return serializeNode(node, opts);
}
function serializeChildNodes(parentNode, options) {
  let html = '';
  // Get container of the child nodes
  const container = options.treeAdapter.isElementNode(parentNode) && options.treeAdapter.getTagName(parentNode) === html_js_1.TAG_NAMES.TEMPLATE && options.treeAdapter.getNamespaceURI(parentNode) === html_js_1.NS.HTML ? options.treeAdapter.getTemplateContent(parentNode) : parentNode;
  const childNodes = options.treeAdapter.getChildNodes(container);
  if (childNodes) {
    for (const currentNode of childNodes) {
      html += serializeNode(currentNode, options);
    }
  }
  return html;
}
function serializeNode(node, options) {
  if (options.treeAdapter.isElementNode(node)) {
    return serializeElement(node, options);
  }
  if (options.treeAdapter.isTextNode(node)) {
    return serializeTextNode(node, options);
  }
  if (options.treeAdapter.isCommentNode(node)) {
    return serializeCommentNode(node, options);
  }
  if (options.treeAdapter.isDocumentTypeNode(node)) {
    return serializeDocumentTypeNode(node, options);
  }
  // Return an empty string for unknown nodes
  return '';
}
function serializeElement(node, options) {
  const tn = options.treeAdapter.getTagName(node);
  return `<${tn}${serializeAttributes(node, options)}>${isVoidElement(node, options) ? '' : `${serializeChildNodes(node, options)}</${tn}>`}`;
}
function serializeAttributes(node, {
  treeAdapter
}) {
  let html = '';
  for (const attr of treeAdapter.getAttrList(node)) {
    html += ' ';
    if (attr.namespace) {
      switch (attr.namespace) {
        case html_js_1.NS.XML:
          {
            html += `xml:${attr.name}`;
            break;
          }
        case html_js_1.NS.XMLNS:
          {
            if (attr.name !== 'xmlns') {
              html += 'xmlns:';
            }
            html += attr.name;
            break;
          }
        case html_js_1.NS.XLINK:
          {
            html += `xlink:${attr.name}`;
            break;
          }
        default:
          {
            html += `${attr.prefix}:${attr.name}`;
          }
      }
    } else {
      html += attr.name;
    }
    html += `="${(0, escape_js_1.escapeAttribute)(attr.value)}"`;
  }
  return html;
}
function serializeTextNode(node, options) {
  const {
    treeAdapter
  } = options;
  const content = treeAdapter.getTextNodeContent(node);
  const parent = treeAdapter.getParentNode(node);
  const parentTn = parent && treeAdapter.isElementNode(parent) && treeAdapter.getTagName(parent);
  return parentTn && treeAdapter.getNamespaceURI(parent) === html_js_1.NS.HTML && (0, html_js_1.hasUnescapedText)(parentTn, options.scriptingEnabled) ? content : (0, escape_js_1.escapeText)(content);
}
function serializeCommentNode(node, {
  treeAdapter
}) {
  return `<!--${treeAdapter.getCommentNodeContent(node)}-->`;
}
function serializeDocumentTypeNode(node, {
  treeAdapter
}) {
  return `<!DOCTYPE ${treeAdapter.getDocumentTypeNodeName(node)}>`;
}

/***/ }),

/***/ "./node_modules/parse5/dist/cjs/tokenizer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/parse5/dist/cjs/tokenizer/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Tokenizer = exports.TokenizerMode = void 0;
const preprocessor_js_1 = __webpack_require__(/*! ./preprocessor.js */ "./node_modules/parse5/dist/cjs/tokenizer/preprocessor.js");
const unicode_js_1 = __webpack_require__(/*! ../common/unicode.js */ "./node_modules/parse5/dist/cjs/common/unicode.js");
const token_js_1 = __webpack_require__(/*! ../common/token.js */ "./node_modules/parse5/dist/cjs/common/token.js");
const decode_js_1 = __webpack_require__(/*! entities/lib/decode.js */ "./node_modules/entities/lib/decode.js");
const error_codes_js_1 = __webpack_require__(/*! ../common/error-codes.js */ "./node_modules/parse5/dist/cjs/common/error-codes.js");
const html_js_1 = __webpack_require__(/*! ../common/html.js */ "./node_modules/parse5/dist/cjs/common/html.js");
//States
var State;
(function (State) {
  State[State["DATA"] = 0] = "DATA";
  State[State["RCDATA"] = 1] = "RCDATA";
  State[State["RAWTEXT"] = 2] = "RAWTEXT";
  State[State["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
  State[State["PLAINTEXT"] = 4] = "PLAINTEXT";
  State[State["TAG_OPEN"] = 5] = "TAG_OPEN";
  State[State["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
  State[State["TAG_NAME"] = 7] = "TAG_NAME";
  State[State["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
  State[State["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
  State[State["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
  State[State["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
  State[State["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
  State[State["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
  State[State["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
  State[State["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
  State[State["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
  State[State["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
  State[State["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
  State[State["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
  State[State["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
  State[State["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
  State[State["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
  State[State["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
  State[State["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
  State[State["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
  State[State["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
  State[State["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
  State[State["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
  State[State["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
  State[State["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
  State[State["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
  State[State["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
  State[State["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
  State[State["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
  State[State["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
  State[State["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
  State[State["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
  State[State["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
  State[State["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
  State[State["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
  State[State["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
  State[State["COMMENT_START"] = 42] = "COMMENT_START";
  State[State["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
  State[State["COMMENT"] = 44] = "COMMENT";
  State[State["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
  State[State["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
  State[State["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
  State[State["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
  State[State["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
  State[State["COMMENT_END"] = 50] = "COMMENT_END";
  State[State["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
  State[State["DOCTYPE"] = 52] = "DOCTYPE";
  State[State["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
  State[State["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
  State[State["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
  State[State["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
  State[State["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
  State[State["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
  State[State["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
  State[State["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
  State[State["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
  State[State["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
  State[State["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
  State[State["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
  State[State["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
  State[State["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
  State[State["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
  State[State["CDATA_SECTION"] = 68] = "CDATA_SECTION";
  State[State["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
  State[State["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
  State[State["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
  State[State["AMBIGUOUS_AMPERSAND"] = 72] = "AMBIGUOUS_AMPERSAND";
})(State || (State = {}));
//Tokenizer initial states for different modes
exports.TokenizerMode = {
  DATA: State.DATA,
  RCDATA: State.RCDATA,
  RAWTEXT: State.RAWTEXT,
  SCRIPT_DATA: State.SCRIPT_DATA,
  PLAINTEXT: State.PLAINTEXT,
  CDATA_SECTION: State.CDATA_SECTION
};
//Utils
//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline
//this functions if they will be situated in another module due to context switch.
//Always perform inlining check before modifying this functions ('node --trace-inlining').
function isAsciiDigit(cp) {
  return cp >= unicode_js_1.CODE_POINTS.DIGIT_0 && cp <= unicode_js_1.CODE_POINTS.DIGIT_9;
}
function isAsciiUpper(cp) {
  return cp >= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_CAPITAL_Z;
}
function isAsciiLower(cp) {
  return cp >= unicode_js_1.CODE_POINTS.LATIN_SMALL_A && cp <= unicode_js_1.CODE_POINTS.LATIN_SMALL_Z;
}
function isAsciiLetter(cp) {
  return isAsciiLower(cp) || isAsciiUpper(cp);
}
function isAsciiAlphaNumeric(cp) {
  return isAsciiLetter(cp) || isAsciiDigit(cp);
}
function toAsciiLower(cp) {
  return cp + 32;
}
function isWhitespace(cp) {
  return cp === unicode_js_1.CODE_POINTS.SPACE || cp === unicode_js_1.CODE_POINTS.LINE_FEED || cp === unicode_js_1.CODE_POINTS.TABULATION || cp === unicode_js_1.CODE_POINTS.FORM_FEED;
}
function isScriptDataDoubleEscapeSequenceEnd(cp) {
  return isWhitespace(cp) || cp === unicode_js_1.CODE_POINTS.SOLIDUS || cp === unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN;
}
function getErrorForNumericCharacterReference(code) {
  if (code === unicode_js_1.CODE_POINTS.NULL) {
    return error_codes_js_1.ERR.nullCharacterReference;
  } else if (code > 1114111) {
    return error_codes_js_1.ERR.characterReferenceOutsideUnicodeRange;
  } else if ((0, unicode_js_1.isSurrogate)(code)) {
    return error_codes_js_1.ERR.surrogateCharacterReference;
  } else if ((0, unicode_js_1.isUndefinedCodePoint)(code)) {
    return error_codes_js_1.ERR.noncharacterCharacterReference;
  } else if ((0, unicode_js_1.isControlCodePoint)(code) || code === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN) {
    return error_codes_js_1.ERR.controlCharacterReference;
  }
  return null;
}
//Tokenizer
class Tokenizer {
  constructor(options, handler) {
    this.options = options;
    this.handler = handler;
    this.paused = false;
    /** Ensures that the parsing loop isn't run multiple times at once. */
    this.inLoop = false;
    /**
     * Indicates that the current adjusted node exists, is not an element in the HTML namespace,
     * and that it is not an integration point for either MathML or HTML.
     *
     * @see {@link https://html.spec.whatwg.org/multipage/parsing.html#tree-construction}
     */
    this.inForeignNode = false;
    this.lastStartTagName = '';
    this.active = false;
    this.state = State.DATA;
    this.returnState = State.DATA;
    this.entityStartPos = 0;
    this.consumedAfterSnapshot = -1;
    this.currentCharacterToken = null;
    this.currentToken = null;
    this.currentAttr = {
      name: '',
      value: ''
    };
    this.preprocessor = new preprocessor_js_1.Preprocessor(handler);
    this.currentLocation = this.getCurrentLocation(-1);
    this.entityDecoder = new decode_js_1.EntityDecoder(decode_js_1.htmlDecodeTree, (cp, consumed) => {
      // Note: Set `pos` _before_ flushing, as flushing might drop
      // the current chunk and invalidate `entityStartPos`.
      this.preprocessor.pos = this.entityStartPos + consumed - 1;
      this._flushCodePointConsumedAsCharacterReference(cp);
    }, handler.onParseError ? {
      missingSemicolonAfterCharacterReference: () => {
        this._err(error_codes_js_1.ERR.missingSemicolonAfterCharacterReference, 1);
      },
      absenceOfDigitsInNumericCharacterReference: consumed => {
        this._err(error_codes_js_1.ERR.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + consumed);
      },
      validateNumericCharacterReference: code => {
        const error = getErrorForNumericCharacterReference(code);
        if (error) this._err(error, 1);
      }
    } : undefined);
  }
  //Errors
  _err(code, cpOffset = 0) {
    var _a, _b;
    (_b = (_a = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a, this.preprocessor.getError(code, cpOffset));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(offset) {
    if (!this.options.sourceCodeLocationInfo) {
      return null;
    }
    return {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - offset,
      startOffset: this.preprocessor.offset - offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
  }
  _runParsingLoop() {
    if (this.inLoop) return;
    this.inLoop = true;
    while (this.active && !this.paused) {
      this.consumedAfterSnapshot = 0;
      const cp = this._consume();
      if (!this._ensureHibernation()) {
        this._callState(cp);
      }
    }
    this.inLoop = false;
  }
  //API
  pause() {
    this.paused = true;
  }
  resume(writeCallback) {
    if (!this.paused) {
      throw new Error('Parser was already resumed');
    }
    this.paused = false;
    // Necessary for synchronous resume.
    if (this.inLoop) return;
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  write(chunk, isLastChunk, writeCallback) {
    this.active = true;
    this.preprocessor.write(chunk, isLastChunk);
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  insertHtmlAtCurrentPos(chunk) {
    this.active = true;
    this.preprocessor.insertHtmlAtCurrentPos(chunk);
    this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    if (this.preprocessor.endOfChunkHit) {
      this.preprocessor.retreat(this.consumedAfterSnapshot);
      this.consumedAfterSnapshot = 0;
      this.active = false;
      return true;
    }
    return false;
  }
  //Consumption
  _consume() {
    this.consumedAfterSnapshot++;
    return this.preprocessor.advance();
  }
  _advanceBy(count) {
    this.consumedAfterSnapshot += count;
    for (let i = 0; i < count; i++) {
      this.preprocessor.advance();
    }
  }
  _consumeSequenceIfMatch(pattern, caseSensitive) {
    if (this.preprocessor.startsWith(pattern, caseSensitive)) {
      // We will already have consumed one character before calling this method.
      this._advanceBy(pattern.length - 1);
      return true;
    }
    return false;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: token_js_1.TokenType.START_TAG,
      tagName: '',
      tagID: html_js_1.TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: token_js_1.TokenType.END_TAG,
      tagName: '',
      tagID: html_js_1.TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(offset) {
    this.currentToken = {
      type: token_js_1.TokenType.COMMENT,
      data: '',
      location: this.getCurrentLocation(offset)
    };
  }
  _createDoctypeToken(initialName) {
    this.currentToken = {
      type: token_js_1.TokenType.DOCTYPE,
      name: initialName,
      forceQuirks: false,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(type, chars) {
    this.currentCharacterToken = {
      type,
      chars,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(attrNameFirstCh) {
    this.currentAttr = {
      name: attrNameFirstCh,
      value: ''
    };
    this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var _a;
    var _b;
    const token = this.currentToken;
    if ((0, token_js_1.getTokenAttr)(token, this.currentAttr.name) === null) {
      token.attrs.push(this.currentAttr);
      if (token.location && this.currentLocation) {
        const attrLocations = (_a = (_b = token.location).attrs) !== null && _a !== void 0 ? _a : _b.attrs = Object.create(null);
        attrLocations[this.currentAttr.name] = this.currentLocation;
        // Set end location
        this._leaveAttrValue();
      }
    } else {
      this._err(error_codes_js_1.ERR.duplicateAttribute);
    }
  }
  _leaveAttrValue() {
    if (this.currentLocation) {
      this.currentLocation.endLine = this.preprocessor.line;
      this.currentLocation.endCol = this.preprocessor.col;
      this.currentLocation.endOffset = this.preprocessor.offset;
    }
  }
  //Token emission
  prepareToken(ct) {
    this._emitCurrentCharacterToken(ct.location);
    this.currentToken = null;
    if (ct.location) {
      ct.location.endLine = this.preprocessor.line;
      ct.location.endCol = this.preprocessor.col + 1;
      ct.location.endOffset = this.preprocessor.offset + 1;
    }
    this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const ct = this.currentToken;
    this.prepareToken(ct);
    ct.tagID = (0, html_js_1.getTagID)(ct.tagName);
    if (ct.type === token_js_1.TokenType.START_TAG) {
      this.lastStartTagName = ct.tagName;
      this.handler.onStartTag(ct);
    } else {
      if (ct.attrs.length > 0) {
        this._err(error_codes_js_1.ERR.endTagWithAttributes);
      }
      if (ct.selfClosing) {
        this._err(error_codes_js_1.ERR.endTagWithTrailingSolidus);
      }
      this.handler.onEndTag(ct);
    }
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(ct) {
    this.prepareToken(ct);
    this.handler.onComment(ct);
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(ct) {
    this.prepareToken(ct);
    this.handler.onDoctype(ct);
    this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(nextLocation) {
    if (this.currentCharacterToken) {
      //NOTE: if we have a pending character token, make it's end location equal to the
      //current token's start location.
      if (nextLocation && this.currentCharacterToken.location) {
        this.currentCharacterToken.location.endLine = nextLocation.startLine;
        this.currentCharacterToken.location.endCol = nextLocation.startCol;
        this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
      }
      switch (this.currentCharacterToken.type) {
        case token_js_1.TokenType.CHARACTER:
          {
            this.handler.onCharacter(this.currentCharacterToken);
            break;
          }
        case token_js_1.TokenType.NULL_CHARACTER:
          {
            this.handler.onNullCharacter(this.currentCharacterToken);
            break;
          }
        case token_js_1.TokenType.WHITESPACE_CHARACTER:
          {
            this.handler.onWhitespaceCharacter(this.currentCharacterToken);
            break;
          }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const location = this.getCurrentLocation(0);
    if (location) {
      location.endLine = location.startLine;
      location.endCol = location.startCol;
      location.endOffset = location.startOffset;
    }
    this._emitCurrentCharacterToken(location);
    this.handler.onEof({
      type: token_js_1.TokenType.EOF,
      location
    });
    this.active = false;
  }
  //Characters emission
  //OPTIMIZATION: The specification uses only one type of character token (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(type, ch) {
    if (this.currentCharacterToken) {
      if (this.currentCharacterToken.type === type) {
        this.currentCharacterToken.chars += ch;
        return;
      } else {
        this.currentLocation = this.getCurrentLocation(0);
        this._emitCurrentCharacterToken(this.currentLocation);
        this.preprocessor.dropParsedChunk();
      }
    }
    this._createCharacterToken(type, ch);
  }
  _emitCodePoint(cp) {
    const type = isWhitespace(cp) ? token_js_1.TokenType.WHITESPACE_CHARACTER : cp === unicode_js_1.CODE_POINTS.NULL ? token_js_1.TokenType.NULL_CHARACTER : token_js_1.TokenType.CHARACTER;
    this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(ch) {
    this._appendCharToCurrentCharacterToken(token_js_1.TokenType.CHARACTER, ch);
  }
  // Character reference helpers
  _startCharacterReference() {
    this.returnState = this.state;
    this.state = State.CHARACTER_REFERENCE;
    this.entityStartPos = this.preprocessor.pos;
    this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? decode_js_1.DecodingMode.Attribute : decode_js_1.DecodingMode.Legacy);
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(cp) {
    if (this._isCharacterReferenceInAttribute()) {
      this.currentAttr.value += String.fromCodePoint(cp);
    } else {
      this._emitCodePoint(cp);
    }
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(cp) {
    switch (this.state) {
      case State.DATA:
        {
          this._stateData(cp);
          break;
        }
      case State.RCDATA:
        {
          this._stateRcdata(cp);
          break;
        }
      case State.RAWTEXT:
        {
          this._stateRawtext(cp);
          break;
        }
      case State.SCRIPT_DATA:
        {
          this._stateScriptData(cp);
          break;
        }
      case State.PLAINTEXT:
        {
          this._statePlaintext(cp);
          break;
        }
      case State.TAG_OPEN:
        {
          this._stateTagOpen(cp);
          break;
        }
      case State.END_TAG_OPEN:
        {
          this._stateEndTagOpen(cp);
          break;
        }
      case State.TAG_NAME:
        {
          this._stateTagName(cp);
          break;
        }
      case State.RCDATA_LESS_THAN_SIGN:
        {
          this._stateRcdataLessThanSign(cp);
          break;
        }
      case State.RCDATA_END_TAG_OPEN:
        {
          this._stateRcdataEndTagOpen(cp);
          break;
        }
      case State.RCDATA_END_TAG_NAME:
        {
          this._stateRcdataEndTagName(cp);
          break;
        }
      case State.RAWTEXT_LESS_THAN_SIGN:
        {
          this._stateRawtextLessThanSign(cp);
          break;
        }
      case State.RAWTEXT_END_TAG_OPEN:
        {
          this._stateRawtextEndTagOpen(cp);
          break;
        }
      case State.RAWTEXT_END_TAG_NAME:
        {
          this._stateRawtextEndTagName(cp);
          break;
        }
      case State.SCRIPT_DATA_LESS_THAN_SIGN:
        {
          this._stateScriptDataLessThanSign(cp);
          break;
        }
      case State.SCRIPT_DATA_END_TAG_OPEN:
        {
          this._stateScriptDataEndTagOpen(cp);
          break;
        }
      case State.SCRIPT_DATA_END_TAG_NAME:
        {
          this._stateScriptDataEndTagName(cp);
          break;
        }
      case State.SCRIPT_DATA_ESCAPE_START:
        {
          this._stateScriptDataEscapeStart(cp);
          break;
        }
      case State.SCRIPT_DATA_ESCAPE_START_DASH:
        {
          this._stateScriptDataEscapeStartDash(cp);
          break;
        }
      case State.SCRIPT_DATA_ESCAPED:
        {
          this._stateScriptDataEscaped(cp);
          break;
        }
      case State.SCRIPT_DATA_ESCAPED_DASH:
        {
          this._stateScriptDataEscapedDash(cp);
          break;
        }
      case State.SCRIPT_DATA_ESCAPED_DASH_DASH:
        {
          this._stateScriptDataEscapedDashDash(cp);
          break;
        }
      case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN:
        {
          this._stateScriptDataEscapedLessThanSign(cp);
          break;
        }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN:
        {
          this._stateScriptDataEscapedEndTagOpen(cp);
          break;
        }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME:
        {
          this._stateScriptDataEscapedEndTagName(cp);
          break;
        }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_START:
        {
          this._stateScriptDataDoubleEscapeStart(cp);
          break;
        }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED:
        {
          this._stateScriptDataDoubleEscaped(cp);
          break;
        }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH:
        {
          this._stateScriptDataDoubleEscapedDash(cp);
          break;
        }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH:
        {
          this._stateScriptDataDoubleEscapedDashDash(cp);
          break;
        }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN:
        {
          this._stateScriptDataDoubleEscapedLessThanSign(cp);
          break;
        }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_END:
        {
          this._stateScriptDataDoubleEscapeEnd(cp);
          break;
        }
      case State.BEFORE_ATTRIBUTE_NAME:
        {
          this._stateBeforeAttributeName(cp);
          break;
        }
      case State.ATTRIBUTE_NAME:
        {
          this._stateAttributeName(cp);
          break;
        }
      case State.AFTER_ATTRIBUTE_NAME:
        {
          this._stateAfterAttributeName(cp);
          break;
        }
      case State.BEFORE_ATTRIBUTE_VALUE:
        {
          this._stateBeforeAttributeValue(cp);
          break;
        }
      case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED:
        {
          this._stateAttributeValueDoubleQuoted(cp);
          break;
        }
      case State.ATTRIBUTE_VALUE_SINGLE_QUOTED:
        {
          this._stateAttributeValueSingleQuoted(cp);
          break;
        }
      case State.ATTRIBUTE_VALUE_UNQUOTED:
        {
          this._stateAttributeValueUnquoted(cp);
          break;
        }
      case State.AFTER_ATTRIBUTE_VALUE_QUOTED:
        {
          this._stateAfterAttributeValueQuoted(cp);
          break;
        }
      case State.SELF_CLOSING_START_TAG:
        {
          this._stateSelfClosingStartTag(cp);
          break;
        }
      case State.BOGUS_COMMENT:
        {
          this._stateBogusComment(cp);
          break;
        }
      case State.MARKUP_DECLARATION_OPEN:
        {
          this._stateMarkupDeclarationOpen(cp);
          break;
        }
      case State.COMMENT_START:
        {
          this._stateCommentStart(cp);
          break;
        }
      case State.COMMENT_START_DASH:
        {
          this._stateCommentStartDash(cp);
          break;
        }
      case State.COMMENT:
        {
          this._stateComment(cp);
          break;
        }
      case State.COMMENT_LESS_THAN_SIGN:
        {
          this._stateCommentLessThanSign(cp);
          break;
        }
      case State.COMMENT_LESS_THAN_SIGN_BANG:
        {
          this._stateCommentLessThanSignBang(cp);
          break;
        }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH:
        {
          this._stateCommentLessThanSignBangDash(cp);
          break;
        }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH:
        {
          this._stateCommentLessThanSignBangDashDash(cp);
          break;
        }
      case State.COMMENT_END_DASH:
        {
          this._stateCommentEndDash(cp);
          break;
        }
      case State.COMMENT_END:
        {
          this._stateCommentEnd(cp);
          break;
        }
      case State.COMMENT_END_BANG:
        {
          this._stateCommentEndBang(cp);
          break;
        }
      case State.DOCTYPE:
        {
          this._stateDoctype(cp);
          break;
        }
      case State.BEFORE_DOCTYPE_NAME:
        {
          this._stateBeforeDoctypeName(cp);
          break;
        }
      case State.DOCTYPE_NAME:
        {
          this._stateDoctypeName(cp);
          break;
        }
      case State.AFTER_DOCTYPE_NAME:
        {
          this._stateAfterDoctypeName(cp);
          break;
        }
      case State.AFTER_DOCTYPE_PUBLIC_KEYWORD:
        {
          this._stateAfterDoctypePublicKeyword(cp);
          break;
        }
      case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER:
        {
          this._stateBeforeDoctypePublicIdentifier(cp);
          break;
        }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED:
        {
          this._stateDoctypePublicIdentifierDoubleQuoted(cp);
          break;
        }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED:
        {
          this._stateDoctypePublicIdentifierSingleQuoted(cp);
          break;
        }
      case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER:
        {
          this._stateAfterDoctypePublicIdentifier(cp);
          break;
        }
      case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS:
        {
          this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
          break;
        }
      case State.AFTER_DOCTYPE_SYSTEM_KEYWORD:
        {
          this._stateAfterDoctypeSystemKeyword(cp);
          break;
        }
      case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER:
        {
          this._stateBeforeDoctypeSystemIdentifier(cp);
          break;
        }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED:
        {
          this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
          break;
        }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED:
        {
          this._stateDoctypeSystemIdentifierSingleQuoted(cp);
          break;
        }
      case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER:
        {
          this._stateAfterDoctypeSystemIdentifier(cp);
          break;
        }
      case State.BOGUS_DOCTYPE:
        {
          this._stateBogusDoctype(cp);
          break;
        }
      case State.CDATA_SECTION:
        {
          this._stateCdataSection(cp);
          break;
        }
      case State.CDATA_SECTION_BRACKET:
        {
          this._stateCdataSectionBracket(cp);
          break;
        }
      case State.CDATA_SECTION_END:
        {
          this._stateCdataSectionEnd(cp);
          break;
        }
      case State.CHARACTER_REFERENCE:
        {
          this._stateCharacterReference();
          break;
        }
      case State.AMBIGUOUS_AMPERSAND:
        {
          this._stateAmbiguousAmpersand(cp);
          break;
        }
      default:
        {
          throw new Error('Unknown state');
        }
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
        {
          this.state = State.TAG_OPEN;
          break;
        }
      case unicode_js_1.CODE_POINTS.AMPERSAND:
        {
          this._startCharacterReference();
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          this._emitCodePoint(cp);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._emitCodePoint(cp);
        }
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.AMPERSAND:
        {
          this._startCharacterReference();
          break;
        }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
        {
          this.state = State.RCDATA_LESS_THAN_SIGN;
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._emitCodePoint(cp);
        }
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
        {
          this.state = State.RAWTEXT_LESS_THAN_SIGN;
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._emitCodePoint(cp);
        }
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
        {
          this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._emitCodePoint(cp);
        }
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._emitCodePoint(cp);
        }
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createStartTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else switch (cp) {
      case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK:
        {
          this.state = State.MARKUP_DECLARATION_OPEN;
          break;
        }
      case unicode_js_1.CODE_POINTS.SOLIDUS:
        {
          this.state = State.END_TAG_OPEN;
          break;
        }
      case unicode_js_1.CODE_POINTS.QUESTION_MARK:
        {
          this._err(error_codes_js_1.ERR.unexpectedQuestionMarkInsteadOfTagName);
          this._createCommentToken(1);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofBeforeTagName);
          this._emitChars('<');
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._err(error_codes_js_1.ERR.invalidFirstCharacterOfTagName);
          this._emitChars('<');
          this.state = State.DATA;
          this._stateData(cp);
        }
    }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createEndTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else switch (cp) {
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._err(error_codes_js_1.ERR.missingEndTagName);
          this.state = State.DATA;
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofBeforeTagName);
          this._emitChars('</');
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._err(error_codes_js_1.ERR.invalidFirstCharacterOfTagName);
          this._createCommentToken(2);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
        }
    }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          this.state = State.BEFORE_ATTRIBUTE_NAME;
          break;
        }
      case unicode_js_1.CODE_POINTS.SOLIDUS:
        {
          this.state = State.SELF_CLOSING_START_TAG;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this.state = State.DATA;
          this.emitCurrentTagToken();
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          token.tagName += unicode_js_1.REPLACEMENT_CHARACTER;
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInTag);
          this._emitEOFToken();
          break;
        }
      default:
        {
          token.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
        }
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(cp) {
    if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
      this.state = State.RCDATA_END_TAG_OPEN;
    } else {
      this._emitChars('<');
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RCDATA_END_TAG_NAME;
      this._stateRcdataEndTagName(cp);
    } else {
      this._emitChars('</');
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  handleSpecialEndTag(_cp) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
      return !this._ensureHibernation();
    }
    this._createEndTagToken();
    const token = this.currentToken;
    token.tagName = this.lastStartTagName;
    const cp = this.preprocessor.peek(this.lastStartTagName.length);
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          this._advanceBy(this.lastStartTagName.length);
          this.state = State.BEFORE_ATTRIBUTE_NAME;
          return false;
        }
      case unicode_js_1.CODE_POINTS.SOLIDUS:
        {
          this._advanceBy(this.lastStartTagName.length);
          this.state = State.SELF_CLOSING_START_TAG;
          return false;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._advanceBy(this.lastStartTagName.length);
          this.emitCurrentTagToken();
          this.state = State.DATA;
          return false;
        }
      default:
        {
          return !this._ensureHibernation();
        }
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars('</');
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(cp) {
    if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
      this.state = State.RAWTEXT_END_TAG_OPEN;
    } else {
      this._emitChars('<');
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RAWTEXT_END_TAG_NAME;
      this._stateRawtextEndTagName(cp);
    } else {
      this._emitChars('</');
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars('</');
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SOLIDUS:
        {
          this.state = State.SCRIPT_DATA_END_TAG_OPEN;
          break;
        }
      case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK:
        {
          this.state = State.SCRIPT_DATA_ESCAPE_START;
          this._emitChars('<!');
          break;
        }
      default:
        {
          this._emitChars('<');
          this.state = State.SCRIPT_DATA;
          this._stateScriptData(cp);
        }
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_END_TAG_NAME;
      this._stateScriptDataEndTagName(cp);
    } else {
      this._emitChars('</');
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars('</');
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(cp) {
    if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPE_START_DASH;
      this._emitChars('-');
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(cp) {
    if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
      this._emitChars('-');
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:
        {
          this.state = State.SCRIPT_DATA_ESCAPED_DASH;
          this._emitChars('-');
          break;
        }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
        {
          this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._emitCodePoint(cp);
        }
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:
        {
          this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
          this._emitChars('-');
          break;
        }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
        {
          this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          this.state = State.SCRIPT_DATA_ESCAPED;
          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this.state = State.SCRIPT_DATA_ESCAPED;
          this._emitCodePoint(cp);
        }
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:
        {
          this._emitChars('-');
          break;
        }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
        {
          this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this.state = State.SCRIPT_DATA;
          this._emitChars('>');
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          this.state = State.SCRIPT_DATA_ESCAPED;
          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this.state = State.SCRIPT_DATA_ESCAPED;
          this._emitCodePoint(cp);
        }
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(cp) {
    if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
    } else if (isAsciiLetter(cp)) {
      this._emitChars('<');
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START;
      this._stateScriptDataDoubleEscapeStart(cp);
    } else {
      this._emitChars('<');
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
      this._stateScriptDataEscapedEndTagName(cp);
    } else {
      this._emitChars('</');
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars('</');
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(cp) {
    if (this.preprocessor.startsWith(unicode_js_1.SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(unicode_js_1.SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i = 0; i < unicode_js_1.SEQUENCES.SCRIPT.length; i++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:
        {
          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
          this._emitChars('-');
          break;
        }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
        {
          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
          this._emitChars('<');
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._emitCodePoint(cp);
        }
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:
        {
          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
          this._emitChars('-');
          break;
        }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
        {
          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
          this._emitChars('<');
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
          this._emitCodePoint(cp);
        }
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:
        {
          this._emitChars('-');
          break;
        }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
        {
          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
          this._emitChars('<');
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this.state = State.SCRIPT_DATA;
          this._emitChars('>');
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
          this._emitChars(unicode_js_1.REPLACEMENT_CHARACTER);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
          this._emitCodePoint(cp);
        }
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(cp) {
    if (cp === unicode_js_1.CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END;
      this._emitChars('/');
    } else {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(cp) {
    if (this.preprocessor.startsWith(unicode_js_1.SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(unicode_js_1.SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i = 0; i < unicode_js_1.SEQUENCES.SCRIPT.length; i++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          // Ignore whitespace
          break;
        }
      case unicode_js_1.CODE_POINTS.SOLIDUS:
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this.state = State.AFTER_ATTRIBUTE_NAME;
          this._stateAfterAttributeName(cp);
          break;
        }
      case unicode_js_1.CODE_POINTS.EQUALS_SIGN:
        {
          this._err(error_codes_js_1.ERR.unexpectedEqualsSignBeforeAttributeName);
          this._createAttr('=');
          this.state = State.ATTRIBUTE_NAME;
          break;
        }
      default:
        {
          this._createAttr('');
          this.state = State.ATTRIBUTE_NAME;
          this._stateAttributeName(cp);
        }
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
      case unicode_js_1.CODE_POINTS.SOLIDUS:
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._leaveAttrName();
          this.state = State.AFTER_ATTRIBUTE_NAME;
          this._stateAfterAttributeName(cp);
          break;
        }
      case unicode_js_1.CODE_POINTS.EQUALS_SIGN:
        {
          this._leaveAttrName();
          this.state = State.BEFORE_ATTRIBUTE_VALUE;
          break;
        }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
      case unicode_js_1.CODE_POINTS.APOSTROPHE:
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
        {
          this._err(error_codes_js_1.ERR.unexpectedCharacterInAttributeName);
          this.currentAttr.name += String.fromCodePoint(cp);
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          this.currentAttr.name += unicode_js_1.REPLACEMENT_CHARACTER;
          break;
        }
      default:
        {
          this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
        }
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          // Ignore whitespace
          break;
        }
      case unicode_js_1.CODE_POINTS.SOLIDUS:
        {
          this.state = State.SELF_CLOSING_START_TAG;
          break;
        }
      case unicode_js_1.CODE_POINTS.EQUALS_SIGN:
        {
          this.state = State.BEFORE_ATTRIBUTE_VALUE;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this.state = State.DATA;
          this.emitCurrentTagToken();
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInTag);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._createAttr('');
          this.state = State.ATTRIBUTE_NAME;
          this._stateAttributeName(cp);
        }
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          // Ignore whitespace
          break;
        }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
        {
          this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
          break;
        }
      case unicode_js_1.CODE_POINTS.APOSTROPHE:
        {
          this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._err(error_codes_js_1.ERR.missingAttributeValue);
          this.state = State.DATA;
          this.emitCurrentTagToken();
          break;
        }
      default:
        {
          this.state = State.ATTRIBUTE_VALUE_UNQUOTED;
          this._stateAttributeValueUnquoted(cp);
        }
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
        {
          this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
          break;
        }
      case unicode_js_1.CODE_POINTS.AMPERSAND:
        {
          this._startCharacterReference();
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInTag);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this.currentAttr.value += String.fromCodePoint(cp);
        }
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.APOSTROPHE:
        {
          this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
          break;
        }
      case unicode_js_1.CODE_POINTS.AMPERSAND:
        {
          this._startCharacterReference();
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInTag);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this.currentAttr.value += String.fromCodePoint(cp);
        }
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          this._leaveAttrValue();
          this.state = State.BEFORE_ATTRIBUTE_NAME;
          break;
        }
      case unicode_js_1.CODE_POINTS.AMPERSAND:
        {
          this._startCharacterReference();
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._leaveAttrValue();
          this.state = State.DATA;
          this.emitCurrentTagToken();
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          this.currentAttr.value += unicode_js_1.REPLACEMENT_CHARACTER;
          break;
        }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
      case unicode_js_1.CODE_POINTS.APOSTROPHE:
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
      case unicode_js_1.CODE_POINTS.EQUALS_SIGN:
      case unicode_js_1.CODE_POINTS.GRAVE_ACCENT:
        {
          this._err(error_codes_js_1.ERR.unexpectedCharacterInUnquotedAttributeValue);
          this.currentAttr.value += String.fromCodePoint(cp);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInTag);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this.currentAttr.value += String.fromCodePoint(cp);
        }
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          this._leaveAttrValue();
          this.state = State.BEFORE_ATTRIBUTE_NAME;
          break;
        }
      case unicode_js_1.CODE_POINTS.SOLIDUS:
        {
          this._leaveAttrValue();
          this.state = State.SELF_CLOSING_START_TAG;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._leaveAttrValue();
          this.state = State.DATA;
          this.emitCurrentTagToken();
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInTag);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._err(error_codes_js_1.ERR.missingWhitespaceBetweenAttributes);
          this.state = State.BEFORE_ATTRIBUTE_NAME;
          this._stateBeforeAttributeName(cp);
        }
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          const token = this.currentToken;
          token.selfClosing = true;
          this.state = State.DATA;
          this.emitCurrentTagToken();
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInTag);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._err(error_codes_js_1.ERR.unexpectedSolidusInTag);
          this.state = State.BEFORE_ATTRIBUTE_NAME;
          this._stateBeforeAttributeName(cp);
        }
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this.state = State.DATA;
          this.emitCurrentComment(token);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this.emitCurrentComment(token);
          this._emitEOFToken();
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          token.data += unicode_js_1.REPLACEMENT_CHARACTER;
          break;
        }
      default:
        {
          token.data += String.fromCodePoint(cp);
        }
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(cp) {
    if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.DASH_DASH, true)) {
      this._createCommentToken(unicode_js_1.SEQUENCES.DASH_DASH.length + 1);
      this.state = State.COMMENT_START;
    } else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.DOCTYPE, false)) {
      // NOTE: Doctypes tokens are created without fixed offsets. We keep track of the moment a doctype *might* start here.
      this.currentLocation = this.getCurrentLocation(unicode_js_1.SEQUENCES.DOCTYPE.length + 1);
      this.state = State.DOCTYPE;
    } else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.CDATA_START, true)) {
      if (this.inForeignNode) {
        this.state = State.CDATA_SECTION;
      } else {
        this._err(error_codes_js_1.ERR.cdataInHtmlContent);
        this._createCommentToken(unicode_js_1.SEQUENCES.CDATA_START.length + 1);
        this.currentToken.data = '[CDATA[';
        this.state = State.BOGUS_COMMENT;
      }
    }
    //NOTE: Sequence lookups can be abrupted by hibernation. In that case, lookup
    //results are no longer valid and we will need to start over.
    else if (!this._ensureHibernation()) {
      this._err(error_codes_js_1.ERR.incorrectlyOpenedComment);
      this._createCommentToken(2);
      this.state = State.BOGUS_COMMENT;
      this._stateBogusComment(cp);
    }
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:
        {
          this.state = State.COMMENT_START_DASH;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._err(error_codes_js_1.ERR.abruptClosingOfEmptyComment);
          this.state = State.DATA;
          const token = this.currentToken;
          this.emitCurrentComment(token);
          break;
        }
      default:
        {
          this.state = State.COMMENT;
          this._stateComment(cp);
        }
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:
        {
          this.state = State.COMMENT_END;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._err(error_codes_js_1.ERR.abruptClosingOfEmptyComment);
          this.state = State.DATA;
          this.emitCurrentComment(token);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInComment);
          this.emitCurrentComment(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          token.data += '-';
          this.state = State.COMMENT;
          this._stateComment(cp);
        }
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:
        {
          this.state = State.COMMENT_END_DASH;
          break;
        }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
        {
          token.data += '<';
          this.state = State.COMMENT_LESS_THAN_SIGN;
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          token.data += unicode_js_1.REPLACEMENT_CHARACTER;
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInComment);
          this.emitCurrentComment(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          token.data += String.fromCodePoint(cp);
        }
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK:
        {
          token.data += '!';
          this.state = State.COMMENT_LESS_THAN_SIGN_BANG;
          break;
        }
      case unicode_js_1.CODE_POINTS.LESS_THAN_SIGN:
        {
          token.data += '<';
          break;
        }
      default:
        {
          this.state = State.COMMENT;
          this._stateComment(cp);
        }
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(cp) {
    if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH;
    } else {
      this.state = State.COMMENT;
      this._stateComment(cp);
    }
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(cp) {
    if (cp === unicode_js_1.CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
    } else {
      this.state = State.COMMENT_END_DASH;
      this._stateCommentEndDash(cp);
    }
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(cp) {
    if (cp !== unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN && cp !== unicode_js_1.CODE_POINTS.EOF) {
      this._err(error_codes_js_1.ERR.nestedComment);
    }
    this.state = State.COMMENT_END;
    this._stateCommentEnd(cp);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:
        {
          this.state = State.COMMENT_END;
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInComment);
          this.emitCurrentComment(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          token.data += '-';
          this.state = State.COMMENT;
          this._stateComment(cp);
        }
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this.state = State.DATA;
          this.emitCurrentComment(token);
          break;
        }
      case unicode_js_1.CODE_POINTS.EXCLAMATION_MARK:
        {
          this.state = State.COMMENT_END_BANG;
          break;
        }
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:
        {
          token.data += '-';
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInComment);
          this.emitCurrentComment(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          token.data += '--';
          this.state = State.COMMENT;
          this._stateComment(cp);
        }
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.HYPHEN_MINUS:
        {
          token.data += '--!';
          this.state = State.COMMENT_END_DASH;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._err(error_codes_js_1.ERR.incorrectlyClosedComment);
          this.state = State.DATA;
          this.emitCurrentComment(token);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInComment);
          this.emitCurrentComment(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          token.data += '--!';
          this.state = State.COMMENT;
          this._stateComment(cp);
        }
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          this.state = State.BEFORE_DOCTYPE_NAME;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this.state = State.BEFORE_DOCTYPE_NAME;
          this._stateBeforeDoctypeName(cp);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInDoctype);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._err(error_codes_js_1.ERR.missingWhitespaceBeforeDoctypeName);
          this.state = State.BEFORE_DOCTYPE_NAME;
          this._stateBeforeDoctypeName(cp);
        }
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(cp) {
    if (isAsciiUpper(cp)) {
      this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
      this.state = State.DOCTYPE_NAME;
    } else switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          // Ignore whitespace
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          this._createDoctypeToken(unicode_js_1.REPLACEMENT_CHARACTER);
          this.state = State.DOCTYPE_NAME;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._err(error_codes_js_1.ERR.missingDoctypeName);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State.DATA;
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInDoctype);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._createDoctypeToken(String.fromCodePoint(cp));
          this.state = State.DOCTYPE_NAME;
        }
    }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          this.state = State.AFTER_DOCTYPE_NAME;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this.state = State.DATA;
          this.emitCurrentDoctype(token);
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          token.name += unicode_js_1.REPLACEMENT_CHARACTER;
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          token.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
        }
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          // Ignore whitespace
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this.state = State.DATA;
          this.emitCurrentDoctype(token);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.PUBLIC, false)) {
            this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD;
          } else if (this._consumeSequenceIfMatch(unicode_js_1.SEQUENCES.SYSTEM, false)) {
            this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD;
          }
          //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup
          //results are no longer valid and we will need to start over.
          else if (!this._ensureHibernation()) {
            this._err(error_codes_js_1.ERR.invalidCharacterSequenceAfterDoctypeName);
            token.forceQuirks = true;
            this.state = State.BOGUS_DOCTYPE;
            this._stateBogusDoctype(cp);
          }
        }
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
          break;
        }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
        {
          this._err(error_codes_js_1.ERR.missingWhitespaceAfterDoctypePublicKeyword);
          token.publicId = '';
          this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
          break;
        }
      case unicode_js_1.CODE_POINTS.APOSTROPHE:
        {
          this._err(error_codes_js_1.ERR.missingWhitespaceAfterDoctypePublicKeyword);
          token.publicId = '';
          this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._err(error_codes_js_1.ERR.missingDoctypePublicIdentifier);
          token.forceQuirks = true;
          this.state = State.DATA;
          this.emitCurrentDoctype(token);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypePublicIdentifier);
          token.forceQuirks = true;
          this.state = State.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          // Ignore whitespace
          break;
        }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
        {
          token.publicId = '';
          this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
          break;
        }
      case unicode_js_1.CODE_POINTS.APOSTROPHE:
        {
          token.publicId = '';
          this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._err(error_codes_js_1.ERR.missingDoctypePublicIdentifier);
          token.forceQuirks = true;
          this.state = State.DATA;
          this.emitCurrentDoctype(token);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypePublicIdentifier);
          token.forceQuirks = true;
          this.state = State.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
        {
          this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          token.publicId += unicode_js_1.REPLACEMENT_CHARACTER;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._err(error_codes_js_1.ERR.abruptDoctypePublicIdentifier);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State.DATA;
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          token.publicId += String.fromCodePoint(cp);
        }
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.APOSTROPHE:
        {
          this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          token.publicId += unicode_js_1.REPLACEMENT_CHARACTER;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._err(error_codes_js_1.ERR.abruptDoctypePublicIdentifier);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State.DATA;
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          token.publicId += String.fromCodePoint(cp);
        }
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this.state = State.DATA;
          this.emitCurrentDoctype(token);
          break;
        }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
        {
          this._err(error_codes_js_1.ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
          token.systemId = '';
          this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
          break;
        }
      case unicode_js_1.CODE_POINTS.APOSTROPHE:
        {
          this._err(error_codes_js_1.ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
          token.systemId = '';
          this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
          token.forceQuirks = true;
          this.state = State.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          // Ignore whitespace
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this.emitCurrentDoctype(token);
          this.state = State.DATA;
          break;
        }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
        {
          token.systemId = '';
          this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
          break;
        }
      case unicode_js_1.CODE_POINTS.APOSTROPHE:
        {
          token.systemId = '';
          this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
          token.forceQuirks = true;
          this.state = State.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
          break;
        }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
        {
          this._err(error_codes_js_1.ERR.missingWhitespaceAfterDoctypeSystemKeyword);
          token.systemId = '';
          this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
          break;
        }
      case unicode_js_1.CODE_POINTS.APOSTROPHE:
        {
          this._err(error_codes_js_1.ERR.missingWhitespaceAfterDoctypeSystemKeyword);
          token.systemId = '';
          this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._err(error_codes_js_1.ERR.missingDoctypeSystemIdentifier);
          token.forceQuirks = true;
          this.state = State.DATA;
          this.emitCurrentDoctype(token);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
          token.forceQuirks = true;
          this.state = State.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          // Ignore whitespace
          break;
        }
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
        {
          token.systemId = '';
          this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
          break;
        }
      case unicode_js_1.CODE_POINTS.APOSTROPHE:
        {
          token.systemId = '';
          this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._err(error_codes_js_1.ERR.missingDoctypeSystemIdentifier);
          token.forceQuirks = true;
          this.state = State.DATA;
          this.emitCurrentDoctype(token);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._err(error_codes_js_1.ERR.missingQuoteBeforeDoctypeSystemIdentifier);
          token.forceQuirks = true;
          this.state = State.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.QUOTATION_MARK:
        {
          this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          token.systemId += unicode_js_1.REPLACEMENT_CHARACTER;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._err(error_codes_js_1.ERR.abruptDoctypeSystemIdentifier);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State.DATA;
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          token.systemId += String.fromCodePoint(cp);
        }
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.APOSTROPHE:
        {
          this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          token.systemId += unicode_js_1.REPLACEMENT_CHARACTER;
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this._err(error_codes_js_1.ERR.abruptDoctypeSystemIdentifier);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State.DATA;
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          token.systemId += String.fromCodePoint(cp);
        }
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.SPACE:
      case unicode_js_1.CODE_POINTS.LINE_FEED:
      case unicode_js_1.CODE_POINTS.TABULATION:
      case unicode_js_1.CODE_POINTS.FORM_FEED:
        {
          // Ignore whitespace
          break;
        }
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this.emitCurrentDoctype(token);
          this.state = State.DATA;
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInDoctype);
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._err(error_codes_js_1.ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
          this.state = State.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(cp) {
    const token = this.currentToken;
    switch (cp) {
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this.emitCurrentDoctype(token);
          this.state = State.DATA;
          break;
        }
      case unicode_js_1.CODE_POINTS.NULL:
        {
          this._err(error_codes_js_1.ERR.unexpectedNullCharacter);
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
      default:
      // Do nothing
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET:
        {
          this.state = State.CDATA_SECTION_BRACKET;
          break;
        }
      case unicode_js_1.CODE_POINTS.EOF:
        {
          this._err(error_codes_js_1.ERR.eofInCdata);
          this._emitEOFToken();
          break;
        }
      default:
        {
          this._emitCodePoint(cp);
        }
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(cp) {
    if (cp === unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET) {
      this.state = State.CDATA_SECTION_END;
    } else {
      this._emitChars(']');
      this.state = State.CDATA_SECTION;
      this._stateCdataSection(cp);
    }
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(cp) {
    switch (cp) {
      case unicode_js_1.CODE_POINTS.GREATER_THAN_SIGN:
        {
          this.state = State.DATA;
          break;
        }
      case unicode_js_1.CODE_POINTS.RIGHT_SQUARE_BRACKET:
        {
          this._emitChars(']');
          break;
        }
      default:
        {
          this._emitChars(']]');
          this.state = State.CDATA_SECTION;
          this._stateCdataSection(cp);
        }
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference() {
    let length = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
    if (length < 0) {
      if (this.preprocessor.lastChunkWritten) {
        length = this.entityDecoder.end();
      } else {
        // Wait for the rest of the entity.
        this.active = false;
        // Mark the entire buffer as read.
        this.preprocessor.pos = this.preprocessor.html.length - 1;
        this.consumedAfterSnapshot = 0;
        this.preprocessor.endOfChunkHit = true;
        return;
      }
    }
    if (length === 0) {
      // This was not a valid entity. Go back to the beginning, and
      // figure out what to do.
      this.preprocessor.pos = this.entityStartPos;
      this._flushCodePointConsumedAsCharacterReference(unicode_js_1.CODE_POINTS.AMPERSAND);
      this.state = !this._isCharacterReferenceInAttribute() && isAsciiAlphaNumeric(this.preprocessor.peek(1)) ? State.AMBIGUOUS_AMPERSAND : this.returnState;
    } else {
      // We successfully parsed an entity. Switch to the return state.
      this.state = this.returnState;
    }
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(cp) {
    if (isAsciiAlphaNumeric(cp)) {
      this._flushCodePointConsumedAsCharacterReference(cp);
    } else {
      if (cp === unicode_js_1.CODE_POINTS.SEMICOLON) {
        this._err(error_codes_js_1.ERR.unknownNamedCharacterReference);
      }
      this.state = this.returnState;
      this._callState(cp);
    }
  }
}
exports.Tokenizer = Tokenizer;

/***/ }),

/***/ "./node_modules/parse5/dist/cjs/tokenizer/preprocessor.js":
/*!****************************************************************!*\
  !*** ./node_modules/parse5/dist/cjs/tokenizer/preprocessor.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Preprocessor = void 0;
const unicode_js_1 = __webpack_require__(/*! ../common/unicode.js */ "./node_modules/parse5/dist/cjs/common/unicode.js");
const error_codes_js_1 = __webpack_require__(/*! ../common/error-codes.js */ "./node_modules/parse5/dist/cjs/common/error-codes.js");
//Const
const DEFAULT_BUFFER_WATERLINE = 1 << 16;
//Preprocessor
//NOTE: HTML input preprocessing
//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)
class Preprocessor {
  constructor(handler) {
    this.handler = handler;
    this.html = '';
    this.pos = -1;
    // NOTE: Initial `lastGapPos` is -2, to ensure `col` on initialisation is 0
    this.lastGapPos = -2;
    this.gapStack = [];
    this.skipNextNewLine = false;
    this.lastChunkWritten = false;
    this.endOfChunkHit = false;
    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
    this.isEol = false;
    this.lineStartPos = 0;
    this.droppedBufferSize = 0;
    this.line = 1;
    //NOTE: avoid reporting errors twice on advance/retreat
    this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(code, cpOffset) {
    const {
      line,
      col,
      offset
    } = this;
    const startCol = col + cpOffset;
    const startOffset = offset + cpOffset;
    return {
      code,
      startLine: line,
      endLine: line,
      startCol,
      endCol: startCol,
      startOffset,
      endOffset: startOffset
    };
  }
  _err(code) {
    if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
      this.lastErrOffset = this.offset;
      this.handler.onParseError(this.getError(code, 0));
    }
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos);
    this.lastGapPos = this.pos;
  }
  _processSurrogate(cp) {
    //NOTE: try to peek a surrogate pair
    if (this.pos !== this.html.length - 1) {
      const nextCp = this.html.charCodeAt(this.pos + 1);
      if ((0, unicode_js_1.isSurrogatePair)(nextCp)) {
        //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.
        this.pos++;
        //NOTE: add a gap that should be avoided during retreat
        this._addGap();
        return (0, unicode_js_1.getSurrogatePairCodePoint)(cp, nextCp);
      }
    }
    //NOTE: we are at the end of a chunk, therefore we can't infer the surrogate pair yet.
    else if (!this.lastChunkWritten) {
      this.endOfChunkHit = true;
      return unicode_js_1.CODE_POINTS.EOF;
    }
    //NOTE: isolated surrogate
    this._err(error_codes_js_1.ERR.surrogateInInputStream);
    return cp;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    if (this.willDropParsedChunk()) {
      this.html = this.html.substring(this.pos);
      this.lineStartPos -= this.pos;
      this.droppedBufferSize += this.pos;
      this.pos = 0;
      this.lastGapPos = -2;
      this.gapStack.length = 0;
    }
  }
  write(chunk, isLastChunk) {
    if (this.html.length > 0) {
      this.html += chunk;
    } else {
      this.html = chunk;
    }
    this.endOfChunkHit = false;
    this.lastChunkWritten = isLastChunk;
  }
  insertHtmlAtCurrentPos(chunk) {
    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
    this.endOfChunkHit = false;
  }
  startsWith(pattern, caseSensitive) {
    // Check if our buffer has enough characters
    if (this.pos + pattern.length > this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return false;
    }
    if (caseSensitive) {
      return this.html.startsWith(pattern, this.pos);
    }
    for (let i = 0; i < pattern.length; i++) {
      const cp = this.html.charCodeAt(this.pos + i) | 0x20;
      if (cp !== pattern.charCodeAt(i)) {
        return false;
      }
    }
    return true;
  }
  peek(offset) {
    const pos = this.pos + offset;
    if (pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return unicode_js_1.CODE_POINTS.EOF;
    }
    const code = this.html.charCodeAt(pos);
    return code === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN ? unicode_js_1.CODE_POINTS.LINE_FEED : code;
  }
  advance() {
    this.pos++;
    //NOTE: LF should be in the last column of the line
    if (this.isEol) {
      this.isEol = false;
      this.line++;
      this.lineStartPos = this.pos;
    }
    if (this.pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return unicode_js_1.CODE_POINTS.EOF;
    }
    let cp = this.html.charCodeAt(this.pos);
    //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters
    if (cp === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN) {
      this.isEol = true;
      this.skipNextNewLine = true;
      return unicode_js_1.CODE_POINTS.LINE_FEED;
    }
    //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character
    //must be ignored.
    if (cp === unicode_js_1.CODE_POINTS.LINE_FEED) {
      this.isEol = true;
      if (this.skipNextNewLine) {
        // `line` will be bumped again in the recursive call.
        this.line--;
        this.skipNextNewLine = false;
        this._addGap();
        return this.advance();
      }
    }
    this.skipNextNewLine = false;
    if ((0, unicode_js_1.isSurrogate)(cp)) {
      cp = this._processSurrogate(cp);
    }
    //OPTIMIZATION: first check if code point is in the common allowed
    //range (ASCII alphanumeric, whitespaces, big chunk of BMP)
    //before going into detailed performance cost validation.
    const isCommonValidRange = this.handler.onParseError === null || cp > 0x1f && cp < 0x7f || cp === unicode_js_1.CODE_POINTS.LINE_FEED || cp === unicode_js_1.CODE_POINTS.CARRIAGE_RETURN || cp > 0x9f && cp < 64976;
    if (!isCommonValidRange) {
      this._checkForProblematicCharacters(cp);
    }
    return cp;
  }
  _checkForProblematicCharacters(cp) {
    if ((0, unicode_js_1.isControlCodePoint)(cp)) {
      this._err(error_codes_js_1.ERR.controlCharacterInInputStream);
    } else if ((0, unicode_js_1.isUndefinedCodePoint)(cp)) {
      this._err(error_codes_js_1.ERR.noncharacterInInputStream);
    }
  }
  retreat(count) {
    this.pos -= count;
    while (this.pos < this.lastGapPos) {
      this.lastGapPos = this.gapStack.pop();
      this.pos--;
    }
    this.isEol = false;
  }
}
exports.Preprocessor = Preprocessor;

/***/ }),

/***/ "./node_modules/parse5/dist/cjs/tree-adapters/default.js":
/*!***************************************************************!*\
  !*** ./node_modules/parse5/dist/cjs/tree-adapters/default.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.defaultTreeAdapter = void 0;
const html_js_1 = __webpack_require__(/*! ../common/html.js */ "./node_modules/parse5/dist/cjs/common/html.js");
exports.defaultTreeAdapter = {
  //Node construction
  createDocument() {
    return {
      nodeName: '#document',
      mode: html_js_1.DOCUMENT_MODE.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: '#document-fragment',
      childNodes: []
    };
  },
  createElement(tagName, namespaceURI, attrs) {
    return {
      nodeName: tagName,
      tagName,
      attrs,
      namespaceURI,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(data) {
    return {
      nodeName: '#comment',
      data,
      parentNode: null
    };
  },
  createTextNode(value) {
    return {
      nodeName: '#text',
      value,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(parentNode, newNode) {
    parentNode.childNodes.push(newNode);
    newNode.parentNode = parentNode;
  },
  insertBefore(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
    parentNode.childNodes.splice(insertionIdx, 0, newNode);
    newNode.parentNode = parentNode;
  },
  setTemplateContent(templateElement, contentElement) {
    templateElement.content = contentElement;
  },
  getTemplateContent(templateElement) {
    return templateElement.content;
  },
  setDocumentType(document, name, publicId, systemId) {
    const doctypeNode = document.childNodes.find(node => node.nodeName === '#documentType');
    if (doctypeNode) {
      doctypeNode.name = name;
      doctypeNode.publicId = publicId;
      doctypeNode.systemId = systemId;
    } else {
      const node = {
        nodeName: '#documentType',
        name,
        publicId,
        systemId,
        parentNode: null
      };
      exports.defaultTreeAdapter.appendChild(document, node);
    }
  },
  setDocumentMode(document, mode) {
    document.mode = mode;
  },
  getDocumentMode(document) {
    return document.mode;
  },
  detachNode(node) {
    if (node.parentNode) {
      const idx = node.parentNode.childNodes.indexOf(node);
      node.parentNode.childNodes.splice(idx, 1);
      node.parentNode = null;
    }
  },
  insertText(parentNode, text) {
    if (parentNode.childNodes.length > 0) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
      if (exports.defaultTreeAdapter.isTextNode(prevNode)) {
        prevNode.value += text;
        return;
      }
    }
    exports.defaultTreeAdapter.appendChild(parentNode, exports.defaultTreeAdapter.createTextNode(text));
  },
  insertTextBefore(parentNode, text, referenceNode) {
    const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
    if (prevNode && exports.defaultTreeAdapter.isTextNode(prevNode)) {
      prevNode.value += text;
    } else {
      exports.defaultTreeAdapter.insertBefore(parentNode, exports.defaultTreeAdapter.createTextNode(text), referenceNode);
    }
  },
  adoptAttributes(recipient, attrs) {
    const recipientAttrsMap = new Set(recipient.attrs.map(attr => attr.name));
    for (let j = 0; j < attrs.length; j++) {
      if (!recipientAttrsMap.has(attrs[j].name)) {
        recipient.attrs.push(attrs[j]);
      }
    }
  },
  //Tree traversing
  getFirstChild(node) {
    return node.childNodes[0];
  },
  getChildNodes(node) {
    return node.childNodes;
  },
  getParentNode(node) {
    return node.parentNode;
  },
  getAttrList(element) {
    return element.attrs;
  },
  //Node data
  getTagName(element) {
    return element.tagName;
  },
  getNamespaceURI(element) {
    return element.namespaceURI;
  },
  getTextNodeContent(textNode) {
    return textNode.value;
  },
  getCommentNodeContent(commentNode) {
    return commentNode.data;
  },
  getDocumentTypeNodeName(doctypeNode) {
    return doctypeNode.name;
  },
  getDocumentTypeNodePublicId(doctypeNode) {
    return doctypeNode.publicId;
  },
  getDocumentTypeNodeSystemId(doctypeNode) {
    return doctypeNode.systemId;
  },
  //Node types
  isTextNode(node) {
    return node.nodeName === '#text';
  },
  isCommentNode(node) {
    return node.nodeName === '#comment';
  },
  isDocumentTypeNode(node) {
    return node.nodeName === '#documentType';
  },
  isElementNode(node) {
    return Object.prototype.hasOwnProperty.call(node, 'tagName');
  },
  // Source code location
  setNodeSourceCodeLocation(node, location) {
    node.sourceCodeLocation = location;
  },
  getNodeSourceCodeLocation(node) {
    return node.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(node, endLocation) {
    node.sourceCodeLocation = Object.assign(Object.assign({}, node.sourceCodeLocation), endLocation);
  }
};

/***/ }),

/***/ "./node_modules/yoastseo/node_modules/memize/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/yoastseo/node_modules/memize/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ memize)
/* harmony export */ });
/**
 * Memize options object.
 *
 * @typedef MemizeOptions
 *
 * @property {number} [maxSize] Maximum size of the cache.
 */

/**
 * Internal cache entry.
 *
 * @typedef MemizeCacheNode
 *
 * @property {?MemizeCacheNode|undefined} [prev] Previous node.
 * @property {?MemizeCacheNode|undefined} [next] Next node.
 * @property {Array<*>}                   args   Function arguments for cache
 *                                               entry.
 * @property {*}                          val    Function result.
 */

/**
 * Properties of the enhanced function for controlling cache.
 *
 * @typedef MemizeMemoizedFunction
 *
 * @property {()=>void} clear Clear the cache.
 */

/**
 * Accepts a function to be memoized, and returns a new memoized function, with
 * optional options.
 *
 * @template {(...args: any[]) => any} F
 *
 * @param {F}             fn        Function to memoize.
 * @param {MemizeOptions} [options] Options object.
 *
 * @return {((...args: Parameters<F>) => ReturnType<F>) & MemizeMemoizedFunction} Memoized function.
 */
function memize(fn, options) {
  var size = 0;

  /** @type {?MemizeCacheNode|undefined} */
  var head;

  /** @type {?MemizeCacheNode|undefined} */
  var tail;
  options = options || {};
  function memoized(/* ...args */
  ) {
    var node = head,
      len = arguments.length,
      args,
      i;
    searchCache: while (node) {
      // Perform a shallow equality test to confirm that whether the node
      // under test is a candidate for the arguments passed. Two arrays
      // are shallowly equal if their length matches and each entry is
      // strictly equal between the two sets. Avoid abstracting to a
      // function which could incur an arguments leaking deoptimization.

      // Check whether node arguments match arguments length
      if (node.args.length !== arguments.length) {
        node = node.next;
        continue;
      }

      // Check whether node arguments match arguments values
      for (i = 0; i < len; i++) {
        if (node.args[i] !== arguments[i]) {
          node = node.next;
          continue searchCache;
        }
      }

      // At this point we can assume we've found a match

      // Surface matched node to head if not already
      if (node !== head) {
        // As tail, shift to previous. Must only shift if not also
        // head, since if both head and tail, there is no previous.
        if (node === tail) {
          tail = node.prev;
        }

        // Adjust siblings to point to each other. If node was tail,
        // this also handles new tail's empty `next` assignment.
        /** @type {MemizeCacheNode} */
        node.prev.next = node.next;
        if (node.next) {
          node.next.prev = node.prev;
        }
        node.next = head;
        node.prev = null;
        /** @type {MemizeCacheNode} */
        head.prev = node;
        head = node;
      }

      // Return immediately
      return node.val;
    }

    // No cached value found. Continue to insertion phase:

    // Create a copy of arguments (avoid leaking deoptimization)
    args = new Array(len);
    for (i = 0; i < len; i++) {
      args[i] = arguments[i];
    }
    node = {
      args: args,
      // Generate the result from original function
      val: fn.apply(null, args)
    };

    // Don't need to check whether node is already head, since it would
    // have been returned above already if it was

    // Shift existing head down list
    if (head) {
      head.prev = node;
      node.next = head;
    } else {
      // If no head, follows that there's no tail (at initial or reset)
      tail = node;
    }

    // Trim tail if we're reached max size and are pending cache insertion
    if (size === /** @type {MemizeOptions} */options.maxSize) {
      tail = /** @type {MemizeCacheNode} */tail.prev;
      /** @type {MemizeCacheNode} */
      tail.next = null;
    } else {
      size++;
    }
    head = node;
    return node.val;
  }
  memoized.clear = function () {
    head = null;
    tail = null;
    size = 0;
  };

  // Ignore reason: There's not a clear solution to create an intersection of
  // the function with additional properties, where the goal is to retain the
  // function signature of the incoming argument and add control properties
  // on the return value.

  // @ts-ignore
  return memoized;
}


/***/ }),

/***/ "./node_modules/dom-serializer/foreignNames.json":
/*!*******************************************************!*\
  !*** ./node_modules/dom-serializer/foreignNames.json ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"elementNames":{"altglyph":"altGlyph","altglyphdef":"altGlyphDef","altglyphitem":"altGlyphItem","animatecolor":"animateColor","animatemotion":"animateMotion","animatetransform":"animateTransform","clippath":"clipPath","feblend":"feBlend","fecolormatrix":"feColorMatrix","fecomponenttransfer":"feComponentTransfer","fecomposite":"feComposite","feconvolvematrix":"feConvolveMatrix","fediffuselighting":"feDiffuseLighting","fedisplacementmap":"feDisplacementMap","fedistantlight":"feDistantLight","fedropshadow":"feDropShadow","feflood":"feFlood","fefunca":"feFuncA","fefuncb":"feFuncB","fefuncg":"feFuncG","fefuncr":"feFuncR","fegaussianblur":"feGaussianBlur","feimage":"feImage","femerge":"feMerge","femergenode":"feMergeNode","femorphology":"feMorphology","feoffset":"feOffset","fepointlight":"fePointLight","fespecularlighting":"feSpecularLighting","fespotlight":"feSpotLight","fetile":"feTile","feturbulence":"feTurbulence","foreignobject":"foreignObject","glyphref":"glyphRef","lineargradient":"linearGradient","radialgradient":"radialGradient","textpath":"textPath"},"attributeNames":{"definitionurl":"definitionURL","attributename":"attributeName","attributetype":"attributeType","basefrequency":"baseFrequency","baseprofile":"baseProfile","calcmode":"calcMode","clippathunits":"clipPathUnits","diffuseconstant":"diffuseConstant","edgemode":"edgeMode","filterunits":"filterUnits","glyphref":"glyphRef","gradienttransform":"gradientTransform","gradientunits":"gradientUnits","kernelmatrix":"kernelMatrix","kernelunitlength":"kernelUnitLength","keypoints":"keyPoints","keysplines":"keySplines","keytimes":"keyTimes","lengthadjust":"lengthAdjust","limitingconeangle":"limitingConeAngle","markerheight":"markerHeight","markerunits":"markerUnits","markerwidth":"markerWidth","maskcontentunits":"maskContentUnits","maskunits":"maskUnits","numoctaves":"numOctaves","pathlength":"pathLength","patterncontentunits":"patternContentUnits","patterntransform":"patternTransform","patternunits":"patternUnits","pointsatx":"pointsAtX","pointsaty":"pointsAtY","pointsatz":"pointsAtZ","preservealpha":"preserveAlpha","preserveaspectratio":"preserveAspectRatio","primitiveunits":"primitiveUnits","refx":"refX","refy":"refY","repeatcount":"repeatCount","repeatdur":"repeatDur","requiredextensions":"requiredExtensions","requiredfeatures":"requiredFeatures","specularconstant":"specularConstant","specularexponent":"specularExponent","spreadmethod":"spreadMethod","startoffset":"startOffset","stddeviation":"stdDeviation","stitchtiles":"stitchTiles","surfacescale":"surfaceScale","systemlanguage":"systemLanguage","tablevalues":"tableValues","targetx":"targetX","targety":"targetY","textlength":"textLength","viewbox":"viewBox","viewtarget":"viewTarget","xchannelselector":"xChannelSelector","ychannelselector":"yChannelSelector","zoomandpan":"zoomAndPan"}}');

/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json":
/*!********************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}');

/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json":
/*!**********************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"\'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\\"","QUOT":"\\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}');

/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json":
/*!********************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"Aacute":"Á","aacute":"á","Acirc":"Â","acirc":"â","acute":"´","AElig":"Æ","aelig":"æ","Agrave":"À","agrave":"à","amp":"&","AMP":"&","Aring":"Å","aring":"å","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","brvbar":"¦","Ccedil":"Ç","ccedil":"ç","cedil":"¸","cent":"¢","copy":"©","COPY":"©","curren":"¤","deg":"°","divide":"÷","Eacute":"É","eacute":"é","Ecirc":"Ê","ecirc":"ê","Egrave":"È","egrave":"è","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","frac12":"½","frac14":"¼","frac34":"¾","gt":">","GT":">","Iacute":"Í","iacute":"í","Icirc":"Î","icirc":"î","iexcl":"¡","Igrave":"Ì","igrave":"ì","iquest":"¿","Iuml":"Ï","iuml":"ï","laquo":"«","lt":"<","LT":"<","macr":"¯","micro":"µ","middot":"·","nbsp":" ","not":"¬","Ntilde":"Ñ","ntilde":"ñ","Oacute":"Ó","oacute":"ó","Ocirc":"Ô","ocirc":"ô","Ograve":"Ò","ograve":"ò","ordf":"ª","ordm":"º","Oslash":"Ø","oslash":"ø","Otilde":"Õ","otilde":"õ","Ouml":"Ö","ouml":"ö","para":"¶","plusmn":"±","pound":"£","quot":"\\"","QUOT":"\\"","raquo":"»","reg":"®","REG":"®","sect":"§","shy":"­","sup1":"¹","sup2":"²","sup3":"³","szlig":"ß","THORN":"Þ","thorn":"þ","times":"×","Uacute":"Ú","uacute":"ú","Ucirc":"Û","ucirc":"û","Ugrave":"Ù","ugrave":"ù","uml":"¨","Uuml":"Ü","uuml":"ü","Yacute":"Ý","yacute":"ý","yen":"¥","yuml":"ÿ"}');

/***/ }),

/***/ "./node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json":
/*!*****************************************************************************!*\
  !*** ./node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"amp":"&","apos":"\'","gt":">","lt":"<","quot":"\\""}');

/***/ }),

/***/ "./node_modules/htmlparser2/node_modules/entities/maps/decode.json":
/*!*************************************************************************!*\
  !*** ./node_modules/htmlparser2/node_modules/entities/maps/decode.json ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}');

/***/ }),

/***/ "./node_modules/htmlparser2/node_modules/entities/maps/entities.json":
/*!***************************************************************************!*\
  !*** ./node_modules/htmlparser2/node_modules/entities/maps/entities.json ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"\'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\\"","QUOT":"\\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}');

/***/ }),

/***/ "./node_modules/htmlparser2/node_modules/entities/maps/legacy.json":
/*!*************************************************************************!*\
  !*** ./node_modules/htmlparser2/node_modules/entities/maps/legacy.json ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"Aacute":"Á","aacute":"á","Acirc":"Â","acirc":"â","acute":"´","AElig":"Æ","aelig":"æ","Agrave":"À","agrave":"à","amp":"&","AMP":"&","Aring":"Å","aring":"å","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","brvbar":"¦","Ccedil":"Ç","ccedil":"ç","cedil":"¸","cent":"¢","copy":"©","COPY":"©","curren":"¤","deg":"°","divide":"÷","Eacute":"É","eacute":"é","Ecirc":"Ê","ecirc":"ê","Egrave":"È","egrave":"è","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","frac12":"½","frac14":"¼","frac34":"¾","gt":">","GT":">","Iacute":"Í","iacute":"í","Icirc":"Î","icirc":"î","iexcl":"¡","Igrave":"Ì","igrave":"ì","iquest":"¿","Iuml":"Ï","iuml":"ï","laquo":"«","lt":"<","LT":"<","macr":"¯","micro":"µ","middot":"·","nbsp":" ","not":"¬","Ntilde":"Ñ","ntilde":"ñ","Oacute":"Ó","oacute":"ó","Ocirc":"Ô","ocirc":"ô","Ograve":"Ò","ograve":"ò","ordf":"ª","ordm":"º","Oslash":"Ø","oslash":"ø","Otilde":"Õ","otilde":"õ","Ouml":"Ö","ouml":"ö","para":"¶","plusmn":"±","pound":"£","quot":"\\"","QUOT":"\\"","raquo":"»","reg":"®","REG":"®","sect":"§","shy":"­","sup1":"¹","sup2":"²","sup3":"³","szlig":"ß","THORN":"Þ","thorn":"þ","times":"×","Uacute":"Ú","uacute":"ú","Ucirc":"Û","ucirc":"û","Ugrave":"Ù","ugrave":"ù","uml":"¨","Uuml":"Ü","uuml":"ü","Yacute":"Ý","yacute":"ý","yen":"¥","yuml":"ÿ"}');

/***/ }),

/***/ "./node_modules/htmlparser2/node_modules/entities/maps/xml.json":
/*!**********************************************************************!*\
  !*** ./node_modules/htmlparser2/node_modules/entities/maps/xml.json ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"amp":"&","apos":"\'","gt":">","lt":"<","quot":"\\""}');

/***/ }),

/***/ "./node_modules/yoastseo/build/languageProcessing/languages/en/config/syllables.json":
/*!*******************************************************************************************!*\
  !*** ./node_modules/yoastseo/build/languageProcessing/languages/en/config/syllables.json ***!
  \*******************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"vowels":"aeiouy","deviations":{"vowels":[{"fragments":["cial","tia","cius","giu","ion","[^bdnprv]iou","sia$","[^aeiuot]{2,}ed$","[aeiouy][^aeiuoyts]{1,}e$","[a-z]ely$","[cgy]ed$","rved$","[aeiouy][dt]es?$","eau","ieu","oeu","[aeiouy][^aeiouydt]e[sd]?$","[aeouy]rse$","^eye"],"countModifier":-1},{"fragments":["ia","iu","ii","io","[aeio][aeiou]{2}","[aeiou]ing","[^aeiou]ying","ui[aeou]"],"countModifier":1},{"fragments":["^ree[jmnpqrsx]","^reele","^reeva","riet","dien","[aeiouym][bdp]le$","uei","uou","^mc","ism$","[^l]lien","^coa[dglx].","[^gqauieo]ua[^auieo]","dn\'t$","uity$","ie(r|st)","[aeiouw]y[aeiou]","[^ao]ire[ds]","[^ao]ire$"],"countModifier":1},{"fragments":["eoa","eoo","ioa","ioe","ioo"],"countModifier":1}],"words":{"full":[{"word":"business","syllables":2},{"word":"coheiress","syllables":3},{"word":"colonel","syllables":2},{"word":"heiress","syllables":2},{"word":"i.e","syllables":2},{"word":"shoreline","syllables":2},{"word":"simile","syllables":3},{"word":"unheired","syllables":2},{"word":"wednesday","syllables":2}],"fragments":{"global":[{"word":"coyote","syllables":3},{"word":"graveyard","syllables":2},{"word":"lawyer","syllables":2}]}}}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!******************************!*\
  !*** ./javascript/worker.js ***!
  \******************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var yoastseo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yoastseo */ "./node_modules/yoastseo/build/index.js");
/* harmony import */ var yoastseo_build_languageProcessing_languages_en_Researcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yoastseo/build/languageProcessing/languages/en/Researcher */ "./node_modules/yoastseo/build/languageProcessing/languages/en/Researcher.js");


const worker = new yoastseo__WEBPACK_IMPORTED_MODULE_0__.AnalysisWebWorker(self, new yoastseo_build_languageProcessing_languages_en_Researcher__WEBPACK_IMPORTED_MODULE_1__["default"]());
worker.register();
})();

/******/ })()
;
//# sourceMappingURL=worker.js.map